'use strict';
// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

/// <disable>JS2025.InsertSpaceBeforeCommentText,JS2027.PunctuateCommentsCorrectly,JS2076.IdentifierIsMiscased,JS3085.VariableDeclaredMultipleTimes, JS3116.PreviousDeclarationWasHere, JS2074.IdentifierNameIsMisspelled, JS2030.FollowKeywordsWithSpace, JS2023.UseDoubleQuotesForStringLiterals, JS2028.UseCPlusPlusStyleComments, JS2026.CapitalizeComments, JS2008.DoNotUseCookies, JS2005.UseShortFormInitializations, JS2064.SpecifyNewWhenCallingConstructor, JS2024.DoNotQuoteObjectLiteralPropertyNames, JS2043.RemoveDebugCode, JS3045.MissingInputFile</disable>
/// <dictionary target='comment'>args,aspx,autocompletion,enqueue,Firefox,Hardcoded,interdependant,Kinda,Moderncop,Nav,param,params,powerview, secweb, serializer, sharepoint, silverlight, src, stylesheet, theming, untokenized, Xmla </dictionary>

// ModernCop Rules and Settings - Disabling some non critical warnings that we currently have per:
// http://secweb01/MSEC/Tools/Lists/MSEC%20Tool%20Errors%20and%20Warnings/AllItems.aspx?FilterField1=Tool&FilterValue1=Moderncop

/// <disable>JS2085.EnableStrictMode</disable>
// Justification: The violation is that strict mode is enabled for global scope, which could lead
// to unexpected behavior if the target JS file of this project is concatenated with other JS files.
// The target JS file of this project is not concatenated with other files.
"use strict";
window.parseTimeMarkers = window.parseTimeMarkers || {};
window.parseTimeMarkers['powerbi-visuals.js'] = {
    nominalStart: Date.now(),
    start: Date.now()
};

/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var VisualDataRoleKind;
    (function (VisualDataRoleKind) {
        /** Indicates that the role should be bound to something that evaluates to a grouping of values. */
        VisualDataRoleKind[VisualDataRoleKind["Grouping"] = 0] = "Grouping";
        /** Indicates that the role should be bound to something that evaluates to a single value in a scope. */
        VisualDataRoleKind[VisualDataRoleKind["Measure"] = 1] = "Measure";
        /** Indicates that the role can be bound to either Grouping or Measure. */
        VisualDataRoleKind[VisualDataRoleKind["GroupingOrMeasure"] = 2] = "GroupingOrMeasure";
    })(VisualDataRoleKind = powerbi.VisualDataRoleKind || (powerbi.VisualDataRoleKind = {}));
    var VisualDataChangeOperationKind;
    (function (VisualDataChangeOperationKind) {
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Create"] = 0] = "Create";
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Append"] = 1] = "Append";
    })(VisualDataChangeOperationKind = powerbi.VisualDataChangeOperationKind || (powerbi.VisualDataChangeOperationKind = {}));
    var VisualUpdateType;
    (function (VisualUpdateType) {
        VisualUpdateType[VisualUpdateType["Data"] = 2] = "Data";
        VisualUpdateType[VisualUpdateType["Resize"] = 4] = "Resize";
        VisualUpdateType[VisualUpdateType["ViewMode"] = 8] = "ViewMode";
        VisualUpdateType[VisualUpdateType["Style"] = 16] = "Style";
        VisualUpdateType[VisualUpdateType["ResizeEnd"] = 32] = "ResizeEnd";
        VisualUpdateType[VisualUpdateType["All"] = 62] = "All";
    })(VisualUpdateType = powerbi.VisualUpdateType || (powerbi.VisualUpdateType = {}));
    var VisualPermissions;
    (function (VisualPermissions) {
    })(VisualPermissions = powerbi.VisualPermissions || (powerbi.VisualPermissions = {}));
})(powerbi || (powerbi = {}));
/**
 * Use `tsconfig.json` to manage source files.
 *
 * `_references.ts` is not used anymore and will be removed soon. Removing this
 * file requires updating all .ts files so we temporary keep it to simplify
 * review of changes associated with moving build system to `pbi-gulp-tools`.
 */ 
;// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

/// <disable>JS2025.InsertSpaceBeforeCommentText,JS2027.PunctuateCommentsCorrectly,JS2076.IdentifierIsMiscased,JS3085.VariableDeclaredMultipleTimes, JS3116.PreviousDeclarationWasHere, JS2074.IdentifierNameIsMisspelled, JS2030.FollowKeywordsWithSpace, JS2023.UseDoubleQuotesForStringLiterals, JS2028.UseCPlusPlusStyleComments, JS2026.CapitalizeComments, JS2008.DoNotUseCookies, JS2005.UseShortFormInitializations, JS2064.SpecifyNewWhenCallingConstructor, JS2024.DoNotQuoteObjectLiteralPropertyNames, JS2043.RemoveDebugCode, JS3045.MissingInputFile</disable>
/// <dictionary target='comment'>args,aspx,autocompletion,enqueue,Firefox,Hardcoded,interdependant,Kinda,Moderncop,Nav,param,params,powerview, secweb, serializer, sharepoint, silverlight, src, stylesheet, theming, untokenized, Xmla </dictionary>

// ModernCop Rules and Settings - Disabling some non critical warnings that we currently have per:
// http://secweb01/MSEC/Tools/Lists/MSEC%20Tool%20Errors%20and%20Warnings/AllItems.aspx?FilterField1=Tool&FilterValue1=Moderncop

/// <disable>JS2085.EnableStrictMode</disable>
// Justification: The violation is that strict mode is enabled for global scope, which could lead
// to unexpected behavior if the target JS file of this project is concatenated with other JS files.
// The target JS file of this project is not concatenated with other files.
"use strict";
// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// This file keeps logic related to assignment global variable from uglify.js to window.DEBUG
// -----------------------------------------------------------------------
window.DEBUG = typeof DEBUG === 'undefined' ? true : !!DEBUG;
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/**
 * Defines a Debug object. Calls to any functions in this object removed by the minifier.
 * The functions within this class are not minified away, so we use the preprocessor-style
 * comments to have the minifier remove those as well.
 */
///#DEBUG
var debug;
(function (debug) {
    /**
     * Asserts that the condition is true, fails otherwise.
     */
    function assert(condition, message) {
        if (condition !== true) {
            assertFail(message || ('condition: ' + condition));
        }
    }
    debug.assert = assert;
    /**
     * Asserts that the value is neither null nor undefined, fails otherwise.
     */
    function assertValue(value, message) {
        if (value === null || value === undefined) {
            assertFail(message || ('condition: ' + value));
        }
    }
    debug.assertValue = assertValue;
    /**
     * Asserts that the value is neither null nor undefined, and has a length property that returns greater than zero, fails otherwise.
     */
    function assertNonEmpty(value, message) {
        if (!(value != null && value.length > 0)) {
            assertFail(message || ('condition: ' + value));
        }
    }
    debug.assertNonEmpty = assertNonEmpty;
    /**
     * Makes no assertion on the given value.
     * This is documentation/placeholder that a value is possibly null or undefined (unlike assertValue).
     */
    function assertAnyValue(value, message) {
    }
    debug.assertAnyValue = assertAnyValue;
    function assertFail(message) {
        (debug.assertFailFunction || alert)('Debug Assert failed: ' + message);
    }
    debug.assertFail = assertFail;
    function log(message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        console.log.apply(console, [message].concat(optionalParams));
    }
    debug.log = log;
    function warn(message) {
        var optionalParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
        }
        if (console && console.warn) {
            console.warn.apply(console, [message].concat(optionalParams));
        }
        else {
            log.apply(void 0, [message].concat(optionalParams));
        }
    }
    debug.warn = warn;
})(debug || (debug = {}));
///#ENDDEBUG 
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var items = {};
    /** Defines a uniquely named module with a factory method. */
    function define(name, factory) {
        debug.assertValue(name, 'name');
        items[name] = { fn: factory };
    }
    powerbi.define = define;
    /** Synchronously returns a module instance that was previously defined using define function. */
    powerbi.requireSync = function (name) {
        debug.assertValue(name, 'name');
        var syncModule = items[name];
        debug.assertValue(syncModule, 'syncModule');
        var factory = syncModule.fn;
        if (factory) {
            var value = syncModule.v = factory(powerbi.requireSync);
            syncModule.fn = null;
            return value;
        }
        return syncModule.v;
    };
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * DOM constants.
     */
    var DOMConstants;
    (function (DOMConstants) {
        /**
       * Names must match specification
       * https://www.w3.org/TR/uievents-code/#key-alphanumeric-writing-system
       * Because keyCode is depricated
       * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
       * after code is implemented for IE \ Edge
       * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code
       * We want to switch using code.
       */
        var KeyDictionary;
        (function (KeyDictionary) {
            KeyDictionary.F6 = 117;
            KeyDictionary.F10 = 121;
        })(KeyDictionary = DOMConstants.KeyDictionary || (DOMConstants.KeyDictionary = {}));
        /**
         * DOM Elements.
         */
        DOMConstants.DocumentBody = 'body';
        DOMConstants.Anchor = 'a';
        DOMConstants.EditableTextElements = ':text, textarea';
        DOMConstants.EditableNumericElements = '[type="number"]';
        /**
         * DOM Attributes and values.
         */
        DOMConstants.disabledAttributeOrValue = 'disabled';
        DOMConstants.readonlyAttributeOrValue = 'readonly';
        DOMConstants.idAttribute = 'id';
        DOMConstants.styleAttribute = 'style';
        DOMConstants.hrefAttribute = 'href';
        DOMConstants.targetAttribute = 'target';
        DOMConstants.blankValue = '_blank';
        DOMConstants.selfValue = '_self';
        DOMConstants.classAttribute = 'class';
        DOMConstants.titleAttribute = 'title';
        DOMConstants.srcAttribute = 'src';
        /**
         * DOM event names.
         */
        DOMConstants.contextmenuEventName = 'contextmenu';
        DOMConstants.blurEventName = 'blur';
        DOMConstants.keyUpEventName = 'keyup';
        DOMConstants.inputEventName = 'input';
        DOMConstants.changeEventName = 'change';
        DOMConstants.cutEventName = 'cut';
        DOMConstants.keyDownEventName = 'keydown';
        DOMConstants.mouseMoveEventName = 'mousemove';
        DOMConstants.mouseDownEventName = 'mousedown';
        DOMConstants.mouseEnterEventName = 'mouseenter';
        DOMConstants.mouseLeaveEventName = 'mouseleave';
        DOMConstants.mouseOverEventName = 'mouseover';
        DOMConstants.mouseOutEventName = 'mouseout';
        DOMConstants.mouseClickEventName = 'click';
        DOMConstants.pasteEventName = 'paste';
        DOMConstants.scrollEventName = 'scroll';
        DOMConstants.dropEventName = 'drop';
        DOMConstants.focusEventName = 'focus';
        DOMConstants.focusInEventName = 'focusin';
        DOMConstants.focusOutEventName = 'focusout';
        DOMConstants.selectEventName = 'select';
        DOMConstants.messageEventName = 'message';
        DOMConstants.loadEventName = 'load';
        DOMConstants.beforeUnload = 'beforeunload';
        /**
         * Common DOM event combination names.
         */
        DOMConstants.inputAndSelectEventNames = 'input, select';
    })(DOMConstants = jsCommon.DOMConstants || (jsCommon.DOMConstants = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    powerbi.RS_AccessDeniedDueToRLSGroup = 'rsAccessDeniedDueToRLSGroup';
    powerbi.RS_CannotRetrieveModel = 'rsCannotRetrieveModel';
    powerbi.DMTS_NoGatewayWithAllDatasourcesToBindError = 'DMTS_NoGatewayWithAllDatasourcesToBindError';
    powerbi.DM_GWPipeline_UnknownError = 'DM_GWPipeline_UnknownError';
    powerbi.PBID_AccessDenied = 'pbidAccessDenied';
    powerbi.PBI_PowerBIServiceLiveConnectModelNotFound = "PowerBIServiceLiveConnectModelNotFound";
    var PowerBIErrorResourceType;
    (function (PowerBIErrorResourceType) {
        PowerBIErrorResourceType[PowerBIErrorResourceType["ResourceCodeReference"] = 0] = "ResourceCodeReference";
        PowerBIErrorResourceType[PowerBIErrorResourceType["EmbeddedString"] = 1] = "EmbeddedString";
    })(PowerBIErrorResourceType = powerbi.PowerBIErrorResourceType || (powerbi.PowerBIErrorResourceType = {}));
    var ServiceErrorToClientError = /** @class */ (function () {
        function ServiceErrorToClientError(serviceError) {
            this.m_serviceError = serviceError;
        }
        Object.defineProperty(ServiceErrorToClientError.prototype, "code", {
            get: function () {
                return ServiceErrorToClientError.codeName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServiceErrorToClientError.prototype, "ignorable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServiceErrorToClientError.prototype, "requestId", {
            get: function () {
                return this.httpRequestId;
            },
            set: function (value) {
                this.httpRequestId = value;
            },
            enumerable: true,
            configurable: true
        });
        ServiceErrorToClientError.prototype.getDetails = function (resourceProvider) {
            var errorDetails;
            if (this.m_serviceError.statusCode === 6 /* ExecuteSemanticQueryTransformError */) {
                errorDetails = PowerBIErrorDetailHelper.GetDetailsFromTransformError(resourceProvider, this.m_serviceError);
            }
            else {
                errorDetails = PowerBIErrorDetailHelper.GetDetailsFromServerError(resourceProvider, this.m_serviceError);
            }
            PowerBIErrorDetailHelper.addAdditionalInfo(errorDetails, this.m_serviceError.errorDetails, resourceProvider);
            PowerBIErrorDetailHelper.addDebugErrorInfo(errorDetails, this.code, this.m_serviceError.message || null, this.m_serviceError.stackTrace || null, this.httpRequestId);
            return errorDetails;
        };
        ServiceErrorToClientError.codeName = 'ServiceErrorToClientError';
        return ServiceErrorToClientError;
    }());
    powerbi.ServiceErrorToClientError = ServiceErrorToClientError;
    var PowerBIErrorDetailHelper = /** @class */ (function () {
        function PowerBIErrorDetailHelper() {
        }
        PowerBIErrorDetailHelper.addAdditionalInfo = function (errorDetails, pbiErrorDetails, localize) {
            if (pbiErrorDetails) {
                for (var _i = 0, pbiErrorDetails_1 = pbiErrorDetails; _i < pbiErrorDetails_1.length; _i++) {
                    var element = pbiErrorDetails_1[_i];
                    var localizedCode = localize.getOptional(PowerBIErrorDetailHelper.serverErrorPrefix + element.code);
                    var additionErrorInfoKeyValuePair = {
                        errorInfoKey: localizedCode ? localizedCode : element.code,
                        errorInfoValue: element.detail.type === PowerBIErrorResourceType.ResourceCodeReference ? localize.get(PowerBIErrorDetailHelper.serverErrorPrefix + element.detail.value) : element.detail.value
                    };
                    errorDetails.displayableErrorInfo.push(additionErrorInfoKeyValuePair);
                }
            }
            return errorDetails;
        };
        PowerBIErrorDetailHelper.addDebugErrorInfo = function (errorDetails, errorCode, message, stackTrace, httpRequestId) {
            errorDetails.debugErrorInfo = errorDetails.debugErrorInfo || [];
            if (httpRequestId) {
                errorDetails.debugErrorInfo.push({ errorInfoKey: powerbi.ClientErrorStrings.HttpRequestId, errorInfoValue: httpRequestId, });
            }
            if (errorCode) {
                errorDetails.debugErrorInfo.push({ errorInfoKey: powerbi.ClientErrorStrings.ClientErrorCode, errorInfoValue: errorCode, });
            }
            if (message) {
                errorDetails.debugErrorInfo.push({ errorInfoKey: powerbi.ClientErrorStrings.ErrorDetails, errorInfoValue: message, });
            }
            if (stackTrace) {
                errorDetails.debugErrorInfo.push({ errorInfoKey: powerbi.ClientErrorStrings.StackTrace, errorInfoValue: stackTrace, });
            }
            return errorDetails;
        };
        PowerBIErrorDetailHelper.GetDetailsFromTransformError = function (localize, serviceError) {
            var message = localize.get('ServiceError_CannotLoadVisual');
            var key = localize.get('ServiceError_CannotLoadVisual');
            var val = serviceError.message;
            var additionalInfo = [];
            additionalInfo.push({ errorInfoKey: key, errorInfoValue: val, });
            var errorDetails = {
                message: message,
                displayableErrorInfo: additionalInfo,
            };
            return errorDetails;
        };
        PowerBIErrorDetailHelper.GetDetailsFromServerError = function (localize, serviceError) {
            // TODO: Localize
            var message = "";
            var key = "";
            var val = "";
            var errorCodeHandled = false;
            switch (serviceError.errorCode) {
                case powerbi.RS_AccessDeniedDueToRLSGroup:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelFetchingFailureKey');
                    val = localize.get('DsrError_NoPermissionDueToRLSGroupMessage');
                    errorCodeHandled = true;
                    break;
                case powerbi.RS_CannotRetrieveModel:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelFetchingFailureKey');
                    val = localize.get('DsrError_CanNotRetrieveModelMessage');
                    errorCodeHandled = true;
                    break;
                case powerbi.DMTS_NoGatewayWithAllDatasourcesToBindError:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelFetchingFailureKey');
                    val = localize.get('ServerError_DM_GWPipeline_Gateway_DataSourceConnectionError');
                    errorCodeHandled = true;
                    break;
                case powerbi.DM_GWPipeline_UnknownError:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelFetchingFailureKey');
                    val = localize.get('ServerError_DM_GWPipeline_Client_GatewayUnreachable');
                    errorCodeHandled = true;
                    break;
                case powerbi.PBID_AccessDenied:
                    message = localize.get('ServiceError_CannotLoadVisual');
                    key = localize.get('ServiceError_AuthenticationErrorKey');
                    val = localize.get('ServiceError_AuthenticationErrorValue');
                    errorCodeHandled = true;
                    break;
                case powerbi.PBI_PowerBIServiceLiveConnectModelNotFound:
                    message = localize.get('UploadPowerBICompanion_AccessDatasetWarning');
                    errorCodeHandled = true;
                    break;
            }
            if (!errorCodeHandled) {
                switch (serviceError.statusCode) {
                    case 2 /* CsdlConvertXmlToConceptualSchema */:
                        message = localize.get('ServiceError_ModelCannotLoad');
                        key = localize.get('ServiceError_ModelConvertFailureKey');
                        val = localize.get('ServiceError_ModelConvertFailureValue');
                        break;
                    case 3 /* CsdlCreateClientSchema */:
                        message = localize.get('ServiceError_ModelCannotLoad');
                        key = localize.get('ServiceError_ModelCreationFailureKey');
                        val = localize.get('ServiceError_ModelCreationFailureValue');
                        break;
                    case 1 /* CsdlFetching */:
                        message = localize.get('ServiceError_ModelCannotLoad');
                        key = localize.get('ServiceError_ModelFetchingFailureKey');
                        val = localize.get('ServiceError_ModelFetchingFailureValue');
                        break;
                    case 4 /* ExecuteSemanticQueryError */:
                        message = localize.get('ServiceError_CannotLoadVisual');
                        key = localize.get('ServiceError_ExecuteSemanticQueryErrorKey');
                        val = localize.get('ServiceError_ExecuteSemanticQueryErrorValue');
                        break;
                    case 5 /* ExecuteSemanticQueryInvalidStreamFormat */:
                        message = localize.get('ServiceError_CannotLoadVisual');
                        key = localize.get('ServiceError_ExecuteSemanticQueryInvalidStreamFormatKey');
                        val = localize.get('ServiceError_ExecuteSemanticQueryInvalidStreamFormatValue');
                        break;
                    case 0 /* GeneralError */:
                    default:
                        message = localize.get('ServiceError_GeneralError');
                        key = localize.get('ServiceError_GeneralErrorKey');
                        val = localize.get('ServiceError_GeneralErrorValue');
                        break;
                }
            }
            var additionalInfo = [];
            additionalInfo.push({ errorInfoKey: key, errorInfoValue: val, });
            var errorDetails = {
                message: message,
                displayableErrorInfo: additionalInfo,
            };
            return errorDetails;
        };
        PowerBIErrorDetailHelper.serverErrorPrefix = "ServerError_";
        return PowerBIErrorDetailHelper;
    }());
    powerbi.PowerBIErrorDetailHelper = PowerBIErrorDetailHelper;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
powerbi.define('VisualsCommon/services/geoTaggingAnalyzerService', (function (imports) {
    var CategoryTypes = {
        Address: "Address",
        City: "City",
        Continent: "Continent",
        CountryRegion: "Country",
        County: "County",
        Longitude: "Longitude",
        Latitude: "Latitude",
        Place: "Place",
        PostalCode: "PostalCode",
        StateOrProvince: "StateOrProvince"
    };
    var EnglishBackup = {
        GeotaggingString_Continent: "continent",
        GeotaggingString_Continents: "continents",
        GeotaggingString_Country: "country",
        GeotaggingString_Countries: "countries",
        GeotaggingString_State: "state",
        GeotaggingString_States: "states",
        GeotaggingString_City: "city",
        GeotaggingString_Cities: "cities",
        GeotaggingString_Town: "town",
        GeotaggingString_Towns: "towns",
        GeotaggingString_Province: "province",
        GeotaggingString_Provinces: "provinces",
        GeotaggingString_County: "county",
        GeotaggingString_Counties: "counties",
        GeotaggingString_Village: "village",
        GeotaggingString_Villages: "villages",
        GeotaggingString_Post: "post",
        GeotaggingString_Zip: "zip",
        GeotaggingString_Code: "code",
        GeotaggingString_Place: "place",
        GeotaggingString_Places: "places",
        GeotaggingString_Address: "address",
        GeotaggingString_Addresses: "addresses",
        GeotaggingString_Street: "street",
        GeotaggingString_Streets: "streets",
        GeotaggingString_Longitude: "longitude",
        GeotaggingString_Longitude_Short: "lon",
        GeotaggingString_Longitude_Short2: "long",
        GeotaggingString_Latitude: "latitude",
        GeotaggingString_Latitude_Short: "lat",
        GeotaggingString_PostalCode: "postal code",
        GeotaggingString_PostalCodes: "postal codes",
        GeotaggingString_ZipCode: "zip code",
        GeotaggingString_ZipCodes: "zip codes",
        GeotaggingString_Territory: "territory",
        GeotaggingString_Territories: "territories",
        GeotaggingString_VRMBackCompat_CountryRegion: "CountryRegion",
        GeotaggingString_VRMBackCompat_StateOrProvince: "StateOrProvince",
    };
    var GeoTaggingAnalyzerService = /** @class */ (function () {
        function GeoTaggingAnalyzerService(getLocalized) {
            this.getLocalized = getLocalized;
            this.GeotaggingString_VRMBackCompat_CountryRegion = "CountryRegion";
            this.GeotaggingString_VRMBackCompat_StateOrProvince = "StateOrProvince";
            this.ensureCategoriesArePopulated();
        }
        GeoTaggingAnalyzerService.prototype.ensureCategoriesArePopulated = function () {
            if (this.GeotaggingString_Continent) {
                return true;
            }
            var getLocalized = this.getLocalized;
            var localizedContinent = getLocalized("GeotaggingString_Continent");
            if (localizedContinent == null) {
                debug.assertFail("We attempted to initialize the geotaggingAnalyzerService before getLocalized is initialized when the localization should be initialized first.");
                return false;
            }
            this.GeotaggingString_Continent = localizedContinent.toLowerCase();
            this.GeotaggingString_Continents = getLocalized("GeotaggingString_Continents").toLowerCase();
            this.GeotaggingString_Country = getLocalized("GeotaggingString_Country").toLowerCase();
            this.GeotaggingString_Countries = getLocalized("GeotaggingString_Countries").toLowerCase();
            this.GeotaggingString_State = getLocalized("GeotaggingString_State").toLowerCase();
            this.GeotaggingString_States = getLocalized("GeotaggingString_States").toLowerCase();
            this.GeotaggingString_City = getLocalized("GeotaggingString_City").toLowerCase();
            this.GeotaggingString_Cities = getLocalized("GeotaggingString_Cities").toLowerCase();
            this.GeotaggingString_Town = getLocalized("GeotaggingString_Town").toLowerCase();
            this.GeotaggingString_Towns = getLocalized("GeotaggingString_Towns").toLowerCase();
            this.GeotaggingString_Province = getLocalized("GeotaggingString_Province").toLowerCase();
            this.GeotaggingString_Provinces = getLocalized("GeotaggingString_Provinces").toLowerCase();
            this.GeotaggingString_County = getLocalized("GeotaggingString_County").toLowerCase();
            this.GeotaggingString_Counties = getLocalized("GeotaggingString_Counties").toLowerCase();
            this.GeotaggingString_Village = getLocalized("GeotaggingString_Village").toLowerCase();
            this.GeotaggingString_Villages = getLocalized("GeotaggingString_Villages").toLowerCase();
            this.GeotaggingString_Post = getLocalized("GeotaggingString_Post").toLowerCase();
            this.GeotaggingString_Zip = getLocalized("GeotaggingString_Zip").toLowerCase();
            this.GeotaggingString_Code = getLocalized("GeotaggingString_Code").toLowerCase();
            this.GeotaggingString_Place = getLocalized("GeotaggingString_Place").toLowerCase();
            this.GeotaggingString_Places = getLocalized("GeotaggingString_Places").toLowerCase();
            this.GeotaggingString_Address = getLocalized("GeotaggingString_Address").toLowerCase();
            this.GeotaggingString_Addresses = getLocalized("GeotaggingString_Addresses").toLowerCase();
            this.GeotaggingString_Street = getLocalized("GeotaggingString_Street").toLowerCase();
            this.GeotaggingString_Streets = getLocalized("GeotaggingString_Streets").toLowerCase();
            this.GeotaggingString_Longitude = getLocalized("GeotaggingString_Longitude").toLowerCase();
            this.GeotaggingString_Longitude_Short = getLocalized("GeotaggingString_Longitude_Short").toLowerCase();
            this.GeotaggingString_Longitude_Short2 = getLocalized("GeotaggingString_Longitude_Short2").toLowerCase();
            this.GeotaggingString_Latitude = getLocalized("GeotaggingString_Latitude").toLowerCase();
            this.GeotaggingString_Latitude_Short = getLocalized("GeotaggingString_Latitude_Short").toLowerCase();
            this.GeotaggingString_PostalCode = getLocalized("GeotaggingString_PostalCode").toLowerCase();
            this.GeotaggingString_PostalCodes = getLocalized("GeotaggingString_PostalCodes").toLowerCase();
            this.GeotaggingString_ZipCode = getLocalized("GeotaggingString_ZipCode").toLowerCase();
            this.GeotaggingString_ZipCodes = getLocalized("GeotaggingString_ZipCodes").toLowerCase();
            this.GeotaggingString_Territory = getLocalized("GeotaggingString_Territory").toLowerCase();
            this.GeotaggingString_Territories = getLocalized("GeotaggingString_Territories").toLowerCase();
            return true;
        };
        GeoTaggingAnalyzerService.prototype.isLongitudeOrLatitude = function (fieldRefName) {
            if (!this.ensureCategoriesArePopulated()) {
                return false;
            }
            return this.isLongitude(fieldRefName) ||
                this.isLatitude(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeographic = function (fieldRefName) {
            if (!this.ensureCategoriesArePopulated()) {
                return false;
            }
            return this.isLongitudeOrLatitude(fieldRefName) ||
                this.isGeocodable(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeocodable = function (fieldRefName) {
            if (!this.ensureCategoriesArePopulated()) {
                return false;
            }
            return this.isAddress(fieldRefName) ||
                this.isCity(fieldRefName) ||
                this.isContinent(fieldRefName) ||
                this.isCountry(fieldRefName) ||
                this.isCounty(fieldRefName) ||
                this.isStateOrProvince(fieldRefName) ||
                this.isPlace(fieldRefName) ||
                this.isPostalCode(fieldRefName) ||
                this.isTerritory(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeoshapable = function (fieldRefName) {
            if (!this.ensureCategoriesArePopulated()) {
                return false;
            }
            return this.isCity(fieldRefName) ||
                this.isCountry(fieldRefName) ||
                this.isCounty(fieldRefName) ||
                this.isStateOrProvince(fieldRefName) ||
                this.isPostalCode(fieldRefName) ||
                this.isTerritory(fieldRefName) ||
                this.isPlace(fieldRefName) ||
                this.isGeoshapableEnglish(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeoshapableEnglish = function (fieldRefName) {
            if (!this.ensureCategoriesArePopulated()) {
                return false;
            }
            return this.isEnglishCity(fieldRefName) ||
                this.isEnglishCountry(fieldRefName) ||
                this.isEnglishCounty(fieldRefName) ||
                this.isEnglishStateOrProvince(fieldRefName) ||
                this.isEnglishPostalCode(fieldRefName) ||
                this.isEnglishTerritory(fieldRefName) ||
                this.isEnglishPlace(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isAddress = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Address,
                this.GeotaggingString_Addresses,
                this.GeotaggingString_Street,
                this.GeotaggingString_Streets
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isPlace = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Place,
                this.GeotaggingString_Places
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isCity = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_City,
                this.GeotaggingString_Cities,
                this.GeotaggingString_Town,
                this.GeotaggingString_Towns,
                this.GeotaggingString_Village,
                this.GeotaggingString_Villages
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isStateOrProvince = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_State,
                this.GeotaggingString_States,
                this.GeotaggingString_Province,
                this.GeotaggingString_Provinces,
                this.GeotaggingString_VRMBackCompat_StateOrProvince,
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isCountry = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Country,
                this.GeotaggingString_Countries,
                this.GeotaggingString_VRMBackCompat_CountryRegion
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isCounty = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_County,
                this.GeotaggingString_Counties
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isContinent = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Continent,
                this.GeotaggingString_Continents
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isPostalCode = function (fieldRefName) {
            var result = (GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Post,
                this.GeotaggingString_Zip
            ])
                && GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Code])) ||
                GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                    this.GeotaggingString_PostalCode,
                    this.GeotaggingString_PostalCodes,
                    this.GeotaggingString_ZipCode,
                    this.GeotaggingString_ZipCodes
                ]);
            //Check again for strings without whitespace
            if (!result) {
                var whiteSpaceRegex = /\s+/;
                var fieldNameWithoutWhitespace = fieldRefName.replace(whiteSpaceRegex, "");
                result = GeoTaggingAnalyzerService.hasMatches(fieldNameWithoutWhitespace, [
                    this.GeotaggingString_PostalCode.replace(whiteSpaceRegex, ''),
                    this.GeotaggingString_PostalCodes.replace(whiteSpaceRegex, ''),
                    this.GeotaggingString_ZipCode.replace(whiteSpaceRegex, ''),
                    this.GeotaggingString_ZipCodes.replace(whiteSpaceRegex, '')
                ]);
            }
            return result;
        };
        GeoTaggingAnalyzerService.prototype.isLongitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Longitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Longitude_Short], true /* useStrict */)
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Longitude_Short2], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isLatitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Latitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Latitude_Short], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isTerritory = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Territory,
                this.GeotaggingString_Territories
            ]);
        };
        GeoTaggingAnalyzerService.hasMatches = function (fieldName, possibleMatches, useStrict) {
            var nonWordRegex = /\W/;
            var value = fieldName.toLowerCase();
            for (var i = 0, len = possibleMatches.length; i < len; i++) {
                var possibleMatch = possibleMatches[i].toLowerCase();
                if (!useStrict) {
                    if (value.indexOf(possibleMatch) > -1)
                        return true;
                }
                else {
                    var indexofpossibleMatch = value.indexOf(possibleMatch);
                    if (indexofpossibleMatch > -1) {
                        var wordEndFlag = void 0, wordBeginFlag = void 0;
                        wordEndFlag = wordBeginFlag = true;
                        if (indexofpossibleMatch - 1 > 0)
                            wordBeginFlag = nonWordRegex.test(value[indexofpossibleMatch - 1]);
                        if (indexofpossibleMatch + possibleMatch.length < value.length)
                            wordEndFlag = nonWordRegex.test(value[indexofpossibleMatch + possibleMatch.length]);
                        if (wordBeginFlag && wordEndFlag)
                            return true;
                    }
                }
            }
            return false;
        };
        GeoTaggingAnalyzerService.prototype.getFieldType = function (fieldName) {
            if (!this.ensureCategoriesArePopulated()) {
                return undefined;
            }
            if (fieldName == null)
                return undefined;
            if (this.isLatitude(fieldName))
                return CategoryTypes.Latitude;
            if (this.isLongitude(fieldName))
                return CategoryTypes.Longitude;
            if (this.isPostalCode(fieldName))
                return CategoryTypes.PostalCode;
            if (this.isAddress(fieldName))
                return CategoryTypes.Address;
            if (this.isPlace(fieldName))
                return CategoryTypes.Place;
            if (this.isCity(fieldName))
                return CategoryTypes.City;
            if (this.isCountry(fieldName))
                return CategoryTypes.CountryRegion;
            if (this.isCounty(fieldName))
                return CategoryTypes.County;
            if (this.isStateOrProvince(fieldName))
                return CategoryTypes.StateOrProvince;
            if (this.isContinent(fieldName))
                return CategoryTypes.Continent;
            return this.getEnglishFieldType(fieldName);
        };
        GeoTaggingAnalyzerService.prototype.getFieldTypeFromDescriptor = function (typeDescriptor) {
            if (typeDescriptor == null || typeDescriptor.geography == null)
                return undefined;
            var geography = typeDescriptor.geography;
            if (geography.latitude)
                return CategoryTypes.Latitude;
            if (geography.longitude)
                return CategoryTypes.Longitude;
            if (geography.postalCode)
                return CategoryTypes.PostalCode;
            if (geography.address)
                return CategoryTypes.Address;
            if (geography.place)
                return CategoryTypes.Place;
            if (geography.city)
                return CategoryTypes.City;
            if (geography.country)
                return CategoryTypes.CountryRegion;
            if (geography.county)
                return CategoryTypes.County;
            if (geography.stateOrProvince)
                return CategoryTypes.StateOrProvince;
            if (geography.continent)
                return CategoryTypes.Continent;
        };
        GeoTaggingAnalyzerService.prototype.isEnglishAddress = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Address,
                EnglishBackup.GeotaggingString_Addresses,
                EnglishBackup.GeotaggingString_Street,
                EnglishBackup.GeotaggingString_Streets
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishPlace = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Place,
                EnglishBackup.GeotaggingString_Places
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishCity = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_City,
                EnglishBackup.GeotaggingString_Cities,
                EnglishBackup.GeotaggingString_Town,
                EnglishBackup.GeotaggingString_Towns,
                EnglishBackup.GeotaggingString_Village,
                EnglishBackup.GeotaggingString_Villages
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishStateOrProvince = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_State,
                EnglishBackup.GeotaggingString_States,
                EnglishBackup.GeotaggingString_Province,
                EnglishBackup.GeotaggingString_Provinces,
                EnglishBackup.GeotaggingString_VRMBackCompat_StateOrProvince,
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishCountry = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Country,
                EnglishBackup.GeotaggingString_Countries,
                EnglishBackup.GeotaggingString_VRMBackCompat_CountryRegion
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishCounty = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_County,
                EnglishBackup.GeotaggingString_Counties
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishContinent = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Continent,
                EnglishBackup.GeotaggingString_Continents
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishPostalCode = function (fieldRefName) {
            var result = (GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Post,
                EnglishBackup.GeotaggingString_Zip
            ])
                && GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Code])) ||
                GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                    EnglishBackup.GeotaggingString_PostalCode,
                    EnglishBackup.GeotaggingString_PostalCodes,
                    EnglishBackup.GeotaggingString_ZipCode,
                    EnglishBackup.GeotaggingString_ZipCodes
                ]);
            //Check again for strings without whitespace
            if (!result) {
                var whiteSpaceRegexPattern = new RegExp('\s');
                result = GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                    EnglishBackup.GeotaggingString_PostalCode.replace(whiteSpaceRegexPattern, ''),
                    EnglishBackup.GeotaggingString_PostalCodes.replace(whiteSpaceRegexPattern, ''),
                    EnglishBackup.GeotaggingString_ZipCode.replace(whiteSpaceRegexPattern, ''),
                    EnglishBackup.GeotaggingString_ZipCodes.replace(whiteSpaceRegexPattern, '')
                ]);
            }
            return result;
        };
        GeoTaggingAnalyzerService.prototype.isEnglishLongitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Longitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Longitude_Short], true /* useStrict */)
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Longitude_Short2], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishLatitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Latitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Latitude_Short], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishTerritory = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Territory,
                EnglishBackup.GeotaggingString_Territories
            ]);
        };
        GeoTaggingAnalyzerService.prototype.getEnglishFieldType = function (fieldName) {
            if (fieldName == null)
                return undefined;
            if (this.isEnglishLatitude(fieldName))
                return CategoryTypes.Latitude;
            if (this.isEnglishLongitude(fieldName))
                return CategoryTypes.Longitude;
            if (this.isEnglishPostalCode(fieldName))
                return CategoryTypes.PostalCode;
            if (this.isEnglishAddress(fieldName))
                return CategoryTypes.Address;
            if (this.isEnglishPlace(fieldName))
                return CategoryTypes.Place;
            if (this.isEnglishCity(fieldName))
                return CategoryTypes.City;
            if (this.isEnglishCountry(fieldName))
                return CategoryTypes.CountryRegion;
            if (this.isEnglishCounty(fieldName))
                return CategoryTypes.County;
            if (this.isEnglishStateOrProvince(fieldName))
                return CategoryTypes.StateOrProvince;
            if (this.isEnglishContinent(fieldName))
                return CategoryTypes.Continent;
            return undefined;
        };
        return GeoTaggingAnalyzerService;
    }());
    return {
        create: function (getLocalized) {
            return new GeoTaggingAnalyzerService(getLocalized);
        },
    };
}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /**
     * Unlocalized strings to be used for error reporting.
     */
    var ClientErrorStrings;
    (function (ClientErrorStrings) {
        ClientErrorStrings.ClientErrorCode = 'Client Error Code';
        ClientErrorStrings.ErrorCode = 'Error Code';
        ClientErrorStrings.ErrorDetails = 'Error Details';
        ClientErrorStrings.HttpRequestId = 'HTTP Request Id';
        ClientErrorStrings.JobId = 'Job Id';
        ClientErrorStrings.ODataErrorMessage = 'OData Error Message';
        ClientErrorStrings.StackTrace = 'Stack Trace';
    })(ClientErrorStrings = powerbi.ClientErrorStrings || (powerbi.ClientErrorStrings = {}));
    /**
     this base class should be derived to give a generic error message but with a unique error code.
     */
    var UnknownClientError = /** @class */ (function () {
        function UnknownClientError(code) {
            debug.assertValue(code, 'code');
            this.errorCode = code;
        }
        Object.defineProperty(UnknownClientError.prototype, "code", {
            get: function () {
                return this.errorCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UnknownClientError.prototype, "ignorable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        UnknownClientError.prototype.getDetails = function (resourceProvider) {
            var details = {
                message: resourceProvider.get('ClientError_UnknownClientErrorValue'),
                displayableErrorInfo: [{ errorInfoKey: resourceProvider.get('ClientError_UnknownClientErrorKey'), errorInfoValue: resourceProvider.get('ClientError_UnknownClientErrorValue'), }],
                debugErrorInfo: [{ errorInfoKey: ClientErrorStrings.ClientErrorCode, errorInfoValue: this.code, }],
            };
            return details;
        };
        return UnknownClientError;
    }());
    powerbi.UnknownClientError = UnknownClientError;
    var HttpClientError = /** @class */ (function () {
        function HttpClientError(httpStatusCode, requestId, errorCode, message) {
            debug.assertValue(httpStatusCode, 'httpStatusCode');
            debug.assertValue(requestId, 'requestId');
            this.httpStatusCode = httpStatusCode;
            this.httpRequestId = requestId;
            this.detailedErrorCode = errorCode;
            this.detailedMessage = message;
        }
        Object.defineProperty(HttpClientError.prototype, "code", {
            get: function () {
                return 'HttpClientError';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HttpClientError.prototype, "ignorable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HttpClientError.prototype, "requestId", {
            get: function () {
                return this.httpRequestId;
            },
            enumerable: true,
            configurable: true
        });
        HttpClientError.prototype.getDetails = function (resourceProvider) {
            // Use a general error message for a HTTP request failure, since we currently do not know of any specifc error cases at this point in time.
            var details = {
                message: null,
                displayableErrorInfo: [
                    { errorInfoKey: resourceProvider.get('DsrError_Key'), errorInfoValue: resourceProvider.get('DsrError_UnknownErrorValue') },
                    { errorInfoKey: resourceProvider.get('ClientError_HttpResponseStatusCodeKey'), errorInfoValue: this.httpStatusCode.toString() }
                ],
                debugErrorInfo: [
                    { errorInfoKey: ClientErrorStrings.HttpRequestId, errorInfoValue: this.httpRequestId },
                    { errorInfoKey: ClientErrorStrings.ClientErrorCode, errorInfoValue: this.code }
                ]
            };
            if (this.detailedMessage) {
                details.debugErrorInfo.push({ errorInfoKey: ClientErrorStrings.ErrorDetails, errorInfoValue: this.detailedMessage });
            }
            if (this.detailedErrorCode) {
                details.debugErrorInfo.push({ errorInfoKey: ClientErrorStrings.ErrorCode, errorInfoValue: this.detailedErrorCode });
            }
            return details;
        };
        return HttpClientError;
    }());
    powerbi.HttpClientError = HttpClientError;
    var IgnorableClientError = /** @class */ (function () {
        function IgnorableClientError() {
        }
        Object.defineProperty(IgnorableClientError.prototype, "code", {
            get: function () {
                return 'IgnorableClientError';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgnorableClientError.prototype, "ignorable", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        IgnorableClientError.prototype.getDetails = function (resourceProvider) {
            var details = {
                message: '',
                displayableErrorInfo: [],
            };
            return details;
        };
        return IgnorableClientError;
    }());
    powerbi.IgnorableClientError = IgnorableClientError;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var ArrayExtensions;
    (function (ArrayExtensions) {
        /**
         * Returns items that exist in target and other.
         */
        function intersect(target, other) {
            var result = [];
            for (var i = target.length - 1; i >= 0; --i) {
                if (other.indexOf(target[i]) !== -1) {
                    result.push(target[i]);
                }
            }
            return result;
        }
        ArrayExtensions.intersect = intersect;
        /**
         * Return elements exists in target but not exists in other.
         */
        function diff(target, other) {
            var result = [];
            for (var i = target.length - 1; i >= 0; --i) {
                var value = target[i];
                if (other.indexOf(value) === -1) {
                    result.push(value);
                }
            }
            return result;
        }
        ArrayExtensions.diff = diff;
        /**
         * Return an array with only the distinct items in the source.
         */
        function distinct(source) {
            var result = [];
            for (var i = 0, len = source.length; i < len; i++) {
                var value = source[i];
                if (result.indexOf(value) === -1) {
                    result.push(value);
                }
            }
            return result;
        }
        ArrayExtensions.distinct = distinct;
        /**
         * Pushes content of source onto target,
         * for parts of course that do not already exist in target.
         */
        function union(target, source) {
            for (var i = 0, len = source.length; i < len; ++i) {
                unionSingle(target, source[i]);
            }
        }
        ArrayExtensions.union = union;
        /**
         * Pushes value onto target, if value does not already exist in target.
         */
        function unionSingle(target, value) {
            if (target.indexOf(value) < 0) {
                target.push(value);
            }
        }
        ArrayExtensions.unionSingle = unionSingle;
        /**
         * Returns an array with a range of items from source,
         * including the startIndex & endIndex.
         */
        function range(source, startIndex, endIndex) {
            debug.assert(startIndex >= 0 && startIndex < source.length, 'startIndex is out of range.');
            debug.assert(endIndex >= 0 && endIndex < source.length, 'endIndex is out of range.');
            var result = [];
            for (var i = startIndex; i <= endIndex; ++i) {
                result.push(source[i]);
            }
            return result;
        }
        ArrayExtensions.range = range;
        /**
         * Returns an array that includes items from source, up to the specified count.
         */
        function take(source, count) {
            debug.assert(count >= 0, 'Count is negative.');
            debug.assert(count <= source.length, 'Count is too large.');
            var result = [];
            for (var i = 0; i < count; ++i) {
                result.push(source[i]);
            }
            return result;
        }
        ArrayExtensions.take = take;
        function copy(source) {
            debug.assertValue(source, 'source');
            return take(source, source.length);
        }
        ArrayExtensions.copy = copy;
        /**
         * Returns a value indicating whether the arrays have the same values in the same sequence.
         */
        function sequenceEqual(left, right, comparison) {
            debug.assertValue(comparison, 'comparison');
            // Normalize falsy to null
            if (!left) {
                left = null;
            }
            if (!right) {
                right = null;
            }
            // T can be same as U, and it is possible for left and right to be the same array object...
            if (left === right) {
                return true;
            }
            if (!!left !== !!right) {
                return false;
            }
            var len = left.length;
            if (len !== right.length) {
                return false;
            }
            var i = 0;
            while (i < len && comparison(left[i], right[i])) {
                ++i;
            }
            return i === len;
        }
        ArrayExtensions.sequenceEqual = sequenceEqual;
        /**
         * Returns null if the specified array is empty.
         * Otherwise returns the specified array.
         */
        function emptyToNull(array) {
            if (array && array.length === 0) {
                return null;
            }
            return array;
        }
        ArrayExtensions.emptyToNull = emptyToNull;
        function indexOf(array, predicate) {
            debug.assertValue(array, 'array');
            debug.assertValue(predicate, 'predicate');
            for (var i = 0, len = array.length; i < len; ++i) {
                if (predicate(array[i])) {
                    return i;
                }
            }
            return -1;
        }
        ArrayExtensions.indexOf = indexOf;
        /**
         * Returns a copy of the array rotated by the specified offset.
         */
        function rotate(array, offset) {
            if (offset === 0)
                return array.slice();
            var rotated = array.slice(offset);
            Array.prototype.push.apply(rotated, array.slice(0, offset));
            return rotated;
        }
        ArrayExtensions.rotate = rotate;
        function createWithId() {
            return extendWithId([]);
        }
        ArrayExtensions.createWithId = createWithId;
        function extendWithId(array) {
            debug.assertValue(array, 'array');
            var extended = array;
            extended.withId = withId;
            return extended;
        }
        ArrayExtensions.extendWithId = extendWithId;
        /**
         * Finds and returns the first item with a matching ID.
         */
        function findWithId(array, id) {
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (item.id === id)
                    return item;
            }
        }
        ArrayExtensions.findWithId = findWithId;
        function withId(id) {
            return ArrayExtensions.findWithId(this, id);
        }
        function createWithName() {
            return extendWithName([]);
        }
        ArrayExtensions.createWithName = createWithName;
        function extendWithName(array) {
            debug.assertValue(array, 'array');
            var extended = array;
            extended.withName = withName;
            return extended;
        }
        ArrayExtensions.extendWithName = extendWithName;
        function findItemWithName(array, name) {
            var index = indexWithName(array, name);
            if (index >= 0)
                return array[index];
        }
        ArrayExtensions.findItemWithName = findItemWithName;
        function indexWithName(array, name) {
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (item.name === name)
                    return i;
            }
            return -1;
        }
        ArrayExtensions.indexWithName = indexWithName;
        /**
         * Inserts a number in sorted order into a list of numbers already in sorted order.
         * @returns True if the item was added, false if it already existed.
         */
        function insertSorted(list, value) {
            debug.assertValue(list, 'list');
            debug.assertValue(value, 'value');
            var len = list.length;
            // NOTE: iterate backwards because incoming values tend to be sorted already.
            for (var i = len - 1; i >= 0; i--) {
                var diff_1 = list[i] - value;
                if (diff_1 === 0)
                    return false;
                if (diff_1 > 0)
                    continue;
                // diff < 0
                list.splice(i + 1, 0, value);
                return true;
            }
            list.unshift(value);
            return true;
        }
        ArrayExtensions.insertSorted = insertSorted;
        /**
         * Removes the first occurrence of a value from a list if it exists.
         * @returns True if the value was removed, false if it did not exist in the list.
         */
        function removeFirst(list, value) {
            var index = list.indexOf(value);
            if (index < 0)
                return false;
            list.splice(index, 1);
            return true;
        }
        ArrayExtensions.removeFirst = removeFirst;
        /**
         * Finds and returns the first item with a matching name.
         */
        function withName(name) {
            var array = this;
            return findItemWithName(array, name);
        }
        /**
         * Deletes all items from the array.
         */
        function clear(array) {
            if (!array)
                return;
            while (array.length > 0)
                array.pop();
        }
        ArrayExtensions.clear = clear;
        /**
         * This method is deprecated, should use _.isEmpty.
         * Cannot remove at this time due to usage by custom visuals.
         */
        function isUndefinedOrEmpty(array) {
            if (!array || array.length === 0) {
                return true;
            }
            return false;
        }
        ArrayExtensions.isUndefinedOrEmpty = isUndefinedOrEmpty;
        function swap(array, firstIndex, secondIndex) {
            var temp = array[firstIndex];
            array[firstIndex] = array[secondIndex];
            array[secondIndex] = temp;
        }
        ArrayExtensions.swap = swap;
        function isInArray(array, lookupItem, compareCallback) {
            return _.any(array, (function (item) { return compareCallback(item, lookupItem); }));
        }
        ArrayExtensions.isInArray = isInArray;
        /** Checks if the given object is an Array, and looking all the way up the prototype chain. */
        function isArrayOrInheritedArray(obj) {
            debug.assertValue(obj, 'obj');
            var nextPrototype = obj;
            while (nextPrototype != null) {
                if (_.isArray(nextPrototype))
                    return true;
                nextPrototype = Object.getPrototypeOf(nextPrototype);
            }
            return false;
        }
        ArrayExtensions.isArrayOrInheritedArray = isArrayOrInheritedArray;
        /**
         * Returns true if the specified values array is sorted in an order as determined by the specified compareFunction.
         */
        function isSorted(values, compareFunction) {
            debug.assertValue(values, 'values');
            debug.assertValue(compareFunction, 'compareFunction');
            var ilen = values.length;
            if (ilen >= 2) {
                for (var i = 1; i < ilen; i++) {
                    if (compareFunction(values[i - 1], values[i]) > 0) {
                        return false;
                    }
                }
            }
            return true;
        }
        ArrayExtensions.isSorted = isSorted;
        /**
         * Returns true if the specified number values array is sorted in ascending order
         * (or descending order if the specified descendingOrder is truthy).
         */
        function isSortedNumeric(values, descendingOrder) {
            debug.assertValue(values, 'values');
            debug.assertAnyValue(descendingOrder, 'descendingOrder');
            var compareFunction = descendingOrder ?
                function (a, b) { return b - a; } :
                function (a, b) { return a - b; };
            return isSorted(values, compareFunction);
        }
        ArrayExtensions.isSortedNumeric = isSortedNumeric;
        /**
         * Ensures that the given T || T[] is in array form, either returning the array or
         * converting single items into an array of length one.
         */
        function ensureArray(value) {
            if (_.isArray(value)) {
                return value;
            }
            return [value];
        }
        ArrayExtensions.ensureArray = ensureArray;
        /**
         * Verifies there are no duplicate names in the given items.
         */
        function hasUniqueNames(items) {
            return _.uniq(items, (function (pod) { return pod.name; })).length === items.length;
        }
        ArrayExtensions.hasUniqueNames = hasUniqueNames;
        /**
         * Rewrites an immutable array. The `rewriter` is called for each item in the array, if any of
         * the values returned is not referentially equal to the original value then a new array is allocated
         * to hold the new values.
         *
         * The `rewriter` should not mutate the input.
         */
        function rewriteArray(array, rewriter) {
            debug.assertValue(array, 'array');
            var rewrittenResult;
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i], rewrittenItem = rewriter(item);
                if (item !== rewrittenItem && !rewrittenResult)
                    rewrittenResult = ArrayExtensions.take(array, i);
                if (rewrittenResult)
                    rewrittenResult.push(rewrittenItem);
            }
            return rewrittenResult || array;
        }
        ArrayExtensions.rewriteArray = rewriteArray;
    })(ArrayExtensions = jsCommon.ArrayExtensions || (jsCommon.ArrayExtensions = {}));
    // TODO: move to a separate file
    var DictionaryExtensions;
    (function (DictionaryExtensions) {
        /**
         * Rewrites an immutable dictionary. The `rewriter` is called for each item in the dictionary, if any of
         * the values returned is not referentially equal to the original value then a new dictionary is allocated
         * to hold the new values.
         *
         * The `rewriter` should not mutate the input.
         */
        function rewriteDictionary(dictionary, rewriter) {
            debug.assertValue(dictionary, 'dictionary');
            var rewrittenResult;
            var keys = Object.getOwnPropertyNames(dictionary);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i], value = dictionary[key], rewrittenValue = rewriter(key, value);
                if (value !== rewrittenValue && !rewrittenResult)
                    rewrittenResult = _.pick(dictionary, ArrayExtensions.take(keys, i));
                if (rewrittenResult)
                    rewrittenResult[key] = rewrittenValue;
            }
            return rewrittenResult || dictionary;
        }
        DictionaryExtensions.rewriteDictionary = rewriteDictionary;
    })(DictionaryExtensions = jsCommon.DictionaryExtensions || (jsCommon.DictionaryExtensions = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var InJs;
(function (InJs) {
    var DomFactory;
    (function (DomFactory) {
        function div() {
            return $('<div/>');
        }
        DomFactory.div = div;
        function span() {
            return $('<span/>');
        }
        DomFactory.span = span;
        function checkbox() {
            return $('<input type="checkbox"/>');
        }
        DomFactory.checkbox = checkbox;
        function ul() {
            return $('<ul/>');
        }
        DomFactory.ul = ul;
        function li() {
            return $('<li/>');
        }
        DomFactory.li = li;
        function button() {
            return $('<input type="button"/>');
        }
        DomFactory.button = button;
        function select() {
            return $('<select/>');
        }
        DomFactory.select = select;
        function textBox() {
            return $('<input type="text"/>');
        }
        DomFactory.textBox = textBox;
        function img() {
            return $('<img/>');
        }
        DomFactory.img = img;
        function iframe() {
            return $('<iframe/>');
        }
        DomFactory.iframe = iframe;
    })(DomFactory = InJs.DomFactory || (InJs.DomFactory = {}));
})(InJs || (InJs = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /**
     * Module Double contains a set of constants and precision based utility methods
     * for dealing with doubles and their decimal garbage in the javascript.
     */
    var Double;
    (function (Double) {
        // Constants.
        Double.MIN_VALUE = -Number.MAX_VALUE;
        Double.MAX_VALUE = Number.MAX_VALUE;
        Double.MIN_EXP = -308;
        Double.MAX_EXP = 308;
        Double.EPSILON = 1E-323;
        Double.DEFAULT_PRECISION = 0.0001;
        Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS = 12;
        Double.LOG_E_10 = Math.log(10);
        Double.POSITIVE_POWERS = [
            1E0, 1E1, 1E2, 1E3, 1E4, 1E5, 1E6, 1E7, 1E8, 1E9, 1E10, 1E11, 1E12, 1E13, 1E14, 1E15, 1E16, 1E17, 1E18, 1E19, 1E20, 1E21, 1E22, 1E23, 1E24, 1E25, 1E26, 1E27, 1E28, 1E29, 1E30, 1E31, 1E32, 1E33, 1E34, 1E35, 1E36, 1E37, 1E38, 1E39, 1E40, 1E41, 1E42, 1E43, 1E44, 1E45, 1E46, 1E47, 1E48, 1E49, 1E50, 1E51, 1E52, 1E53, 1E54, 1E55, 1E56, 1E57, 1E58, 1E59, 1E60, 1E61, 1E62, 1E63, 1E64, 1E65, 1E66, 1E67, 1E68, 1E69, 1E70, 1E71, 1E72, 1E73, 1E74, 1E75, 1E76, 1E77, 1E78, 1E79, 1E80, 1E81, 1E82, 1E83, 1E84, 1E85, 1E86, 1E87, 1E88, 1E89, 1E90, 1E91, 1E92, 1E93, 1E94, 1E95, 1E96, 1E97, 1E98, 1E99,
            1E100, 1E101, 1E102, 1E103, 1E104, 1E105, 1E106, 1E107, 1E108, 1E109, 1E110, 1E111, 1E112, 1E113, 1E114, 1E115, 1E116, 1E117, 1E118, 1E119, 1E120, 1E121, 1E122, 1E123, 1E124, 1E125, 1E126, 1E127, 1E128, 1E129, 1E130, 1E131, 1E132, 1E133, 1E134, 1E135, 1E136, 1E137, 1E138, 1E139, 1E140, 1E141, 1E142, 1E143, 1E144, 1E145, 1E146, 1E147, 1E148, 1E149, 1E150, 1E151, 1E152, 1E153, 1E154, 1E155, 1E156, 1E157, 1E158, 1E159, 1E160, 1E161, 1E162, 1E163, 1E164, 1E165, 1E166, 1E167, 1E168, 1E169, 1E170, 1E171, 1E172, 1E173, 1E174, 1E175, 1E176, 1E177, 1E178, 1E179, 1E180, 1E181, 1E182, 1E183, 1E184, 1E185, 1E186, 1E187, 1E188, 1E189, 1E190, 1E191, 1E192, 1E193, 1E194, 1E195, 1E196, 1E197, 1E198, 1E199,
            1E200, 1E201, 1E202, 1E203, 1E204, 1E205, 1E206, 1E207, 1E208, 1E209, 1E210, 1E211, 1E212, 1E213, 1E214, 1E215, 1E216, 1E217, 1E218, 1E219, 1E220, 1E221, 1E222, 1E223, 1E224, 1E225, 1E226, 1E227, 1E228, 1E229, 1E230, 1E231, 1E232, 1E233, 1E234, 1E235, 1E236, 1E237, 1E238, 1E239, 1E240, 1E241, 1E242, 1E243, 1E244, 1E245, 1E246, 1E247, 1E248, 1E249, 1E250, 1E251, 1E252, 1E253, 1E254, 1E255, 1E256, 1E257, 1E258, 1E259, 1E260, 1E261, 1E262, 1E263, 1E264, 1E265, 1E266, 1E267, 1E268, 1E269, 1E270, 1E271, 1E272, 1E273, 1E274, 1E275, 1E276, 1E277, 1E278, 1E279, 1E280, 1E281, 1E282, 1E283, 1E284, 1E285, 1E286, 1E287, 1E288, 1E289, 1E290, 1E291, 1E292, 1E293, 1E294, 1E295, 1E296, 1E297, 1E298, 1E299,
            1E300, 1E301, 1E302, 1E303, 1E304, 1E305, 1E306, 1E307, 1E308
        ];
        Double.NEGATIVE_POWERS = [
            1E0, 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9, 1E-10, 1E-11, 1E-12, 1E-13, 1E-14, 1E-15, 1E-16, 1E-17, 1E-18, 1E-19, 1E-20, 1E-21, 1E-22, 1E-23, 1E-24, 1E-25, 1E-26, 1E-27, 1E-28, 1E-29, 1E-30, 1E-31, 1E-32, 1E-33, 1E-34, 1E-35, 1E-36, 1E-37, 1E-38, 1E-39, 1E-40, 1E-41, 1E-42, 1E-43, 1E-44, 1E-45, 1E-46, 1E-47, 1E-48, 1E-49, 1E-50, 1E-51, 1E-52, 1E-53, 1E-54, 1E-55, 1E-56, 1E-57, 1E-58, 1E-59, 1E-60, 1E-61, 1E-62, 1E-63, 1E-64, 1E-65, 1E-66, 1E-67, 1E-68, 1E-69, 1E-70, 1E-71, 1E-72, 1E-73, 1E-74, 1E-75, 1E-76, 1E-77, 1E-78, 1E-79, 1E-80, 1E-81, 1E-82, 1E-83, 1E-84, 1E-85, 1E-86, 1E-87, 1E-88, 1E-89, 1E-90, 1E-91, 1E-92, 1E-93, 1E-94, 1E-95, 1E-96, 1E-97, 1E-98, 1E-99,
            1E-100, 1E-101, 1E-102, 1E-103, 1E-104, 1E-105, 1E-106, 1E-107, 1E-108, 1E-109, 1E-110, 1E-111, 1E-112, 1E-113, 1E-114, 1E-115, 1E-116, 1E-117, 1E-118, 1E-119, 1E-120, 1E-121, 1E-122, 1E-123, 1E-124, 1E-125, 1E-126, 1E-127, 1E-128, 1E-129, 1E-130, 1E-131, 1E-132, 1E-133, 1E-134, 1E-135, 1E-136, 1E-137, 1E-138, 1E-139, 1E-140, 1E-141, 1E-142, 1E-143, 1E-144, 1E-145, 1E-146, 1E-147, 1E-148, 1E-149, 1E-150, 1E-151, 1E-152, 1E-153, 1E-154, 1E-155, 1E-156, 1E-157, 1E-158, 1E-159, 1E-160, 1E-161, 1E-162, 1E-163, 1E-164, 1E-165, 1E-166, 1E-167, 1E-168, 1E-169, 1E-170, 1E-171, 1E-172, 1E-173, 1E-174, 1E-175, 1E-176, 1E-177, 1E-178, 1E-179, 1E-180, 1E-181, 1E-182, 1E-183, 1E-184, 1E-185, 1E-186, 1E-187, 1E-188, 1E-189, 1E-190, 1E-191, 1E-192, 1E-193, 1E-194, 1E-195, 1E-196, 1E-197, 1E-198, 1E-199,
            1E-200, 1E-201, 1E-202, 1E-203, 1E-204, 1E-205, 1E-206, 1E-207, 1E-208, 1E-209, 1E-210, 1E-211, 1E-212, 1E-213, 1E-214, 1E-215, 1E-216, 1E-217, 1E-218, 1E-219, 1E-220, 1E-221, 1E-222, 1E-223, 1E-224, 1E-225, 1E-226, 1E-227, 1E-228, 1E-229, 1E-230, 1E-231, 1E-232, 1E-233, 1E-234, 1E-235, 1E-236, 1E-237, 1E-238, 1E-239, 1E-240, 1E-241, 1E-242, 1E-243, 1E-244, 1E-245, 1E-246, 1E-247, 1E-248, 1E-249, 1E-250, 1E-251, 1E-252, 1E-253, 1E-254, 1E-255, 1E-256, 1E-257, 1E-258, 1E-259, 1E-260, 1E-261, 1E-262, 1E-263, 1E-264, 1E-265, 1E-266, 1E-267, 1E-268, 1E-269, 1E-270, 1E-271, 1E-272, 1E-273, 1E-274, 1E-275, 1E-276, 1E-277, 1E-278, 1E-279, 1E-280, 1E-281, 1E-282, 1E-283, 1E-284, 1E-285, 1E-286, 1E-287, 1E-288, 1E-289, 1E-290, 1E-291, 1E-292, 1E-293, 1E-294, 1E-295, 1E-296, 1E-297, 1E-298, 1E-299,
            1E-300, 1E-301, 1E-302, 1E-303, 1E-304, 1E-305, 1E-306, 1E-307, 1E-308, 1E-309, 1E-310, 1E-311, 1E-312, 1E-313, 1E-314, 1E-315, 1E-316, 1E-317, 1E-318, 1E-319, 1E-320, 1E-321, 1E-322, 1E-323, 1E-324
        ];
        /**
         * Returns powers of 10.
         * Unlike the Math.pow this function produces no decimal garbage.
         * @param exp Exponent.
         */
        function pow10(exp) {
            debug.assertValue(exp, "exp");
            // Positive & zero
            if (exp >= 0) {
                if (exp < Double.POSITIVE_POWERS.length) {
                    return Double.POSITIVE_POWERS[exp];
                }
                else {
                    return Infinity;
                }
            }
            // Negative
            exp = -exp;
            if (exp > 0 && exp < Double.NEGATIVE_POWERS.length) {
                return Double.NEGATIVE_POWERS[exp];
            }
            else {
                return 0;
            }
        }
        Double.pow10 = pow10;
        /**
         * Returns the 10 base logarithm of the number.
         * Unlike Math.log function this produces integer results with no decimal garbage.
         * @param val Positive value or zero.
         */
        function log10(val) {
            debug.assert(val >= 0, "val");
            // Fast Log10() algorithm 
            if (val > 1 && val < 1E16) {
                if (val < 1E8) {
                    if (val < 1E4) {
                        if (val < 1E2) {
                            if (val < 1E1) {
                                return 0;
                            }
                            else {
                                return 1;
                            }
                        }
                        else {
                            if (val < 1E3) {
                                return 2;
                            }
                            else {
                                return 3;
                            }
                        }
                    }
                    else {
                        if (val < 1E6) {
                            if (val < 1E5) {
                                return 4;
                            }
                            else {
                                return 5;
                            }
                        }
                        else {
                            if (val < 1E7) {
                                return 6;
                            }
                            else {
                                return 7;
                            }
                        }
                    }
                }
                else {
                    if (val < 1E12) {
                        if (val < 1E10) {
                            if (val < 1E9) {
                                return 8;
                            }
                            else {
                                return 9;
                            }
                        }
                        else {
                            if (val < 1E11) {
                                return 10;
                            }
                            else {
                                return 11;
                            }
                        }
                    }
                    else {
                        if (val < 1E14) {
                            if (val < 1E13) {
                                return 12;
                            }
                            else {
                                return 13;
                            }
                        }
                        else {
                            if (val < 1E15) {
                                return 14;
                            }
                            else {
                                return 15;
                            }
                        }
                    }
                }
            }
            if (val > 1E-16 && val < 1) {
                if (val < 1E-8) {
                    if (val < 1E-12) {
                        if (val < 1E-14) {
                            if (val < 1E-15) {
                                return -16;
                            }
                            else {
                                return -15;
                            }
                        }
                        else {
                            if (val < 1E-13) {
                                return -14;
                            }
                            else {
                                return -13;
                            }
                        }
                    }
                    else {
                        if (val < 1E-10) {
                            if (val < 1E-11) {
                                return -12;
                            }
                            else {
                                return -11;
                            }
                        }
                        else {
                            if (val < 1E-9) {
                                return -10;
                            }
                            else {
                                return -9;
                            }
                        }
                    }
                }
                else {
                    if (val < 1E-4) {
                        if (val < 1E-6) {
                            if (val < 1E-7) {
                                return -8;
                            }
                            else {
                                return -7;
                            }
                        }
                        else {
                            if (val < 1E-5) {
                                return -6;
                            }
                            else {
                                return -5;
                            }
                        }
                    }
                    else {
                        if (val < 1E-2) {
                            if (val < 1E-3) {
                                return -4;
                            }
                            else {
                                return -3;
                            }
                        }
                        else {
                            if (val < 1E-1) {
                                return -2;
                            }
                            else {
                                return -1;
                            }
                        }
                    }
                }
            }
            // JS Math provides only natural log function so we need to calc the 10 base logarithm:
            // logb(x) = logk(x)/logk(b); 
            var log10 = Math.log(val) / Double.LOG_E_10;
            return Double.floorWithPrecision(log10);
        }
        Double.log10 = log10;
        /**
         * Returns a power of 10 representing precision of the number based on the number of meaningful decimal digits.
         * For example the precision of 56,263.3767 with the 6 meaningful decimal digit is 0.1.
         * @param x Value.
         * @param decimalDigits How many decimal digits are meaningfull.
         */
        function getPrecision(x, decimalDigits) {
            if (decimalDigits === undefined) {
                decimalDigits = Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS;
            }
            else {
                debug.assert(decimalDigits >= 0, "decimalDigits");
            }
            if (!x || !isFinite(x)) {
                return undefined;
            }
            var exp = Double.log10(Math.abs(x));
            if (exp < Double.MIN_EXP) {
                return 0;
            }
            var precisionExp = Math.max(exp - decimalDigits, -Double.NEGATIVE_POWERS.length + 1);
            return Double.pow10(precisionExp);
        }
        Double.getPrecision = getPrecision;
        /**
         * Checks if a delta between 2 numbers is less than provided precision.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function equalWithPrecision(x, y, precision) {
            precision = detectPrecision(precision, x, y);
            debug.assert(precision >= 0, "precision");
            return x === y || Math.abs(x - y) < precision;
        }
        Double.equalWithPrecision = equalWithPrecision;
        /**
         * Checks if a first value is less than another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function lessWithPrecision(x, y, precision) {
            precision = detectPrecision(precision, x, y);
            debug.assert(precision >= 0, "precision");
            return x < y && Math.abs(x - y) > precision;
        }
        Double.lessWithPrecision = lessWithPrecision;
        /**
         * Checks if a first value is less or equal than another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function lessOrEqualWithPrecision(x, y, precision) {
            precision = detectPrecision(precision, x, y);
            debug.assert(precision >= 0, "precision");
            return x < y || Math.abs(x - y) < precision;
        }
        Double.lessOrEqualWithPrecision = lessOrEqualWithPrecision;
        /**
         * Checks if a first value is greater than another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function greaterWithPrecision(x, y, precision) {
            precision = detectPrecision(precision, x, y);
            debug.assert(precision >= 0, "precision");
            return x > y && Math.abs(x - y) > precision;
        }
        Double.greaterWithPrecision = greaterWithPrecision;
        /**
         * Checks if a first value is greater or equal to another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function greaterOrEqualWithPrecision(x, y, precision) {
            precision = detectPrecision(precision, x, y);
            debug.assert(precision >= 0, "precision");
            return x > y || Math.abs(x - y) < precision;
        }
        Double.greaterOrEqualWithPrecision = greaterOrEqualWithPrecision;
        /**
         * Floors the number unless it's withing the precision distance from the higher int.
         * @param x One value.
         * @param precision Precision value.
         */
        function floorWithPrecision(x, precision) {
            precision = precision != null ? precision : Double.DEFAULT_PRECISION;
            debug.assert(precision >= 0, "precision");
            var roundX = Math.round(x);
            if (Math.abs(x - roundX) < precision) {
                return roundX;
            }
            else {
                return Math.floor(x);
            }
        }
        Double.floorWithPrecision = floorWithPrecision;
        /**
         * Ceils the number unless it's withing the precision distance from the lower int.
         * @param x One value.
         * @param precision Precision value.
         */
        function ceilWithPrecision(x, precision) {
            precision = detectPrecision(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            var roundX = Math.round(x);
            if (Math.abs(x - roundX) < precision) {
                return roundX;
            }
            else {
                return Math.ceil(x);
            }
        }
        Double.ceilWithPrecision = ceilWithPrecision;
        /**
         * Floors the number to the provided precision.
         * For example 234,578 floored to 1,000 precision is 234,000.
         * @param x One value.
         * @param precision Precision value.
         */
        function floorToPrecision(x, precision) {
            precision = detectPrecision(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            //Precision must be a Power of 10
            return Math.floor(x / precision) * precision;
        }
        Double.floorToPrecision = floorToPrecision;
        /**
         * Ceils the number to the provided precision.
         * For example 234,578 floored to 1,000 precision is 235,000.
         * @param x One value.
         * @param precision Precision value.
         */
        function ceilToPrecision(x, precision) {
            precision = detectPrecision(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            //Precision must be a Power of 10
            return Math.ceil(x / precision) * precision;
        }
        Double.ceilToPrecision = ceilToPrecision;
        /**
         * Rounds the number to the provided precision.
         * For example 234,578 floored to 1,000 precision is 235,000.
         * @param x One value.
         * @param precision Precision value.
         */
        function roundToPrecision(x, precision) {
            precision = detectPrecision(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            //Precision must be a Power of 10
            var result = Math.round(x / precision) * precision;
            var decimalDigits = Math.round(Double.log10(Math.abs(x)) - Double.log10(precision)) + 1;
            if (decimalDigits > 0 && decimalDigits < 16) {
                result = parseFloat(result.toPrecision(decimalDigits));
            }
            return result;
        }
        Double.roundToPrecision = roundToPrecision;
        /**
         * Returns the value making sure that it's restricted to the provided range.
         * @param x One value.
         * @param min Range min boundary.
         * @param max Range max boundary.
         */
        function ensureInRange(x, min, max) {
            debug.assert(min <= max, "min must be less or equal to max");
            if (x === undefined || x === null) {
                return x;
            }
            if (x < min) {
                return min;
            }
            if (x > max) {
                return max;
            }
            return x;
        }
        Double.ensureInRange = ensureInRange;
        /**
         * Rounds the value - this method is actually faster than Math.round - used in the graphics utils.
         * @param x Value to round.
         */
        function round(x) {
            debug.assert(x >= 0, "x must be greater or equal to 0");
            return (0.5 + x) << 0;
        }
        Double.round = round;
        /**
         * Projects the value from the source range into the target range.
         * @param value Value to project.
         * @param fromMin Minimum of the source range.
         * @param toMin Minimum of the target range.
         * @param toMax Maximum of the target range.
         */
        function project(value, fromMin, fromSize, toMin, toSize) {
            if (fromSize === 0 || toSize === 0) {
                if (fromMin <= value && value <= fromMin + fromSize) {
                    return toMin;
                }
                else {
                    return NaN;
                }
            }
            var relativeX = (value - fromMin) / fromSize;
            var projectedX = toMin + relativeX * toSize;
            return projectedX;
        }
        Double.project = project;
        /**
         * Removes decimal noise.
         * @param value Value to be processed.
         */
        function removeDecimalNoise(value) {
            return roundToPrecision(value, getPrecision(value));
        }
        Double.removeDecimalNoise = removeDecimalNoise;
        /**
         * Checks whether the number is integer.
         * @param value Value to be checked.
         */
        function isInteger(value) {
            return value !== null && value % 1 === 0;
        }
        Double.isInteger = isInteger;
        /**
         * Dividing by increment will give us count of increments
         * Round out the rough edges into even integer
         * Multiply back by increment to get rounded value
         * e.g. Rounder.toIncrement(0.647291, 0.05) => 0.65
         * @param value - value to round to nearest increment
         * @param increment - smallest increment to round toward
         */
        function toIncrement(value, increment) {
            return Math.round(value / increment) * increment;
        }
        Double.toIncrement = toIncrement;
        /**
         * Overrides the given precision with defaults if necessary. Exported only for tests
         *
         * precision defined returns precision
         * x defined with y undefined returns twelve digits of precision based on x
         * x defined but zero with y defined; returns twelve digits of precision based on y
         * x and y defined returns twelve digits of precision based on the minimum of the two
         * if no applicable precision is found based on those (such as x and y being zero), the default precision is used
         */
        function detectPrecision(precision, x, y) {
            if (precision !== undefined) {
                return precision;
            }
            var calculatedPrecision;
            if (!y) {
                calculatedPrecision = Double.getPrecision(x);
            }
            else if (!x) {
                calculatedPrecision = Double.getPrecision(y);
            }
            else {
                calculatedPrecision = Double.getPrecision(Math.min(Math.abs(x), Math.abs(y)));
            }
            return calculatedPrecision || Double.DEFAULT_PRECISION;
        }
        Double.detectPrecision = detectPrecision;
    })(Double = powerbi.Double || (powerbi.Double = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Double = powerbi.Double;
    var Color;
    (function (Color) {
        function rotate(rgbString, rotateFactor) {
            if (rotateFactor === 0)
                return rgbString;
            var originalRgb = parseColorString(rgbString);
            var originalHsv = rgbToHsv(originalRgb);
            var rotatedHsv = rotateHsv(originalHsv, rotateFactor);
            var rotatedRgb = hsvToRgb(rotatedHsv);
            return hexString(rotatedRgb);
        }
        Color.rotate = rotate;
        function normalizeToHexString(color) {
            var rgb = parseColorString(color);
            return hexString(rgb);
        }
        Color.normalizeToHexString = normalizeToHexString;
        function parseColorString(color) {
            debug.assertValue(color, 'color');
            if (color.indexOf('#') >= 0) {
                if (color.length === 7) {
                    // #RRGGBB
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
                    if (result == null || result.length < 4)
                        return;
                    return {
                        R: parseInt(result[1], 16),
                        G: parseInt(result[2], 16),
                        B: parseInt(result[3], 16),
                    };
                }
                else if (color.length === 4) {
                    // #RGB
                    var result = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(color);
                    if (result == null || result.length < 4)
                        return;
                    return {
                        R: parseInt(result[1] + result[1], 16),
                        G: parseInt(result[2] + result[2], 16),
                        B: parseInt(result[3] + result[3], 16),
                    };
                }
            }
            else if (color.indexOf('rgb(') >= 0) {
                // rgb(R, G, B)
                var result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(color);
                if (result == null || result.length < 4)
                    return;
                return {
                    R: parseInt(result[1], 10),
                    G: parseInt(result[2], 10),
                    B: parseInt(result[3], 10),
                };
            }
            else if (color.indexOf('rgba(') >= 0) {
                // rgba(R, G, B, A)
                var result = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d*(?:\.\d+)?)\)$/.exec(color);
                if (result == null || result.length < 5)
                    return;
                return {
                    R: parseInt(result[1], 10),
                    G: parseInt(result[2], 10),
                    B: parseInt(result[3], 10),
                    A: parseFloat(result[4]),
                };
            }
        }
        Color.parseColorString = parseColorString;
        function rgbToHsv(rgbColor) {
            var s, h;
            var r = rgbColor.R / 255, g = rgbColor.G / 255, b = rgbColor.B / 255;
            var min = Math.min(r, Math.min(g, b));
            var max = Math.max(r, Math.max(g, b));
            var v = max;
            var delta = max - min;
            if (max === 0 || delta === 0) {
                // R, G, and B must be 0.0, or all the same.
                // In this case, S is 0.0, and H is undefined.
                // Using H = 0.0 is as good as any...
                s = 0;
                h = 0;
            }
            else {
                s = delta / max;
                if (r === max) {
                    // Between Yellow and Magenta
                    h = (g - b) / delta;
                }
                else if (g === max) {
                    // Between Cyan and Yellow
                    h = 2 + (b - r) / delta;
                }
                else {
                    // Between Magenta and Cyan
                    h = 4 + (r - g) / delta;
                }
            }
            // Scale h to be between 0.0 and 1.
            // This may require adding 1, if the value
            // is negative.
            h /= 6;
            if (h < 0) {
                h += 1;
            }
            return {
                H: h,
                S: s,
                V: v,
            };
        }
        function hsvToRgb(hsvColor) {
            var r, g, b;
            var h = hsvColor.H, s = hsvColor.S, v = hsvColor.V;
            if (s === 0) {
                // If s is 0, all colors are the same.
                // This is some flavor of gray.
                r = v;
                g = v;
                b = v;
            }
            else {
                var p = void 0, q = void 0, t = void 0, fractionalSector = void 0, sectorNumber = void 0, sectorPos = void 0;
                // The color wheel consists of 6 sectors.
                // Figure out which sector you//re in.
                sectorPos = h * 6;
                sectorNumber = Math.floor(sectorPos);
                // get the fractional part of the sector.
                // That is, how many degrees into the sector
                // are you?
                fractionalSector = sectorPos - sectorNumber;
                // Calculate values for the three axes
                // of the color.
                p = v * (1.0 - s);
                q = v * (1.0 - (s * fractionalSector));
                t = v * (1.0 - (s * (1 - fractionalSector)));
                // Assign the fractional colors to r, g, and b
                // based on the sector the angle is in.
                switch (sectorNumber) {
                    case 0:
                        r = v;
                        g = t;
                        b = p;
                        break;
                    case 1:
                        r = q;
                        g = v;
                        b = p;
                        break;
                    case 2:
                        r = p;
                        g = v;
                        b = t;
                        break;
                    case 3:
                        r = p;
                        g = q;
                        b = v;
                        break;
                    case 4:
                        r = t;
                        g = p;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = p;
                        b = q;
                        break;
                }
            }
            return {
                R: Math.floor(r * 255),
                G: Math.floor(g * 255),
                B: Math.floor(b * 255),
            };
        }
        function rotateHsv(hsvColor, rotateFactor) {
            var newH = hsvColor.H + rotateFactor;
            return {
                H: newH > 1 ? newH - 1 : newH,
                S: hsvColor.S,
                V: hsvColor.V,
            };
        }
        function darken(color, diff) {
            var flooredNumber = Math.floor(diff);
            return {
                R: Math.max(0, color.R - flooredNumber),
                G: Math.max(0, color.G - flooredNumber),
                B: Math.max(0, color.B - flooredNumber),
            };
        }
        Color.darken = darken;
        function rgbString(color) {
            if (color.A == null)
                return "rgb(" + color.R + "," + color.G + "," + color.B + ")";
            return "rgba(" + color.R + "," + color.G + "," + color.B + "," + color.A + ")";
        }
        Color.rgbString = rgbString;
        function hexString(color) {
            return "#" + componentToHex(color.R) + componentToHex(color.G) + componentToHex(color.B);
        }
        Color.hexString = hexString;
        function isFullHexString(color) {
            return /^#[0-9a-f]{6}$/i.test(color);
        }
        Color.isFullHexString = isFullHexString;
        /**
         * Overlays a color with opacity over a background color
         * @param {string} foreColor Color to overlay
         * @param {number} opacity number between 0 (transparent) to 1 (opaque)
         * @param {string} backColor Background color
         * @returns Result color
         */
        function hexBlend(foreColor, opacity, backColor) {
            return hexString(rgbBlend(parseColorString(foreColor), opacity, parseColorString(backColor)));
        }
        Color.hexBlend = hexBlend;
        /**
         * Overlays a color with opacity over a background color. Any alpha-channel is ignored.
         * @param {RgbColor} foreColor Color to overlay
         * @param {number} opacity number between 0 (transparent) to 1 (opaque). Any value out of range will be corrected.
         * @param {RgbColor} backColor Background color
         * @returns
         */
        function rgbBlend(foreColor, opacity, backColor) {
            // correct opacity
            opacity = Double.ensureInRange(opacity, 0, 1);
            return {
                R: channelBlend(foreColor.R, opacity, backColor.R),
                G: channelBlend(foreColor.G, opacity, backColor.G),
                B: channelBlend(foreColor.B, opacity, backColor.B)
            };
        }
        Color.rgbBlend = rgbBlend;
        /**
         * Blend a single channel for two colors
         * @param {number} foreChannel Channel of foreground color. Will be enforced to be between 0 and 255.
         * @param {number} opacity opacity of the foreground color. Will be enforced to be between 0 and 1.
         * @param {number} backChannel channel of the background color. Will be enforced to be between 0 and 255.
         * @returns result channel value
         */
        function channelBlend(foreChannel, opacity, backChannel) {
            opacity = Double.ensureInRange(opacity, 0, 1);
            foreChannel = Double.ensureInRange(foreChannel, 0, 255);
            backChannel = Double.ensureInRange(backChannel, 0, 255);
            return Math.round((opacity * foreChannel) +
                ((1 - opacity) * backChannel));
        }
        Color.channelBlend = channelBlend;
        /**
         * Calculate the highlight color from the rgbColor based on the lumianceThreshold and delta.
         * @param {RgbColor} rgbColor The original color.
         * @param {number} lumianceThreshold The lumiance threshold used, the highlight color will be brighter when the lumiance is smaller the threshold, otherwise the highlight color will be darker. Will be enforced to be between 0 and 1.
         * @param {number} delta the highlight color will be calculated based on the delta. Will be enforced to be between 0 and 1. lumianceThreshold + delta cannot greater than 1.
         * @returns result highlight color value
         */
        function calculateHighlightColor(rgbColor, lumianceThreshold, delta) {
            var hsvColor = rgbToHsv(rgbColor);
            // For invalid lumianceThreshold and delta value, use default.
            if (lumianceThreshold + delta > 1 || lumianceThreshold <= 0 || delta <= 0) {
                debug.assert(false, 'Invalid lumianceThreshold and highlightColor adjusting delta.');
                lumianceThreshold = 0.8;
                delta = 0.2;
            }
            // Make it lighter when the lumianceValue is less than 200, otherwise make it darker.
            if (hsvColor.V < lumianceThreshold)
                hsvColor.V = hsvColor.V + delta;
            else
                hsvColor.V = hsvColor.V - delta;
            return hexString(hsvToRgb(hsvColor));
        }
        Color.calculateHighlightColor = calculateHighlightColor;
        function componentToHex(hexComponent) {
            var clamped = Double.ensureInRange(hexComponent, 0, 255);
            var hex = clamped.toString(16).toUpperCase();
            return hex.length === 1 ? "0" + hex : hex;
        }
        function createLinearColorScale(domain, range, clamp) {
            debug.assert(domain.length === range.length, "createLinearColorScale - domain and range must be the same size");
            debug.assert(domain.length > 1, "createLinearColorScale - domain and range must contain at least 2 values");
            var rangeColors = range.map((function (v) { return Color.parseColorString(v); }));
            return function (value) {
                // treat undefined and NULL as 0
                if (value == null)
                    value = 0;
                // Returns undefined for NaN values
                if (isNaN(value))
                    return undefined;
                if (clamp) {
                    if (value >= _.last(domain))
                        return _.last(range);
                    if (value <= domain[0])
                        return range[0];
                }
                var domainMin, domainMax, rangeMin, rangeMax;
                for (var i = 1, len = domain.length; i < len; i++) {
                    domainMin = domain[i - 1];
                    domainMax = domain[i];
                    // In case the domain is from -Infinity to Infinity and Mid point is NaN
                    // The first segment will be from -Infinity to NaN
                    // We should color the value as the end color
                    // This needs to special cased as comparisons against NaN always fail
                    if (domainMin === Number.NEGATIVE_INFINITY && isNaN(domainMax))
                        return range[i];
                    // If min or max are NaN, we can't color any value
                    if (isNaN(domainMin) || isNaN(domainMax))
                        return undefined;
                    if (value === domainMax)
                        return range[i];
                    if (value >= domainMin && value <= domainMax) {
                        rangeMin = rangeColors[i - 1];
                        rangeMax = rangeColors[i];
                        break;
                    }
                }
                var newValue = {
                    R: interpolateValue(value, domainMin, domainMax, rangeMin.R, rangeMax.R),
                    G: interpolateValue(value, domainMin, domainMax, rangeMin.G, rangeMax.G),
                    B: interpolateValue(value, domainMin, domainMax, rangeMin.B, rangeMax.B)
                };
                return Color.hexString(newValue);
            };
        }
        Color.createLinearColorScale = createLinearColorScale;
        function interpolateValue(value, domainMin, domainMax, rangeMin, rangeMax) {
            // In case the range is from Infinitiy to -Infinity with no midpoint
            // All values should be colored as the half-way color
            if (domainMin === Number.NEGATIVE_INFINITY && domainMax === Number.POSITIVE_INFINITY)
                return Math.round((rangeMax + rangeMin) / 2);
            if (domainMin === Number.NEGATIVE_INFINITY)
                return rangeMax;
            if (domainMax === Number.POSITIVE_INFINITY)
                return rangeMin;
            return Math.round(rangeMin + (((value - domainMin) * (rangeMax - rangeMin)) / (domainMax - domainMin)));
        }
        /**
         * Convert string hex expression to number, calculate percentage and R, G, B channels.
         * Apply percentage for each channel and return back hex value as string with pound sign.
         */
        function shadeColor(color, percent) {
            var hexNum = parseInt(color.slice(1), 16);
            var t = percent < 0 ? 0 : 255;
            var p = percent < 0 ? percent * -1 : percent;
            var R = hexNum >> 16;
            var G = hexNum >> 8 & 0x00FF;
            var B = hexNum & 0x0000FF;
            var hexString = "#" + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
            return hexString;
        }
        Color.shadeColor = shadeColor;
        /**
         * Expand a set of colors into a full palette
         */
        function expandDataColorSet(colors, desiredCount) {
            debug.assert(!_.isEmpty(colors), 'colors');
            var colorsCount = colors.length;
            if (colorsCount < desiredCount) {
                colors = _.clone(colors);
                // will work in HSV space
                var hsvColors_1 = _.chain(colors)
                    .map((function (color) { return rgbToHsv(Color.parseColorString(color)); }))
                    .sortBy((function (color) { return color.H; }))
                    .value();
                // get gaps between H-adjacent pairs of colors
                var hsvGaps = _.chain(hsvColors_1)
                    .map((function (color, index) { return ({ color1: color, color2: hsvColors_1[index + 1 === hsvColors_1.length ? 0 : index + 1] }); }))
                    .value();
                var lastColor_1 = rgbToHsv(Color.parseColorString(_.last(colors)));
                for (;;) {
                    hsvGaps.sort((function (a, b) { return comparePairs(a, b, lastColor_1); }));
                    var gap = hsvGaps[0];
                    hsvGaps.splice(0, 1);
                    var color1 = gap.color1;
                    var color2 = gap.color2;
                    var newColor = pickColorBetween(gap);
                    colors.push(hexString(hsvToRgb(newColor)));
                    if (colors.length >= desiredCount)
                        break;
                    hsvGaps.push({ color1: color1, color2: newColor });
                    hsvGaps.push({ color1: newColor, color2: color2 });
                    lastColor_1 = newColor;
                }
            }
            return colors;
        }
        Color.expandDataColorSet = expandDataColorSet;
        // compare gaps but bias away from the last colors
        function comparePairs(a, b, lastColor) {
            // penalty factors to move away from last color
            var h = hNormalize(lastColor.H - 0.1);
            var apenalty = Math.sqrt(2 * dhUnordered(hCenter(a), h));
            var bpenalty = Math.sqrt(2 * dhUnordered(hCenter(b), h));
            // b - a to get descending order
            return bpenalty * dhOrdered(b) - apenalty * dhOrdered(a);
        }
        // H width of gap between two colors
        function dhOrdered(pair) {
            return hNormalize(pair.color2.H - pair.color1.H);
        }
        // H width of gap between two colors *when order is not considered*
        function dhUnordered(h1, h2) {
            var gap = Math.abs(h2 - h1);
            if (gap > 0.5)
                gap -= 1;
            return gap;
        }
        // H in the middle of the gap
        function hCenter(pair) {
            var dh = dhOrdered(pair);
            if (dh === 0)
                dh = 1;
            return (pair.color1.H + dh / 2) % 1;
        }
        function hNormalize(h) {
            h = h % 1;
            if (h < 0)
                h += 1;
            return h;
        }
        function pickColorBetween(pair) {
            var color1 = pair.color1;
            var color2 = pair.color2;
            var h, s, v;
            // split the hue gap
            h = hCenter(pair);
            // keep "colorfulness" about the same
            s = (color1.S + color2.S) / 2;
            // and similarly with V
            v = (color1.V + color2.V) / 2;
            return { H: h, S: s, V: v };
        }
    })(Color = jsCommon.Color || (jsCommon.Color = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var contract;
    (function (contract) {
        /**
         * Checks that the condition is true; throws an exception otherwise.
         */
        function check(condition, message) {
            if (condition !== true)
                fail(message || ('condition: ' + condition));
        }
        contract.check = check;
        /**
         * Checks that the value is neither null nor undefined; throws an exception otherwise.
         */
        function checkValue(value, message) {
            if (value === null || value === undefined)
                fail(message || ('condition: ' + value));
        }
        contract.checkValue = checkValue;
        /**
         * Checks that the value is neither null nor undefined, and has a length property that returns greater than zero;
         * throws an exception otherwise.
         */
        function checkNonEmpty(value, message) {
            if (_.isEmpty(value))
                fail(message || ('condition: ' + value));
        }
        contract.checkNonEmpty = checkNonEmpty;
        /**
         * Throws an exception that indicates a contract failure.
         */
        function fail(message) {
            throw new Error('Contract check failed: ' + message);
        }
        contract.fail = fail;
    })(contract = powerbi.contract || (powerbi.contract = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * CSS constants.
     */
    var CssConstants;
    (function (CssConstants) {
        function createClassAndSelector(className) {
            return {
                class: className,
                selector: '.' + className,
            };
        }
        CssConstants.createClassAndSelector = createClassAndSelector;
        CssConstants.styleAttribute = 'style';
        CssConstants.pixelUnits = 'px';
        CssConstants.heightProperty = 'height';
        CssConstants.widthProperty = 'width';
        CssConstants.topProperty = 'top';
        CssConstants.bottomProperty = 'bottom';
        CssConstants.leftProperty = 'left';
        CssConstants.rightProperty = 'right';
        CssConstants.marginTopProperty = 'margin-top';
        CssConstants.marginLeftProperty = 'margin-left';
        CssConstants.displayProperty = 'display';
        CssConstants.backgroundProperty = 'background';
        CssConstants.backgroundColorProperty = 'background-color';
        CssConstants.backgroundRepeatProperty = 'background-repeat';
        CssConstants.backgroundSizeProperty = 'background-size';
        CssConstants.backgroundImageProperty = 'background-image';
        CssConstants.textShadowProperty = 'text-shadow';
        CssConstants.textAlignProperty = 'text-align';
        CssConstants.borderProperty = 'border';
        CssConstants.borderTopWidthProperty = 'border-top-width';
        CssConstants.borderBottomWidthProperty = 'border-bottom-width';
        CssConstants.borderLeftWidthProperty = 'border-left-width';
        CssConstants.borderRightWidthProperty = 'border-right-width';
        CssConstants.fontFamilyProperty = 'font-family';
        CssConstants.fontSizeProperty = 'font-size';
        CssConstants.fontWeightProperty = 'font-weight';
        CssConstants.colorProperty = 'color';
        CssConstants.opacityProperty = 'opacity';
        CssConstants.paddingLeftProperty = 'padding-left';
        CssConstants.paddingRightProperty = 'padding-right';
        CssConstants.positionProperty = 'position';
        CssConstants.maxWidthProperty = 'max-width';
        CssConstants.minWidthProperty = 'min-width';
        CssConstants.overflowProperty = 'overflow';
        CssConstants.overflowXProperty = 'overflow-x';
        CssConstants.overflowYProperty = 'overflow-y';
        CssConstants.transformProperty = 'transform';
        CssConstants.webkitTransformProperty = '-webkit-transform';
        CssConstants.cursorProperty = 'cursor';
        CssConstants.visibilityProperty = 'visibility';
        CssConstants.absoluteValue = 'absolute';
        CssConstants.zeroPixelValue = '0px';
        CssConstants.autoValue = 'auto';
        CssConstants.hiddenValue = 'hidden';
        CssConstants.noneValue = 'none';
        CssConstants.blockValue = 'block';
        CssConstants.inlineBlockValue = 'inline-block';
        CssConstants.transparentValue = 'transparent';
        CssConstants.boldValue = 'bold';
        CssConstants.visibleValue = 'visible';
        CssConstants.tableRowValue = 'table-row';
        CssConstants.coverValue = 'cover';
        CssConstants.pointerValue = 'pointer';
        CssConstants.scrollValue = 'scroll';
    })(CssConstants = jsCommon.CssConstants || (jsCommon.CssConstants = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Deprecated functions that nevertheless we must use
     */
    var Deprecated;
    (function (Deprecated) {
        Deprecated.escape = window['escape'];
        Deprecated.unescape = window['unescape'];
    })(Deprecated = jsCommon.Deprecated || (jsCommon.Deprecated = {}));
    var API;
    (function (API) {
        function deprecated(message) {
            console.log("Deprecated: " + message);
        }
        API.deprecated = deprecated;
    })(API = jsCommon.API || (jsCommon.API = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Errors;
    (function (Errors) {
        function argumentNull(argumentName) {
            return {
                name: 'argumentNull',
                argument: argumentName,
                message: 'Argument was null',
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentNull = argumentNull;
        function argumentUndefined(argumentName) {
            return {
                name: 'argumentUndefined',
                argument: argumentName,
                message: 'Argument was undefined',
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentUndefined = argumentUndefined;
        function argumentOutOfRange(argumentName) {
            return {
                name: 'argumentOutOfRange',
                argument: argumentName,
                message: 'Argument was out of range',
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentOutOfRange = argumentOutOfRange;
        function notImplementedException(message) {
            return {
                name: 'notImplementedException',
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.notImplementedException = notImplementedException;
        function getExceptionStackTrace() {
            return getStackTrace(/*leadingFramesToRemove*/ 2);
        }
    })(Errors = jsCommon.Errors || (jsCommon.Errors = {}));
    /**
     * Captures the stack trace, if available.
     * It optionally takes the number of frames to remove from the stack trace.
     * By default, it removes the last frame to consider the calling type's
     * constructor and the temporary error used to capture the stack trace (below).
     * More levels can be requested as needed e..g. when an error is created
     * from a helper method. <Min requirement: IE10, Chrome, Firefox, Opera>.
     */
    function getStackTrace(leadingFramesToRemove) {
        if (leadingFramesToRemove === void 0) { leadingFramesToRemove = 1; }
        var stackTrace, stackSegments;
        try {
            // needs to throw for stack trace to work in IE
            throw new Error();
        }
        catch (error) {
            stackTrace = error.stack;
            if (stackTrace != null) {
                stackSegments = stackTrace.split('\n');
                stackSegments.splice(1, leadingFramesToRemove);
                // Finally
                stackTrace = stackSegments.join('\n');
            }
        }
        return stackTrace;
    }
    jsCommon.getStackTrace = getStackTrace;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
$.fn.multiline = function (text) {
    this.text(text);
    this.html(this.html().replace(/\n/g, '<br/>'));
    return this;
};
// Taken from jQuery UI 1.11.1
// Added here for cases when jQuery UI is not on the page, but tabbable psuedo-selector is required.
$.extend($.expr[":"], {
    tabbable: function (element) {
        var tabIndex = parseInt($(element).attr("tabindex"), 10), isTabIndexNaN = isNaN(tabIndex);
        return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    }
});
function focusable(element, isTabIndexNotNaN) {
    var map, mapName, img, nodeName = element.nodeName.toLowerCase();
    if ("area" === nodeName) {
        map = element.parentNode;
        mapName = map.name;
        if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
            return false;
        }
        img = $("img[usemap='#" + mapName + "']")[0];
        return !!img && visible(img);
    }
    return (/input|select|textarea|button|object/.test(nodeName) ?
        !element.disabled :
        "a" === nodeName ?
            element.href || isTabIndexNotNaN :
            isTabIndexNotNaN) &&
        // the element and all of its ancestors must be visible
        visible(element);
}
function visible(element) {
    return $.expr.filters.visible(element) &&
        !$(element).parents().addBack().filter((function () {
            return $(this).css("visibility") === "hidden";
        })).length;
}
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Represents a lazily instantiated value.
     */
    var Lazy = /** @class */ (function () {
        function Lazy(factoryMethod) {
            debug.assertValue(factoryMethod, 'factoryMethod');
            this.factoryMethod = factoryMethod;
        }
        Lazy.prototype.getValue = function () {
            if (this.factoryMethod !== null) {
                this.value = this.factoryMethod();
                // Optimization: Release the factoryMethod, as it could be holding a large object graph.
                this.factoryMethod = null;
            }
            return this.value;
        };
        return Lazy;
    }());
    jsCommon.Lazy = Lazy;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var Prototype;
    (function (Prototype) {
        /**
         * Returns a new object with the provided obj as its prototype.
         */
        function inherit(obj, extension) {
            debug.assertValue(obj, 'obj');
            function wrapCtor() { }
            wrapCtor.prototype = obj;
            var inherited = new wrapCtor();
            if (extension)
                extension(inherited);
            return inherited;
        }
        Prototype.inherit = inherit;
        /**
         * Returns a new object with the provided obj as its prototype
         * if, and only if, the prototype has not been previously set
         */
        function inheritSingle(obj) {
            debug.assertValue(obj, 'obj');
            var proto = Object.getPrototypeOf(obj);
            if (proto === Object.prototype || proto === Array.prototype)
                obj = inherit(obj);
            return obj;
        }
        Prototype.inheritSingle = inheritSingle;
        /**
         * Uses the provided callback function to selectively replace contents in the provided array.
         * @return A new array with those values overriden
         * or undefined if no overrides are necessary.
         */
        function overrideArray(prototype, override) {
            if (!prototype)
                return;
            var overwritten;
            for (var i = 0, len = prototype.length; i < len; i++) {
                var value = override(prototype[i]);
                if (value) {
                    if (!overwritten)
                        overwritten = inherit(prototype);
                    overwritten[i] = value;
                }
            }
            return overwritten;
        }
        Prototype.overrideArray = overrideArray;
        /**
         * Helper usually called after _.cloneDeep().
         * Current version of lodash doesn't copy the prototype of each object.
         * The function recursively copies the prototype of the "from" object to the "to" and its descendants if needed.
         * @param from - object which its prototype recursively will be copied.
         * @param to - object which its prototype will be updated.
         *
         */
        function copyPrototypeDeep(from, to) {
            if (!from || !to || typeof from !== "object")
                return;
            if (Object.getPrototypeOf(from) !== Object.getPrototypeOf(to)) {
                to.__proto__ = from.__proto__;
            }
            for (var _i = 0, _a = Object.getOwnPropertyNames(from); _i < _a.length; _i++) {
                var key = _a[_i];
                copyPrototypeDeep(from[key], to[key]);
            }
        }
        Prototype.copyPrototypeDeep = copyPrototypeDeep;
    })(Prototype = powerbi.Prototype || (powerbi.Prototype = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Formatting;
    (function (Formatting) {
        var regexCache;
        /**
         * Translate .NET format into something supported by jQuery.Globalize.
         */
        function findDateFormat(value, format, cultureName) {
            switch (format) {
                case "m":
                    // Month + day
                    format = "M";
                    break;
                case "O":
                case "o":
                    // Roundtrip
                    format = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff'0000'";
                    break;
                case "R":
                case "r":
                    // RFC1123 pattern - - time must be converted to UTC before formatting 
                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                    format = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
                    break;
                case "s":
                    // Sortable - should use invariant culture
                    format = "S";
                    break;
                case "u":
                    // Universal sortable - should convert to UTC before applying the "yyyy'-'MM'-'dd HH':'mm':'ss'Z' format.
                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                    format = "yyyy'-'MM'-'dd HH':'mm':'ss'Z'";
                    break;
                case "U":
                    // Universal full - the pattern is same as F but the time must be converted to UTC before formatting
                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                    format = "F";
                    break;
                case "y":
                case "Y":
                    // Year and month
                    switch (cultureName) {
                        case "default":
                        case "en":
                        case "en-US":
                            format = "MMMM, yyyy"; // Fix the default year-month pattern for english
                            break;
                        default:
                            format = "Y"; // For other cultures - use the localized pattern
                    }
                    break;
            }
            return { value: value, format: format };
        }
        Formatting.findDateFormat = findDateFormat;
        /**
         * Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize.
         */
        function fixDateTimeFormat(format) {
            // Fix for the "K" format (timezone): 
            //The js dates don't have a kind property so we'll support only local kind which is equavalent to zzz format.
            format = format.replace(/%K/g, "zzz");
            format = format.replace(/K/g, "zzz");
            format = format.replace(/fffffff/g, "fff0000");
            format = format.replace(/ffffff/g, "fff000");
            format = format.replace(/fffff/g, "fff00");
            format = format.replace(/ffff/g, "fff0");
            // Fix for the 5 digit year: "yyyyy" format. 
            //The Globalize doesn't support dates greater than 9999 so we replace the "yyyyy" with "0yyyy".
            format = format.replace(/yyyyy/g, "0yyyy");
            // Fix for the 3 digit year: "yyy" format. 
            //The Globalize doesn't support this formatting so we need to replace it with the 4 digit year "yyyy" format.
            format = format.replace(/(^y|^)yyy(^y|$)/g, "yyyy");
            if (!regexCache) {
                // Creating Regexes for cases "Using single format specifier" 
                //- http://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx#UsingSingleSpecifiers
                // This is not supported from The Globalize.
                // The case covers all single "%" lead specifier (like "%d" but not %dd) 
                // The cases as single "%d" are filtered in if the bellow.
                // (?!S) where S is the specifier make sure that we only one symbol for specifier.
                regexCache = ["d", "f", "F", "g", "h", "H", "K", "m", "M", "s", "t", "y", "z", ":", "/"].map((function (s) {
                    return { r: new RegExp("\%" + s + "(?!" + s + ")", "g"), s: s };
                }));
            }
            if (format.indexOf("%") !== -1 && format.length > 2) {
                for (var _i = 0, regexCache_1 = regexCache; _i < regexCache_1.length; _i++) {
                    var cacheItem = regexCache_1[_i];
                    format = format.replace(cacheItem.r, cacheItem.s);
                }
            }
            return format;
        }
        Formatting.fixDateTimeFormat = fixDateTimeFormat;
    })(Formatting = jsCommon.Formatting || (jsCommon.Formatting = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Http Status code we are interested.
     */
    var HttpStatusCode;
    (function (HttpStatusCode) {
        HttpStatusCode[HttpStatusCode["OK"] = 200] = "OK";
        HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
        HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
        HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
        HttpStatusCode[HttpStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    })(HttpStatusCode = jsCommon.HttpStatusCode || (jsCommon.HttpStatusCode = {}));
    /**
     * Other HTTP Constants.
     */
    var HttpConstants;
    (function (HttpConstants) {
        HttpConstants.ApplicationOctetStream = 'application/octet-stream';
        HttpConstants.JsonContentType = 'application/json';
        HttpConstants.JpegContentType = 'image/jpeg';
        HttpConstants.Blob = 'blob';
        HttpConstants.ArrayBuffer = 'arraybuffer';
        HttpConstants.Accept = 'Accept';
    })(HttpConstants = jsCommon.HttpConstants || (jsCommon.HttpConstants = {}));
    /**
     * Extensions to String class.
     */
    var StringExtensions;
    (function (StringExtensions) {
        var HtmlTagRegex = new RegExp('[<>]', 'g');
        function format() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var s = args[0];
            if (isNullOrUndefinedOrWhiteSpaceString(s))
                return s;
            for (var i = 0; i < args.length - 1; i++) {
                var reg = new RegExp("\\{" + i + "\\}", "gm");
                s = s.replace(reg, args[i + 1]);
            }
            return s;
        }
        StringExtensions.format = format;
        /**
         * Compares two strings for equality, ignoring case.
         */
        function equalIgnoreCase(a, b) {
            return StringExtensions.normalizeCase(a) === StringExtensions.normalizeCase(b);
        }
        StringExtensions.equalIgnoreCase = equalIgnoreCase;
        function startsWithIgnoreCase(a, b) {
            var normalizedSearchString = StringExtensions.normalizeCase(b);
            return StringExtensions.normalizeCase(a).indexOf(normalizedSearchString) === 0;
        }
        StringExtensions.startsWithIgnoreCase = startsWithIgnoreCase;
        /** Determines whether a string contains a specified substring (by case-sensitive comparison). */
        function contains(source, substring) {
            if (source == null)
                return false;
            return source.indexOf(substring) !== -1;
        }
        StringExtensions.contains = contains;
        /** Determines whether a string contains a specified substring (while ignoring case). */
        function containsIgnoreCase(source, substring) {
            if (source == null)
                return false;
            return contains(normalizeCase(source), normalizeCase(substring));
        }
        StringExtensions.containsIgnoreCase = containsIgnoreCase;
        /**
         * Normalizes case for a string.
         * Used by equalIgnoreCase method.
         */
        function normalizeCase(value) {
            Utility.throwIfNullOrUndefined(value, StringExtensions, 'normalizeCase', 'value');
            return value.toUpperCase();
        }
        StringExtensions.normalizeCase = normalizeCase;
        /**
         * Returns true if the string is null, undefined, empty, or only includes white spaces.
         * @return True if the str is null, undefined, empty, or only includes white spaces,
         * otherwise false.
         */
        function isNullOrUndefinedOrWhiteSpaceString(str) {
            return _.isEmpty(str) || _.isEmpty(str.trim());
        }
        StringExtensions.isNullOrUndefinedOrWhiteSpaceString = isNullOrUndefinedOrWhiteSpaceString;
        /**
         * Returns a value indicating whether the str contains any whitespace.
         */
        function containsWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, Utility, 'containsWhitespace', 'str');
            var expr = /\s/;
            return expr.test(str);
        }
        StringExtensions.containsWhitespace = containsWhitespace;
        /**
         * Returns a value indicating whether the str is a whitespace string.
         */
        function isWhitespace(str) {
            return _.trim(str) === '';
        }
        StringExtensions.isWhitespace = isWhitespace;
        /**
         * Returns the string with any trailing whitespace from str removed.
         */
        function trimTrailingWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, Utility, 'trimTrailingWhitespace', 'str');
            return str.replace(/\s+$/, '');
        }
        StringExtensions.trimTrailingWhitespace = trimTrailingWhitespace;
        /**
         * Returns the string with any leading and trailing whitespace from str removed.
         */
        function trimWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, Utility, 'trimWhitespace', 'str');
            return str.replace(/^\s+/, '').replace(/\s+$/, '');
        }
        StringExtensions.trimWhitespace = trimWhitespace;
        /**
         * Replace all the occurrences of the textToFind in the text with the textToReplace.
         * @param text The original string.
         * @param textToFind Text to find in the original string.
         * @param textToReplace New text replacing the textToFind.
         */
        function replaceAll(text, textToFind, textToReplace) {
            if (!textToFind)
                return text;
            var pattern = escapeStringForRegex(textToFind);
            return text.replace(new RegExp(pattern, 'gi'), textToReplace);
        }
        StringExtensions.replaceAll = replaceAll;
        function ensureUniqueNames(names) {
            debug.assertValue(names, 'names');
            var usedNames = {};
            // Make sure we are giving fair chance for all columns to stay with their original name
            // First we fill the used names map to contain all the original unique names from the list.
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                usedNames[name_1] = false;
            }
            var uniqueNames = [];
            // Now we go over all names and find a unique name for each
            for (var _a = 0, names_2 = names; _a < names_2.length; _a++) {
                var name_2 = names_2[_a];
                var uniqueName = name_2;
                // If the (original) column name is already taken lets try to find another name
                if (usedNames[uniqueName]) {
                    var counter = 0;
                    // Find a name that is not already in the map
                    while (usedNames[uniqueName] !== undefined) {
                        uniqueName = name_2 + "." + (++counter);
                    }
                }
                uniqueNames.push(uniqueName);
                usedNames[uniqueName] = true;
            }
            return uniqueNames;
        }
        StringExtensions.ensureUniqueNames = ensureUniqueNames;
        /**
         * Returns a name that is not specified in the values.
         */
        function findUniqueName(usedNames, baseName, startSuffix) {
            debug.assertValue(usedNames, 'usedNames');
            debug.assertValue(baseName, 'baseName');
            debug.assert(startSuffix == null || startSuffix >= 0, 'startSuffix == null || startSuffix >= 0');
            var i = startSuffix || 0, uniqueName = baseName;
            if (startSuffix)
                uniqueName += startSuffix;
            // Find a unique name
            while (usedNames[uniqueName]) {
                uniqueName = baseName + (++i);
            }
            return uniqueName;
        }
        StringExtensions.findUniqueName = findUniqueName;
        function constructNameFromList(list, separator, maxCharacter) {
            var labels = [];
            var exceeded;
            var length = 0;
            for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                var item = list_1[_i];
                if (length + item.length > maxCharacter && labels.length > 0) {
                    exceeded = true;
                    break;
                }
                labels.push(item);
                length += item.length;
            }
            var separatorWithSpace = ' ' + separator + ' ';
            var name = labels.join(separatorWithSpace);
            if (exceeded)
                name += separatorWithSpace + "...";
            return name;
        }
        StringExtensions.constructNameFromList = constructNameFromList;
        function constructCommaSeparatedList(list, resourceProvider, maxValue) {
            if (!list || list.length === 0)
                return '';
            if (maxValue === null || maxValue === undefined)
                maxValue = Number.MAX_VALUE;
            var length = Math.min(maxValue, list.length);
            var replacedList = [];
            // Only need to replace user entries of {0} and {1} since we build the list in pairs.
            for (var j = 0; j < 2; j++) {
                var targetValue = '{' + j + '}';
                var replaceValue = '_|_<' + j + '>_|_';
                for (var i = 0; i < length; i++) {
                    if (list[i].indexOf(targetValue) > -1) {
                        list[i] = list[i].replace(targetValue, replaceValue);
                        replacedList.push({ targetValue: targetValue, replaceValue: replaceValue });
                    }
                }
            }
            var commaSeparatedList = '';
            for (var i = 0; i < length; i++) {
                if (i === 0)
                    commaSeparatedList = list[i];
                else
                    commaSeparatedList = StringExtensions.format(resourceProvider.get('FilterRestatement_Comma'), commaSeparatedList, list[i]);
            }
            for (var _i = 0, replacedList_1 = replacedList; _i < replacedList_1.length; _i++) {
                var replacedItem = replacedList_1[_i];
                commaSeparatedList = commaSeparatedList.replace(replacedItem.replaceValue, replacedItem.targetValue);
            }
            return commaSeparatedList;
        }
        StringExtensions.constructCommaSeparatedList = constructCommaSeparatedList;
        function escapeStringForRegex(s) {
            return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
        }
        StringExtensions.escapeStringForRegex = escapeStringForRegex;
        /**
         * Remove file name reserved characters <>:"/\|?* from input string.
         */
        function normalizeFileName(fileName) {
            debug.assertValue(fileName, 'fileName');
            return fileName.replace(/[\<\>\:"\/\\\|\?*]/g, '');
        }
        StringExtensions.normalizeFileName = normalizeFileName;
        /**
         * Similar to JSON.stringify, but strips away escape sequences so that the resulting
         * string is human-readable (and parsable by JSON formatting/validating tools).
         */
        function stringifyAsPrettyJSON(object) {
            //let specialCharacterRemover = (key: string, value: string) => value.replace(/[^\w\s]/gi, '');
            return JSON.stringify(object /*, specialCharacterRemover*/);
        }
        StringExtensions.stringifyAsPrettyJSON = stringifyAsPrettyJSON;
        /**
         * Derive a CLS-compliant name from a specified string.  If no allowed characters are present, return a fallback string instead.
         * TODO (6708134): this should have a fully Unicode-aware implementation
         */
        function deriveClsCompliantName(input, fallback) {
            debug.assertValue(input, 'input');
            var result = input.replace(/^[^A-Za-z]*/g, '').replace(/[ :\.\/\\\-\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000]/g, '_').replace(/[\W]/g, '');
            return result.length > 0 ? result : fallback;
        }
        StringExtensions.deriveClsCompliantName = deriveClsCompliantName;
        /** Performs cheap sanitization by stripping away HTML tag (<>) characters. */
        function stripTagDelimiters(s) {
            return s.replace(HtmlTagRegex, '');
        }
        StringExtensions.stripTagDelimiters = stripTagDelimiters;
        /**
         * Converts string into the HTML encoded string. This is the same as the .NET HttpUtility.HtmlEncode() method.
         * Encodes certain characters (for example '<','>','"') into html entities (&lt;&gt;&quot;) so the returned string is safe to be used inside of the div/spans tags or inside quoted attributes except inside url/event handlers.
         * @param value - value to be html encoded
         * @param encodeSpaces - should the spaces be encoded as nonbreakable spaces (&nbsp;) - this is usefull when spaces should be preserved & shown in the html as in the original text
         */
        function encodeHtml(value, encodeSpaces) {
            if (encodeSpaces === void 0) { encodeSpaces = false; }
            if (!value) {
                return value;
            }
            var result = value
                .replace(/&/g, "&amp;") // &
                .replace(/</g, "&lt;") // <
                .replace(/>/g, "&gt;") // >
                .replace(/\"/g, "&quot;") // "
                .replace(/\'/g, "&#39;") // '
                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, (function (match) {
                var hi = match.charCodeAt(0);
                var low = match.charCodeAt(1);
                return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
            }))
                .replace(/([^!-~ ])/g, (function (match) {
                return '&#' + match.charCodeAt(0) + ';';
            }));
            if (encodeSpaces) {
                result = result.replace(/\ /g, "&nbsp;"); // space
            }
            return result;
        }
        StringExtensions.encodeHtml = encodeHtml;
    })(StringExtensions = jsCommon.StringExtensions || (jsCommon.StringExtensions = {}));
    /**
     * The general utility class.
     */
    var Utility;
    (function (Utility) {
        var staticContentLocation = window.location.protocol + '//' + window.location.host;
        /**
         * Ensures the specified value is not null or undefined. Throws a relevent exception if it is.
         * @param value The value to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name of the value to check.
         */
        function throwIfNullOrUndefined(value, context, methodName, parameterName) {
            if (value === null) {
                Utility.throwException(jsCommon.Errors.argumentNull(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
            else if (value === undefined) {
                Utility.throwException(jsCommon.Errors.argumentUndefined(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        }
        Utility.throwIfNullOrUndefined = throwIfNullOrUndefined;
        /**
         * Ensures the specified string is not null, undefined or empty. Throws a relevent exception if it is.
         * @param value The value to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name of the value to check.
         */
        function throwIfNullOrEmptyString(value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (value.length < 1) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        }
        Utility.throwIfNullOrEmptyString = throwIfNullOrEmptyString;
        /**
         * Checks if the value is defined and returns it, else, returns undefined
         * @param {T} value Value to check
         * @param {T} defaultValue Default value to return if value is undefined
         * @returns value if defined, else defaultValue
         */
        function valueOrDefault(value, defaultValue) {
            if (value != null)
                return value;
            return defaultValue;
        }
        Utility.valueOrDefault = valueOrDefault;
        /**
         * Combine a base url and a path.
         * @param baseUrl The base url.
         * @param path The path to add on to the base url.
         * @returns The combined url.
         */
        function urlCombine(baseUrl, path) {
            Utility.throwIfNullOrUndefined(baseUrl, null, "urlCombine", "baseUrl");
            Utility.throwIfNullOrUndefined(path, null, "urlCombine", "path");
            // should any of the components be empty, fail gracefuly - this is important when using the test page
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(path)) {
                return baseUrl;
            }
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(baseUrl)) {
                return path;
            }
            var finalUrl = baseUrl;
            if (finalUrl.charAt(finalUrl.length - 1) === '/') {
                if (path.charAt(0) === '/')
                    path = path.slice(1);
            }
            else {
                if (path.charAt(0) !== '/')
                    path = '/' + path;
            }
            return finalUrl + path;
        }
        Utility.urlCombine = urlCombine;
        function getAbsoluteUri(path) {
            Utility.throwIfNullOrUndefined(path, null, "getAbsoluteUri", "path");
            var url = path;
            // Make absolute
            if (url && url.indexOf('http') === -1) {
                url = Utility.urlCombine(clusterUri, url);
            }
            return url;
        }
        Utility.getAbsoluteUri = getAbsoluteUri;
        function getStaticResourceUri(path) {
            Utility.throwIfNullOrUndefined(path, null, "getStaticResourceUri", "path");
            var url = path;
            // Make absolute
            if (url && url.indexOf('http') === -1) {
                url = jsCommon.Utility.urlCombine(staticContentLocation, url);
            }
            return url;
        }
        Utility.getStaticResourceUri = getStaticResourceUri;
        function getComponentName(context) {
            return !context ? '' : (typeof context).toString() + '.';
        }
        Utility.getComponentName = getComponentName;
        function throwException(e) {
            jsCommon.Trace.error("Throwing exception: " + JSON.stringify(e), 
            /*includeStackTrace*/ e.stack != null ? false : true);
            throw e;
        }
        Utility.throwException = throwException;
        function createClassSelector(className) {
            Utility.throwIfNullOrEmptyString(className, null, 'CreateClassSelector', 'className');
            return '.' + className;
        }
        Utility.createClassSelector = createClassSelector;
        function createIdSelector(id) {
            Utility.throwIfNullOrEmptyString(id, null, 'CreateIdSelector', 'id');
            return '#' + id;
        }
        Utility.createIdSelector = createIdSelector;
        /**
         * Take numeric value, min and max and normalize it to be greater than
         * or equal to the min number and less than or equal to the max number.
         * @param value The value to be normalized
         * @param min min value allowed
         * @param max max value allowed
         */
        function clampValue(value, min, max) {
            debug.assert(min <= max, "min value must be less than or equal the max value");
            value = Math.min(value, max);
            value = Math.max(value, min);
            return value;
        }
        Utility.clampValue = clampValue;
        /**
         * Creates a client-side Guid string.
         * @returns A string representation of a Guid.
         */
        function generateGuid() {
            var guid = "", idx = 0;
            for (idx = 0; idx < 32; idx += 1) {
                var guidDigitsItem = Math.random() * 16 | 0;
                switch (idx) {
                    case 8:
                    case 12:
                    case 16:
                    case 20:
                        guid += "-";
                        break;
                }
                guid += guidDigitsItem.toString(16);
            }
            return guid;
        }
        Utility.generateGuid = generateGuid;
        /**
         * Try extract a cookie from {@link document.cookie} identified by key.
         */
        function getCookieValue(key) {
            // the cookie is of the format <key1=value1>; <key2=value2>. Split by ';', then by '=' 
            // to search for the key
            var keyValuePairs = document.cookie.split(';');
            for (var _i = 0, keyValuePairs_1 = keyValuePairs; _i < keyValuePairs_1.length; _i++) {
                var keyValue = keyValuePairs_1[_i];
                var split = keyValue.split('=');
                if (split.length > 0 && split[0].trim() === key) {
                    return keyValue.substr(keyValue.indexOf('=') + 1);
                }
            }
            return null;
        }
        Utility.getCookieValue = getCookieValue;
        /**
         * Extracts the protocol://hostname section of a url.
         * @param url The URL from which to extract the section.
         * @returns The protocol://hostname portion of the given URL.
         */
        function getDomainForUrl(url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return hrefObject.prop('protocol') + '//' + hrefObject.prop('hostname');
        }
        Utility.getDomainForUrl = getDomainForUrl;
        /**
         * Extracts the hostname and absolute path sections of a url.
         * @param url The URL from which to extract the section.
         * @returns The hostname and absolute path portion of the given URL.
         */
        function getHostNameForUrl(url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return Utility.urlCombine(hrefObject.prop('hostname'), hrefObject.prop('pathname'));
        }
        Utility.getHostNameForUrl = getHostNameForUrl;
        /**
         * Return the original url with query string stripped.
         * @param url The URL from which to extract the section.
         * @returns the original url with query string stripped.
         */
        function getUrlWithoutQueryString(url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return hrefObject.prop('protocol') + '//' + Utility.urlCombine(hrefObject.prop('host'), hrefObject.prop('pathname'));
        }
        Utility.getUrlWithoutQueryString = getUrlWithoutQueryString;
        /**
         * Extracts the protocol section of a url.
         * @param url The URL from which to extract the section.
         * @returns The protocol for the current URL.
         */
        function getProtocolFromUrl(url) {
            return Utility.getHrefObjectFromUrl(url).prop('protocol').replace(':', '');
        }
        Utility.getProtocolFromUrl = getProtocolFromUrl;
        /**
         * Returns a formatted href object from a URL.
         * @param url The URL used to generate the object.
         * @returns A jQuery object with the url.
         */
        function getHrefObjectFromUrl(url) {
            var aObject = $('<a>');
            aObject = aObject.prop('href', url);
            return aObject;
        }
        Utility.getHrefObjectFromUrl = getHrefObjectFromUrl;
        function getDateFromWcfJsonString(jsonDate, fromUtcMilliseconds) {
            if (_.isEmpty(jsonDate)) {
                return null;
            }
            var begIndex = jsonDate.indexOf('(');
            var endIndex = jsonDate.indexOf(')');
            if (begIndex !== -1 && endIndex !== -1) {
                var milliseconds = parseInt(jsonDate.substring(begIndex + 1, endIndex), 10);
                if (isNaN(milliseconds))
                    milliseconds = 0; // fallback
                if (fromUtcMilliseconds) {
                    return new Date(milliseconds);
                }
                else {
                    var retValue = new Date(0);
                    retValue.setUTCMilliseconds(milliseconds);
                    return retValue;
                }
            }
            return null;
        }
        Utility.getDateFromWcfJsonString = getDateFromWcfJsonString;
        /**
         * Verifies image data url of images.
         */
        function isValidImageDataUrl(url) {
            var regex = new RegExp('data:(image\/(png|jpg|jpeg|gif|svg))');
            return regex.test(url);
        }
        Utility.isValidImageDataUrl = isValidImageDataUrl;
        function isLocalUrl(url) {
            return _.startsWith(url, "data:") || _.startsWith(url, "blob:");
        }
        Utility.isLocalUrl = isLocalUrl;
        /**
         * Extract the filename out of a full path delimited by '\' or '/'.
         * @param filePath File path.
         * @returns filename File name.
         */
        function extractFileNameFromPath(filePath) {
            return filePath.replace(/^.*[\\\/]/, '');
        }
        Utility.extractFileNameFromPath = extractFileNameFromPath;
        /**
         * This method indicates whether window.clipboardData is supported.
         * For example, clipboard support for Windows Store apps is currently disabled
         * since window.clipboardData is unsupported (it raises access denied error)
         * since clipboard in Windows Store is being
         * achieved through Windows.ApplicationModel.DataTransfer.Clipboard class.
         */
        function canUseClipboard() {
            return (typeof MSApp === "undefined");
        }
        Utility.canUseClipboard = canUseClipboard;
        function is64BitOperatingSystem() {
            return navigator.userAgent.indexOf("WOW64") !== -1 ||
                navigator.userAgent.indexOf("Win64") !== -1;
        }
        Utility.is64BitOperatingSystem = is64BitOperatingSystem;
        function parseNumber(value, defaultValue) {
            if (value === null)
                return null;
            if (value === undefined)
                return defaultValue;
            var result = Number(value);
            if (isFinite(result))
                return result;
            if (isNaN(result) && !(typeof value === "number" || value === "NaN"))
                return defaultValue;
            return result;
        }
        Utility.parseNumber = parseNumber;
        function getURLParamValue(name) {
            var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
            if (results == null) {
                return null;
            }
            else {
                return results[1] || 0;
            }
        }
        Utility.getURLParamValue = getURLParamValue;
        /**
         * Return local timezone.
         * This function uses summer and winter offset to determine local time zone.
         * The result localTimeZoneString must be a subset of the strings used by server,
         * as documented here: https://msdn.microsoft.com/en-us/library/gg154758.aspx (Dynamic Daylight Savings Time (Compact 2013)).
         * @return Local timezone string or UTC if timezone cannot be found.
         */
        function getLocalTimeZoneString() {
            var timeSummer = new Date(Date.UTC(2005, 6, 30, 0, 0, 0, 0));
            var summerOffset = -1 * timeSummer.getTimezoneOffset();
            var timeWinter = new Date(Date.UTC(2005, 12, 30, 0, 0, 0, 0));
            var winterOffset = -1 * timeWinter.getTimezoneOffset();
            var localTimeZoneString;
            if (-720 === summerOffset && -720 === winterOffset) {
                localTimeZoneString = 'Dateline Standard Time';
            }
            else if (-660 === summerOffset && -660 === winterOffset) {
                localTimeZoneString = 'UTC-11';
            }
            else if (-660 === summerOffset && -660 === winterOffset) {
                localTimeZoneString = 'Samoa Standard Time';
            }
            else if (-600 === summerOffset && -600 === winterOffset) {
                localTimeZoneString = 'Hawaiian Standard Time';
            }
            else if (-480 === summerOffset && -540 === winterOffset) {
                localTimeZoneString = 'Alaskan Standard Time';
            }
            else if (-420 === summerOffset && -480 === winterOffset) {
                localTimeZoneString = 'Pacific Standard Time';
            }
            else if (-420 === summerOffset && -420 === winterOffset) {
                localTimeZoneString = 'US Mountain Standard Time';
            }
            else if (-360 === summerOffset && -420 === winterOffset) {
                localTimeZoneString = 'Mountain Standard Time';
            }
            else if (-360 === summerOffset && -360 === winterOffset) {
                localTimeZoneString = 'Central America Standard Time';
            }
            else if (-300 === summerOffset && -360 === winterOffset) {
                localTimeZoneString = 'Central Standard Time';
            }
            else if (-300 === summerOffset && -300 === winterOffset) {
                localTimeZoneString = 'SA Pacific Standard Time';
            }
            else if (-240 === summerOffset && -300 === winterOffset) {
                localTimeZoneString = 'Eastern Standard Time';
            }
            else if (-270 === summerOffset && -270 === winterOffset) {
                localTimeZoneString = 'Venezuela Standard Time';
            }
            else if (-240 === summerOffset && -240 === winterOffset) {
                localTimeZoneString = 'SA Western Standard Time';
            }
            else if (-240 === summerOffset && -180 === winterOffset) {
                localTimeZoneString = 'Central Brazilian Standard Time';
            }
            else if (-180 === summerOffset && -240 === winterOffset) {
                localTimeZoneString = 'Atlantic Standard Time';
            }
            else if (-180 === summerOffset && -180 === winterOffset) {
                localTimeZoneString = 'Montevideo Standard Time';
            }
            else if (-180 === summerOffset && -120 === winterOffset) {
                localTimeZoneString = 'E. South America Standard Time';
            }
            else if (-150 === summerOffset && -210 === winterOffset) {
                localTimeZoneString = 'Mid-Atlantic Standard Time';
            }
            else if (-120 === summerOffset && -120 === winterOffset) {
                localTimeZoneString = 'SA Eastern Standard Time';
            }
            else if (0 === summerOffset && 0 === winterOffset) {
                localTimeZoneString = 'UTC';
            }
            else if (60 === summerOffset && 0 === winterOffset) {
                localTimeZoneString = 'GMT Standard Time';
            }
            else if (60 === summerOffset && 120 === winterOffset) {
                localTimeZoneString = 'Namibia Standard Time';
            }
            else if (120 === summerOffset && 60 === winterOffset) {
                localTimeZoneString = 'Romance Standard Time';
            }
            else if (120 === summerOffset && 120 === winterOffset) {
                localTimeZoneString = 'South Africa Standard Time';
            }
            else if (180 === summerOffset && 120 === winterOffset) {
                localTimeZoneString = 'GTB Standard Time';
            }
            else if (180 === summerOffset && 180 === winterOffset) {
                localTimeZoneString = 'E. Africa Standard Time';
            }
            else if (240 === summerOffset && 180 === winterOffset) {
                localTimeZoneString = 'Russian Standard Time';
            }
            else if (240 === summerOffset && 240 === winterOffset) {
                localTimeZoneString = 'Arabian Standard Time';
            }
            else if (270 === summerOffset && 210 === winterOffset) {
                localTimeZoneString = 'Iran Standard Time';
            }
            else if (270 === summerOffset && 270 === winterOffset) {
                localTimeZoneString = 'Afghanistan Standard Time';
            }
            else if (300 === summerOffset && 240 === winterOffset) {
                localTimeZoneString = 'Pakistan Standard Time';
            }
            else if (300 === summerOffset && 300 === winterOffset) {
                localTimeZoneString = 'West Asia Standard Time';
            }
            else if (330 === summerOffset && 330 === winterOffset) {
                localTimeZoneString = 'India Standard Time';
            }
            else if (345 === summerOffset && 345 === winterOffset) {
                localTimeZoneString = 'Nepal Standard Time';
            }
            else if (360 === summerOffset && 300 === winterOffset) {
                localTimeZoneString = 'N. Central Asia Standard Time';
            }
            else if (360 === summerOffset && 360 === winterOffset) {
                localTimeZoneString = 'Central Asia Standard Time';
            }
            else if (390 === summerOffset && 390 === winterOffset) {
                localTimeZoneString = 'Myanmar Standard Time';
            }
            else if (420 === summerOffset && 360 === winterOffset) {
                localTimeZoneString = 'North Asia Standard Time';
            }
            else if (420 === summerOffset && 420 === winterOffset) {
                localTimeZoneString = 'SE Asia Standard Time';
            }
            else if (480 === summerOffset && 420 === winterOffset) {
                localTimeZoneString = 'North Asia East Standard Time';
            }
            else if (480 === summerOffset && 480 === winterOffset) {
                localTimeZoneString = 'China Standard Time';
            }
            else if (540 === summerOffset && 480 === winterOffset) {
                localTimeZoneString = 'Yakutsk Standard Time';
            }
            else if (540 === summerOffset && 540 === winterOffset) {
                localTimeZoneString = 'Tokyo Standard Time';
            }
            else if (570 === summerOffset && 570 === winterOffset) {
                localTimeZoneString = 'Cen. Australia Standard Time';
            }
            else if (600 === summerOffset && 600 === winterOffset) {
                localTimeZoneString = 'E. Australia Standard Time';
            }
            else if (600 === summerOffset && 660 === winterOffset) {
                localTimeZoneString = 'AUS Eastern Standard Time';
            }
            else if (660 === summerOffset && 600 === winterOffset) {
                localTimeZoneString = 'Tasmania Standard Time';
            }
            else if (660 === summerOffset && 660 === winterOffset) {
                localTimeZoneString = 'West Pacific Standard Time';
            }
            else if (690 === summerOffset && 690 === winterOffset) {
                localTimeZoneString = 'Central Pacific Standard Time';
            }
            else if (720 === summerOffset && 660 === winterOffset) {
                localTimeZoneString = 'Magadan Standard Time';
            }
            else if (720 === summerOffset && 720 === winterOffset) {
                localTimeZoneString = 'Fiji Standard Time';
            }
            else if (720 === summerOffset && 780 === winterOffset) {
                localTimeZoneString = 'New Zealand Standard Time';
            }
            else if (780 === summerOffset && 780 === winterOffset) {
                localTimeZoneString = 'Tonga Standard Time';
            }
            else {
                localTimeZoneString = 'UTC';
            }
            return localTimeZoneString;
        }
        Utility.getLocalTimeZoneString = getLocalTimeZoneString;
    })(Utility = jsCommon.Utility || (jsCommon.Utility = {}));
    var VersionUtility = /** @class */ (function () {
        function VersionUtility() {
        }
        /**
         * Compares 2 version strings.
         * @param versionA The first version string.
         * @param versionB The second version string.
         * @returns A result for the comparison.
         */
        VersionUtility.compareVersions = function (versionA, versionB) {
            var a = versionA.split('.').map(parseFloat);
            var b = versionB.split('.').map(parseFloat);
            var versionParts = Math.max(a.length, b.length);
            for (var i = 0; i < versionParts; i++) {
                var partA = a[i] || 0;
                var partB = b[i] || 0;
                if (partA > partB)
                    return 1;
                if (partA < partB)
                    return -1;
            }
            return 0;
        };
        return VersionUtility;
    }());
    jsCommon.VersionUtility = VersionUtility;
    var PerfTimer;
    (function (PerfTimer) {
        /** Begins a perf marker that can be completed by invoking the returned function. */
        function start(name) {
            var performance = window.performance;
            if (!performance || !performance.mark)
                return _.noop;
            if (console.time)
                console.time(name);
            var startMark = 'Begin ' + name;
            performance.mark(startMark);
            return function () {
                var end = 'End ' + name;
                performance.mark(end);
                // NOTE: Chromium supports performance.mark but not performance.measure.
                if (performance.measure)
                    performance.measure(name, startMark, end);
                if (console.timeEnd)
                    console.timeEnd(name);
            };
        }
        PerfTimer.start = start;
        /** Logs time using Date.now() and returns the duration to execute the action in ms */
        function logTime(action) {
            // Desktop's old Chromium doesn't support use of Performance Markers yet  
            var start = Date.now();
            action();
            return Date.now() - start;
        }
        PerfTimer.logTime = logTime;
    })(PerfTimer = jsCommon.PerfTimer || (jsCommon.PerfTimer = {}));
    var DeferUtility;
    (function (DeferUtility) {
        /**
         * Wraps a callback and returns a new function.
         * The function can be called many times but the callback
         * will only be executed once on the next frame.
         * Use this to throttle big UI updates and access to DOM.
         */
        function deferUntilNextFrame(callback) {
            var isWaiting, args, context;
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = function (func) { return setTimeout(func, 1000 / 50); };
            }
            return function () {
                if (!isWaiting) {
                    isWaiting = true;
                    args = arguments;
                    context = this;
                    window.requestAnimationFrame((function () {
                        isWaiting = false;
                        callback.apply(context, args);
                    }));
                }
            };
        }
        DeferUtility.deferUntilNextFrame = deferUntilNextFrame;
    })(DeferUtility = jsCommon.DeferUtility || (jsCommon.DeferUtility = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var PerfTimer = jsCommon.PerfTimer;
    function createModuleLoader(promiseFactory, loadTelemetry, config, rjs) {
        return new ModuleLoader(promiseFactory, loadTelemetry, config, rjs);
    }
    powerbi.createModuleLoader = createModuleLoader;
    var ModuleLoader = /** @class */ (function () {
        function ModuleLoader(promiseFactory, telemetry, config, rjs) {
            this.promiseFactory = promiseFactory;
            this.telemetry = telemetry;
            this.rjs = rjs || window.require;
            this.active = {};
            debug.assertValue(this.rjs, 'Could not load require.js.');
            if (config) {
                this.rjs.config(config);
                this.cssPaths = config.cssPaths;
                this.bundles = config.bundles;
            }
            else {
                this.cssPaths = {};
                this.bundles = {};
            }
        }
        ModuleLoader.prototype.require = function (dependency) {
            var _this = this;
            debug.assertValue(dependency, 'dependency');
            loadStyleSheets(this.cssPaths, dependency.css);
            var script = dependency.javascript;
            var activeRequests = this.active;
            var previousRequest = activeRequests[script];
            if (previousRequest)
                return previousRequest;
            var bundleName = getBundleName(script, this.bundles);
            var defer = this.promiseFactory.defer();
            activeRequests[script] = defer.promise;
            defer.promise.finally((function () { return delete activeRequests[script]; }));
            var loadRequestedScript = function () { return loadJavaScript(_this.rjs, _this.telemetry, script, (function (result) { return defer.resolve(result); }), (function (error) { return defer.reject(error); })); };
            // If the script exists within a bundle that is not loaded, we must request the bundle first.
            // This is a workaround for https://github.com/requirejs/requirejs/issues/1668
            if (bundleName == null || this.rjs.defined(bundleName))
                loadRequestedScript();
            else
                loadJavaScript(this.rjs, this.telemetry, bundleName, loadRequestedScript, (function (error) { return defer.reject(error); }));
            return defer.promise;
        };
        return ModuleLoader;
    }());
    function loadJavaScript(rjs, telemetry, script, success, failure) {
        debug.assertValue(rjs, 'rjs');
        debug.assertValue(telemetry, 'telemetry');
        debug.assertValue(script, 'script');
        debug.assertValue(success, 'success');
        debug.assertValue(failure, 'failure');
        // If the module has already been loaded, resolve immediately.
        // NOTE: RequireJS has a brief timeout built-in for script-based loads.  We prefer to avoid it.
        if (rjs.defined(script)) {
            success(rjs(script));
            return;
        }
        // Log load time for the initial load only.
        var timer = PerfTimer.start("moduleLoader.require('" + script + "')");
        var startTimeIso = new Date().toISOString();
        rjs([script], (function () {
            telemetry(script, /*error*/ undefined, startTimeIso, new Date().toISOString());
            timer();
            success(arguments[0]);
        }), (function (error) {
            telemetry(script, error.requireType, startTimeIso, new Date().toISOString());
            timer();
            failure(error);
        }));
    }
    function getBundleName(script, bundles) {
        debug.assertValue(script, 'script');
        debug.assertValue(bundles, 'bundles');
        for (var name_3 in bundles) {
            if (_.contains(bundles[name_3], script))
                return name_3;
        }
    }
    var doc = document, headElement = doc.head, firstScriptInHeadElement = headElement.getElementsByTagName('script')[0], linkElement = doc.createElement('link'), styleSheetLoaded = [];
    linkElement.setAttribute('rel', 'stylesheet');
    function loadStyleSheets(cssPaths, hrefList) {
        if (!hrefList)
            return;
        for (var _i = 0, hrefList_1 = hrefList; _i < hrefList_1.length; _i++) {
            var href = hrefList_1[_i];
            href = cssPaths[href] || href;
            if (!_.endsWith(href, '.css'))
                href += '.css';
            if (styleSheetLoaded.indexOf(href) === -1) {
                styleSheetLoaded.push(href);
                loadStyleSheet(href);
            }
        }
    }
    function loadStyleSheet(href) {
        var link = linkElement.cloneNode();
        link.href = href;
        if (firstScriptInHeadElement) {
            headElement.insertBefore(link, firstScriptInHeadElement);
        }
        else {
            headElement.appendChild(link);
        }
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    function createJQueryPromiseFactory() {
        return new JQueryPromiseFactory();
    }
    powerbi.createJQueryPromiseFactory = createJQueryPromiseFactory;
    /**
     * Values that JQueryPromise.state() may return. No better place for it.
     */
    var JQueryPromiseState;
    (function (JQueryPromiseState) {
        JQueryPromiseState[JQueryPromiseState["pending"] = 0] = "pending";
        JQueryPromiseState[JQueryPromiseState["resolved"] = 1] = "resolved";
        JQueryPromiseState[JQueryPromiseState["rejected"] = 2] = "rejected";
    })(JQueryPromiseState = powerbi.JQueryPromiseState || (powerbi.JQueryPromiseState = {}));
    /**
     * jQuery-based implementation of IPromiseFactory.
     * This is useful for cases when Angular is not present, or when immediate promise resolving (not tied to Angular digest cycle) is desired.
     */
    var JQueryPromiseFactory = /** @class */ (function () {
        function JQueryPromiseFactory() {
        }
        JQueryPromiseFactory.prototype.defer = function () {
            return new JQueryDeferredWrapper($.Deferred());
        };
        JQueryPromiseFactory.prototype.reject = function (reason) {
            var deferred = this.defer();
            deferred.reject(reason);
            return deferred.promise;
        };
        JQueryPromiseFactory.prototype.resolve = function (value) {
            var deferred = this.defer();
            deferred.resolve(value);
            return deferred.promise;
        };
        JQueryPromiseFactory.prototype.all = function (promises) {
            var unwrappedPromises = jQuery.map(promises, (function (value) {
                return value && value.promise ? value.promise : value;
            }));
            return new JQueryPromiseWrapper($.when.apply($, unwrappedPromises).then((function () { return Array.prototype.slice.call(arguments); })));
        };
        JQueryPromiseFactory.prototype.allSettled = function (promises) {
            var deferred = this.defer();
            var promiseCount = promises.length;
            if (promiseCount > 0) {
                var resolvedCount_1 = 0;
                var results_1 = [];
                var _loop_1 = function (i) {
                    promises[i].then((function (result) {
                        results_1[i] = {
                            value: result,
                            type: 0 /* Success */
                        };
                    })).catch((function (result) {
                        results_1[i] = {
                            value: result,
                            type: 1 /* Failure */
                        };
                    })).finally((function () {
                        resolvedCount_1++;
                        if (resolvedCount_1 === promiseCount) {
                            deferred.resolve(results_1);
                        }
                    }));
                };
                for (var i = 0; i < promiseCount; i++) {
                    _loop_1(i);
                }
            }
            else {
                deferred.resolve([]);
            }
            return deferred.promise;
        };
        JQueryPromiseFactory.prototype.when = function (value) {
            var unwrappedPromise = value && value.promise ? value.promise : value;
            return new JQueryPromiseWrapper($.when(unwrappedPromise));
        };
        return JQueryPromiseFactory;
    }());
    /**
     * Implements IDeferred via a wrapped a jQuery Deferred.
     */
    var JQueryDeferredWrapper = /** @class */ (function () {
        function JQueryDeferredWrapper(deferred) {
            debug.assertValue(deferred, 'deferred');
            this.deferred = deferred;
            this.promise = new JQueryPromiseWrapper(deferred.promise());
        }
        JQueryDeferredWrapper.prototype.resolve = function (value) {
            this.deferred.resolve(value);
        };
        JQueryDeferredWrapper.prototype.reject = function (reason) {
            this.deferred.reject(reason);
        };
        return JQueryDeferredWrapper;
    }());
    /**
     * Implements IDeferred via a wrapped a jQuery Promise.
     */
    var JQueryPromiseWrapper = /** @class */ (function () {
        function JQueryPromiseWrapper(promise) {
            debug.assertValue(promise, 'promise');
            this.promise = promise;
        }
        JQueryPromiseWrapper.prototype.then = function (a, b) {
            return new JQueryPromiseWrapper(this.promise.then(JQueryPromiseWrapper.wrapCallback(a), JQueryPromiseWrapper.wrapCallback(b)));
        };
        JQueryPromiseWrapper.prototype.catch = function (callback) {
            return this.then(null, callback);
        };
        JQueryPromiseWrapper.prototype.finally = function (callback) {
            this.promise.always(JQueryPromiseWrapper.wrapCallback(callback));
            return this;
        };
        /**
         * Wraps a callback, which may return a IPromise.
         */
        JQueryPromiseWrapper.wrapCallback = function (callback) {
            if (callback)
                return function () {
                    var value = callback.apply(this, arguments);
                    // If the callback returns a Promise, unwrap that to allow jQuery to chain.
                    if (value instanceof JQueryPromiseWrapper)
                        return value.promise;
                    return value;
                };
            return callback;
        };
        return JQueryPromiseWrapper;
    }());
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var LocalStorageService = /** @class */ (function () {
        function LocalStorageService() {
        }
        LocalStorageService.prototype.getData = function (key) {
            try {
                if (localStorage) {
                    var value = localStorage[key];
                    if (value) {
                        return JSON.parse(value);
                    }
                }
            }
            catch (exception) { }
            return null;
        };
        LocalStorageService.prototype.setData = function (key, data) {
            try {
                if (localStorage) {
                    localStorage[key] = JSON.stringify(data);
                }
            }
            catch (e) { }
        };
        return LocalStorageService;
    }());
    var EphemeralStorageService = /** @class */ (function () {
        function EphemeralStorageService(clearCacheInterval) {
            this.cache = {};
            this.clearCacheInterval = (clearCacheInterval != null)
                ? clearCacheInterval
                : EphemeralStorageService.defaultClearCacheInterval;
            this.clearCache();
        }
        EphemeralStorageService.prototype.getData = function (key) {
            return this.cache[key];
        };
        EphemeralStorageService.prototype.setData = function (key, data) {
            var _this = this;
            this.cache[key] = data;
            if (this.clearCacheTimerId == null) {
                this.clearCacheTimerId = setTimeout((function () { return _this.clearCache(); }), this.clearCacheInterval);
            }
        };
        EphemeralStorageService.prototype.clearCache = function () {
            this.cache = {};
            this.clearCacheTimerId = undefined;
        };
        EphemeralStorageService.defaultClearCacheInterval = (1000 * 60 * 60 * 24); // 1 day
        return EphemeralStorageService;
    }());
    powerbi.EphemeralStorageService = EphemeralStorageService;
    powerbi.localStorageService = new LocalStorageService();
    powerbi.ephemeralStorageService = new EphemeralStorageService();
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var WorkScheduler = /** @class */ (function () {
        function WorkScheduler() {
            this.timeoutHandles = {};
            this.animationFrameHandles = {};
        }
        WorkScheduler.prototype.scheduleTimeoutTask = function (callback, timeout) {
            var _this = this;
            var handle = setTimeout((function () {
                callback();
                _this.removeTimeoutTask(handle);
            }), timeout);
            this.timeoutHandles[handle] = handle;
        };
        WorkScheduler.prototype.scheduleAnimationFrameTask = function (callback) {
            var _this = this;
            var handle = requestAnimationFrame((function () {
                callback();
                _this.removeAnimationFrameTask(handle);
            }));
            this.animationFrameHandles[handle] = handle;
        };
        WorkScheduler.prototype.removeTimeoutTask = function (handle) {
            delete this.timeoutHandles[handle];
            this.checkOnIdle();
        };
        WorkScheduler.prototype.removeAnimationFrameTask = function (handle) {
            delete this.animationFrameHandles[handle];
            this.checkOnIdle();
        };
        WorkScheduler.prototype.clear = function () {
            for (var handle in this.timeoutHandles)
                clearTimeout(this.timeoutHandles[handle]);
            this.timeoutHandles = {};
            for (var handle in this.animationFrameHandles)
                cancelAnimationFrame(this.animationFrameHandles[handle]);
            this.animationFrameHandles = {};
        };
        WorkScheduler.prototype.checkOnIdle = function () {
            if (this.onIdle && _.isEmpty(this.timeoutHandles) && _.isEmpty(this.animationFrameHandles))
                this.onIdle();
        };
        return WorkScheduler;
    }());
    powerbi.WorkScheduler = WorkScheduler;
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    /**
     * A Promise class that enables using TypeScript's async/await functionality.  TS's ES5 emulation
     * relies on a class such as this being the return value of an async function.
     *
     * NOTE: Exceptions thrown during continuations result in the promise chain being rejected with the exception.
     *
     * Example:
     *      async function asyncStuff(abc): Promise<number, errorType> {
     *          try {
     *              let xyz = await callServer(abc);
     *              // do work based on xyz response...
     *          }
     *          catch (reason) {
     *              // handle errors from callServer
     *          }
     *      }
     */
    var Promise = /** @class */ (function () {
        function Promise(init) {
            var _this = this;
            this.defer = Promise.ensureFactory().defer();
            init((function (value) { return _this.onResolve(value); }), (function (reason) { return _this.onReject(reason); }));
        }
        Promise.prototype.then = function (successCallback, errorCallback) {
            return this.defer.promise.then(successCallback, errorCallback);
        };
        Promise.prototype.catch = function (onRejected) {
            return this.defer.promise.catch(onRejected);
        };
        Promise.prototype.finally = function (finallyCallback) {
            return this.defer.promise.finally(finallyCallback);
        };
        Promise.init = function (promiseFactory, exceptionHandler) {
            debug.assertValue(promiseFactory, 'promiseFactory');
            debug.assertAnyValue(exceptionHandler, 'exceptionHandler');
            // NOTE: In production code, we expect only one Angular app bootstrapped on the page, and
            // the registered promise factory & exceptionHandler should use that one.
            Promise.factory = promiseFactory;
            Promise.exceptions = exceptionHandler;
        };
        Promise.ensureFactory = function () {
            var factory = Promise.factory;
            if (!factory) {
                // When unspecified, fall back on the jQuery promise factory.
                factory = Promise.factory = powerbi.createJQueryPromiseFactory();
            }
            return factory;
        };
        Promise.prototype.onResolve = function (value) {
            var _this = this;
            debug.assertAnyValue(value, 'value');
            if (isPromise(value)) {
                // NOTE: this should be recursive
                value.then((function (chainedValue) { return _this.onResolve(chainedValue); }), (function (chainedValue) { return _this.onReject(chainedValue); }));
            }
            else {
                this.defer.resolve(value);
            }
        };
        Promise.prototype.onReject = function (error) {
            debug.assertAnyValue(error, 'error');
            if (error instanceof Error &&
                !error.suppressExceptionHandler) {
                var exceptionHandler = Promise.exceptions;
                if (exceptionHandler) {
                    // Mark the Error as handled to avoid multiple notifications from chained promises.
                    error.suppressExceptionHandler = true;
                    // NOTE: For consistency with Angular 1.x's exception handling:
                    // 1) notify the $exceptionHandler service of "unhandled" exceptions
                    // 2) continue with the Promise "rejection" path
                    //
                    // We ought to filter exceptions here for cases where we use exceptions
                    // to "abort" async functions.
                    exceptionHandler(error);
                }
            }
            this.defer.reject(error);
        };
        return Promise;
    }());
    powerbi.Promise = Promise;
    function isPromise(value) {
        return value && _.isFunction(value.then);
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var WordBreaker;
    (function (WordBreaker) {
        var SPACE = ' ';
        var NewLineRegex = /\n+/g;
        var BREAKERS_REGEX = /[\s\n]+/g;
        function search(index, content, backward) {
            if (backward) {
                for (var i = index - 1; i > -1; i--) {
                    if (hasBreakers(content[i]))
                        return i + 1;
                }
            }
            else {
                for (var i = index, ilen = content.length; i < ilen; i++) {
                    if (hasBreakers(content[i]))
                        return i;
                }
            }
            return backward ? 0 : content.length;
        }
        /**
         * Find the word nearest the cursor specified within content
         * @param index - point within content to search forward/backward from
         * @param content - string to search
        */
        function find(index, content) {
            debug.assert(index >= 0 && index <= content.length, 'index within content string bounds');
            var result = { start: 0, end: 0 };
            if (content.length === 0)
                return result;
            result.start = search(index, content, true);
            result.end = search(index, content, false);
            return result;
        }
        WordBreaker.find = find;
        /**
         * Test for presence of breakers within content
         * @param content - string to test
        */
        function hasBreakers(content) {
            BREAKERS_REGEX.lastIndex = 0;
            return BREAKERS_REGEX.test(content);
        }
        WordBreaker.hasBreakers = hasBreakers;
        /**
         * Count the number of pieces when broken by BREAKERS_REGEX
         * ~2.7x faster than WordBreaker.split(content).length
         * @param content - string to break and count
        */
        function wordCount(content) {
            var count = 1;
            BREAKERS_REGEX.lastIndex = 0;
            BREAKERS_REGEX.exec(content);
            while (BREAKERS_REGEX.lastIndex !== 0) {
                count++;
                BREAKERS_REGEX.exec(content);
            }
            return count;
        }
        WordBreaker.wordCount = wordCount;
        function getMaxWordWidth(content, textWidthMeasurer, properties) {
            var words = split(content);
            var maxWidth = 0;
            for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {
                var w = words_1[_i];
                properties.text = w;
                maxWidth = Math.max(maxWidth, textWidthMeasurer(properties));
            }
            return maxWidth;
        }
        WordBreaker.getMaxWordWidth = getMaxWordWidth;
        function split(content) {
            return content.split(BREAKERS_REGEX);
        }
        function getWidth(content, properties, textWidthMeasurer) {
            properties.text = content;
            return textWidthMeasurer(properties);
        }
        function truncate(content, properties, truncator, maxWidth) {
            properties.text = content;
            return truncator(properties, maxWidth);
        }
        var TextLine = /** @class */ (function () {
            function TextLine() {
                this.words = [];
                this.width = 0;
            }
            TextLine.prototype.getWidth = function () {
                return this.width;
            };
            TextLine.prototype.addWord = function (word, width) {
                this.words.push(word);
                this.width += width;
            };
            TextLine.prototype.toString = function () {
                return this.words.join(SPACE);
            };
            TextLine.prototype.isEmpty = function () {
                return _.isEmpty(this.words);
            };
            return TextLine;
        }());
        var TextLines = /** @class */ (function () {
            function TextLines() {
                this.lastLine = new TextLine();
                this.lines = [this.lastLine];
            }
            /**
             * Returns the last line and adds a new one
             */
            TextLines.prototype.newLine = function () {
                var currentLast = this.lastLine;
                this.lastLine = new TextLine();
                this.lines.push(this.lastLine);
                return currentLast;
            };
            Object.defineProperty(TextLines.prototype, "count", {
                get: function () {
                    return this.lines.length;
                },
                enumerable: true,
                configurable: true
            });
            TextLines.prototype.getLastLine = function () {
                return this.lastLine;
            };
            TextLines.prototype.getLastLineWidth = function () {
                return this.getLastLine().getWidth();
            };
            TextLines.prototype.addWord = function (word, width) {
                this.lastLine.addWord(word, width);
            };
            TextLines.prototype.getLines = function () {
                return this.lines;
            };
            return TextLines;
        }());
        /**
         * Split content by breakers (words) and greedy fit as many words
         * into each index in the result based on max width and number of lines
         * e.g. Each index in result corresponds to a line of content
         * @param content - string to split
         * @param properties - text properties to be used by @param:textWidthMeasurer
         * @param textWidthMeasurer - function to calculate width of given text content
         * @param maxWidth - maximum allowed width of text content in each result
         * @param maxNumLines - maximum number of results we will allow,
         *                      any value below 1 means no maximum
         *                      if result exceeds this number, last line will be truncated
         * @param truncator - (optional) if specified, used as a function to truncate content to a given width
         *                    if not specified, no truncation happens
         * @param breakLongWords - (optional, false by default) if true, break single words if they can't fit alone on a single line
         *                         i.e. if the word width is more than the maximum width, it will be split
        */
        // ToDo: wrap args into interface as an overload 
        function splitByWidth(content, properties, textWidthMeasurer, maxWidth, maxNumLines, truncator, splitLongWords, preserveNewLine) {
            if (maxNumLines < 1)
                maxNumLines = Number.POSITIVE_INFINITY;
            if (preserveNewLine) {
                // Split the content into paragraphs then split each paragraph
                var paragraphs = content.split(NewLineRegex);
                var paragraphsResult = [];
                for (var _i = 0, paragraphs_1 = paragraphs; _i < paragraphs_1.length; _i++) {
                    var paragraph = paragraphs_1[_i];
                    var paragraphChunks = splitByWidth(paragraph, properties, textWidthMeasurer, maxWidth, Math.max(1, maxNumLines), // if we are past the maximum, get 1 line
                    truncator, splitLongWords, false);
                    if (maxNumLines > 0) {
                        paragraphsResult.push.apply(paragraphsResult, paragraphChunks);
                        maxNumLines -= paragraphChunks.length;
                    }
                    else {
                        var lastLine = _.last(paragraphsResult);
                        paragraphsResult[paragraphsResult.length - 1] = lastLine + SPACE + paragraphChunks;
                    }
                }
                return paragraphsResult;
            }
            // Default truncator returns string as-is
            truncator = truncator ? truncator : function (properties, maxWidth) { return properties.text; };
            var SpaceWidth = getWidth(SPACE, properties, textWidthMeasurer);
            var lines = new TextLines();
            var words = split(content);
            for (var _a = 0, words_2 = words; _a < words_2.length; _a++) {
                var word = words_2[_a];
                var wordWidth = getWidth(word, properties, textWidthMeasurer);
                // Determine width if we add this word
                // Account for SPACE we will add when joining...
                var addedWidth = wordWidth;
                var isLastLineEmpty = lines.getLastLine().isEmpty();
                if (!isLastLineEmpty)
                    addedWidth += SpaceWidth;
                // If there is still enough space for the word, or it's the last line
                // append the word and add the width of the word with a space
                if (lines.getLastLineWidth() + addedWidth <= maxWidth || lines.count >= maxNumLines) {
                    lines.addWord(word, addedWidth);
                    continue;
                }
                // If the line is not empty, start a new line
                if (!isLastLineEmpty)
                    lines.newLine();
                // If word can fit on the new line, append it
                // and add the width of the word without a space
                if (wordWidth <= maxWidth) {
                    lines.addWord(word, wordWidth);
                    continue;
                }
                var remainingLines = maxNumLines - lines.count;
                // Otherwise, if no splitting is allowed, or we have hit maxNumLines, append the word
                if (!splitLongWords || remainingLines <= 0) {
                    lines.addWord(word, wordWidth);
                    continue;
                }
                // Otherwise, if splitting is allowed, split the word to individual chunks that can fit in a single line
                // Make sure we are not past the maximum number of lines
                var wordSplittingResult = splitWordByWidth(word, properties, textWidthMeasurer, maxWidth, remainingLines + 1);
                for (var i = 0, len = wordSplittingResult.chunks.length; i < len; i++) {
                    var chunk = wordSplittingResult.chunks[i];
                    if (i < len - 1) {
                        lines.addWord(chunk, maxWidth);
                        lines.newLine();
                    }
                    else {
                        lines.addWord(chunk, wordSplittingResult.lastChunkWidth);
                    }
                }
            }
            var result = _.map(lines.getLines(), (function (line) {
                if (line.getWidth() > maxWidth)
                    return truncate(line.toString(), properties, truncator, maxWidth);
                else
                    return line.toString();
            }));
            return result;
        }
        WordBreaker.splitByWidth = splitByWidth;
        /**
         * Split the word into small chunks, each can fit into the maxWidth.
         * If the chunks count would exceed maxNumChunks, last chunk would have the rest of the word
         * @param {string} word Word to split
         * @param {TextProperties} properties Text properties for the word
         * @param {ITextAsSVGMeasurer} textWidthMeasurer Measruing function for text width
         * @param {number} maxWidth Maximum width for each chunk
         * @param {number} maxNumChunks Maximum number of chunks
         * @returns Chunks of text
         */
        function splitWordByWidth(word, properties, textWidthMeasurer, maxWidth, maxNumChunks) {
            var result = {
                chunks: [],
                lastChunkWidth: 0,
            };
            if (maxNumChunks < 1)
                return result;
            var wordLength = word.length;
            var chunks = result.chunks;
            var chunk = "";
            for (var charIdx = 0; charIdx < wordLength; charIdx++) {
                var remainingChunks = maxNumChunks - chunks.length;
                var char = word.charAt(charIdx);
                var chunkWithChar = chunk + char;
                var newWidth = getWidth(chunkWithChar, properties, textWidthMeasurer);
                // if there is room for the character, or it's the first character, or it's the last line
                // Append the character
                if (newWidth <= maxWidth || _.isEmpty(chunk) || remainingChunks <= 1) {
                    chunk = chunkWithChar;
                    result.lastChunkWidth = newWidth;
                    continue;
                }
                // Else, push the line and add a new line
                chunks.push(chunk);
                chunk = char;
                result.lastChunkWidth = getWidth(char, properties, textWidthMeasurer);
            }
            // Push last line if not empty
            if (!_.isEmpty(chunk))
                chunks.push(chunk);
            return result;
        }
        WordBreaker.splitWordByWidth = splitWordByWidth;
    })(WordBreaker = jsCommon.WordBreaker || (jsCommon.WordBreaker = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var TextMeasurementService;
    (function (TextMeasurementService) {
        var ellipsis = '';
        var OverflowingText = jsCommon.CssConstants.createClassAndSelector('overflowingText');
        var spanElement;
        var svgTextElement;
        var canvasCtx;
        var fallbackFontFamily;
        var fontLoadCache = {};
        /**
         * Idempotent function for adding the elements to the DOM.
         */
        function ensureDOM() {
            if (spanElement)
                return;
            spanElement = $('<span/>');
            $('body').append(spanElement);
            //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
            svgTextElement = d3.select($('body').get(0))
                .append('svg')
                .style({
                'height': '0px',
                'width': '0px',
                'position': 'absolute'
            })
                .append('text');
            canvasCtx = $('<canvas/>').get(0).getContext("2d");
            var style = window.getComputedStyle(svgTextElement.node());
            if (style)
                fallbackFontFamily = style.fontFamily;
            else
                fallbackFontFamily = "";
        }
        /**
         * Removes spanElement from DOM.
         */
        function removeSpanElement() {
            if (spanElement && spanElement.remove) {
                spanElement.remove();
            }
            spanElement = null;
        }
        TextMeasurementService.removeSpanElement = removeSpanElement;
        /**
         * This method measures the width of the text with the given SVG text properties.
         * @param textProperties The text properties to use for text measurement.
         * @param text The text to measure.
         */
        function measureSvgTextWidth(textProperties, text) {
            debug.assertValue(textProperties, 'textProperties');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            ensureDOM();
            canvasCtx.font =
                (textProperties.fontStyle || "") + " " +
                    (textProperties.fontVariant || "") + " " +
                    (textProperties.fontWeight || "") + " " +
                    textProperties.fontSize + " " +
                    (textProperties.fontFamily || fallbackFontFamily);
            return canvasCtx.measureText(text || textProperties.text).width;
        }
        TextMeasurementService.measureSvgTextWidth = measureSvgTextWidth;
        /**
         * This method return the rect with the given SVG text properties.
         * @param textProperties The text properties to use for text measurement.
         * @param text The text to measure.
         */
        function measureSvgTextRect(textProperties, text) {
            debug.assertValue(textProperties, 'textProperties');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            ensureDOM();
            svgTextElement.style(null);
            svgTextElement
                .text(text || textProperties.text)
                .attr({
                'visibility': 'hidden',
                'font-family': textProperties.fontFamily || fallbackFontFamily,
                'font-variant': textProperties.fontVariant,
                'font-size': textProperties.fontSize,
                'font-weight': textProperties.fontWeight,
                'font-style': textProperties.fontStyle,
                'white-space': textProperties.whiteSpace || 'nowrap'
            });
            // We're expecting the browser to give a synchronous measurement here
            // We're using SVGTextElement because it works across all browsers 
            return powerbi.visuals.SVGUtil.tryGetBBox(svgTextElement.node());
        }
        TextMeasurementService.measureSvgTextRect = measureSvgTextRect;
        /**
         * This method measures the height of the text with the given SVG text properties.
         * @param textProperties The text properties to use for text measurement.
         * @param text The text to measure.
         */
        function measureSvgTextHeight(textProperties, text) {
            var box = measureSvgTextRect(textProperties, text);
            return box ? box.height : 0;
        }
        TextMeasurementService.measureSvgTextHeight = measureSvgTextHeight;
        /**
         * This method returns the text Rect with the given SVG text properties.
         * Does NOT return text width; obliterates text value
         * @param {TextProperties} textProperties - The text properties to use for text measurement
         */
        function estimateSvgTextRect(textProperties) {
            debug.assertValue(textProperties, 'textProperties');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            var propertiesKey = textProperties.fontFamily + textProperties.fontSize;
            var rect = powerbi.ephemeralStorageService.getData(propertiesKey);
            if (rect == null) {
                // To estimate we check the height of a particular character, once it is cached, subsequent
                // calls should always get the height from the cache (regardless of the text).
                var estimatedTextProperties = {
                    fontFamily: textProperties.fontFamily,
                    fontSize: textProperties.fontSize,
                    text: "M",
                };
                rect = TextMeasurementService.measureSvgTextRect(estimatedTextProperties);
                // NOTE: In some cases (disconnected/hidden DOM) we may provide incorrect measurement results (zero sized bounding-box), so
                // we only store values in the cache if we are confident they are correct.
                if (rect.height > 0 && isFontLoaded(estimatedTextProperties) !== false) {
                    powerbi.ephemeralStorageService.setData(propertiesKey, rect);
                }
            }
            return rect;
        }
        /**
         * This method checks whether the font in the text properties has been loaded or not.
         * Text measurement should only be cached when font is loaded.
         * @param textProperties - estimated text properties used for text measurement
         */
        function isFontLoaded(textProperties) {
            var standardFontSize = "16px";
            var fontSet = document.fonts;
            var fontFamily = textProperties.fontFamily;
            var loaded;
            if (fontLoadCache[fontFamily])
                return true;
            if (fontSet && fontFamily) {
                // for chrome and firefox
                loaded = fontSet.check(standardFontSize + " " + fontFamily);
            }
            else {
                // check with golden truth
                // fallback font is Helvetica so we can detect whether Segoe fonts are loaded with the golden truth
                textProperties.fontSize = standardFontSize;
                var rect = TextMeasurementService.measureSvgTextRect(textProperties);
                // make sure to use first font in list to check
                var fontName = fontFamily.split(',')[0];
                if (fontName.indexOf("Segoe UI") !== -1) {
                    // font family is of standard Segoe UI
                    // all fonts in the family (light, bold, etc) have golden truth height 21.280000686645508
                    loaded = powerbi.Double.equalWithPrecision(rect.height, 21.28, 0.00001);
                }
                else if (fontName.indexOf("wf_standard-font") !== -1) {
                    // font family is of standard secondary font 
                    // all fonts in the family (light, bold, etc) have golden truth height 16.349998474121093
                    loaded = powerbi.Double.equalWithPrecision(rect.height, 16.35, 0.00001);
                }
                else {
                    // font family is not one of the standard fonts; should be cached
                    return null;
                }
            }
            fontLoadCache[fontFamily] = loaded;
            return loaded;
        }
        function clearFontLoadedCache() {
            fontLoadCache = {};
        }
        TextMeasurementService.clearFontLoadedCache = clearFontLoadedCache;
        /**
         * This method returns the delta between baseline (usually the anchor point) to the bottom of the text rect.
         * @param {TextProperties} textProperties - The text properties to use for text measurement
         */
        function estimateSvgTextBaselineDelta(textProperties) {
            var rect = estimateSvgTextRect(textProperties);
            return rect.y + rect.height;
        }
        TextMeasurementService.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
        /**
         * This method estimates the height of the text with the given SVG text properties.
         * @param {TextProperties} textProperties - The text properties to use for text measurement
         */
        function estimateSvgTextHeight(textProperties, tightFightForNumeric) {
            if (tightFightForNumeric === void 0) { tightFightForNumeric = false; }
            var height = estimateSvgTextRect(textProperties).height;
            //TODO: replace it with new baseline calculation
            if (tightFightForNumeric)
                height *= 0.7;
            return height;
        }
        TextMeasurementService.estimateSvgTextHeight = estimateSvgTextHeight;
        /**
         * This method measures the width of the svgElement.
         * @param svgElement The SVGTextElement to be measured.
         */
        function measureSvgTextElementWidth(svgElement) {
            debug.assertValue(svgElement, 'svgElement');
            return measureSvgTextWidth(getSvgMeasurementProperties(svgElement));
        }
        TextMeasurementService.measureSvgTextElementWidth = measureSvgTextElementWidth;
        /**
         * This method fetches the text measurement properties of the given DOM element.
         * @param element The selector for the DOM Element.
         */
        function getMeasurementProperties(element) {
            debug.assertValue(element, 'element');
            return {
                text: element.val() || element.text(),
                fontFamily: element.css('font-family'),
                fontSize: element.css('font-size'),
                fontWeight: element.css('font-weight'),
                fontStyle: element.css('font-style'),
                fontVariant: element.css('font-variant'),
                whiteSpace: element.css('white-space')
            };
        }
        TextMeasurementService.getMeasurementProperties = getMeasurementProperties;
        /**
         * This method fetches the text measurement properties of the given SVG text element.
         * @param svgElement The SVGTextElement to be measured.
         */
        function getSvgMeasurementProperties(svgElement) {
            debug.assertValue(svgElement, 'svgElement');
            var style = window.getComputedStyle(svgElement, null);
            if (style)
                return {
                    text: svgElement.textContent,
                    fontFamily: style.fontFamily,
                    fontSize: style.fontSize,
                    fontWeight: style.fontWeight,
                    fontStyle: style.fontStyle,
                    fontVariant: style.fontVariant,
                    whiteSpace: style.whiteSpace
                };
            else
                return {
                    text: svgElement && svgElement.textContent,
                    fontFamily: "",
                    fontSize: "0",
                };
        }
        TextMeasurementService.getSvgMeasurementProperties = getSvgMeasurementProperties;
        /**
         * This method returns the width of a div element.
         * @param element The div element.
         */
        function getDivElementWidth(element) {
            debug.assert(element.is('div'), 'Given element is not a div type. Cannot get width');
            var style = getComputedStyle(element[0]);
            if (style)
                return style.width;
            else
                return "0";
        }
        TextMeasurementService.getDivElementWidth = getDivElementWidth;
        /**
         * Compares labels text size to the available size and renders ellipses when the available size is smaller.
         * @param textProperties The text properties (including text content) to use for text measurement.
         * @param maxWidth The maximum width available for rendering the text.
         */
        function getTailoredTextOrDefault(textProperties, maxWidth) {
            debug.assertValue(textProperties, 'properties');
            debug.assertValue(textProperties.text, 'properties.text');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            ensureDOM();
            var text = textProperties.text;
            if (!text || text.length === 0)
                return text;
            // Set canvas font properties once, since the text properties stay the same through the method
            canvasCtx.font =
                (textProperties.fontStyle || "") + " " +
                    (textProperties.fontVariant || "") + " " +
                    (textProperties.fontWeight || "") + " " +
                    textProperties.fontSize + " " +
                    (textProperties.fontFamily || fallbackFontFamily);
            var width = canvasCtx.measureText(text).width;
            if (width <= maxWidth)
                return text;
            // Add the elipses to the text, then, binary search for the answer
            text = ellipsis + text;
            var min = 1;
            var max = text.length;
            while (min < max) {
                // bitshift never lets down, plus it's the fastest (known to mankind) way to divide by 2
                var mid = (min + max) >> 1;
                width = canvasCtx.measureText(text.substr(0, mid)).width;
                if (maxWidth > width)
                    min = mid + 1;
                else if (maxWidth < width)
                    max = mid - 1;
                else {
                    min = mid;
                    max = mid;
                }
            }
            // Since the search algorithm almost never finds an exact match,
            // it will pick one of the closest two, which could result in a
            // value bigger with than 'maxWidth' thus we need to go back by 
            // one to guarantee a smaller width than 'maxWidth'.
            width = canvasCtx.measureText(text.substr(0, min)).width;
            if (width > maxWidth)
                min--;
            return text.substr(ellipsis.length, min - ellipsis.length) + ellipsis;
        }
        TextMeasurementService.getTailoredTextOrDefault = getTailoredTextOrDefault;
        /**
         * Compares labels text size to the available size and renders ellipses when the available size is smaller.
         * @param textElement The SVGTextElement containing the text to render.
         * @param maxWidth The maximum width available for rendering the text.
         */
        function svgEllipsis(textElement, maxWidth) {
            debug.assertValue(textElement, 'textElement');
            var properties = getSvgMeasurementProperties(textElement);
            var originalText = properties.text;
            var tailoredText = getTailoredTextOrDefault(properties, maxWidth);
            if (originalText !== tailoredText) {
                textElement.textContent = tailoredText;
            }
        }
        TextMeasurementService.svgEllipsis = svgEllipsis;
        /**
         * Word break textContent of <text> SVG element into <tspan>s
         * Each tspan will be the height of a single line of text
         * @param textElement - the SVGTextElement containing the text to wrap
         * @param maxWidth - the maximum width available
         * @param maxHeight - the maximum height available (defaults to single line)
         * @param linePadding - (optional) padding to add to line height
         */
        function wordBreak(textElement, maxWidth, maxHeight, linePadding) {
            if (linePadding === void 0) { linePadding = 0; }
            jsCommon.API.deprecated('powerbi.TextMeasurementService.wordBreak is deprecated. Use powerbi.visuals.TextUtil.wordBreak instead');
            debug.assertValue(textElement, 'textElement');
            var properties = getSvgMeasurementProperties(textElement);
            var height = estimateSvgTextHeight(properties) + linePadding;
            var maxNumLines = Math.max(1, Math.floor(maxHeight / height));
            var node = d3.select(textElement);
            // Save y of parent textElement to apply as first tspan dy
            var firstDY = node.attr('y');
            // Store and clear text content
            var labelText = textElement.textContent;
            textElement.textContent = null;
            // Append a tspan for each word broken section
            var words = jsCommon.WordBreaker.splitByWidth(labelText, properties, measureSvgTextWidth, maxWidth, maxNumLines);
            for (var i = 0, ilen = words.length; i < ilen; i++) {
                properties.text = words[i];
                node
                    .append('tspan')
                    .attr({
                    'x': 0,
                    'dy': i === 0 ? firstDY : height,
                })
                    .text(getTailoredTextOrDefault(properties, maxWidth));
            }
        }
        TextMeasurementService.wordBreak = wordBreak;
        /**
         * Word break textContent of span element into <span>s
         * Each span will be the height of a single line of text
         * @param textElement - the element containing the text to wrap
         * @param maxWidth - the maximum width available
         * @param maxHeight - the maximum height available (defaults to single line)
         * @param linePadding - (optional) padding to add to line height
         */
        function wordBreakOverflowingText(textElement, maxWidth, maxHeight, linePadding) {
            if (linePadding === void 0) { linePadding = 0; }
            debug.assertValue(textElement, 'textElement');
            var properties = getSvgMeasurementProperties(textElement);
            var height = estimateSvgTextHeight(properties) + linePadding;
            var maxNumLines = Math.max(1, Math.floor(maxHeight / height));
            // Store and clear text content
            var labelText = textElement.textContent;
            textElement.textContent = null;
            // Append a span for each word broken section
            var words = jsCommon.WordBreaker.splitByWidth(labelText, properties, measureSvgTextWidth, maxWidth, maxNumLines);
            var spanItem = d3.select(textElement)
                .selectAll(OverflowingText.selector)
                .data(words, (function (d) { return $.inArray(d, words); }));
            spanItem
                .enter()
                .append("span")
                .classed(OverflowingText.class, true)
                .text((function (d) { return d; }))
                .style("width", jsCommon.PixelConverter.toString(maxWidth));
        }
        TextMeasurementService.wordBreakOverflowingText = wordBreakOverflowingText;
    })(TextMeasurementService = powerbi.TextMeasurementService || (powerbi.TextMeasurementService = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var DOMConstants = jsCommon.DOMConstants;
    var KeyUtils;
    (function (KeyUtils) {
        function isArrowKey(keyCode) {
            return keyCode === 40 /* downArrowKeyCode */
                || keyCode === 38 /* upArrowKeyCode */
                || keyCode === 37 /* leftArrowKeyCode */
                || keyCode === 39 /* rightArrowKeyCode */;
        }
        KeyUtils.isArrowKey = isArrowKey;
        function isCtrlShortcutKey(keyCode) {
            return keyCode === 65 /* aKeyCode */
                || keyCode === 67 /* cKeyCode */
                || keyCode === 88 /* xKeyCode */
                || keyCode === 86 /* vKeyCode */
                || keyCode === 90 /* zKeyCode */
                || keyCode === 89 /* yKeyCode */;
        }
        KeyUtils.isCtrlShortcutKey = isCtrlShortcutKey;
        function isNudgeModifierKey(keyCode) {
            return keyCode === 16 /* shiftKeyCode */;
        }
        KeyUtils.isNudgeModifierKey = isNudgeModifierKey;
        function isDeleteKey(keyCode) {
            return keyCode === 46 /* deleteKeyCode */;
        }
        KeyUtils.isDeleteKey = isDeleteKey;
    })(KeyUtils = jsCommon.KeyUtils || (jsCommon.KeyUtils = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Responsible for creating timer promises.
     */
    var TimerPromiseFactory = /** @class */ (function () {
        function TimerPromiseFactory() {
        }
        /**
         * {@inheritDoc}
         */
        TimerPromiseFactory.prototype.create = function (delayInMs) {
            debug.assertValue(delayInMs, 'delayInMs');
            debug.assert(delayInMs >= 0, 'delayInMs must be a positive value.');
            var deferred = $.Deferred();
            window.setTimeout((function () { return deferred.resolve(); }), delayInMs);
            return deferred;
        };
        TimerPromiseFactory.instance = new TimerPromiseFactory();
        return TimerPromiseFactory;
    }());
    jsCommon.TimerPromiseFactory = TimerPromiseFactory;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TouchUtils;
        (function (TouchUtils) {
            function touchStartEventName() {
                var eventName = "touchstart";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerdown";
                }
                return eventName;
            }
            TouchUtils.touchStartEventName = touchStartEventName;
            function touchEndEventName() {
                var eventName = "touchend";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerup";
                }
                return eventName;
            }
            TouchUtils.touchEndEventName = touchEndEventName;
            function touchMoveEventName() {
                var eventName = "touchmove";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointermove";
                }
                return eventName;
            }
            TouchUtils.touchMoveEventName = touchMoveEventName;
            function usePointerEvents() {
                var eventName = touchStartEventName();
                return eventName === "pointerdown" || eventName === "MSPointerDown";
            }
            TouchUtils.usePointerEvents = usePointerEvents;
        })(TouchUtils = visuals.TouchUtils || (visuals.TouchUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var FileUtils;
    (function (FileUtils) {
        /**
         * Returns the extension of a specified file path.
         */
        function getFileExtension(filePath) {
            var index = _.lastIndexOf(filePath, '.');
            if (index >= 0)
                return filePath.substr(index + 1);
            return '';
        }
        FileUtils.getFileExtension = getFileExtension;
        /**
         * Returns a file path without the extension.
         */
        function getFileWithoutExtension(filePath) {
            var index = _.lastIndexOf(filePath, '.');
            if (index >= 0)
                return filePath.substr(0, index);
            return filePath;
        }
        FileUtils.getFileWithoutExtension = getFileWithoutExtension;
    })(FileUtils = jsCommon.FileUtils || (jsCommon.FileUtils = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var DomEventUtils;
    (function (DomEventUtils) {
        /**
         * Determines whether an element has a specific event handler registered.
         * Note: This works only for event handlers registered through jQuery.
         */
        function hasEventHandler(element, eventName) {
            if (_.isEmpty(element))
                return false;
            var events = $._data(element[0], 'events');
            return !!events && events.hasOwnProperty(eventName);
        }
        DomEventUtils.hasEventHandler = hasEventHandler;
        /**
         * Get the DOM element that first received the event before any bubbling
         */
        function getEventTarget(e) {
            debug.assertValue(e, 'getEventTarget - e');
            // Target is 'srcElement' for IE, 'target' for any other browser
            var target = (e.target || e.srcElement);
            if (!target)
                return;
            // For Safari, there is a bug that the target would be a Text element
            if (target.nodeType === 3)
                target = target.parentNode;
            if (target.nodeType === 1)
                return target;
        }
        DomEventUtils.getEventTarget = getEventTarget;
    })(DomEventUtils = jsCommon.DomEventUtils || (jsCommon.DomEventUtils = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var TraceItem = /** @class */ (function () {
        function TraceItem(text, type, sessionId, requestId) {
            this.text = text;
            this.type = type;
            this.sessionId = sessionId;
            this.requestId = requestId;
            this.timeStamp = new Date();
        }
        TraceItem.prototype.toString = function () {
            var resultString = '';
            resultString += TraceItem.traceTypeStrings[this.type] + " (" + this.timeStamp.toUTCString() + "): " + this.text;
            if (this.requestId)
                resultString += ('\n(Request id: ' + this.requestId + ')');
            return resultString;
        };
        TraceItem.traceTypeStrings = [
            'INFORMATION',
            'VERBOSE',
            'WARNING',
            'ERROR',
            'EXPECTEDERROR',
            'UNEXPECTEDERROR',
            'FATAL',
        ];
        return TraceItem;
    }());
    jsCommon.TraceItem = TraceItem;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Deprecated = jsCommon.Deprecated;
    var UrlUtils;
    (function (UrlUtils) {
        function isValidHttpUrl(value) {
            if (_.isEmpty(value))
                return false;
            switch (getUrlScheme(value)) {
                case UrlScheme.http:
                case UrlScheme.https:
                    return true;
                default:
                    return false;
            }
        }
        UrlUtils.isValidHttpUrl = isValidHttpUrl;
        /* Tests whether a URL is valid.
         * @param url The url to be tested.
         * @returns Whether the provided url is valid.
         **/
        function isValidImageUrl(url) {
            // VSTS: 7252099 / 7112236
            // For now, passes for any valid Url
            return isValidHttpUrl(url);
        }
        UrlUtils.isValidImageUrl = isValidImageUrl;
        function isDataUri(uri) {
            return uri && uri.indexOf('data:') === 0;
        }
        UrlUtils.isDataUri = isDataUri;
        function getBase64ContentFromDataUri(uri) {
            if (!isDataUri(uri))
                throw new Error("Expected data uri");
            // Locate the base 64 content from the URL (e.g. "data:image/png;base64,xxxxx=")
            var base64Token = ";base64,";
            var indexBase64TokenStart = uri.indexOf(base64Token);
            if (indexBase64TokenStart < 0)
                throw new Error("Expected base 64 content in data url");
            var indexBase64Start = indexBase64TokenStart + base64Token.length;
            return uri.substr(indexBase64Start, uri.length - indexBase64Start);
        }
        UrlUtils.getBase64ContentFromDataUri = getBase64ContentFromDataUri;
        /**
         * Create a base64 data URI for a string with a UTF-8 character encoding.
         * @param rawText {string} The text string to be encapsulated. It is the raw Javascript string
         */
        function makeUTF8EncodedBase64DataUri(contentType, rawText) {
            return "data:" + contentType + ";base64," + UrlUtils.utoa(rawText);
        }
        UrlUtils.makeUTF8EncodedBase64DataUri = makeUTF8EncodedBase64DataUri;
        function makeJsonDataUri(rawJson) {
            return makeUTF8EncodedBase64DataUri("application/json", rawJson);
        }
        UrlUtils.makeJsonDataUri = makeJsonDataUri;
        /**
         * Based off of from https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#Important_MIME_types_for_Web_developers
         * TODO Investigate using a module like https://www.npmjs.com/package/mime-types for this instead
         */
        UrlUtils.MIMEMap = {
            txt: 'text/plain',
            css: 'text/css',
            html: 'text/html',
            gif: 'image/gif',
            jpg: 'image/jpg',
            png: 'image/png',
            svg: 'image/svg+xml'
        };
        /**
         * Gets the MIMIE type for the given `path` based on its extension.
         * @param path Path to get the MIME type for (including the extension)
         */
        function getMIMEType(path) {
            var extension = path.split('.').pop().toLowerCase();
            return UrlUtils.MIMEMap[extension];
        }
        UrlUtils.getMIMEType = getMIMEType;
        // btoa does not work for char codes > 0xff. for these we have to UTF-8 encode it
        // first. cleverly combining the deprecated functions unescape/escape with
        // encode/decodeURIComponent gets the browser to do all the work. in case
        // unescape/escape are not present, use slower Javascript implementations.
        // https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa#Unicode_strings
        // http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html
        // http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf#sec-15.1.2.4
        // exported for testing
        function escapeSlow(s) {
            if (!s)
                return s;
            return s.replace(/[^*+\-./0123456789@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz]/g, (function (unescaped) {
                var escaped = unescaped.charCodeAt(0).toString(16).toUpperCase();
                switch (escaped.length) {
                    case 1: return '%0' + escaped;
                    case 2: return '%' + escaped;
                    case 3: return '%u0' + escaped;
                    default: return '%u' + escaped;
                }
            }));
        }
        UrlUtils.escapeSlow = escapeSlow;
        // exported for testing
        function unescapeSlow(s) {
            if (!s)
                return s;
            return s.replace(/%([0-9a-fA-F]{2})|%u([0-9a-fA-F]{4})/g, (function (_, short, long) {
                return String.fromCharCode(parseInt(short || long, 16));
            }));
        }
        UrlUtils.unescapeSlow = unescapeSlow;
        var unescape = Deprecated.unescape || unescapeSlow;
        var escape = Deprecated.escape || escapeSlow;
        function encodeUTF8(s) {
            return unescape(encodeURIComponent(s));
        }
        UrlUtils.encodeUTF8 = encodeUTF8;
        function decodeUTF8(s) {
            return decodeURIComponent(escape(s));
        }
        UrlUtils.decodeUTF8 = decodeUTF8;
        function utoa(s) {
            return btoa(encodeUTF8(s));
        }
        UrlUtils.utoa = utoa;
        function atou(s) {
            return decodeUTF8(atob(s));
        }
        UrlUtils.atou = atou;
        /** Returns the set of query parameters in a URL */
        function getQueryParameters(url) {
            var query = getQueryString(url);
            if (!query) {
                return;
            }
            return parseQueryString(query);
        }
        UrlUtils.getQueryParameters = getQueryParameters;
        /**
         * Given a URL, set the provided query string parameters
         * @param url The URL to modify
         * @param parameters The query parameters to set.
         * @param keepExisting if true, existing query parameters will be maintained, even if specified in the parameters argument. Else, all existing parameters are removed
         */
        function setQueryParameters(url, parameters, keepExisting) {
            if (keepExisting === void 0) { keepExisting = false; }
            var splitUrl = splitUrlAndQuery(url);
            var result = splitUrl.baseUrl;
            if (keepExisting) {
                _.assign(parameters, splitUrl.queryParameters);
            }
            if (_.isEmpty(parameters))
                return result;
            var expandedParameters = [];
            for (var key in parameters) {
                var value = parameters[key];
                if (value == null) {
                    expandedParameters.push(encodeURIComponent(key));
                }
                else if (typeof value === "string") {
                    expandedParameters.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
                }
                else {
                    for (var _i = 0, _a = value; _i < _a.length; _i++) {
                        var onevalue = _a[_i];
                        expandedParameters.push(encodeURIComponent(key) + '=' + encodeURIComponent(onevalue));
                    }
                }
            }
            result += '?' + expandedParameters.join('&');
            return result;
        }
        UrlUtils.setQueryParameters = setQueryParameters;
        /** Given a URL, split it into the base URL (everything before the query string) and its collection of query string parameters */
        function splitUrlAndQuery(url) {
            var queryString = getQueryString(url);
            var baseUrl = queryString ? url.slice(0, url.lastIndexOf(queryString)) : url;
            return {
                baseUrl: baseUrl,
                queryParameters: parseQueryString(queryString)
            };
        }
        UrlUtils.splitUrlAndQuery = splitUrlAndQuery;
        function parseUrl(url) {
            if (url == null) {
                return {
                    scheme: '',
                    host: '',
                    path: '',
                    query: '',
                    fragment: '',
                };
            }
            // see http://www.ietf.org/rfc/rfc3986.txt, Appendix B (around page 50)
            // ^(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?
            //     1                 2          3            4            5
            // http://www.ics.uci.edu/pub/ietf/uri/#Related
            // scheme   = $1 = http
            // host     = $2 = www.ics.uci.edu
            // path     = $3 = /pub/ietf/uri/
            // query    = $4 = <undefined>
            // fragment = $5 = Related
            var matches = url.match(/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
            if (matches)
                return {
                    scheme: matches[1],
                    host: matches[2],
                    path: matches[3],
                    query: matches[4],
                    fragment: matches[5]
                };
        }
        UrlUtils.parseUrl = parseUrl;
        var UrlScheme;
        (function (UrlScheme) {
            /** The string belongs to a non-URL column, or is an invalid Url, or has an unsupported Scheme */
            UrlScheme[UrlScheme["NONE"] = 0] = "NONE";
            UrlScheme[UrlScheme["http"] = 1] = "http";
            UrlScheme[UrlScheme["https"] = 2] = "https";
            UrlScheme[UrlScheme["file"] = 3] = "file";
            UrlScheme[UrlScheme["ftp"] = 4] = "ftp";
            UrlScheme[UrlScheme["mailto"] = 5] = "mailto";
            UrlScheme[UrlScheme["news"] = 6] = "news";
            UrlScheme[UrlScheme["telnet"] = 7] = "telnet";
        })(UrlScheme = UrlUtils.UrlScheme || (UrlUtils.UrlScheme = {}));
        /**
         * Returns the URL scheme for URLs using http, https, file, ftp, mailto, news or telnet.
         * For any other scheme or invalid URLs, it returns UrlScheme.NONE.
         * @param content The string representation of a URL.
         */
        function getUrlScheme(content) {
            var urlParts = UrlUtils.parseUrl(content);
            if (urlParts == null || urlParts.scheme == null)
                return UrlScheme.NONE;
            switch (urlParts.scheme.toLowerCase()) {
                case 'http':
                    return UrlScheme.http;
                case 'https':
                    return UrlScheme.https;
                case 'file':
                    return UrlScheme.file;
                case 'ftp':
                    return UrlScheme.ftp;
                case 'mailto':
                    return UrlScheme.mailto;
                case 'news':
                    return UrlScheme.news;
                case 'telnet':
                    return UrlScheme.telnet;
                default:
                    return UrlScheme.NONE;
            }
        }
        UrlUtils.getUrlScheme = getUrlScheme;
        function getHost(url) {
            var parsed = parseUrl(url);
            return parsed && parsed.host;
        }
        UrlUtils.getHost = getHost;
        var HostnameRegex = /https?:\/\/[^\/]+/i;
        /**
         * Returns everything in a URL after the hostname. Per RFC 3986, this is known as the absolute path reference.
         * @example for "https://foo.bar/hello/world", return "/hello/world".
         */
        function getAbsolutePath(url) {
            if (!url)
                return url;
            return url.replace(HostnameRegex, '');
        }
        UrlUtils.getAbsolutePath = getAbsolutePath;
        function getQueryString(url) {
            var elem = document.createElement('a');
            elem.href = url;
            return elem.search;
        }
        /** Parses a query string of the form ?param1=value1&param2=value2 into its invidual parameters. The leading ? is not required */
        function parseQueryString(queryString) {
            if (!queryString)
                return null;
            if (_.startsWith(queryString, '?')) {
                queryString = queryString.substring(1);
            }
            var params = queryString.split("&");
            var result = {};
            for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {
                var keyEqualsValue = params_1[_i];
                var pair = keyEqualsValue.split("=");
                var key = decodeURIComponent(pair[0]);
                var value = decodeURIComponent(pair[1]);
                var valueAlready = result[key];
                if (valueAlready == null)
                    result[key] = value;
                else if (typeof valueAlready === "string")
                    result[key] = [valueAlready, value];
                else
                    valueAlready.push(value);
            }
            return result;
        }
    })(UrlUtils = jsCommon.UrlUtils || (jsCommon.UrlUtils = {}));
})(jsCommon || (jsCommon = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var jsCommon;
(function (jsCommon) {
    var BrowserUtils;
    (function (BrowserUtils) {
        function isChrome() {
            var vendorName = window.navigator.vendor || "";
            var userAgent = window.navigator.userAgent.toLowerCase();
            return vendorName.toLowerCase().indexOf('google') > -1 &&
                userAgent.indexOf('chrome') > -1 &&
                userAgent.indexOf('edge') === -1 &&
                userAgent.indexOf('opr') === -1;
        }
        BrowserUtils.isChrome = isChrome;
        function isInternetExplorerOrEdge() {
            var userAgent = window.navigator.userAgent.toLowerCase();
            return userAgent.indexOf('msie') > -1
                || userAgent.indexOf('trident') > -1
                || userAgent.indexOf('edge') > -1;
        }
        BrowserUtils.isInternetExplorerOrEdge = isInternetExplorerOrEdge;
        /**
         * Get the current version of IE
         * @returns The version of Internet Explorer or a 0 (indicating the use of another browser).
         */
        function getInternetExplorerVersion() {
            var retValue = 0;
            if (navigator.appName === 'Microsoft Internet Explorer' || window.navigator.userAgent.indexOf('MSIE') >= 0) {
                var re = new RegExp('MSIE ([0-9]{1,}[\\.0-9]{0,})');
                var result = re.exec(window.navigator.userAgent);
                if (result) {
                    retValue = parseFloat(result[1]);
                }
            }
            return retValue;
        }
        BrowserUtils.getInternetExplorerVersion = getInternetExplorerVersion;
        function isFirefox() {
            return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        }
        BrowserUtils.isFirefox = isFirefox;
    })(BrowserUtils = jsCommon.BrowserUtils || (jsCommon.BrowserUtils = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    // NOTE: this file includes standalone utilities that should have no dependencies on external libraries, including jQuery.
    /**
     * Extensions for Enumerations.
     */
    var EnumExtensions;
    (function (EnumExtensions) {
        /**
         * Gets a value indicating whether the value has the bit flags set.
         */
        function hasFlag(value, flag) {
            debug.assert(!!flag, 'flag must be specified and nonzero.');
            return (value & flag) === flag;
        }
        EnumExtensions.hasFlag = hasFlag;
        /**
         * Sets a value of a flag without modifying any other flags.
         */
        function setFlag(value, flag) {
            debug.assert(!!flag, "flag must be specified and nonzero.");
            return value |= flag;
        }
        EnumExtensions.setFlag = setFlag;
        /**
         * Resets a value of a flag without modifying any other flags.
         */
        function resetFlag(value, flag) {
            debug.assert(!!flag, "flag must be specified and nonzero.");
            return value &= ~flag;
        }
        EnumExtensions.resetFlag = resetFlag;
        /**
         * According to the TypeScript Handbook, this is safe to do.
         */
        function toString(enumType, value) {
            return enumType[value];
        }
        EnumExtensions.toString = toString;
        /**
         * Returns the number of 1's in the specified value that is a set of binary bit flags.
         */
        function getBitCount(value) {
            if (value === null || value % 1 !== 0)
                return 0;
            var bitCount = 0;
            var shiftingValue = value;
            while (shiftingValue !== 0) {
                if ((shiftingValue & 1) === 1) {
                    bitCount++;
                }
                shiftingValue = shiftingValue >>> 1;
            }
            return bitCount;
        }
        EnumExtensions.getBitCount = getBitCount;
    })(EnumExtensions = jsCommon.EnumExtensions || (jsCommon.EnumExtensions = {}));
    var LogicExtensions;
    (function (LogicExtensions) {
        function XOR(a, b) {
            return (a || b) && !(a && b);
        }
        LogicExtensions.XOR = XOR;
    })(LogicExtensions = jsCommon.LogicExtensions || (jsCommon.LogicExtensions = {}));
    var JsonComparer;
    (function (JsonComparer) {
        /**
         * Performs JSON-style comparison of two objects.
         */
        function equals(x, y) {
            if (x === y)
                return true;
            return JSON.stringify(x) === JSON.stringify(y);
        }
        JsonComparer.equals = equals;
    })(JsonComparer = jsCommon.JsonComparer || (jsCommon.JsonComparer = {}));
    /**
     * Values are in terms of 'pt'
     * Convert to pixels using PixelConverter.fromPoint
     */
    var TextSizeDefaults;
    (function (TextSizeDefaults) {
        /**
         * Stored in terms of 'pt'
         * Convert to pixels using PixelConverter.fromPoint
         */
        TextSizeDefaults.TextSizeMin = 8;
        /**
         * Stored in terms of 'pt'
         * Convert to pixels using PixelConverter.fromPoint
         */
        TextSizeDefaults.TextSizeMax = 40;
        var TextSizeRange = TextSizeDefaults.TextSizeMax - TextSizeDefaults.TextSizeMin;
        /**
         * Returns the percentage of this value relative to the TextSizeMax
         * @param textSize - should be given in terms of 'pt'
         */
        function getScale(textSize) {
            return (textSize - TextSizeDefaults.TextSizeMin) / TextSizeRange;
        }
        TextSizeDefaults.getScale = getScale;
    })(TextSizeDefaults = jsCommon.TextSizeDefaults || (jsCommon.TextSizeDefaults = {}));
    var PixelConverter;
    (function (PixelConverter) {
        PixelConverter.PxPtRatio = 4 / 3;
        var PixelString = 'px';
        /**
         * Appends 'px' to the end of number value for use as pixel string in styles
         */
        function toString(px) {
            return px + PixelString;
        }
        PixelConverter.toString = toString;
        /**
         * Converts point value (pt) to pixels
         * Returns a string for font-size property
         * e.g. fromPoint(8) => '24px'
         */
        function fromPoint(pt) {
            return toString(fromPointToPixel(pt));
        }
        PixelConverter.fromPoint = fromPoint;
        /**
         * Converts point value (pt) to pixels
         * Returns a number for font-size property
         * e.g. fromPoint(8) => 24px
         */
        function fromPointToPixel(pt) {
            return (PixelConverter.PxPtRatio * pt);
        }
        PixelConverter.fromPointToPixel = fromPointToPixel;
        /**
         * Converts pixel value (px) to pt
         * e.g. toPoint(24) => 8
         */
        function toPoint(px) {
            return px / PixelConverter.PxPtRatio;
        }
        PixelConverter.toPoint = toPoint;
    })(PixelConverter = jsCommon.PixelConverter || (jsCommon.PixelConverter = {}));
    var RegExpExtensions;
    (function (RegExpExtensions) {
        /**
         * Runs exec on regex starting from 0 index
         * This is the expected behavior but RegExp actually remember
         * the last index they stopped at (found match at) and will
         * return unexpected results when run in sequence.
         * @param regex - regular expression object
         * @param value - string to search wiht regex
         * @param start - index within value to start regex
         */
        function run(regex, value, start) {
            debug.assertValue(regex, 'regex');
            regex.lastIndex = start || 0;
            return regex.exec(value);
        }
        RegExpExtensions.run = run;
    })(RegExpExtensions = jsCommon.RegExpExtensions || (jsCommon.RegExpExtensions = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var utility;
        (function (utility) {
            var StyleUtils;
            (function (StyleUtils) {
                function getRotateAngleFromElement(element) {
                    var rawElemStyle = element.get(0).style;
                    var transformString = rawElemStyle.transform || rawElemStyle.webkitTransform;
                    if (transformString) {
                        var transform = transformString.match(/rotate\((-?\d+(?:\.\d*)?)deg\)/);
                        if (transform) {
                            return parseFloat(transform[1]);
                        }
                    }
                    return 0;
                }
                StyleUtils.getRotateAngleFromElement = getRotateAngleFromElement;
                function getTranslateTransformFromElement(element) {
                    var rawElemStyle = element.get(0).style;
                    // IE will recognize "webkitTransform" as "WebkitTransform" and set that as style property. 
                    // This means transform property is not read.
                    // We put the "transform" before the "webkitTransform" to counteract the weirdness of IE. 
                    var transformString = rawElemStyle.transform || rawElemStyle.webkitTransform;
                    var retValue = { x: 0, y: 0 };
                    if (transformString && transformString.length > 0) {
                        var transform = transformString.match(/translate\((-?\d+(?:\.\d*)?)px, (-?\d+(?:\.\d*)?)px\)/);
                        if (transform) {
                            retValue.x = parseFloat(transform[1]);
                            retValue.y = parseFloat(transform[2]);
                        }
                    }
                    return retValue;
                }
                StyleUtils.getTranslateTransformFromElement = getTranslateTransformFromElement;
                function getPadding(element) {
                    if (!element)
                        return;
                    return {
                        left: parseFloat(element.css('padding-left')) || 0,
                        right: parseFloat(element.css('padding-right')) || 0,
                        top: parseFloat(element.css('padding-top')) || 0,
                        bottom: parseFloat(element.css('padding-bottom')) || 0,
                    };
                }
                StyleUtils.getPadding = getPadding;
            })(StyleUtils = utility.StyleUtils || (utility.StyleUtils = {}));
        })(utility = visuals.utility || (visuals.utility = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in SVG manupilation.
         */
        var SVGUtil;
        (function (SVGUtil) {
            /**
             * Very small values, when stringified, may be converted to scientific notation and cause a temporarily
             * invalid attribute or style property value.
             * For example, the number 0.0000001 is converted to the string "1e-7".
             * This is particularly noticeable when interpolating opacity values.
             * To avoid scientific notation, start or end the transition at 1e-6,
             * which is the smallest value that is not stringified in exponential notation.
             */
            SVGUtil.AlmostZero = 1e-6;
            /**
             * Creates a translate string for use with the SVG transform call.
             */
            function translate(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + ',' + y + ')';
            }
            SVGUtil.translate = translate;
            /**
             * Creates a translateX string for use with the SVG transform call.
             */
            function translateXWithPixels(x) {
                debug.assertValue(x, 'x');
                return 'translateX(' + x + 'px)';
            }
            SVGUtil.translateXWithPixels = translateXWithPixels;
            function translateWithPixels(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + 'px,' + y + 'px)';
            }
            SVGUtil.translateWithPixels = translateWithPixels;
            /**
             * Creates a translate + rotate string for use with the SVG transform call.
             */
            function translateAndRotate(x, y, px, py, angle) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(px, 'px');
                debug.assertValue(py, 'py');
                debug.assertValue(angle, 'angle');
                return "translate("
                    + x + "," + y + ")"
                    + " rotate(" + angle + "," + px + "," + py + ")";
            }
            SVGUtil.translateAndRotate = translateAndRotate;
            /**
             * Creates a scale string for use in a CSS transform property.
             */
            function scale(scale) {
                debug.assertValue(scale, 'scale');
                return "scale(" + scale + ")";
            }
            SVGUtil.scale = scale;
            /**
             * Creates a translate + scale string for use with the SVG transform call.
             */
            function translateAndScale(x, y, ratio) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(ratio, 'ratio');
                return "translate("
                    + x + "," + y + ")"
                    + " scale(" + ratio + ")";
            }
            SVGUtil.translateAndScale = translateAndScale;
            /**
             * Creates a transform origin string for use in a CSS transform-origin property.
             */
            function transformOrigin(xOffset, yOffset) {
                debug.assertValue(xOffset, 'xOffset');
                debug.assertValue(yOffset, 'yOffset');
                return xOffset + " " + yOffset;
            }
            SVGUtil.transformOrigin = transformOrigin;
            /**
             * Forces all D3 transitions to complete.
             * Normally, zero-delay transitions are executed after an instantaneous delay (<10ms).
             * This can cause a brief flicker if the browser renders the page twice: once at the end of the first event loop,
             * then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop,
             * you can run any zero-delay transitions immediately and avoid the flicker.
             *
             * These flickers are noticable on IE, and with a large number of webviews(not recommend you ever do this) on iOS.
             */
            function flushAllD3Transitions() {
                var now = Date.now;
                Date.now = function () { return Infinity; };
                d3.timer.flush();
                Date.now = now;
            }
            SVGUtil.flushAllD3Transitions = flushAllD3Transitions;
            /**
             * Wrapper for flushAllD3Transitions.
             */
            function flushAllD3TransitionsIfNeeded(options) {
                if (!options)
                    return;
                var animationOptions = options;
                var asVisualInitOptions = options;
                if (asVisualInitOptions.animation)
                    animationOptions = asVisualInitOptions.animation;
                if (animationOptions && animationOptions.transitionImmediate) {
                    flushAllD3Transitions();
                }
            }
            SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded;
            /**
             * In IE10, it is possible to return SVGPoints with NaN members.
             */
            function ensureValidSVGPoint(point) {
                if (isNaN(point.x)) {
                    point.x = 0;
                }
                if (isNaN(point.y)) {
                    point.y = 0;
                }
            }
            SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint;
            /**
             * Parse the Transform string with value 'translate(x,y)'.
             * In Chrome for the translate(position) string the delimiter
             * is a comma and in IE it is a spaceso checking for both.
             */
            function parseTranslateTransform(input) {
                if (!input || input.length === 0) {
                    return {
                        x: "0",
                        y: "0",
                    };
                }
                var translateCoordinates = input.split(/[\s,]+/);
                debug.assertValue(translateCoordinates, 'translateCoordinates');
                debug.assert(translateCoordinates.length > 0, 'translate array must atleast have one value');
                var yValue = '0';
                var xValue;
                var xCoord = translateCoordinates[0];
                // Y coordinate is ommited in I.E if it is 0, so need to check against that
                if (translateCoordinates.length === 1) {
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length - 1);
                }
                else {
                    var yCoord = translateCoordinates[1];
                    yValue = yCoord.substring(0, yCoord.length - 1);
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length);
                }
                return {
                    x: xValue,
                    y: yValue
                };
            }
            SVGUtil.parseTranslateTransform = parseTranslateTransform;
            /**
             * Create an arrow.
             */
            function createArrow(width, height, rotate) {
                var transform = "rotate(" + rotate + " " + width / 2 + " " + height / 2 + ")";
                var path = "M0 0";
                path += "L0 " + height;
                path += "L" + width + " " + height / 2 + " Z";
                return {
                    path: path,
                    transform: transform
                };
            }
            SVGUtil.createArrow = createArrow;
            /**
             * Use the ratio of the scaled bounding rect and the SVG DOM bounding box to get the x and y transform scale values
             * @deprecated This function is unreliable across browser implementations, prefer to use SVGScaleDetector if needed.
             */
            function getTransformScaleRatios(svgElement) {
                debug.assertFail('deprecated');
                if (svgElement != null) {
                    var scaledRect = svgElement.getBoundingClientRect();
                    var domRect = SVGUtil.tryGetBBox(svgElement);
                    if (domRect.height > 0 && domRect.width > 0) {
                        return {
                            x: scaledRect.width / domRect.width,
                            y: scaledRect.height / domRect.height
                        };
                    }
                }
                return { x: 1, y: 1 };
            }
            SVGUtil.getTransformScaleRatios = getTransformScaleRatios;
            /**
             * Attempt to get the bounding-box of the svg element. There is an issue with Firefox
             * which causes the getBBox() api to throw an exception when the SVG element is not attached
             * to the DOM or the display is "none", in this case this method will return an 0-sized rectangle.
             *
             * https://bugzilla.mozilla.org/show_bug.cgi?id=612118
             */
            function tryGetBBox(element) {
                var rect;
                try {
                    rect = element.getBBox();
                }
                catch (e) {
                    // We will fall back to an empty rect below.
                }
                return rect || getEmptyRect();
            }
            SVGUtil.tryGetBBox = tryGetBBox;
            function getEmptyRect() {
                return {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0,
                };
            }
        })(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
        var SVGScaleDetector = /** @class */ (function () {
            function SVGScaleDetector(svgElement) {
                this.scaleDetectorElement = svgElement
                    .append('rect') // Using a <rect> which should have a reliable bounding box across browser implementations.
                    .classed('scale-detector', true)
                    .attr({
                    width: 1,
                    height: 1,
                    'stroke-width': '0px',
                    fill: 'none',
                })
                    .node();
            }
            SVGScaleDetector.prototype.getScale = function () {
                var scaledRect = this.scaleDetectorElement.getBoundingClientRect();
                var domRect = SVGUtil.tryGetBBox(this.scaleDetectorElement);
                if (domRect.height > 0 && domRect.width > 0) {
                    return {
                        x: scaledRect.width / domRect.width,
                        y: scaledRect.height / domRect.height
                    };
                }
                return {
                    x: 1,
                    y: 1
                };
            };
            return SVGScaleDetector;
        }());
        visuals.SVGScaleDetector = SVGScaleDetector;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------
var jsCommon;
(function (jsCommon) {
    var FreezeUtility;
    (function (FreezeUtility) {
        /** Performs a deep Object.freeze() operation on an object. */
        function deepFreeze(obj) {
            Object.freeze(obj);
            for (var _i = 0, _a = Object.getOwnPropertyNames(obj); _i < _a.length; _i++) {
                var property = _a[_i];
                var value = obj[property];
                if (value && typeof value === 'object')
                    deepFreeze(value);
            }
        }
        FreezeUtility.deepFreeze = deepFreeze;
    })(FreezeUtility = jsCommon.FreezeUtility || (jsCommon.FreezeUtility = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var ConsoleTracer = /** @class */ (function () {
        function ConsoleTracer() {
        }
        ConsoleTracer.prototype.logTrace = function (trace) {
            if (window.DEBUG) {
                switch (trace.type) {
                    case jsCommon.TraceType.Information:
                        console.info(trace.toString());
                        break;
                    case jsCommon.TraceType.UnexpectedError:
                    case jsCommon.TraceType.Error:
                    case jsCommon.TraceType.Fatal:
                        console.error(trace.toString());
                        break;
                    case jsCommon.TraceType.ExpectedError:
                    case jsCommon.TraceType.Warning:
                        console.warn(trace.toString());
                        break;
                    case jsCommon.TraceType.Verbose:
                        console.log(trace.toString());
                        break;
                    default:
                        console.log(trace.toString());
                        break;
                }
            }
        };
        return ConsoleTracer;
    }());
    jsCommon.ConsoleTracer = ConsoleTracer;
    var Trace;
    (function (Trace) {
        var traceMaxCount = 1000;
        var traces = new Array(traceMaxCount);
        var lastTraceIndex = -1;
        var defaultListener = new ConsoleTracer();
        var listeners = new Array(defaultListener);
        /**
         * Trace a warning. Please ensure that no PII is being logged.
         */
        function warning(text, requestId) {
            debug.assertValue(text, 'text');
            logTraceInternal(new jsCommon.TraceItem(text, jsCommon.TraceType.Warning, requestId));
        }
        Trace.warning = warning;
        /**
         * Trace an error. Please ensure that no PII is being logged.
         */
        function error(text, includeStackTrace, requestId) {
            debug.assertValue(text, 'text');
            if (includeStackTrace)
                text = jsCommon.StringExtensions.format("{0}.\nStack:\n{1}", text, jsCommon.getStackTrace());
            logTraceInternal(new jsCommon.TraceItem(text, jsCommon.TraceType.Error, requestId));
        }
        Trace.error = error;
        /**
         * Trace an information. Please ensure that no PII is being logged.
         */
        function verbose(text, requestId) {
            debug.assertValue(text, 'text');
            logTraceInternal(new jsCommon.TraceItem(text, jsCommon.TraceType.Verbose, requestId));
        }
        Trace.verbose = verbose;
        function addListener(listener) {
            debug.assertValue(listener, 'listener');
            listeners.push(listener);
        }
        Trace.addListener = addListener;
        function removeListener(listener) {
            debug.assertValue(listener, 'listener');
            var index = listeners.indexOf(listener);
            if (index >= 0)
                listeners.splice(index, 1);
        }
        Trace.removeListener = removeListener;
        function resetListeners() {
            listeners = new Array(defaultListener);
        }
        Trace.resetListeners = resetListeners;
        function reset() {
            lastTraceIndex = -1;
        }
        Trace.reset = reset;
        function getTraces() {
            if (lastTraceIndex < 0)
                return;
            var result = new Array(lastTraceIndex + 1);
            for (var i = 0; i <= lastTraceIndex; i++)
                result[i] = traces[i];
            return result;
        }
        Trace.getTraces = getTraces;
        /**
         * Note: Used for unit-test only.
         */
        function disableDefaultListener() {
            removeListener(defaultListener);
        }
        Trace.disableDefaultListener = disableDefaultListener;
        function enableDefaultListener() {
            addListener(defaultListener);
        }
        Trace.enableDefaultListener = enableDefaultListener;
        function logTraceInternal(trace) {
            if ((lastTraceIndex + 1) >= traceMaxCount)
                reset();
            traces[++lastTraceIndex] = trace;
            for (var i = 0, len = listeners.length; i < len; i++)
                listeners[i].logTrace(trace);
        }
    })(Trace = jsCommon.Trace || (jsCommon.Trace = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * The types of possible traces within the system, this aligns to the traces available in Cloud Platform.
     */
    var TraceType;
    (function (TraceType) {
        TraceType[TraceType["Information"] = 0] = "Information";
        TraceType[TraceType["Verbose"] = 1] = "Verbose";
        TraceType[TraceType["Warning"] = 2] = "Warning";
        TraceType[TraceType["Error"] = 3] = "Error";
        TraceType[TraceType["ExpectedError"] = 4] = "ExpectedError";
        TraceType[TraceType["UnexpectedError"] = 5] = "UnexpectedError";
        TraceType[TraceType["Fatal"] = 6] = "Fatal";
    })(TraceType = jsCommon.TraceType || (jsCommon.TraceType = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var WaitForMSMapLoad;
    function ensureMap(promiseFactory, loader, bingMapBaseUrl, locale) {
        if (WaitForMSMapLoad) {
            return WaitForMSMapLoad.promise;
        }
        bingMapBaseUrl = jsCommon.UrlUtils.setQueryParameters(bingMapBaseUrl, {
            onscriptload: 'globalMapControlLoaded',
            callback: 'globalMapControlLoaded',
        }, /*keepExisting*/ true);
        var bingMapUrl = bingMapBaseUrl;
        var baseUrlParameters = jsCommon.UrlUtils.getQueryParameters(bingMapBaseUrl);
        var culture = (baseUrlParameters['c'] || baseUrlParameters['culture'] || locale);
        if (!_.isEmpty(culture)) {
            var cultureSplit = culture.split('-', 2);
            var localizationParameters = {
                // language to use for the map
                'mkt': locale || culture,
                // user region - determines Geopolitical borders and labels 
                'ur': (cultureSplit.length > 1 ? cultureSplit[1] : culture),
                // culture
                'c': culture
            };
            bingMapUrl = jsCommon.UrlUtils.setQueryParameters(bingMapBaseUrl, localizationParameters, /*keepExisting*/ true);
        }
        WaitForMSMapLoad = promiseFactory.defer();
        loader.require({ javascript: bingMapUrl });
        return WaitForMSMapLoad.promise;
    }
    powerbi.ensureMap = ensureMap;
    function mapControlLoaded() {
        debug.assertValue(WaitForMSMapLoad, 'WaitForMSMapLoad');
        WaitForMSMapLoad.resolve(undefined);
    }
    powerbi.mapControlLoaded = mapControlLoaded;
})(powerbi || (powerbi = {}));
/* tslint:disable:no-unused-variable */
window.globalMapControlLoaded = function () {
    // Map requires a function in the global namespace to callback once loaded
    powerbi.mapControlLoaded();
};
/* tslint:enable:no-unused-variable */ 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var InJs;
(function (InJs) {
    /**
     * The types of possible traces within the system, this aligns to the traces available in Cloud Platform.
     */
    var TraceType;
    (function (TraceType) {
        TraceType[TraceType["information"] = 0] = "information";
        TraceType[TraceType["verbose"] = 1] = "verbose";
        TraceType[TraceType["warning"] = 2] = "warning";
        TraceType[TraceType["error"] = 3] = "error";
        TraceType[TraceType["expectedError"] = 4] = "expectedError";
        TraceType[TraceType["unexpectedError"] = 5] = "unexpectedError";
        TraceType[TraceType["fatal"] = 6] = "fatal";
    })(TraceType = InJs.TraceType || (InJs.TraceType = {}));
})(InJs || (InJs = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Point = /** @class */ (function () {
            function Point(x, y) {
                this.x = x || 0;
                this.y = y || 0;
            }
            return Point;
        }());
        visuals.Point = Point;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Rect = /** @class */ (function () {
            // Constructor
            function Rect(left, top, width, height) {
                this.left = left || 0;
                this.top = top || 0;
                this.width = width || 0;
                this.height = height || 0;
            }
            return Rect;
        }());
        visuals.Rect = Rect;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        "use strict";
        var shapes;
        (function (shapes) {
            var Utility = jsCommon.Utility;
            var Polygon = /** @class */ (function () {
                function Polygon(absolutePoints) {
                    this.polygonPoints = this.convertArrayPathToPoints(absolutePoints);
                }
                Polygon.prototype.absoluteCentroid = function () {
                    if (this._absoluteCentroid == null) {
                        this._absoluteCentroid = this.calculatePolygonCentroid();
                    }
                    return this._absoluteCentroid;
                };
                Polygon.prototype.absoluteBoundingRect = function () {
                    if (this._absoluteBoundingRect == null) {
                        this._absoluteBoundingRect = this.calculateBoundingRect();
                    }
                    return this._absoluteBoundingRect;
                };
                /**
                 * Check if label text contain in polygon shape.
                 *
                 * @return true/false is the label fit in polygon.
                 * measure if rects points are inside the polygon shape
                 * return true if there is at least 3 point inside the polygon
                 */
                Polygon.prototype.contains = function (rect) {
                    var topLeft = { x: rect.left, y: rect.top };
                    var topRight = { x: rect.left + rect.width, y: rect.top };
                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
                    return (this.inside(topLeft)
                        && this.inside(topRight)
                        && this.inside(bottomLeft)
                        && this.inside(bottomRight));
                };
                /**
                * Check if label text is outside of polygon shape.
                * It checks 8 points in the label. TopLeft, TopCenter, TopRight, MiddleLeft, MiddleRight, BottomLeft, BottomMiddle, BottomRight
                * @return true/false is there is any conflict (at least one point inside the shape).
                */
                Polygon.prototype.conflicts = function (rect) {
                    if (!this.isConflictWithBoundingBox(rect)) {
                        return false;
                    }
                    var topLeft = { x: rect.left, y: rect.top };
                    var topCenter = { x: rect.left + rect.width / 2, y: rect.top };
                    var topRight = { x: rect.left + rect.width, y: rect.top };
                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
                    var bottomCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height };
                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
                    var middleLeft = { x: rect.left, y: rect.top + rect.height / 2 };
                    var middleRight = { x: rect.left + rect.width, y: rect.top + rect.height / 2 };
                    return (this.inside(topLeft)
                        || this.inside(topCenter)
                        || this.inside(topRight)
                        || this.inside(bottomLeft)
                        || this.inside(bottomCenter)
                        || this.inside(bottomRight)
                        || this.inside(middleLeft)
                        || this.inside(middleRight));
                };
                /**
                * returns intersection point of a line (depicted by two points) and a polygon.
                *
                * @return the point of intersection or null if there is no intersection.
                */
                Polygon.prototype.lineIntersectionPoint = function (p0, p1) {
                    for (var i = 0; i < this.polygonPoints.length; i++) {
                        var p2 = this.polygonPoints[i];
                        var p3 = (i === this.polygonPoints.length - 1 ? this.polygonPoints[0] : this.polygonPoints[i + 1]);
                        var intersection = this.getLineIntersection(p0, p1, p2, p3);
                        if (intersection !== null) {
                            return intersection;
                        }
                    }
                    return null;
                };
                /**
                 * calculate Polygon Area.
                 *
                 * @return the area of the polygon (as number).
                 */
                Polygon.calculateAbsolutePolygonArea = function (polygonPoints) {
                    var i, j = 1;
                    var area = 0.0;
                    for (i = 0; i < polygonPoints.length; i++) {
                        area += polygonPoints[i].x * polygonPoints[j].y - polygonPoints[j].x * polygonPoints[i].y;
                        j = (j + 1) % polygonPoints.length;
                    }
                    area *= 0.5;
                    return area;
                };
                /**
                * Check if label text is outside of polygon bounding box.
                *
                * @return true/false is there is any conflict (at least one point inside the shape).
                */
                Polygon.prototype.isConflictWithBoundingBox = function (rect) {
                    return Rect.isIntersecting(this.absoluteBoundingRect(), rect);
                };
                /**
                 * Calculate Polygon Centroid.
                 *
                 * @return 'center' point of the polygon.
                 * calculate the polygon area
                 * calculate the average points of the polygon by x & y axis.
                 * divided the average point by the area
                 */
                Polygon.prototype.calculatePolygonCentroid = function () {
                    var area, tempPoint, cx, cy, i, j;
                    /* First calculate the polygon's signed area A */
                    area = Polygon.calculateAbsolutePolygonArea(this.polygonPoints);
                    /* Now calculate the centroid coordinates Cx and Cy */
                    cx = cy = 0.0;
                    j = 1;
                    for (i = 0; i < this.polygonPoints.length; i++) {
                        tempPoint = this.polygonPoints[i].x * this.polygonPoints[j].y - this.polygonPoints[j].x * this.polygonPoints[i].y;
                        cx += (this.polygonPoints[i].x + this.polygonPoints[j].x) * tempPoint;
                        cy += (this.polygonPoints[i].y + this.polygonPoints[j].y) * tempPoint;
                        j = (j + 1) % this.polygonPoints.length;
                    }
                    cx = cx / (6.0 * area);
                    cy = cy / (6.0 * area);
                    return {
                        x: cx,
                        y: cy,
                    };
                };
                Polygon.prototype.calculateBoundingRect = function () {
                    var minX = Number.POSITIVE_INFINITY;
                    var minY = Number.POSITIVE_INFINITY;
                    var maxX = Number.NEGATIVE_INFINITY;
                    var maxY = Number.NEGATIVE_INFINITY;
                    for (var _i = 0, _a = this.polygonPoints; _i < _a.length; _i++) {
                        var polygonPoint = _a[_i];
                        if (polygonPoint.x < minX) {
                            minX = polygonPoint.x;
                        }
                        else if (polygonPoint.x > maxX) {
                            maxX = polygonPoint.x;
                        }
                        if (polygonPoint.y < minY) {
                            minY = polygonPoint.y;
                        }
                        else if (polygonPoint.y > maxY) {
                            maxY = polygonPoint.y;
                        }
                    }
                    return {
                        left: minX,
                        top: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                };
                /**
                 * Check if point exist inside polygon shape.
                 *
                 * @return true/false if point exist inside shape.
                 * ray-casting algorithm based on:
                 * http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                 */
                Polygon.prototype.inside = function (point) {
                    var x = point.x, y = point.y;
                    var insideVar = false;
                    for (var i = 0, j = this.polygonPoints.length - 1; i < this.polygonPoints.length; j = i++) {
                        var xi = this.polygonPoints[i].x, yi = this.polygonPoints[i].y;
                        var xj = this.polygonPoints[j].x, yj = this.polygonPoints[j].y;
                        var intersect = ((yi > y) !== (yj > y))
                            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                        if (intersect) {
                            insideVar = !insideVar;
                        }
                    }
                    return insideVar;
                };
                /**
                 * Checks if a line (presented as two points) intersects with a another line
                 */
                Polygon.prototype.getLineIntersection = function (line0p1, line0p2, line1p1, line1p2) {
                    var p0_x = line0p1.x;
                    var p0_y = line0p1.y;
                    var p1_x = line0p2.x;
                    var p1_y = line0p2.y;
                    var p2_x = line1p1.x;
                    var p2_y = line1p1.y;
                    var p3_x = line1p2.x;
                    var p3_y = line1p2.y;
                    var s1_x = p1_x - p0_x;
                    var s1_y = p1_y - p0_y;
                    var s2_x = p3_x - p2_x;
                    var s2_y = p3_y - p2_y;
                    //Calculating collisions using cross products
                    var s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
                    var t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
                    // 0<=s<=1 and 0<=t<=1 ensures that the collision is part of the original line
                    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                        // Collision detected
                        return { x: (p0_x + (t * s1_x)), y: (p0_y + (t * s1_y)) };
                    }
                    return null; // No collision
                };
                Polygon.prototype.convertArrayPathToPoints = function (path) {
                    var pointsRes = [];
                    for (var i = 0; i < path.length; i += 2) {
                        var x = path[i];
                        var y = path[i + 1];
                        var newPoint = {
                            x: x,
                            y: y,
                        };
                        pointsRes.push(newPoint);
                    }
                    return pointsRes;
                };
                return Polygon;
            }());
            shapes.Polygon = Polygon;
            var Point;
            (function (Point) {
                function offset(point, offsetX, offsetY) {
                    var newPointX = ((point.x + offsetX) >= 0) ? (point.x + offsetX) : 0;
                    var newPointY = ((point.y + offsetY) >= 0) ? (point.y + offsetY) : 0;
                    return { x: newPointX, y: newPointY };
                }
                Point.offset = offset;
                function equals(point, other) {
                    return point !== undefined && point !== null && other !== undefined && other !== null && point.x === other.x && point.y === other.y;
                }
                Point.equals = equals;
                function clone(point) {
                    return (point !== null) ? { x: point.x, y: point.y } : null;
                }
                Point.clone = clone;
                function toString(point) {
                    return "{x:" + point.x + ", y:" + point.y + "}";
                }
                Point.toString = toString;
                function serialize(point) {
                    return point.x + "," + point.y;
                }
                Point.serialize = serialize;
                function getDistance(point, other) {
                    if ((point === null) || (other) === null) {
                        return null;
                    }
                    var diffX = other.x - point.x;
                    var diffY = other.y - point.y;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                Point.getDistance = getDistance;
                function equalWithPrecision(point1, point2) {
                    return point1 === point2 ||
                        (point1 !== undefined && point2 !== undefined && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y));
                }
                Point.equalWithPrecision = equalWithPrecision;
                function parsePoint(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { x: Utility.parseNumber(value[0]), y: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { x: Utility.parseNumber(parts[0]), y: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { x: Utility.parseNumber(value.x), y: Utility.parseNumber(value.y) };
                        }
                    }
                }
                Point.parsePoint = parsePoint;
            })(Point = shapes.Point || (shapes.Point = {}));
            var Size;
            (function (Size) {
                function isEmpty(size) {
                    return size.width === 0 && size.height === 0;
                }
                Size.isEmpty = isEmpty;
                function equals(size, other) {
                    return size !== undefined && size !== null && other !== undefined && other !== null && size.width === other.width && size.height === other.height;
                }
                Size.equals = equals;
                function clone(size) {
                    return (size !== null) ? { width: size.width, height: size.height } : null;
                }
                Size.clone = clone;
                function inflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Size.inflate = inflate;
                function deflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width = result.width - padding.left - padding.right;
                        if (result.width < 0) {
                            result.width = 0;
                        }
                        result.height = result.height - padding.top - padding.bottom;
                        if (result.height < 0) {
                            result.height = 0;
                        }
                    }
                    return result;
                }
                Size.deflate = deflate;
                function combine(size, other) {
                    if (other) {
                        size.width = Math.max(size.width, other.width);
                        size.height = Math.max(size.height, other.height);
                    }
                    return size;
                }
                Size.combine = combine;
                function toRect(size) {
                    return { left: 0, top: 0, width: size.width, height: size.height };
                }
                Size.toRect = toRect;
                function toString(size) {
                    return "{width:" + size.width + ", height:" + size.height + "}";
                }
                Size.toString = toString;
                function equal(size1, size2) {
                    return size1 === size2 ||
                        (size1 !== undefined && size2 !== undefined && size1.width === size2.width && size1.height === size2.height);
                }
                Size.equal = equal;
                function equalWithPrecision(size1, size2) {
                    return size1 === size2 ||
                        (size1 !== undefined && size2 !== undefined && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height));
                }
                Size.equalWithPrecision = equalWithPrecision;
                function parseSize(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { width: Utility.parseNumber(value[0]), height: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { width: Utility.parseNumber(parts[0]), height: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Size.parseSize = parseSize;
            })(Size = shapes.Size || (shapes.Size = {}));
            var Rect;
            (function (Rect) {
                function getOffset(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.getOffset = getOffset;
                function getSize(rect) {
                    return { width: rect.width, height: rect.height };
                }
                Rect.getSize = getSize;
                function setSize(rect, value) {
                    rect.width = value.width;
                    rect.height = value.height;
                }
                Rect.setSize = setSize;
                function right(rect) {
                    return rect.left + rect.width;
                }
                Rect.right = right;
                function bottom(rect) {
                    return rect.top + rect.height;
                }
                Rect.bottom = bottom;
                function topLeft(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.topLeft = topLeft;
                function topRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top };
                }
                Rect.topRight = topRight;
                function bottomLeft(rect) {
                    return { x: rect.left, y: rect.top + rect.height };
                }
                Rect.bottomLeft = bottomLeft;
                function bottomRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top + rect.height };
                }
                Rect.bottomRight = bottomRight;
                function equals(rect, other) {
                    return other !== undefined && other !== null &&
                        rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                }
                Rect.equals = equals;
                function clone(rect) {
                    return (rect !== null) ? { left: rect.left, top: rect.top, width: rect.width, height: rect.height } : null;
                }
                Rect.clone = clone;
                function toString(rect) {
                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                }
                Rect.toString = toString;
                function offset(rect, offsetX, offsetY) {
                    var newLeft = ((rect.left + offsetX) >= 0) ? rect.left + offsetX : 0;
                    var newTop = ((rect.top + offsetY) >= 0) ? rect.top + offsetY : 0;
                    return { left: newLeft, top: newTop, width: rect.width, height: rect.height };
                }
                Rect.offset = offset;
                function add(rect, rect2) {
                    debug.assertValue(rect, 'rect');
                    debug.assertValue(rect2, 'rect2');
                    return {
                        left: rect.left + rect2.left,
                        top: rect.top + rect2.top,
                        height: rect.height + rect2.height,
                        width: rect.width + rect2.width
                    };
                }
                Rect.add = add;
                function subtract(rect, rect2) {
                    debug.assertValue(rect, 'rect');
                    debug.assertValue(rect2, 'rect2');
                    return {
                        left: rect.left - rect2.left,
                        top: rect.top - rect2.top,
                        height: rect.height - rect2.height,
                        width: rect.width - rect2.width
                    };
                }
                Rect.subtract = subtract;
                function inflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left -= padding.left;
                        result.top -= padding.top;
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.inflate = inflate;
                function deflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left += padding.left;
                        result.top += padding.top;
                        result.width -= padding.left + padding.right;
                        result.height -= padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.deflate = deflate;
                function inflateBy(rect, padding) {
                    return { left: rect.left - padding, top: rect.top - padding, width: rect.width + padding + padding, height: rect.height + padding + padding };
                }
                Rect.inflateBy = inflateBy;
                function deflateBy(rect, padding) {
                    return { left: rect.left + padding, top: rect.top + padding, width: rect.width - padding - padding, height: rect.height - padding - padding };
                }
                Rect.deflateBy = deflateBy;
                /**
                 * Get closest point.
                 *
                 * @return the closest point on the rect to the (x,y) point given.
                 * In case the (x,y) given is inside the rect, (x,y) will be returned.
                 * Otherwise, a point on a border will be returned.
                 */
                function getClosestPoint(rect, x, y) {
                    return {
                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                    };
                }
                Rect.getClosestPoint = getClosestPoint;
                function equal(rect1, rect2) {
                    return rect1 === rect2 ||
                        (rect1 !== undefined && rect2 !== undefined && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height);
                }
                Rect.equal = equal;
                function equalWithPrecision(rect1, rect2) {
                    return rect1 === rect2 ||
                        (rect1 !== undefined && rect2 !== undefined &&
                            powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) &&
                            powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height));
                }
                Rect.equalWithPrecision = equalWithPrecision;
                function isEmpty(rect) {
                    return rect === undefined || rect === null || (rect.width === 0 && rect.height === 0);
                }
                Rect.isEmpty = isEmpty;
                function containsPoint(rect, point, excludeEdges) {
                    if (excludeEdges === void 0) { excludeEdges = false; }
                    if ((rect === null) || (point === null)) {
                        return false;
                    }
                    if (excludeEdges) {
                        return powerbi.Double.lessWithPrecision(rect.left, point.x) &&
                            powerbi.Double.lessWithPrecision(point.x, rect.left + rect.width) &&
                            powerbi.Double.lessWithPrecision(rect.top, point.y) &&
                            powerbi.Double.lessWithPrecision(point.y, rect.top + rect.height);
                    }
                    return powerbi.Double.lessOrEqualWithPrecision(rect.left, point.x) &&
                        powerbi.Double.lessOrEqualWithPrecision(point.x, rect.left + rect.width) &&
                        powerbi.Double.lessOrEqualWithPrecision(rect.top, point.y) &&
                        powerbi.Double.lessOrEqualWithPrecision(point.y, rect.top + rect.height);
                }
                Rect.containsPoint = containsPoint;
                function isIntersecting(rect1, rect2) {
                    if (!rect1 || !rect2) {
                        return false;
                    }
                    return !(rect2.left > rect1.left + rect1.width ||
                        rect2.left + rect2.width < rect1.left ||
                        rect2.top > rect1.top + rect1.height ||
                        rect2.top + rect2.height < rect1.top);
                }
                Rect.isIntersecting = isIntersecting;
                function intersect(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var top = Math.max(rect1.top, rect2.top);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    if (left <= right && top <= bottom) {
                        return { left: left, top: top, width: right - left, height: bottom - top };
                    }
                    else {
                        return { left: 0, top: 0, width: 0, height: 0 };
                    }
                }
                Rect.intersect = intersect;
                function combine(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.min(rect1.left, rect2.left);
                    var top = Math.min(rect1.top, rect2.top);
                    var right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                    return { left: left, top: top, width: right - left, height: bottom - top };
                }
                Rect.combine = combine;
                function parseRect(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), width: Utility.parseNumber(value[2]), height: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return {
                                left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), width: Utility.parseNumber(parts[2]), height: Utility.parseNumber(parts[3])
                            };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Rect.parseRect = parseRect;
                function getCentroid(rect) {
                    return {
                        x: rect.left + (rect.width / 2),
                        y: rect.top + (rect.height / 2)
                    };
                }
                Rect.getCentroid = getCentroid;
            })(Rect = shapes.Rect || (shapes.Rect = {}));
            var Thickness;
            (function (Thickness) {
                function inflate(thickness, other) {
                    var result = clone(thickness);
                    if (other) {
                        result.left = thickness.left + other.left;
                        result.right = thickness.right + other.right;
                        result.bottom = thickness.bottom + other.bottom;
                        result.top = thickness.top + other.top;
                    }
                    return result;
                }
                Thickness.inflate = inflate;
                function getWidth(thickness) {
                    return thickness.left + thickness.right;
                }
                Thickness.getWidth = getWidth;
                function getHeight(thickness) {
                    return thickness.top + thickness.bottom;
                }
                Thickness.getHeight = getHeight;
                function clone(thickness) {
                    return (thickness !== null) ? { left: thickness.left, top: thickness.top, right: thickness.right, bottom: thickness.bottom } : null;
                }
                Thickness.clone = clone;
                function equals(thickness, other) {
                    return thickness !== undefined && thickness !== null && other !== undefined && other !== null && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                }
                Thickness.equals = equals;
                function flipHorizontal(thickness) {
                    var temp = thickness.right;
                    thickness.right = thickness.left;
                    thickness.left = temp;
                }
                Thickness.flipHorizontal = flipHorizontal;
                function flipVertical(thickness) {
                    var top = thickness.top;
                    thickness.top = thickness.bottom;
                    thickness.bottom = top;
                }
                Thickness.flipVertical = flipVertical;
                function toString(thickness) {
                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                }
                Thickness.toString = toString;
                function toCssString(thickness) {
                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                }
                Thickness.toCssString = toCssString;
                function isEmpty(thickness) {
                    return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;
                }
                Thickness.isEmpty = isEmpty;
                function equal(thickness1, thickness2) {
                    return thickness1 === thickness2 ||
                        (thickness1 !== undefined && thickness2 !== undefined && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom);
                }
                Thickness.equal = equal;
                function equalWithPrecision(thickness1, thickness2) {
                    return thickness1 === thickness2 ||
                        (thickness1 !== undefined && thickness2 !== undefined &&
                            powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) &&
                            powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom));
                }
                Thickness.equalWithPrecision = equalWithPrecision;
                function parseThickness(value, defaultValue, resetValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), right: Utility.parseNumber(value[2]), bottom: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), right: Utility.parseNumber(parts[2]), bottom: Utility.parseNumber(parts[3]) };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), right: Utility.parseNumber(value.right), bottom: Utility.parseNumber(value.bottom) };
                        }
                    }
                }
                Thickness.parseThickness = parseThickness;
            })(Thickness = shapes.Thickness || (shapes.Thickness = {}));
            var Vector;
            (function (Vector) {
                function isEmpty(vector) {
                    return vector.x === 0 && vector.y === 0;
                }
                Vector.isEmpty = isEmpty;
                function equals(vector, other) {
                    return vector !== undefined && vector !== null && other !== undefined && other !== null && vector.x === other.x && vector.y === other.y;
                }
                Vector.equals = equals;
                function clone(vector) {
                    return (vector !== null) ? { x: vector.x, y: vector.y } : null;
                }
                Vector.clone = clone;
                function toString(vector) {
                    return "{x:" + vector.x + ", y:" + vector.y + "}";
                }
                Vector.toString = toString;
                function getLength(vector) {
                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                }
                Vector.getLength = getLength;
                function getLengthSqr(vector) {
                    return vector.x * vector.x + vector.y * vector.y;
                }
                Vector.getLengthSqr = getLengthSqr;
                function scale(vector, scalar) {
                    return { x: vector.x * scalar, y: vector.y * scalar };
                }
                Vector.scale = scale;
                function normalize(vector) {
                    return !isEmpty(vector) ? scale(vector, 1 / getLength(vector)) : vector;
                }
                Vector.normalize = normalize;
                function rotate90DegCW(vector) {
                    return { x: vector.y, y: -vector.x };
                }
                Vector.rotate90DegCW = rotate90DegCW;
                function rotate90DegCCW(vector) {
                    return { x: -vector.y, y: vector.x };
                }
                Vector.rotate90DegCCW = rotate90DegCCW;
                function rotate(vector, angle) {
                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
                    var newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                    return { x: newX, y: newY };
                }
                Vector.rotate = rotate;
                function equal(vector1, vector2) {
                    return vector1 === vector2 ||
                        (vector1 !== undefined && vector2 !== undefined && vector1.x === vector2.x && vector1.y === vector2.y);
                }
                Vector.equal = equal;
                function equalWithPrecision(vector1, vector2) {
                    return vector1 === vector2 ||
                        (vector1 !== undefined && vector2 !== undefined && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y));
                }
                Vector.equalWithPrecision = equalWithPrecision;
                function add(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x + vect2.x, y: vect1.y + vect2.y };
                }
                Vector.add = add;
                function subtract(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x - vect2.x, y: vect1.y - vect2.y };
                }
                Vector.subtract = subtract;
                function dotProduct(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return vect1.x * vect2.x + vect1.y * vect2.y;
                }
                Vector.dotProduct = dotProduct;
                function getDeltaVector(p0, p1) {
                    if (!p0 || !p1) {
                        return undefined;
                    }
                    return { x: p1.x - p0.x, y: p1.y - p0.y };
                }
                Vector.getDeltaVector = getDeltaVector;
            })(Vector = shapes.Vector || (shapes.Vector = {}));
        })(shapes = visuals.shapes || (visuals.shapes = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
;// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

/// <disable>JS2025.InsertSpaceBeforeCommentText,JS2027.PunctuateCommentsCorrectly,JS2076.IdentifierIsMiscased,JS3085.VariableDeclaredMultipleTimes, JS3116.PreviousDeclarationWasHere, JS2074.IdentifierNameIsMisspelled, JS2030.FollowKeywordsWithSpace, JS2023.UseDoubleQuotesForStringLiterals, JS2028.UseCPlusPlusStyleComments, JS2026.CapitalizeComments, JS2008.DoNotUseCookies, JS2005.UseShortFormInitializations, JS2064.SpecifyNewWhenCallingConstructor, JS2024.DoNotQuoteObjectLiteralPropertyNames, JS2043.RemoveDebugCode, JS3045.MissingInputFile</disable>
/// <dictionary target='comment'>args,aspx,autocompletion,enqueue,Firefox,Hardcoded,interdependant,Kinda,Moderncop,Nav,param,params,powerview, secweb, serializer, sharepoint, silverlight, src, stylesheet, theming, untokenized, Xmla </dictionary>

// ModernCop Rules and Settings - Disabling some non critical warnings that we currently have per:
// http://secweb01/MSEC/Tools/Lists/MSEC%20Tool%20Errors%20and%20Warnings/AllItems.aspx?FilterField1=Tool&FilterValue1=Moderncop

/// <disable>JS2085.EnableStrictMode</disable>
// Justification: The violation is that strict mode is enabled for global scope, which could lead
// to unexpected behavior if the target JS file of this project is concatenated with other JS files.
// The target JS file of this project is not concatenated with other files.
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */
        var DefaultSQExprVisitorWithArg = /** @class */ (function () {
            function DefaultSQExprVisitorWithArg() {
            }
            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitSubqueryRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNamedQueryRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitPercentile = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitGroupRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitSelectRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitConditional = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitFloor = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitThemeColor = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitFilteredEval = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitWithRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitTransformTableRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitTransformOutputRoleRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitRoleRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDiscretize = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitMember = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {
                return;
            };
            return DefaultSQExprVisitorWithArg;
        }());
        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;
        /** Default ISQExprVisitor implementation that others may derive from. */
        var DefaultSQExprVisitor = /** @class */ (function (_super) {
            __extends(DefaultSQExprVisitor, _super);
            function DefaultSQExprVisitor() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return DefaultSQExprVisitor;
        }(DefaultSQExprVisitorWithArg));
        data.DefaultSQExprVisitor = DefaultSQExprVisitor;
        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */
        var DefaultSQExprVisitorWithTraversal = /** @class */ (function () {
            function DefaultSQExprVisitorWithTraversal() {
            }
            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitSubqueryRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNamedQueryRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {
                expr.source.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {
                expr.source.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitPercentile = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitGroupRef = function (expr) {
                expr.source.accept(this);
                for (var _i = 0, _a = expr.groupedExprs; _i < _a.length; _i++) {
                    var groupedColumn = _a[_i];
                    groupedColumn.accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitSelectRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {
                expr.arg.accept(this);
                expr.lower.accept(this);
                expr.upper.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {
                var args = expr.args;
                for (var i = 0, len = args.length; i < len; i++)
                    args[i].accept(this);
                var values = expr.values;
                if (values) {
                    for (var i = 0, len = values.length; i < len; i++) {
                        var valueTuple = values[i];
                        for (var j = 0, jlen = valueTuple.length; j < jlen; j++)
                            valueTuple[j].accept(this);
                    }
                }
                else {
                    expr.table.accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitConditional = function (expr) {
                debug.assertValue(expr, 'expr');
                debug.assertNonEmpty(expr.cases, 'expr.cases');
                for (var _i = 0, _a = expr.cases; _i < _a.length; _i++) {
                    var conditionalCase = _a[_i];
                    conditionalCase.condition.accept(this);
                    conditionalCase.value.accept(this);
                }
                if (expr.defaultValue)
                    expr.defaultValue.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFloor = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {
                expr.input.accept(this);
                var rule = expr.rule;
                var gradient2 = rule.linearGradient2;
                if (gradient2)
                    this.visitLinearGradient2(gradient2);
                var gradient3 = rule.linearGradient3;
                if (gradient3)
                    this.visitLinearGradient3(gradient3);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {
                debug.assertValue(gradient2, 'gradient2');
                this.visitFillRuleStop(gradient2.min);
                this.visitFillRuleStop(gradient2.max);
                this.visitFillNullStrategy(gradient2.nullColoringStrategy);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {
                debug.assertValue(gradient3, 'gradient3');
                this.visitFillRuleStop(gradient3.min);
                this.visitFillRuleStop(gradient3.mid);
                this.visitFillRuleStop(gradient3.max);
                this.visitFillNullStrategy(gradient3.nullColoringStrategy);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitThemeColor = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {
                expr.expression.accept(this);
                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {
                    var scopeExpr = _a[_i];
                    scopeExpr.accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFilteredEval = function (expr) {
                expr.expression.accept(this);
                for (var _i = 0, _a = expr.filters; _i < _a.length; _i++) {
                    var filter = _a[_i];
                    if (!_.isEmpty(filter.target)) {
                        for (var _b = 0, _c = filter.target; _b < _c.length; _b++) {
                            var target = _c[_b];
                            target.accept(this);
                        }
                    }
                    filter.condition.accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitWithRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitTransformTableRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitTransformOutputRoleRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitRoleRef = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDiscretize = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitMember = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {
                return;
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {
                debug.assertValue(stop, 'stop');
                stop.color.accept(this);
                var value = stop.value;
                if (value)
                    value.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFillNullStrategy = function (defn) {
                if (defn) {
                    defn.strategy.accept(this);
                    if (defn.color)
                        defn.color.accept(this);
                }
            };
            return DefaultSQExprVisitorWithTraversal;
        }());
        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    function createEnumType(members) {
        return new EnumType(members);
    }
    powerbi.createEnumType = createEnumType;
    var EnumType = /** @class */ (function () {
        function EnumType(allMembers) {
            debug.assertValue(allMembers, 'allMembers');
            this.allMembers = allMembers;
        }
        EnumType.prototype.members = function (validMembers) {
            var allMembers = this.allMembers;
            if (!validMembers)
                return allMembers;
            var membersToReturn = [];
            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {
                var member = allMembers_1[_i];
                if (_.contains(validMembers, member.value))
                    membersToReturn.push(member);
            }
            return membersToReturn;
        };
        return EnumType;
    }());
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var fillDefinitionHelpers;
    (function (fillDefinitionHelpers) {
        function createSolidFillDefinition(color) {
            if (color)
                return { solid: { color: powerbi.data.SQExprBuilder.text(color) } };
        }
        fillDefinitionHelpers.createSolidFillDefinition = createSolidFillDefinition;
    })(fillDefinitionHelpers = powerbi.fillDefinitionHelpers || (powerbi.fillDefinitionHelpers = {}));
    var FillSolidColorTypeDescriptor;
    (function (FillSolidColorTypeDescriptor) {
        /** Gets a value indicating whether the descriptor is nullable or not. */
        function nullable(descriptor) {
            debug.assertValue(descriptor, 'descriptor');
            if (descriptor === true)
                return false;
            var advancedDescriptor = descriptor;
            return !!advancedDescriptor.nullable;
        }
        FillSolidColorTypeDescriptor.nullable = nullable;
    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NullStrategy;
    (function (NullStrategy) {
        NullStrategy.asZero = 'asZero';
        NullStrategy.noColor = 'noColor';
        NullStrategy.specificColor = 'specificColor';
        NullStrategy.type = powerbi.createEnumType([
            { value: NullStrategy.asZero, displayName: function (resources) { return resources.get('ConditionalFormattingDialog_FormatNull_AsZero'); } },
            { value: NullStrategy.noColor, displayName: function (resources) { return resources.get('ConditionalFormattingDialog_FormatNull_NoFormat'); } },
            { value: NullStrategy.specificColor, displayName: function (resources) { return resources.get('ConditionalFormattingDialog_FormatNull_SpecificColor'); } },
        ]);
    })(NullStrategy = powerbi.NullStrategy || (powerbi.NullStrategy = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var GeoJsonTypes;
    (function (GeoJsonTypes) {
        GeoJsonTypes.shared = "shared";
        GeoJsonTypes.packaged = "packaged";
    })(GeoJsonTypes = powerbi.GeoJsonTypes || (powerbi.GeoJsonTypes = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var ImageDefinition;
    (function (ImageDefinition) {
        ImageDefinition.urlType = { misc: { imageUrl: true } };
    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var StructuralTypeDescriptor;
    (function (StructuralTypeDescriptor) {
        function isValid(type) {
            debug.assertValue(type, 'type');
            if (type.fill ||
                type.fillRule ||
                type.filter ||
                type.expression ||
                type.image ||
                type.paragraphs ||
                type.geoJson ||
                type.queryTransform ||
                type.dataBars) {
                return true;
            }
            return false;
        }
        StructuralTypeDescriptor.isValid = isValid;
    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var EnumExtensions = jsCommon.EnumExtensions;
    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */
    var ValueType = /** @class */ (function () {
        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */
        function ValueType(type, category, enumType, variantTypes) {
            debug.assert((!!type && ExtendedTypeStrings[type] != null) || type === 0 /* Null */, 'type');
            debug.assert(!!category || category === null, 'category');
            debug.assert(type !== 26214401 /* Enumeration */ || !!enumType, 'enumType');
            this.underlyingType = type;
            this.category = category;
            if (EnumExtensions.hasFlag(type, 512 /* Temporal */)) {
                this.temporalType = new TemporalType(type);
            }
            if (EnumExtensions.hasFlag(type, 1024 /* Geography */)) {
                this.geographyType = new GeographyType(type);
            }
            if (EnumExtensions.hasFlag(type, 2048 /* Miscellaneous */)) {
                this.miscType = new MiscellaneousType(type);
            }
            if (EnumExtensions.hasFlag(type, 4096 /* Formatting */)) {
                this.formattingType = new FormattingType(type);
            }
            if (EnumExtensions.hasFlag(type, 26214401 /* Enumeration */)) {
                this.enumType = enumType;
            }
            if (EnumExtensions.hasFlag(type, 8192 /* Scripting */)) {
                this.scriptingType = new ScriptType(type);
            }
            if (EnumExtensions.hasFlag(type, 16384 /* Reference */)) {
                this.referenceType = new ReferenceType(type);
            }
            if (EnumExtensions.hasFlag(type, 13 /* Variant */)) {
                this.variationTypes = variantTypes;
            }
        }
        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */
        ValueType.fromDescriptor = function (descriptor) {
            descriptor = descriptor || {};
            // Simplified primitive types
            if (descriptor.text)
                return ValueType.fromExtendedType(1 /* Text */);
            if (descriptor.integer)
                return ValueType.fromExtendedType(260 /* Integer */);
            if (descriptor.numeric)
                return ValueType.fromExtendedType(259 /* Double */);
            if (descriptor.bool)
                return ValueType.fromExtendedType(5 /* Boolean */);
            if (descriptor.dateTime)
                return ValueType.fromExtendedType(519 /* DateTime */);
            if (descriptor.duration)
                return ValueType.fromExtendedType(10 /* Duration */);
            if (descriptor.binary)
                return ValueType.fromExtendedType(11 /* Binary */);
            if (descriptor.none)
                return ValueType.fromExtendedType(12 /* None */);
            // Extended types
            if (descriptor.scripting) {
                if (descriptor.scripting.source)
                    return ValueType.fromExtendedType(32776193 /* ScriptSource */);
            }
            if (descriptor.enumeration)
                return ValueType.fromEnum(descriptor.enumeration);
            if (descriptor.temporal) {
                if (descriptor.temporal.year)
                    return ValueType.fromExtendedType(66308 /* Years_Integer */);
                if (descriptor.temporal.quarter)
                    return ValueType.fromExtendedType(262916 /* Quarters_Integer */);
                if (descriptor.temporal.month)
                    return ValueType.fromExtendedType(131844 /* Months_Integer */);
                if (descriptor.temporal.day)
                    return ValueType.fromExtendedType(328452 /* DayOfMonth_Integer */);
                if (descriptor.temporal.paddedDateTableDate)
                    return ValueType.fromExtendedType(197127 /* PaddedDateTableDates */);
            }
            if (descriptor.geography) {
                if (descriptor.geography.address)
                    return ValueType.fromExtendedType(6554625 /* Address */);
                if (descriptor.geography.city)
                    return ValueType.fromExtendedType(6620161 /* City */);
                if (descriptor.geography.continent)
                    return ValueType.fromExtendedType(6685697 /* Continent */);
                if (descriptor.geography.country)
                    return ValueType.fromExtendedType(6751233 /* Country */);
                if (descriptor.geography.county)
                    return ValueType.fromExtendedType(6816769 /* County */);
                if (descriptor.geography.region)
                    return ValueType.fromExtendedType(6882305 /* Region */);
                if (descriptor.geography.postalCode)
                    return ValueType.fromExtendedType(6947841 /* PostalCode_Text */);
                if (descriptor.geography.stateOrProvince)
                    return ValueType.fromExtendedType(7013377 /* StateOrProvince */);
                if (descriptor.geography.place)
                    return ValueType.fromExtendedType(7078913 /* Place */);
                if (descriptor.geography.latitude)
                    return ValueType.fromExtendedType(7144707 /* Latitude_Double */);
                if (descriptor.geography.longitude)
                    return ValueType.fromExtendedType(7210243 /* Longitude_Double */);
            }
            if (descriptor.misc) {
                if (descriptor.misc.image)
                    return ValueType.fromExtendedType(13109259 /* Image */);
                if (descriptor.misc.imageUrl)
                    return ValueType.fromExtendedType(13174785 /* ImageUrl */);
                if (descriptor.misc.webUrl)
                    return ValueType.fromExtendedType(13240321 /* WebUrl */);
                if (descriptor.misc.barcode)
                    return ValueType.fromExtendedType(13305857 /* Barcode_Text */);
            }
            if (descriptor.formatting) {
                if (descriptor.formatting.color)
                    return ValueType.fromExtendedType(19664897 /* Color */);
                if (descriptor.formatting.formatString)
                    return ValueType.fromExtendedType(19730433 /* FormatString */);
                if (descriptor.formatting.alignment)
                    return ValueType.fromExtendedType(20058113 /* Alignment */);
                if (descriptor.formatting.labelDisplayUnits)
                    return ValueType.fromExtendedType(20123649 /* LabelDisplayUnits */);
                if (descriptor.formatting.fontFamily)
                    return ValueType.fromExtendedType(20385793 /* FontFamily */);
                if (descriptor.formatting.fontSize)
                    return ValueType.fromExtendedType(20189443 /* FontSize */);
                if (descriptor.formatting.labelDensity)
                    return ValueType.fromExtendedType(20254979 /* LabelDensity */);
                if (descriptor.formatting.bubbleSize)
                    return ValueType.fromExtendedType(20320515 /* BubbleSize */);
                if (descriptor.formatting.altText)
                    return ValueType.fromExtendedType(20451329 /* AltText */);
            }
            if (descriptor.extendedType) {
                return ValueType.fromExtendedType(descriptor.extendedType);
            }
            if (descriptor.operations) {
                if (descriptor.operations.searchEnabled)
                    return ValueType.fromExtendedType(65541 /* SearchEnabled */);
            }
            if (descriptor.reference) {
                if (descriptor.reference.bookmark)
                    return ValueType.fromExtendedType(39337985 /* BookmarkRef */);
            }
            if (descriptor.variant) {
                var variantTypes = _.map(descriptor.variant, (function (variantType) { return ValueType.fromDescriptor(variantType); }));
                return ValueType.fromVariant(variantTypes);
            }
            return ValueType.fromExtendedType(0 /* Null */);
        };
        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */
        ValueType.fromExtendedType = function (extendedType) {
            extendedType = extendedType || 0 /* Null */;
            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);
            debug.assert(primitiveType !== 0 /* Null */ || extendedType === 0 /* Null */, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');
            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);
        };
        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */
        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {
            primitiveType = primitiveType || 0 /* Null */;
            category = category || null;
            var id = primitiveType.toString();
            if (category)
                id += '|' + category;
            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));
        };
        /** Creates a ValueType to describe the given IEnumType. */
        ValueType.fromEnum = function (enumType) {
            debug.assertValue(enumType, 'enumType');
            return new ValueType(26214401 /* Enumeration */, null, enumType);
        };
        /** Creates a ValueType to describe the given Variant type. */
        ValueType.fromVariant = function (variantTypes) {
            debug.assertValue(variantTypes, 'variantTypes');
            return new ValueType(13 /* Variant */, /* category */ null, /* enumType */ null, variantTypes);
        };
        /**
         * Determines if the specified type is compatible from at least one of the otherTypes.
         * Note: non-integer numerics are only convertable into integer numerics if the strict flag is set to false.
         */
        ValueType.isCompatibleTo = function (type, otherTypes, strictNumeric) {
            debug.assertValue(type, 'type');
            debug.assertValue(otherTypes, 'otherTypes');
            var valueType = ValueType.fromDescriptor(type);
            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {
                var otherType = otherTypes_1[_i];
                var otherValueType = ValueType.fromDescriptor(otherType);
                if (otherValueType.isCompatibleFrom(valueType, strictNumeric))
                    return true;
            }
            return false;
        };
        /**
         * Determines if the instance ValueType is convertable from the 'other' ValueType.
         * Note: non-integer numerics are only convertable into integer numerics if the strict flag is set to false.
         */
        ValueType.prototype.isCompatibleFrom = function (other, strictNumeric) {
            debug.assertValue(other, 'other');
            if (this === other)
                return true;
            // If the 'other' value type is a variant type, all of its variation types need to be convertable into
            // the instance value type.
            if (other.variant) {
                for (var _i = 0, _a = other.variant; _i < _a.length; _i++) {
                    var otherType = _a[_i];
                    if (!this.isCompatibleFrom(otherType, strictNumeric))
                        return false;
                }
            }
            // If the instance value type is a variant type, return true if 'other' is convertable into
            // at least one of the variation types.
            if (this.variant) {
                for (var _b = 0, _c = this.variant; _b < _c.length; _b++) {
                    var variantType = _c[_b];
                    if (variantType.isCompatibleFrom(other, strictNumeric))
                        return true;
                }
            }
            var otherPrimitiveType = other.primitiveType;
            return this.primitiveType === otherPrimitiveType ||
                otherPrimitiveType === 0 /* Null */ ||
                // Return true if both types are numbers
                (this.numeric && other.numeric && (!strictNumeric || !this.integer || other.integer));
        };
        /**
         * Determines if the instance ValueType is equal to the 'other' ValueType
         * @param {ValueType} other the other ValueType to check equality against
         * @returns True if the instance ValueType is equal to the 'other' ValueType
         */
        ValueType.prototype.equals = function (other) {
            return _.isEqual(this, other);
        };
        Object.defineProperty(ValueType.prototype, "primitiveType", {
            /** Gets the exact primitive type of this ValueType. */
            get: function () {
                return getPrimitiveType(this.underlyingType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "extendedType", {
            /** Gets the exact extended type of this ValueType. */
            get: function () {
                return this.underlyingType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "categoryString", {
            /** Gets the data category string (if any) for this ValueType. */
            get: function () {
                return this.category;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "text", {
            // Simplified primitive types
            /** Indicates whether the type represents text values. */
            get: function () {
                return this.primitiveType === 1 /* Text */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "numeric", {
            /** Indicates whether the type represents any numeric value. */
            get: function () {
                return EnumExtensions.hasFlag(this.underlyingType, 256 /* Numeric */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "integer", {
            /** Indicates whether the type represents integer numeric values. */
            get: function () {
                return this.primitiveType === 4 /* Integer */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "bool", {
            /** Indicates whether the type represents Boolean values. */
            get: function () {
                return this.primitiveType === 5 /* Boolean */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "dateTime", {
            /** Indicates whether the type represents any date/time values. */
            get: function () {
                return this.primitiveType === 7 /* DateTime */ ||
                    this.primitiveType === 6 /* Date */ ||
                    this.primitiveType === 9 /* Time */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "duration", {
            /** Indicates whether the type represents duration values. */
            get: function () {
                return this.primitiveType === 10 /* Duration */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "binary", {
            /** Indicates whether the type represents binary values. */
            get: function () {
                return this.primitiveType === 11 /* Binary */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "none", {
            /** Indicates whether the type represents none values. */
            get: function () {
                return this.primitiveType === 12 /* None */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "temporal", {
            // Extended types
            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */
            get: function () {
                return this.temporalType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "geography", {
            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */
            get: function () {
                return this.geographyType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "misc", {
            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */
            get: function () {
                return this.miscType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "formatting", {
            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */
            get: function () {
                return this.formattingType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "enum", {
            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */
            get: function () {
                return this.enumType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "scripting", {
            get: function () {
                return this.scriptingType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "reference", {
            get: function () {
                return this.referenceType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "variant", {
            /** Returns an array describing the variant values represented by the type, if it represents an Variant type. */
            get: function () {
                return this.variationTypes;
            },
            enumerable: true,
            configurable: true
        });
        ValueType.typeCache = {};
        return ValueType;
    }());
    powerbi.ValueType = ValueType;
    var ScriptType = /** @class */ (function () {
        function ScriptType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, 8192 /* Scripting */), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(ScriptType.prototype, "source", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 32776193 /* ScriptSource */);
            },
            enumerable: true,
            configurable: true
        });
        return ScriptType;
    }());
    var TemporalType = /** @class */ (function () {
        function TemporalType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, 512 /* Temporal */), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(TemporalType.prototype, "year", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 66048 /* Years */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemporalType.prototype, "quarter", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 262656 /* Quarters */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemporalType.prototype, "month", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 131584 /* Months */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemporalType.prototype, "day", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 328192 /* DayOfMonth */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemporalType.prototype, "paddedDateTableDate", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 197127 /* PaddedDateTableDates */);
            },
            enumerable: true,
            configurable: true
        });
        return TemporalType;
    }());
    var GeographyType = /** @class */ (function () {
        function GeographyType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, 1024 /* Geography */), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(GeographyType.prototype, "address", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6554625 /* Address */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "city", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6620161 /* City */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "continent", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6685697 /* Continent */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "country", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6751233 /* Country */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "county", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6816769 /* County */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "region", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6882305 /* Region */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "postalCode", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 6947840 /* PostalCode */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "stateOrProvince", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 7013377 /* StateOrProvince */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "place", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 7078913 /* Place */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "latitude", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 7144448 /* Latitude */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "longitude", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 7209984 /* Longitude */);
            },
            enumerable: true,
            configurable: true
        });
        return GeographyType;
    }());
    var MiscellaneousType = /** @class */ (function () {
        function MiscellaneousType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, 2048 /* Miscellaneous */), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(MiscellaneousType.prototype, "image", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 13109259 /* Image */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "imageUrl", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 13174785 /* ImageUrl */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "webUrl", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 13240321 /* WebUrl */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "barcode", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 13305856 /* Barcode */);
            },
            enumerable: true,
            configurable: true
        });
        return MiscellaneousType;
    }());
    var ReferenceType = /** @class */ (function () {
        function ReferenceType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, 16384 /* Reference */), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(ReferenceType.prototype, "bookmark", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 39337985 /* BookmarkRef */);
            },
            enumerable: true,
            configurable: true
        });
        return ReferenceType;
    }());
    var FormattingType = /** @class */ (function () {
        function FormattingType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, 4096 /* Formatting */), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(FormattingType.prototype, "color", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 19664897 /* Color */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "formatString", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 19730433 /* FormatString */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "alignment", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20058113 /* Alignment */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "labelDisplayUnits", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20123649 /* LabelDisplayUnits */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "fontFamily", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20385793 /* FontFamily */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "fontSize", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20189443 /* FontSize */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "labelDensity", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20254979 /* LabelDensity */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "bubbleSize", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20320515 /* BubbleSize */);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "altText", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, 20451329 /* AltText */);
            },
            enumerable: true,
            configurable: true
        });
        return FormattingType;
    }());
    var PrimitiveTypeStrings;
    (function (PrimitiveTypeStrings) {
        PrimitiveTypeStrings[PrimitiveTypeStrings["Null"] = 0] = "Null";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Text"] = 1] = "Text";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Decimal"] = 2] = "Decimal";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Double"] = 3] = "Double";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Integer"] = 4] = "Integer";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Boolean"] = 5] = "Boolean";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Date"] = 6] = "Date";
        PrimitiveTypeStrings[PrimitiveTypeStrings["DateTime"] = 7] = "DateTime";
        PrimitiveTypeStrings[PrimitiveTypeStrings["DateTimeZone"] = 8] = "DateTimeZone";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Time"] = 9] = "Time";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Duration"] = 10] = "Duration";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Binary"] = 11] = "Binary";
        PrimitiveTypeStrings[PrimitiveTypeStrings["None"] = 12] = "None";
        PrimitiveTypeStrings[PrimitiveTypeStrings["Variant"] = 13] = "Variant";
    })(PrimitiveTypeStrings = powerbi.PrimitiveTypeStrings || (powerbi.PrimitiveTypeStrings = {}));
    var ExtendedTypeStrings;
    (function (ExtendedTypeStrings) {
        ExtendedTypeStrings[ExtendedTypeStrings["Numeric"] = 256] = "Numeric";
        ExtendedTypeStrings[ExtendedTypeStrings["Temporal"] = 512] = "Temporal";
        ExtendedTypeStrings[ExtendedTypeStrings["Geography"] = 1024] = "Geography";
        ExtendedTypeStrings[ExtendedTypeStrings["Miscellaneous"] = 2048] = "Miscellaneous";
        ExtendedTypeStrings[ExtendedTypeStrings["Formatting"] = 4096] = "Formatting";
        ExtendedTypeStrings[ExtendedTypeStrings["Scripting"] = 8192] = "Scripting";
        ExtendedTypeStrings[ExtendedTypeStrings["Null"] = 0] = "Null";
        ExtendedTypeStrings[ExtendedTypeStrings["Text"] = 1] = "Text";
        ExtendedTypeStrings[ExtendedTypeStrings["Decimal"] = 258] = "Decimal";
        ExtendedTypeStrings[ExtendedTypeStrings["Double"] = 259] = "Double";
        ExtendedTypeStrings[ExtendedTypeStrings["Integer"] = 260] = "Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["Boolean"] = 5] = "Boolean";
        ExtendedTypeStrings[ExtendedTypeStrings["Date"] = 518] = "Date";
        ExtendedTypeStrings[ExtendedTypeStrings["DateTime"] = 519] = "DateTime";
        ExtendedTypeStrings[ExtendedTypeStrings["DateTimeZone"] = 520] = "DateTimeZone";
        ExtendedTypeStrings[ExtendedTypeStrings["Time"] = 521] = "Time";
        ExtendedTypeStrings[ExtendedTypeStrings["Duration"] = 10] = "Duration";
        ExtendedTypeStrings[ExtendedTypeStrings["Binary"] = 11] = "Binary";
        ExtendedTypeStrings[ExtendedTypeStrings["None"] = 12] = "None";
        ExtendedTypeStrings[ExtendedTypeStrings["Variant"] = 13] = "Variant";
        ExtendedTypeStrings[ExtendedTypeStrings["Years"] = 66048] = "Years";
        ExtendedTypeStrings[ExtendedTypeStrings["Years_Text"] = 66049] = "Years_Text";
        ExtendedTypeStrings[ExtendedTypeStrings["Years_Integer"] = 66308] = "Years_Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["Years_Date"] = 66054] = "Years_Date";
        ExtendedTypeStrings[ExtendedTypeStrings["Years_DateTime"] = 66055] = "Years_DateTime";
        ExtendedTypeStrings[ExtendedTypeStrings["Months"] = 131584] = "Months";
        ExtendedTypeStrings[ExtendedTypeStrings["Months_Text"] = 131585] = "Months_Text";
        ExtendedTypeStrings[ExtendedTypeStrings["Months_Integer"] = 131844] = "Months_Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["Months_Date"] = 131590] = "Months_Date";
        ExtendedTypeStrings[ExtendedTypeStrings["Months_DateTime"] = 131591] = "Months_DateTime";
        ExtendedTypeStrings[ExtendedTypeStrings["PaddedDateTableDates"] = 197127] = "PaddedDateTableDates";
        ExtendedTypeStrings[ExtendedTypeStrings["Quarters"] = 262656] = "Quarters";
        ExtendedTypeStrings[ExtendedTypeStrings["Quarters_Text"] = 262657] = "Quarters_Text";
        ExtendedTypeStrings[ExtendedTypeStrings["Quarters_Integer"] = 262916] = "Quarters_Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["Quarters_Date"] = 262662] = "Quarters_Date";
        ExtendedTypeStrings[ExtendedTypeStrings["Quarters_DateTime"] = 262663] = "Quarters_DateTime";
        ExtendedTypeStrings[ExtendedTypeStrings["DayOfMonth"] = 328192] = "DayOfMonth";
        ExtendedTypeStrings[ExtendedTypeStrings["DayOfMonth_Text"] = 328193] = "DayOfMonth_Text";
        ExtendedTypeStrings[ExtendedTypeStrings["DayOfMonth_Integer"] = 328452] = "DayOfMonth_Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["DayOfMonth_Date"] = 328198] = "DayOfMonth_Date";
        ExtendedTypeStrings[ExtendedTypeStrings["DayOfMonth_DateTime"] = 328199] = "DayOfMonth_DateTime";
        ExtendedTypeStrings[ExtendedTypeStrings["Address"] = 6554625] = "Address";
        ExtendedTypeStrings[ExtendedTypeStrings["City"] = 6620161] = "City";
        ExtendedTypeStrings[ExtendedTypeStrings["Continent"] = 6685697] = "Continent";
        ExtendedTypeStrings[ExtendedTypeStrings["Country"] = 6751233] = "Country";
        ExtendedTypeStrings[ExtendedTypeStrings["County"] = 6816769] = "County";
        ExtendedTypeStrings[ExtendedTypeStrings["Region"] = 6882305] = "Region";
        ExtendedTypeStrings[ExtendedTypeStrings["PostalCode"] = 6947840] = "PostalCode";
        ExtendedTypeStrings[ExtendedTypeStrings["PostalCode_Text"] = 6947841] = "PostalCode_Text";
        ExtendedTypeStrings[ExtendedTypeStrings["PostalCode_Integer"] = 6948100] = "PostalCode_Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["StateOrProvince"] = 7013377] = "StateOrProvince";
        ExtendedTypeStrings[ExtendedTypeStrings["Place"] = 7078913] = "Place";
        ExtendedTypeStrings[ExtendedTypeStrings["Latitude"] = 7144448] = "Latitude";
        ExtendedTypeStrings[ExtendedTypeStrings["Latitude_Decimal"] = 7144706] = "Latitude_Decimal";
        ExtendedTypeStrings[ExtendedTypeStrings["Latitude_Double"] = 7144707] = "Latitude_Double";
        ExtendedTypeStrings[ExtendedTypeStrings["Longitude"] = 7209984] = "Longitude";
        ExtendedTypeStrings[ExtendedTypeStrings["Longitude_Decimal"] = 7210242] = "Longitude_Decimal";
        ExtendedTypeStrings[ExtendedTypeStrings["Longitude_Double"] = 7210243] = "Longitude_Double";
        ExtendedTypeStrings[ExtendedTypeStrings["Image"] = 13109259] = "Image";
        ExtendedTypeStrings[ExtendedTypeStrings["ImageUrl"] = 13174785] = "ImageUrl";
        ExtendedTypeStrings[ExtendedTypeStrings["WebUrl"] = 13240321] = "WebUrl";
        ExtendedTypeStrings[ExtendedTypeStrings["Barcode"] = 13305856] = "Barcode";
        ExtendedTypeStrings[ExtendedTypeStrings["Barcode_Text"] = 13305857] = "Barcode_Text";
        ExtendedTypeStrings[ExtendedTypeStrings["Barcode_Integer"] = 13306116] = "Barcode_Integer";
        ExtendedTypeStrings[ExtendedTypeStrings["Color"] = 19664897] = "Color";
        ExtendedTypeStrings[ExtendedTypeStrings["FormatString"] = 19730433] = "FormatString";
        ExtendedTypeStrings[ExtendedTypeStrings["Alignment"] = 20058113] = "Alignment";
        ExtendedTypeStrings[ExtendedTypeStrings["LabelDisplayUnits"] = 20123649] = "LabelDisplayUnits";
        ExtendedTypeStrings[ExtendedTypeStrings["FontFamily"] = 20385793] = "FontFamily";
        ExtendedTypeStrings[ExtendedTypeStrings["AltText"] = 20451329] = "AltText";
        ExtendedTypeStrings[ExtendedTypeStrings["FontSize"] = 20189443] = "FontSize";
        ExtendedTypeStrings[ExtendedTypeStrings["LabelDensity"] = 20254979] = "LabelDensity";
        ExtendedTypeStrings[ExtendedTypeStrings["BubbleSize"] = 20320515] = "BubbleSize";
        ExtendedTypeStrings[ExtendedTypeStrings["Enumeration"] = 26214401] = "Enumeration";
        ExtendedTypeStrings[ExtendedTypeStrings["ScriptSource"] = 32776193] = "ScriptSource";
        ExtendedTypeStrings[ExtendedTypeStrings["SearchEnabled"] = 65541] = "SearchEnabled";
        ExtendedTypeStrings[ExtendedTypeStrings["BookmarkRef"] = 39337985] = "BookmarkRef";
    })(ExtendedTypeStrings || (ExtendedTypeStrings = {}));
    var PrimitiveTypeMask = 0xFF;
    var PrimitiveTypeWithFlagsMask = 0xFFFF;
    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;
    function getPrimitiveType(extendedType) {
        return extendedType & PrimitiveTypeMask;
    }
    function isPrimitiveType(extendedType) {
        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;
    }
    function getCategoryFromExtendedType(extendedType) {
        if (isPrimitiveType(extendedType))
            return null;
        var category = ExtendedTypeStrings[extendedType];
        if (category) {
            // Check for ExtendedType declaration without a primitive type.
            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)
            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)
            var delimIdx = category.lastIndexOf('_');
            if (delimIdx > 0) {
                var baseCategory = category.slice(0, delimIdx);
                if (ExtendedTypeStrings[baseCategory]) {
                    debug.assert((ExtendedTypeStrings[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);
                    category = baseCategory;
                }
            }
        }
        return category || null;
    }
    function toExtendedType(primitiveType, category) {
        var primitiveString = PrimitiveTypeStrings[primitiveType];
        var t = ExtendedTypeStrings[primitiveString];
        if (t == null) {
            debug.assertFail('Unexpected primitiveType ' + primitiveType);
            t = 0 /* Null */;
        }
        if (primitiveType && category) {
            var categoryType = ExtendedTypeStrings[category];
            if (categoryType) {
                var categoryPrimitiveType = getPrimitiveType(categoryType);
                if (categoryPrimitiveType === 0 /* Null */) {
                    // Category supports multiple primitive types, check if requested primitive type is supported
                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)
                    categoryType = t | categoryType;
                    if (ExtendedTypeStrings[categoryType]) {
                        debug.assert(ExtendedTypeStrings[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);
                        t = categoryType;
                    }
                }
                else if (categoryPrimitiveType === primitiveType) {
                    // Primitive type matches the single supported type for the category
                    t = categoryType;
                }
            }
        }
        return t;
    }
    function matchesExtendedTypeWithAnyPrimitive(a, b) {
        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataShapeBindingdataReductionPlotAxisTransform;
        (function (DataShapeBindingdataReductionPlotAxisTransform) {
            DataShapeBindingdataReductionPlotAxisTransform[DataShapeBindingdataReductionPlotAxisTransform["None"] = 0] = "None";
            DataShapeBindingdataReductionPlotAxisTransform[DataShapeBindingdataReductionPlotAxisTransform["Log"] = 1] = "Log";
        })(DataShapeBindingdataReductionPlotAxisTransform = data.DataShapeBindingdataReductionPlotAxisTransform || (data.DataShapeBindingdataReductionPlotAxisTransform = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataShapeBindingDataReduction;
        (function (DataShapeBindingDataReduction) {
            function createFrom(reduction, selects) {
                if (!reduction)
                    return;
                var result;
                if (reduction.top) {
                    result = {
                        Top: {}
                    };
                    if (reduction.top.count)
                        result.Top.Count = reduction.top.count;
                }
                if (reduction.bottom) {
                    result = {
                        Bottom: {}
                    };
                    if (reduction.bottom.count)
                        result.Bottom.Count = reduction.bottom.count;
                }
                if (reduction.sample) {
                    result = {
                        Sample: {}
                    };
                    if (reduction.sample.count)
                        result.Sample.Count = reduction.sample.count;
                }
                if (reduction.window) {
                    result = {
                        Window: {}
                    };
                    if (reduction.window.count)
                        result.Window.Count = reduction.window.count;
                }
                if (reduction.binnedLineSample) {
                    result = {
                        BinnedLineSample: {}
                    };
                    if (reduction.binnedLineSample.primaryScalarKey != null)
                        result.BinnedLineSample.PrimaryScalarKey = reduction.binnedLineSample.primaryScalarKey;
                }
                if (reduction.overlappingPointsSample) {
                    var overlappingPointsSample = reduction.overlappingPointsSample;
                    result = {
                        OverlappingPointsSample: {}
                    };
                    if (overlappingPointsSample.count) {
                        result.OverlappingPointsSample.Count = overlappingPointsSample.count;
                    }
                    var compiledX = overlappingPointsSample.x;
                    if (compiledX && _.size(compiledX.role.items) === 1)
                        result.OverlappingPointsSample.X = getReductionAxisBinding(selects, compiledX.role.items[0].queryName, compiledX.transform);
                    var compiledY = overlappingPointsSample.y;
                    if (compiledY && _.size(compiledY.role.items) === 1)
                        result.OverlappingPointsSample.Y = getReductionAxisBinding(selects, compiledY.role.items[0].queryName, compiledY.transform);
                }
                return result;
            }
            DataShapeBindingDataReduction.createFrom = createFrom;
            function getReductionAxisBinding(selects, axisQueryName, transform) {
                var plotAxisBinding = { Index: _.findIndex(selects, (function (select) { return select.name === axisQueryName; })) };
                if (transform && transform === 1 /* Log */)
                    plotAxisBinding.Transform = data.DataShapeBindingdataReductionPlotAxisTransform.Log;
                return plotAxisBinding;
            }
        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Represents a federated conceptual schema. */
        var FederatedConceptualSchema = /** @class */ (function () {
            function FederatedConceptualSchema(options) {
                debug.assertValue(options, 'options');
                this.schemasByName = options.schemas;
                if (options.links)
                    this.links = options.links;
            }
            FederatedConceptualSchema.merge = function (federatedSchemas) {
                if (federatedSchemas.length === 1)
                    return federatedSchemas[0];
                var combinedSchemas = {};
                var combinedLinks = [];
                for (var _i = 0, federatedSchemas_1 = federatedSchemas; _i < federatedSchemas_1.length; _i++) {
                    var federatedSchema = federatedSchemas_1[_i];
                    for (var conceptualSchemaName in federatedSchema.schemasByName) {
                        debug.assert(!combinedSchemas[conceptualSchemaName], "Duplicate schema name " + conceptualSchemaName + " found while merging");
                        combinedSchemas[conceptualSchemaName] = federatedSchema.schemasByName[conceptualSchemaName];
                    }
                    combinedLinks.push.apply(combinedLinks, federatedSchema.links);
                }
                for (var schemaName in combinedSchemas) {
                    var schema = combinedSchemas[schemaName];
                    if (schema.isExtensionSchema) {
                        var base = combinedSchemas[schema.extends];
                        debug.assert(!base.isExtensionSchema, 'Extension schemas cannot themselves be extended');
                        FederatedConceptualSchema.mergeCapabilities(base, schema);
                    }
                }
                var options = {
                    schemas: combinedSchemas
                };
                if (_.any(combinedLinks))
                    options.links = combinedLinks;
                return new FederatedConceptualSchema(options);
            };
            Object.defineProperty(FederatedConceptualSchema.prototype, "schemas", {
                get: function () {
                    return _.values(this.schemasByName);
                },
                enumerable: true,
                configurable: true
            });
            FederatedConceptualSchema.prototype.schema = function (name) {
                return this.schemasByName[name];
            };
            FederatedConceptualSchema.mergeCapabilities = function (base, extension) {
                extension.capabilities = __assign({}, base.capabilities, { canEdit: extension.capabilities.canEdit, isExtendable: extension.capabilities.isExtendable });
            };
            return FederatedConceptualSchema;
        }());
        data.FederatedConceptualSchema = FederatedConceptualSchema;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data_1) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var Selector;
        (function (Selector) {
            function isScopeIdentity(data) {
                return data != null && data.kind === 1 /* ScopeIdentity */;
            }
            Selector.isScopeIdentity = isScopeIdentity;
            function isScopeWildcard(data) {
                return data != null && data.kind === 3 /* ScopeWildcard */;
            }
            Selector.isScopeWildcard = isScopeWildcard;
            function isScopeTotal(data) {
                return data != null && data.kind === 2 /* ScopeTotal */;
            }
            Selector.isScopeTotal = isScopeTotal;
            function isRoleWildcard(data) {
                return data != null && data.kind === 0 /* RoleWildcard */;
            }
            Selector.isRoleWildcard = isRoleWildcard;
            function isWildcard(data) {
                return data != null && data.kind === 4 /* Wildcard */;
            }
            Selector.isWildcard = isWildcard;
            function filterFromSelector(selectors, isNot) {
                if (_.isEmpty(selectors))
                    return;
                var exprs = filterExprsFromSelectors(selectors);
                if (!_.isEmpty(exprs))
                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);
            }
            Selector.filterFromSelector = filterFromSelector;
            function filterFromSelectorsByColumn(selectorsByColumn, isNot) {
                return filterFromSelector(_.map(selectorsByColumn, (function (selector) { return Selector.convertSelectorsByColumnToSelector(selector); })));
            }
            Selector.filterFromSelectorsByColumn = filterFromSelectorsByColumn;
            function filterExprsFromSelectors(selectors) {
                if (_.isEmpty(selectors))
                    return;
                var exprs = [];
                for (var i = 0, ilen = selectors.length; i < ilen; i++) {
                    var identity = selectors[i];
                    var data_2 = identity.data;
                    var exprToAdd = void 0;
                    if (data_2 && data_2.length) {
                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {
                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);
                        }
                    }
                    if (exprToAdd)
                        exprs.push(exprToAdd);
                }
                return exprs;
            }
            Selector.filterExprsFromSelectors = filterExprsFromSelectors;
            /**
             * Determines whether the Selector matches identities.
             * If the identity belongs to a subtotal, totalIdentityFields would contain the Identity Fields of the Total level
             * By design, subtotal item has the Identity of its parent, and doesn't have children
             * @param selector Selector to match against
             * @param identities Identities of the Node to match
             * @param totalIdentityFields Identities of the Total level, sent only if the data point is a Total
             */
            function matchesData(selector, identities, totalIdentityFields) {
                debug.assertValue(selector, 'selector');
                debug.assertValue(selector.data, 'selector.data');
                debug.assertValue(identities, 'identities');
                var selectorData = selector.data;
                var selectorDataLength = selectorData.length;
                /* If totalIdentityFields is passed, this means the identities are 1 item less than the selectorData
                 * As the Subtotal has the Identity of its parent, but appears on a level beneath it
                */
                var identityFieldsCount = identities.length;
                var isTotal = !_.isEmpty(totalIdentityFields);
                if (isTotal)
                    identityFieldsCount++;
                // if selectorData has a wildCard element, it must exist by its own
                if (selectorDataLength === 1 && isWildcard(selectorData[0]))
                    return data_1.DataViewWildcard.matches(selectorData[0], isTotal);
                // Non-Wildcard, identity fields count must match data items
                if (selectorDataLength !== identityFieldsCount)
                    return false;
                for (var i = 0, len = identities.length; i < len; i++) {
                    var dataItem = selector.data[i];
                    var identity = identities[i];
                    if (isRoleWildcard(dataItem)) {
                        debug.assertFail('Selector.matchesData: RoleWildCard should be converted to ScopeWildCards before matching');
                        return false;
                    }
                    else if (isScopeIdentity(dataItem)) {
                        if (!powerbi.DataViewScopeIdentity.equals(dataItem, identity))
                            return false;
                    }
                    else if (isScopeWildcard(dataItem)) {
                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identity))
                            return false;
                    }
                    else if (isScopeTotal(dataItem)) {
                        // If node is subtotal, ScopeTotal selector should appear at the end of the data array (outside the loop)
                        if (!_.isEmpty(totalIdentityFields))
                            debug.assertFail('Selector.matchesData: ScopeTotal should appear at the end of Selector.Data elements');
                        return false;
                    }
                    else {
                        // Invalid Selector or Wildcard
                        debug.assertFail('unexpected Selector data item kind: ' + dataItem.kind.toString());
                        return false;
                    }
                }
                // Naturally, ScopeTotal appears at the end of Selector.data
                if (!_.isEmpty(totalIdentityFields)) {
                    var dataItem = _.last(selectorData);
                    return isScopeTotal(dataItem) && data_1.DataViewScopeTotal.matches(dataItem, totalIdentityFields);
                }
                return true;
            }
            Selector.matchesData = matchesData;
            /**
             * Determines if the Selector matches the keys of the Identity in the same order
             * Does not check for Identity matching
             * Does not match empty identity
             */
            function matchesKeys(selector, keysList, partialMatch) {
                if (partialMatch === void 0) { partialMatch = false; }
                debug.assertValue(selector, 'selector');
                debug.assertValue(selector.data, 'selector.data');
                debug.assertValue(keysList, 'keysList');
                var selectorData = selector.data;
                var selectorDataLength = selectorData.length;
                // if selectorData has a wildCard element, it must exist by its own
                if (selectorDataLength === 1 && isWildcard(selectorData[0]))
                    return true;
                // flatten keyList and selectorKeys
                var flattenedIdentityKeys = _.flatten(keysList);
                var flattenedSelectorExprs = [];
                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {
                    var dataRepetitionItem = _a[_i];
                    var dataItemKeys = getDataRepetitionIdentityKeys(dataRepetitionItem);
                    if (!dataItemKeys)
                        return false;
                    flattenedSelectorExprs.push.apply(flattenedSelectorExprs, dataItemKeys);
                }
                var flattenedSelectorDataLength = flattenedSelectorExprs.length;
                // Matching keys should work against certain identity
                if (flattenedSelectorDataLength === 0 || flattenedIdentityKeys.length === 0)
                    return false;
                // For partial matching, the Selector can be part of the identity keys to match a non-leaf node in Matrix Hierarchy
                if (partialMatch && flattenedSelectorDataLength > flattenedIdentityKeys.length || !partialMatch && flattenedSelectorDataLength !== flattenedIdentityKeys.length)
                    return false;
                for (var i = 0; i < flattenedSelectorDataLength; i++) {
                    if (!data_1.SQExpr.equals(flattenedIdentityKeys[i], flattenedSelectorExprs[i]))
                        return false;
                }
                return true;
            }
            Selector.matchesKeys = matchesKeys;
            function getDataRepetitionIdentityKeys(dataItem) {
                if (isScopeIdentity(dataItem)) {
                    return data_1.ScopeIdentityExtractor.getKeys(dataItem.expr);
                }
                if (isScopeWildcard(dataItem)) {
                    return dataItem.exprs;
                }
                if (isScopeTotal(dataItem)) {
                    return dataItem.exprs;
                }
                if (isRoleWildcard(dataItem)) {
                    debug.assertFail('Selector.matchesData: RoleWildCard should be converted to ScopeWildCards before matching');
                    return;
                }
                debug.assertFail('Unexpected Selector data item kind: ' + dataItem.kind.toString());
            }
            /** Determines whether two selectors are equal. */
            function equals(x, y) {
                // Normalize falsy to null
                x = x || null;
                y = y || null;
                if (x === y)
                    return true;
                if (!x !== !y)
                    return false;
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                if (x.id !== y.id)
                    return false;
                if (x.metadata !== y.metadata)
                    return false;
                if (!equalsDataArray(x.data, y.data))
                    return false;
                return true;
            }
            Selector.equals = equals;
            function equalsDataArray(x, y) {
                // Normalize falsy to null
                x = x || null;
                y = y || null;
                if (x === y)
                    return true;
                if (!x !== !y)
                    return false;
                if (x.length !== y.length)
                    return false;
                for (var i = 0, len = x.length; i < len; i++) {
                    if (!equalsData(x[i], y[i]))
                        return false;
                }
                return true;
            }
            function equalsData(x, y) {
                if (isScopeIdentity(x) && isScopeIdentity(y))
                    return powerbi.DataViewScopeIdentity.equals(x, y);
                if (isScopeWildcard(x) && isScopeWildcard(y))
                    return data_1.DataViewScopeWildcard.equals(x, y);
                if (isScopeTotal(x) && isScopeTotal(y))
                    return data_1.DataViewScopeTotal.equals(x, y);
                if (isRoleWildcard(x) && isRoleWildcard(y))
                    return data_1.DataViewRoleWildcard.equals(x, y);
                if (isWildcard(x) && isWildcard(y))
                    return data_1.DataViewWildcard.equals(x, y);
                return false;
            }
            function getKey(selector) {
                var toStringify = {};
                if (selector.data) {
                    var data_3 = [];
                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {
                        data_3.push(selector.data[i].key);
                    }
                    toStringify.data = data_3;
                }
                if (selector.metadata)
                    toStringify.metadata = selector.metadata;
                if (selector.id)
                    toStringify.id = selector.id;
                return JSON.stringify(toStringify);
            }
            Selector.getKey = getKey;
            /**
             * Indicates whether the Selector can match more than one Scope
             */
            function containsWildcard(selector) {
                debug.assertValue(selector, 'selector');
                var dataItems = selector.data;
                if (!dataItems)
                    return false;
                return _.any(dataItems, (function (dataItem) {
                    return isRoleWildcard(dataItem) ||
                        isScopeWildcard(dataItem) ||
                        isWildcard(dataItem);
                }));
            }
            Selector.containsWildcard = containsWildcard;
            function hasRoleWildcard(selector) {
                debug.assertValue(selector, 'selector');
                var dataItems = selector.data;
                if (_.isEmpty(dataItems))
                    return false;
                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {
                    var dataItem = dataItems_1[_i];
                    if (isRoleWildcard(dataItem))
                        return true;
                }
                return false;
            }
            Selector.hasRoleWildcard = hasRoleWildcard;
            function convertSelectorsByColumnToSelector(selectorsByColumn) {
                if (!selectorsByColumn)
                    return undefined;
                var data = [];
                for (var key in selectorsByColumn.dataMap) {
                    var selectors = ArrayExtensions.ensureArray(selectorsByColumn.dataMap[key]);
                    for (var _i = 0, selectors_1 = selectors; _i < selectors_1.length; _i++) {
                        var selector_1 = selectors_1[_i];
                        data.push(selector_1);
                    }
                }
                var selector = {};
                if (data.length > 0) {
                    selector.data = data;
                }
                if (selectorsByColumn.metadata) {
                    selector.metadata = _.first(selectorsByColumn.metadata);
                }
                if (selectorsByColumn.id) {
                    selector.id = selectorsByColumn.id;
                }
                return selector;
            }
            Selector.convertSelectorsByColumnToSelector = convertSelectorsByColumnToSelector;
            function filterTransformSelectorsForSelection(dataItems) {
                debug.assertValue(dataItems, 'dataItems');
                return _.filter(dataItems, (function (dataViewScopeIdentity) { return !data_1.SQExprUtils.detectTransformExpr(dataViewScopeIdentity.expr); }));
            }
            Selector.filterTransformSelectorsForSelection = filterTransformSelectorsForSelection;
            /**
             * Normalize a series selector for property pane usage by removing the
             * metadata unless there is no dynamic series data to remove all non-series
             * information from the selector.
             */
            function normalizeSelector(selector) {
                debug.assertAnyValue(selector, 'selector');
                if (selector && selector.data)
                    return { data: selector.data };
                return selector;
            }
            Selector.normalizeSelector = normalizeSelector;
        })(Selector = data_1.Selector || (data_1.Selector = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var EntitySourceType;
        (function (EntitySourceType) {
            EntitySourceType[EntitySourceType["Table"] = 0] = "Table";
            EntitySourceType[EntitySourceType["Pod"] = 1] = "Pod";
            EntitySourceType[EntitySourceType["Expression"] = 2] = "Expression";
        })(EntitySourceType = data.EntitySourceType || (data.EntitySourceType = {}));
        function getArithmeticOperatorName(arithmeticOperatorKind) {
            switch (arithmeticOperatorKind) {
                case 0 /* Add */:
                    return "Add";
                case 1 /* Subtract */:
                    return "Subtract";
                case 2 /* Multiply */:
                    return "Multiply";
                case 3 /* Divide */:
                    return "Divide";
            }
            return powerbi.contract.fail('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);
        }
        data.getArithmeticOperatorName = getArithmeticOperatorName;
        function aggregateFunctionName(aggr) {
            switch (aggr) {
                case 0 /* Sum */:
                    return 'Sum';
                case 1 /* Avg */:
                    return 'Avg';
                case 2 /* Count */:
                    return 'Count';
                case 3 /* Min */:
                    return 'Min';
                case 4 /* Max */:
                    return 'Max';
                case 5 /* CountNonNull */:
                    return 'CountNonNull';
                case 6 /* Median */:
                    return 'Median';
                case 7 /* StandardDeviation */:
                    return 'StandardDeviation';
                case 8 /* Variance */:
                    return 'Variance';
                default:
                    debug.assert(aggr == null, 'Unrecognized aggregate function.');
                    break;
            }
        }
        data.aggregateFunctionName = aggregateFunctionName;
        var FilterKind;
        (function (FilterKind) {
            FilterKind[FilterKind["Default"] = 0] = "Default";
            FilterKind[FilterKind["Period"] = 1] = "Period";
        })(FilterKind = data.FilterKind || (data.FilterKind = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var QueryProjectionCollection = /** @class */ (function () {
            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {
                debug.assertValue(items, 'items');
                this.items = items;
                this._activeProjectionRefs = activeProjectionRefs;
                this._showAll = showAll;
            }
            /** Returns all projections in a mutable array. */
            QueryProjectionCollection.prototype.all = function () {
                return this.items;
            };
            Object.defineProperty(QueryProjectionCollection.prototype, "activeProjectionRefs", {
                get: function () {
                    return this._activeProjectionRefs;
                },
                set: function (queryReferences) {
                    if (!_.isEmpty(queryReferences)) {
                        var queryRefs = this.items.map((function (val) { return val.queryRef; }));
                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {
                            var queryReference = queryReferences_1[_i];
                            if (!_.contains(queryRefs, queryReference))
                                return;
                        }
                        this._activeProjectionRefs = queryReferences;
                    }
                    else {
                        this._activeProjectionRefs = undefined;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(QueryProjectionCollection.prototype, "showAll", {
                get: function () {
                    return this._showAll;
                },
                set: function (value) {
                    this._showAll = value;
                },
                enumerable: true,
                configurable: true
            });
            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {
                if (!this._activeProjectionRefs)
                    this._activeProjectionRefs = [queryRef];
                else
                    this._activeProjectionRefs.push(queryRef);
            };
            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {
                if (!_.isEmpty(this._activeProjectionRefs)) {
                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];
                }
            };
            /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */
            QueryProjectionCollection.prototype.replaceQueryRef = function (oldQueryRef, newQueryRef) {
                debug.assertValue(oldQueryRef, 'oldQueryRef');
                debug.assertValue(newQueryRef, 'newQueryRef');
                debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');
                debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');
                // Note: the same queryRef can get projected multiple times
                for (var _i = 0, _a = this.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.queryRef === oldQueryRef) {
                        item.queryRef = newQueryRef;
                    }
                }
            };
            QueryProjectionCollection.prototype.clone = function () {
                return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);
            };
            return QueryProjectionCollection;
        }());
        data.QueryProjectionCollection = QueryProjectionCollection;
        var QueryProjectionsByRole;
        (function (QueryProjectionsByRole) {
            /** Clones the QueryProjectionsByRole. */
            function clone(roles) {
                if (!roles)
                    return roles;
                var clonedRoles = {};
                for (var roleName in roles)
                    clonedRoles[roleName] = roles[roleName].clone();
                return clonedRoles;
            }
            QueryProjectionsByRole.clone = clone;
            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */
            function getRole(roles, name) {
                debug.assertAnyValue(roles, 'roles');
                debug.assertValue(name, 'name');
                if (!roles)
                    return;
                return roles[name];
            }
            QueryProjectionsByRole.getRole = getRole;
        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** The system used to determine display units used during formatting */
    var DisplayUnitSystemType;
    (function (DisplayUnitSystemType) {
        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */
        DisplayUnitSystemType[DisplayUnitSystemType["Default"] = 0] = "Default";
        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */
        DisplayUnitSystemType[DisplayUnitSystemType["Verbose"] = 1] = "Verbose";
        /**
         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).
         * Suitable for dashboard tile cards
         */
        DisplayUnitSystemType[DisplayUnitSystemType["WholeUnits"] = 2] = "WholeUnits";
        /**A display unit system that also contains Auto and None units for data labels*/
        DisplayUnitSystemType[DisplayUnitSystemType["DataLabels"] = 3] = "DataLabels";
    })(DisplayUnitSystemType = powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));
    var VisualElement;
    (function (VisualElement) {
        function getDataRolesFromVisualElements(visualElements) {
            debug.assertValue(visualElements, "visualElements shouldn't be empty");
            var dataRoles = [];
            for (var _i = 0, visualElements_1 = visualElements; _i < visualElements_1.length; _i++) {
                var visualElement = visualElements_1[_i];
                var _loop_1 = function (dataRole) {
                    // We erase the repeated ones to avoid a bug with the combo chart
                    // when opening it in infocus mode we have two labels appearing for each column.
                    // However, erasing the repeated ones can be considered a bug if the user wanted to have at least one projection multiple times.
                    // Because that case is odd this is fine for the moment.
                    if (!_.find(dataRoles, (function (role) { return _.isEqual(role, dataRole); }))) {
                        dataRoles.push(dataRole);
                    }
                };
                for (var _a = 0, _b = visualElement.DataRoles; _a < _b.length; _a++) {
                    var dataRole = _b[_a];
                    _loop_1(dataRole);
                }
            }
            return dataRoles;
        }
        VisualElement.getDataRolesFromVisualElements = getDataRolesFromVisualElements;
    })(VisualElement = powerbi.VisualElement || (powerbi.VisualElement = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** Repreasents the sequence of the dates/times */
    var DateTimeSequence = /** @class */ (function () {
        // Constructors
        /** Creates new instance of the DateTimeSequence */
        function DateTimeSequence(unit) {
            this.unit = unit;
            this.sequence = [];
            this.min = new Date("9999-12-31T23:59:59.999");
            this.max = new Date("0001-01-01T00:00:00.000");
        }
        // Methods
        /**
         * Add a new Date to a sequence.
         * @param date - date to add
         */
        DateTimeSequence.prototype.add = function (date) {
            if (date < this.min) {
                this.min = date;
            }
            if (date > this.max) {
                this.max = date;
            }
            this.sequence.push(date);
        };
        /**
         * Move the sequence to cover new date range
         * @param min - new min to be covered by sequence
         * @param max - new max to be covered by sequence
         */
        DateTimeSequence.prototype.moveToCover = function (min, max) {
            var delta = DateTimeSequence.getDelta(min, max, this.unit);
            var count = Math.floor(delta / this.interval);
            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);
            this.sequence = [];
            this.sequence.push(this.min);
            this.max = this.min;
            while (this.max < max) {
                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);
                this.sequence.push(this.max);
            }
        };
        // Static
        /**
         * Calculate a new DateTimeSequence
         * @param dataMin - Date representing min of the data range
         * @param dataMax - Date representing max of the data range
         * @param expectedCount - expected number of intervals in the sequence
         * @param unit - of the intervals in the sequence
         */
        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {
            if (!unit) {
                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);
            }
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Month:
                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Week:
                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Day:
                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Hour:
                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Minute:
                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Second:
                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Millisecond:
                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);
                default:
                    debug.assertFail("Unsupported DateTimeUnit");
            }
        };
        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "Expected count is out of range");
            // Calculate range and sequence
            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);
            // Calculate year sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);
            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;
            var date = new Date(newMinYear, 0, 1);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);
            return result;
        };
        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var minYear = dataMin.getFullYear();
            var maxYear = dataMax.getFullYear();
            var minMonth = dataMin.getMonth();
            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();
            var date = new Date(minYear, 0, 1);
            // Calculate month sequence
            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);
            return result;
        };
        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            var firstDayOfWeek = 0;
            var minDayOfWeek = dataMin.getDay();
            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;
            var minDay = dataMin.getDate() - dayOffset;
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));
            // Calculate week sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);
            return result;
        };
        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));
            // Calculate day sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);
            return result;
        };
        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));
            // Calculate hour sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);
            return result;
        };
        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);
            return result;
        };
        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);
            return result;
        };
        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());
            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);
            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);
            // Calculate milliseconds numeric sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);
            return result;
        };
        DateTimeSequence.addInterval = function (value, interval, unit) {
            interval = Math.round(interval);
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    return DateUtils.addYears(value, interval);
                case powerbi.DateTimeUnit.Month:
                    return DateUtils.addMonths(value, interval);
                case powerbi.DateTimeUnit.Week:
                    return DateUtils.addWeeks(value, interval);
                case powerbi.DateTimeUnit.Day:
                    return DateUtils.addDays(value, interval);
                case powerbi.DateTimeUnit.Hour:
                    return DateUtils.addHours(value, interval);
                case powerbi.DateTimeUnit.Minute:
                    return DateUtils.addMinutes(value, interval);
                case powerbi.DateTimeUnit.Second:
                    return DateUtils.addSeconds(value, interval);
                case powerbi.DateTimeUnit.Millisecond:
                    return DateUtils.addMilliseconds(value, interval);
            }
        };
        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {
            var result = new DateTimeSequence(unit);
            for (var _i = 0, _a = sequence.sequence; _i < _a.length; _i++) {
                var x = _a[_i];
                var d = DateTimeSequence.addInterval(date, x, unit);
                result.add(d);
            }
            result.interval = sequence.interval;
            result.intervalOffset = sequence.intervalOffset;
            return result;
        };
        DateTimeSequence.getDelta = function (min, max, unit) {
            var delta = 0;
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    delta = max.getFullYear() - min.getFullYear();
                    break;
                case powerbi.DateTimeUnit.Month:
                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();
                    break;
                case powerbi.DateTimeUnit.Week:
                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);
                    break;
                case powerbi.DateTimeUnit.Day:
                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);
                    break;
                case powerbi.DateTimeUnit.Hour:
                    delta = (max.getTime() - min.getTime()) / 3600000;
                    break;
                case powerbi.DateTimeUnit.Minute:
                    delta = (max.getTime() - min.getTime()) / 60000;
                    break;
                case powerbi.DateTimeUnit.Second:
                    delta = (max.getTime() - min.getTime()) / 1000;
                    break;
                case powerbi.DateTimeUnit.Millisecond:
                    delta = max.getTime() - min.getTime();
                    break;
            }
            return delta;
        };
        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {
            maxCount = Math.max(maxCount, 2);
            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);
            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)
                return powerbi.DateTimeUnit.Year;
            if (totalDays > 60 && totalDays > 7 * maxCount)
                return powerbi.DateTimeUnit.Month;
            if (totalDays > 14 && totalDays > 2 * maxCount)
                return powerbi.DateTimeUnit.Week;
            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);
            if (totalDays > 2 && totalHours > 12 * maxCount)
                return powerbi.DateTimeUnit.Day;
            if (totalHours >= 24 && totalHours >= maxCount)
                return powerbi.DateTimeUnit.Hour;
            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);
            if (totalMinutes > 2 && totalMinutes >= maxCount)
                return powerbi.DateTimeUnit.Minute;
            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);
            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)
                return powerbi.DateTimeUnit.Second;
            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);
            if (totalMilliseconds > 0)
                return powerbi.DateTimeUnit.Millisecond;
            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds
            var date = min;
            if (date.getMilliseconds() !== 0)
                return powerbi.DateTimeUnit.Millisecond;
            if (date.getSeconds() !== 0)
                return powerbi.DateTimeUnit.Second;
            if (date.getMinutes() !== 0)
                return powerbi.DateTimeUnit.Minute;
            if (date.getHours() !== 0)
                return powerbi.DateTimeUnit.Hour;
            if (date.getDate() !== 1)
                return powerbi.DateTimeUnit.Day;
            if (date.getMonth() !== 0)
                return powerbi.DateTimeUnit.Month;
            return powerbi.DateTimeUnit.Year;
        };
        // Constants
        DateTimeSequence.MIN_COUNT = 1;
        DateTimeSequence.MAX_COUNT = 1000;
        return DateTimeSequence;
    }());
    powerbi.DateTimeSequence = DateTimeSequence;
    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */
    var DateUtils;
    (function (DateUtils) {
        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        /**
         * Returns bool indicating weither the provided year is a leap year.
         * @param year - year value
         */
        function isLeap(year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        }
        /**
         * Returns number of days in the provided year/month.
         * @param year - year value
         * @param month - month value
         */
        function getMonthDays(year, month) {
            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];
        }
        /**
         * Adds a specified number of years to the provided date.
         * @param date - date value
         * @param yearDelta - number of years to add
         */
        function addYears(date, yearDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var isLeapDay = month === 2 && day === 29;
            var result = new Date(date.getTime());
            year = year + yearDelta;
            if (isLeapDay && !isLeap(year)) {
                day = 28;
            }
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addYears = addYears;
        /**
         * Adds a specified number of months to the provided date.
         * @param date - date value
         * @param monthDelta - number of months to add
         */
        function addMonths(date, monthDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            year += (monthDelta - (monthDelta % 12)) / 12;
            month += monthDelta % 12;
            // VSTS 1325771: Certain column charts don't display any data
            // Wrap arround the month if is after december (value 11)
            if (month > 11) {
                month = month % 12;
                year++;
            }
            day = Math.min(day, getMonthDays(year, month));
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addMonths = addMonths;
        /**
         * Adds a specified number of weeks to the provided date.
         * @param date - date value
         * @param weeks - number of weeks to add
         */
        function addWeeks(date, weeks) {
            return addDays(date, weeks * 7);
        }
        DateUtils.addWeeks = addWeeks;
        /**
         * Adds a specified number of days to the provided date.
         * @param date - date value
         * @param days - number of days to add
         */
        function addDays(date, days) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            result.setFullYear(year, month, day + days);
            return result;
        }
        DateUtils.addDays = addDays;
        /**
         * Adds a specified number of hours to the provided date.
         * @param date - date value
         * @param hours - number of hours to add
         */
        function addHours(date, hours) {
            return new Date(date.getTime() + hours * 3600000);
        }
        DateUtils.addHours = addHours;
        /**
         * Adds a specified number of minutes to the provided date.
         * @param date - date value
         * @param minutes - number of minutes to add
         */
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + minutes * 60000);
        }
        DateUtils.addMinutes = addMinutes;
        /**
         * Adds a specified number of seconds to the provided date.
         * @param date - date value
         * @param seconds - number of seconds to add
         */
        function addSeconds(date, seconds) {
            return new Date(date.getTime() + seconds * 1000);
        }
        DateUtils.addSeconds = addSeconds;
        /**
         * Adds a specified number of milliseconds to the provided date.
         * @param date - date value
         * @param milliseconds - number of milliseconds to add
         */
        function addMilliseconds(date, milliseconds) {
            return new Date(date.getTime() + milliseconds);
        }
        DateUtils.addMilliseconds = addMilliseconds;
    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    // Constants
    var maxExponent = 24;
    var defaultScientificBigNumbersBoundary = 1E15;
    var scientificSmallNumbersBoundary = 1E-4;
    var PERCENTAGE_FORMAT = '%';
    var SCIENTIFIC_FORMAT = 'E+0';
    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;
    // Regular expressions
    /**
     * This regex looks for strings that match one of the following conditions:
     *   - Optionally contain "0", "#", followed by a period, followed by at least one "0" or "#" (Ex. ###,000.###)
     *   - Contains at least one of "0", "#", or "," (Ex. ###,000)
     *   - Contain a "g" (indicates to use the general .NET numeric format string)
     * The entire string (start to end) must match, and the match is not case-sensitive.
     */
    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\#,]*\.[0\#]+|[0\#,]+|g)$/i;
    var DisplayUnit = /** @class */ (function () {
        function DisplayUnit() {
        }
        // Methods
        DisplayUnit.prototype.project = function (value) {
            if (this.value) {
                return powerbi.Double.removeDecimalNoise(value / this.value);
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.isApplicableTo = function (value) {
            value = Math.abs(value);
            var precision = powerbi.Double.getPrecision(value, 3);
            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);
        };
        DisplayUnit.prototype.isScaling = function () {
            return this.value > 1;
        };
        return DisplayUnit;
    }());
    powerbi.DisplayUnit = DisplayUnit;
    var DisplayUnitSystem = /** @class */ (function () {
        // Constructor
        function DisplayUnitSystem(units) {
            this.units = units ? units : [];
        }
        Object.defineProperty(DisplayUnitSystem.prototype, "title", {
            // Properties
            get: function () {
                return this.displayUnit ? this.displayUnit.title : undefined;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        DisplayUnitSystem.prototype.update = function (value) {
            if (value === undefined)
                return;
            this.unitBaseValue = value;
            this.displayUnit = this.findApplicableDisplayUnit(value);
        };
        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {
            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {
                var unit = _a[_i];
                if (unit.isApplicableTo(value))
                    return unit;
            }
            return undefined;
        };
        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {
            debug.assert(typeof (value) === "number", "value must be a number");
            decimals = this.getNumberOfDecimalsForFormatting(format, decimals);
            var nonScientificFormat = '';
            if (this.isFormatSupported(format) && !this.hasScientitifcFormat(format) && this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {
                value = this.displayUnit.project(value);
                nonScientificFormat = this.displayUnit.labelFormat;
            }
            return this.formatHelper(value, nonScientificFormat, format, decimals, trailingZeros);
        };
        DisplayUnitSystem.prototype.isFormatSupported = function (format) {
            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        };
        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {
            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;
        };
        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {
            return true;
        };
        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {
            return decimals;
        };
        DisplayUnitSystem.prototype.isScalingUnit = function () {
            return this.displayUnit && this.displayUnit.isScaling();
        };
        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {
            // If the format is "general" and we want to override the number of decimal places then use the default numeric format string.
            if ((format === 'g' || format === 'G') && decimals != null)
                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;
            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);
            if (format && !powerbi.formattingService.isStandardNumberFormat(format))
                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);
            if (!format)
                format = 'G';
            if (!nonScientificFormat)
                nonScientificFormat = '{0}';
            var text = powerbi.formattingService.formatValue(value, format);
            return powerbi.formattingService.format(nonScientificFormat, [text]);
        };
        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */
        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {
            // Change unit base to a value appropriate for this value
            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);
            return this.format(value, format, decimals, trailingZeros);
        };
        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {
            if (this.units.length === 0)
                return true;
            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).
            var applicableRangeMin = 0;
            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {
                var unit = _a[_i];
                if (unit.isScaling()) {
                    applicableRangeMin = unit.applicableRangeMin;
                    break;
                }
            }
            return Math.abs(value) < applicableRangeMin;
        };
        DisplayUnitSystem.prototype.isScientific = function (value) {
            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||
                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);
        };
        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {
            return format && format.toUpperCase().indexOf("E") !== -1;
        };
        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {
            if (format)
                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);
            return true;
        };
        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {
            return !this.hasScientitifcFormat(format)
                && this.supportsScientificFormat(format)
                && this.isScientific(value);
        };
        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {
            // Use scientific format outside of the range
            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {
                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);
                if (decimals)
                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);
                if (numericFormat)
                    return numericFormat + SCIENTIFIC_FORMAT;
                else
                    return DEFAULT_SCIENTIFIC_FORMAT;
            }
            return format;
        };
        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\d*)|(e\d*)$/i;
        return DisplayUnitSystem;
    }());
    powerbi.DisplayUnitSystem = DisplayUnitSystem;
    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */
    var NoDisplayUnitSystem = /** @class */ (function (_super) {
        __extends(NoDisplayUnitSystem, _super);
        // Constructor
        function NoDisplayUnitSystem() {
            return _super.call(this, []) || this;
        }
        return NoDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where
        we are showing values (chart axes) and as such it is the default unit system. */
    var DefaultDisplayUnitSystem = /** @class */ (function (_super) {
        __extends(DefaultDisplayUnitSystem, _super);
        // Constructor
        function DefaultDisplayUnitSystem(unitLookup) {
            return _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup)) || this;
        }
        // Methods
        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        DefaultDisplayUnitSystem.reset = function () {
            DefaultDisplayUnitSystem.units = null;
        };
        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DefaultDisplayUnitSystem.units) {
                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, (function (value, previousUnitValue, min) {
                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc
                    if (value - previousUnitValue >= 1000) {
                        return value / 10;
                    }
                    return min;
                }));
                // Ensure last unit has max of infinity
                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return DefaultDisplayUnitSystem.units;
        };
        return DefaultDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least
        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles
        where we have restricted space but do not want to show partial units. */
    var WholeUnitsDisplayUnitSystem = /** @class */ (function (_super) {
        __extends(WholeUnitsDisplayUnitSystem, _super);
        // Constructor
        function WholeUnitsDisplayUnitSystem(unitLookup) {
            return _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup)) || this;
        }
        WholeUnitsDisplayUnitSystem.reset = function () {
            WholeUnitsDisplayUnitSystem.units = null;
        };
        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!WholeUnitsDisplayUnitSystem.units) {
                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);
                // Ensure last unit has max of infinity
                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return WholeUnitsDisplayUnitSystem.units;
        };
        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        return WholeUnitsDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;
    var DataLabelsDisplayUnitSystem = /** @class */ (function (_super) {
        __extends(DataLabelsDisplayUnitSystem, _super);
        function DataLabelsDisplayUnitSystem(unitLookup) {
            return _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup)) || this;
        }
        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {
            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        };
        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DataLabelsDisplayUnitSystem.units) {
                var units = [];
                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {
                    // Never returns true, we are always ignoring
                    // We do not early switch (e.g. 100K instead of 0.1M)
                    // Intended? If so, remove this function, otherwise, remove if statement
                    if (value === -1)
                        if (value - previousUnitValue >= 1000) {
                            return value / 10;
                        }
                    return min;
                };
                // Add Auto & None
                var names = unitLookup(-1);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);
                names = unitLookup(0);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);
                // Add normal units
                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));
                // Ensure last unit has max of infinity
                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return DataLabelsDisplayUnitSystem.units;
        };
        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        // Constants
        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;
        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;
        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\d*)$/i;
        return DataLabelsDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;
    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {
        var units = [];
        for (var i = 3; i < maxExponent; i++) {
            var names = unitLookup(i);
            if (names)
                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);
        }
        return units;
    }
    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {
        if (title || labelFormat) {
            var min = value;
            if (units.length > 0) {
                var previousUnit = units[units.length - 1];
                if (adjustMinBasedOnPreviousUnit)
                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);
                previousUnit.applicableRangeMax = min;
            }
            var unit = new DisplayUnit();
            unit.value = value;
            unit.applicableRangeMin = min;
            unit.applicableRangeMax = min * 1000;
            unit.title = title;
            unit.labelFormat = labelFormat;
            units.push(unit);
        }
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequence = /** @class */ (function () {
        function NumericSequence() {
        }
        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {
            debug.assertValue(range, "range");
            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), "expectedCount");
            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), "minPower");
            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), "maxAllowedMargin");
            var result = new NumericSequence();
            if (expectedCount === undefined)
                expectedCount = 10;
            else
                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (minPower === undefined)
                minPower = powerbi.Double.MIN_EXP;
            if (useZeroRefPoint === undefined)
                useZeroRefPoint = false;
            if (maxAllowedMargin === undefined)
                maxAllowedMargin = 1;
            if (steps === undefined)
                steps = [1, 2, 5];
            // Handle single stop case
            if (range.forcedSingleStop) {
                result.interval = range.getSize();
                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);
                result.min = range.min;
                result.max = range.max;
                result.sequence = [range.forcedSingleStop];
                return result;
            }
            var interval = 0;
            var min = 0;
            var max = 9;
            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;
            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;
            var size = range.getSize();
            var exp = powerbi.Double.log10(size);
            // Account for Exp of steps
            var stepExp = powerbi.Double.log10(steps[0]);
            exp = exp - stepExp;
            // Account for MaxCount
            var expectedCountExp = powerbi.Double.log10(expectedCount);
            exp = exp - expectedCountExp;
            // Account for MinPower
            exp = Math.max(exp, minPower - stepExp + 1);
            var count;
            // Create array of "good looking" numbers
            if (interval !== 0) {
                // If explicit interval is defined - use it instead of the steps array.
                var power = powerbi.Double.pow10(exp);
                var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);
                roundRange.shrinkByStep(range, interval);
                min = roundRange.min;
                max = roundRange.max;
                count = Math.floor(roundRange.getSize() / interval);
            }
            else {
                // No interval defined -> find optimal interval
                var dexp = void 0;
                for (dexp = 0; dexp < 3; dexp++) {
                    var e = exp + dexp;
                    var power = powerbi.Double.pow10(e);
                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                    // Go throught the steps array looking for the smallest step that produces the right interval count.
                    var stepsCount = steps.length;
                    var stepPower = powerbi.Double.pow10(e - 1);
                    for (var i = 0; i < stepsCount; i++) {
                        var step = steps[i] * stepPower;
                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);
                        roundRange.shrinkByStep(range, step);
                        // If the range is based on Data we might need to extend it to provide nice data margins.
                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)
                            roundRange.min -= step;
                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)
                            roundRange.max += step;
                        // Count the intervals
                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step, powerbi.Double.DEFAULT_PRECISION);
                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {
                            interval = step;
                            min = roundRange.min;
                            max = roundRange.max;
                            break;
                        }
                    }
                    // Increase the scale power until the interval is found
                    if (interval !== 0)
                        break;
                }
            }
            // Avoid extreme count cases (>1000 ticks)
            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {
                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);
                interval = (max - min) / count;
            }
            result.min = min;
            result.max = max;
            result.interval = interval;
            result.intervalOffset = min - range.min;
            result.maxAllowedMargin = maxAllowedMargin;
            result.canExtendMin = canExtendMin;
            result.canExtendMax = canExtendMax;
            // Fill in the Sequence
            var precision = powerbi.Double.getPrecision(interval, 0);
            result.precision = precision;
            var sequence = [];
            var x = powerbi.Double.roundToPrecision(min, precision);
            sequence.push(x);
            for (var i = 0; i < count; i++) {
                x = powerbi.Double.roundToPrecision(x + interval, precision);
                sequence.push(x);
            }
            result.sequence = sequence;
            result.trimMinMax(range.min, range.max);
            return result;
        };
        /**
         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.
         * @min - The minimum of the range.
         * @max - The maximum of the range.
         * @maxCount - The max count of intervals.
         * @steps - array of intervals.
         */
        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {
            // Initialization actions
            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (min === max) {
                max = min + 1;
            }
            var stepCount = 0;
            var step = 0;
            // Calculate step
            for (var i = 0; i < steps.length; i++) {
                step = steps[i];
                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);
                var minStepCount = powerbi.Double.floorWithPrecision(min / step);
                stepCount = maxStepCount - minStepCount;
                if (stepCount <= maxCount) {
                    break;
                }
            }
            // Calculate the offset
            var offset = -min;
            offset = offset % step;
            // Create sequence
            var result = new NumericSequence();
            result.sequence = [];
            for (var x = min + offset;; x += step) {
                result.sequence.push(x);
                if (x >= max)
                    break;
            }
            result.interval = step;
            result.intervalOffset = offset;
            result.min = result.sequence[0];
            result.max = result.sequence[result.sequence.length - 1];
            return result;
        };
        NumericSequence.prototype.trimMinMax = function (min, max) {
            var minMargin = (min - this.min) / this.interval;
            var maxMargin = (this.max - max) / this.interval;
            var marginPrecision = 0.001;
            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {
                this.min = min;
            }
            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {
                this.max = max;
            }
        };
        NumericSequence.MIN_COUNT = 1;
        NumericSequence.MAX_COUNT = 1000;
        return NumericSequence;
    }());
    powerbi.NumericSequence = NumericSequence;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequenceRange = /** @class */ (function () {
        function NumericSequenceRange() {
        }
        NumericSequenceRange.prototype._ensureIncludeZero = function () {
            if (this.includeZero) {
                // fixed min and max has higher priority than includeZero
                if (this.min > 0 && !this.hasFixedMin) {
                    this.min = 0;
                }
                if (this.max < 0 && !this.hasFixedMax) {
                    this.max = 0;
                }
            }
        };
        NumericSequenceRange.prototype._ensureNotEmpty = function () {
            if (this.min === this.max) {
                if (!this.min) {
                    this.min = 0;
                    this.max = NumericSequenceRange.DEFAULT_MAX;
                    this.hasFixedMin = true;
                    this.hasFixedMax = true;
                }
                else {
                    // We are dealing with a single data value (includeZero is not set)
                    // In order to fix the range we need to extend it in both directions by half of the interval.
                    // Interval is calculated based on the number:
                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006
                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.
                    var value = this.min;
                    var exp = powerbi.Double.log10(Math.abs(value));
                    var step = void 0;
                    if (exp >= 0 && exp < 4) {
                        step = 0.5;
                        this.forcedSingleStop = value;
                    }
                    else {
                        step = powerbi.Double.pow10(exp) / 2;
                        this.forcedSingleStop = null;
                    }
                    this.min = value - step;
                    this.max = value + step;
                }
            }
        };
        NumericSequenceRange.prototype._ensureDirection = function () {
            if (this.min > this.max) {
                var temp = this.min;
                this.min = this.max;
                this.max = temp;
            }
        };
        NumericSequenceRange.prototype.getSize = function () {
            return this.max - this.min;
        };
        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {
            debug.assertValue(range, "range");
            debug.assert(step > 0, "step");
            var oldCount = this.min / step;
            var newCount = range.min / step;
            var deltaCount = Math.floor(newCount - oldCount);
            this.min += deltaCount * step;
            oldCount = this.max / step;
            newCount = range.max / step;
            deltaCount = Math.ceil(newCount - oldCount);
            this.max += deltaCount * step;
        };
        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {
            debug.assert(dataMin <= dataMax, "dataMin should be less or equal to dataMax.");
            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, "fixedMin should be less or equal to fixedMax.");
            var result = new NumericSequenceRange();
            result.includeZero = includeZero ? true : false;
            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);
            result.hasFixedMin = ValueUtil.hasValue(fixedMin);
            result.hasFixedMax = ValueUtil.hasValue(fixedMax);
            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            // Calculate the range using the min, max, dataRange
            if (result.hasFixedMin && result.hasFixedMax) {
                result.min = fixedMin;
                result.max = fixedMax;
            }
            else if (result.hasFixedMin) {
                result.min = fixedMin;
                result.max = dataMax > fixedMin ? dataMax : fixedMin;
            }
            else if (result.hasFixedMax) {
                result.min = dataMin < fixedMax ? dataMin : fixedMax;
                result.max = fixedMax;
            }
            else if (result.hasDataRange) {
                result.min = dataMin;
                result.max = dataMax;
            }
            else {
                result.min = 0;
                result.max = 0;
            }
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            if (result.min === 0) {
                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range
            }
            else if (result.max === 0) {
                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range
            }
            return result;
        };
        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {
            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {
                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);
            }
            else {
                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);
            }
        };
        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {
            debug.assertValue(fixedMin, "fixedMin");
            debug.assertValue(fixedMax, "fixedMax");
            var result = new NumericSequenceRange();
            result.hasDataRange = false;
            result.includeZero = includeZero;
            result.min = fixedMin;
            result.max = fixedMax;
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            result.hasFixedMin = true;
            result.hasFixedMax = true;
            return result;
        };
        NumericSequenceRange.DEFAULT_MAX = 10;
        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;
        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;
        return NumericSequenceRange;
    }());
    powerbi.NumericSequenceRange = NumericSequenceRange;
    /** Note: Exported for testability */
    var ValueUtil;
    (function (ValueUtil) {
        function hasValue(value) {
            return value !== undefined && value !== null;
        }
        ValueUtil.hasValue = hasValue;
    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var RelativeDateQualifier;
        (function (RelativeDateQualifier) {
            RelativeDateQualifier[RelativeDateQualifier["Last"] = 0] = "Last";
            RelativeDateQualifier[RelativeDateQualifier["Current"] = 1] = "Current";
            RelativeDateQualifier[RelativeDateQualifier["Next"] = 2] = "Next";
        })(RelativeDateQualifier = data.RelativeDateQualifier || (data.RelativeDateQualifier = {}));
        var RelativeDateUnit;
        (function (RelativeDateUnit) {
            RelativeDateUnit[RelativeDateUnit["Day"] = 0] = "Day";
            RelativeDateUnit[RelativeDateUnit["Week"] = 1] = "Week";
            RelativeDateUnit[RelativeDateUnit["CalendarWeek"] = 2] = "CalendarWeek";
            RelativeDateUnit[RelativeDateUnit["Month"] = 3] = "Month";
            RelativeDateUnit[RelativeDateUnit["CalendarMonth"] = 4] = "CalendarMonth";
            RelativeDateUnit[RelativeDateUnit["Year"] = 5] = "Year";
            RelativeDateUnit[RelativeDateUnit["CalendarYear"] = 6] = "CalendarYear";
        })(RelativeDateUnit = data.RelativeDateUnit || (data.RelativeDateUnit = {}));
        var RelativeDateRangeHelper;
        (function (RelativeDateRangeHelper) {
            function getDateRange(date, options) {
                switch (options.relativeUnit) {
                    case RelativeDateUnit.Day:
                        return getDaysRange(date, options);
                    case RelativeDateUnit.Week:
                        return getWeeksRange(date, options);
                    case RelativeDateUnit.CalendarWeek:
                        return getCalendarWeekRange(date, options);
                    case RelativeDateUnit.Month:
                        return getMonthRange(date, options);
                    case RelativeDateUnit.CalendarMonth:
                        return getCalendarMonthRange(date, options);
                    case RelativeDateUnit.Year:
                        return getYearRange(date, options);
                    case RelativeDateUnit.CalendarYear:
                        return getCalendarYearRange(date, options);
                    default:
                        debug.assertFail("Unexpected RelativeDateUnit: " + options.relativeUnit);
                        return;
                }
            }
            RelativeDateRangeHelper.getDateRange = getDateRange;
            function getDaysRange(date, options) {
                var result = { min: null, max: null };
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        result.max = options.includeToday ? date : addDays(date, -1);
                        result.min = addDays(result.max, -options.duration + 1);
                        break;
                    case RelativeDateQualifier.Current:
                        result.min = date;
                        result.max = date;
                        break;
                    case RelativeDateQualifier.Next:
                        result.min = options.includeToday ? date : addDays(date, 1);
                        result.max = addDays(result.min, options.duration - 1);
                        break;
                }
                return result;
            }
            // For weeks or months, adding or subtracting weeks or months takes you to same day next/previous week/month. Minimum unit of filtering right now is Day and
            // since we start not with current hour but current day, we do not want to be on the same day next/previous week/month but rather one day before or after the 
            // same day next/previous week/month. We offset our date range calculations by 1 to account for this. 
            function getWeeksRange(date, options) {
                var result = { min: null, max: null };
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        result.max = options.includeToday ? date : addDays(date, -1);
                        result.min = addDays(result.max, -(options.duration * 7) + 1);
                        break;
                    case RelativeDateQualifier.Current:
                        result = getCalendarWeek(date);
                        break;
                    case RelativeDateQualifier.Next:
                        result.min = options.includeToday ? date : addDays(date, 1);
                        result.max = addDays(result.min, (options.duration * 7) - 1);
                        break;
                }
                return result;
            }
            function getCalendarWeekRange(date, options) {
                var result = { min: null, max: null };
                var dayOfWeek = date.getDay();
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        var lastDayOfLastWeek = addDays(date, -dayOfWeek - 1);
                        result.min = addDays(lastDayOfLastWeek, -(options.duration * 7) + 1);
                        result.max = lastDayOfLastWeek;
                        break;
                    case RelativeDateQualifier.Current:
                        result = getCalendarWeek(date);
                        break;
                    case RelativeDateQualifier.Next:
                        var firstDayOfNextWeek = addDays(date, 7 - dayOfWeek);
                        result.min = firstDayOfNextWeek;
                        result.max = addDays(firstDayOfNextWeek, (options.duration * 7) - 1);
                        break;
                }
                return result;
            }
            function getMonthRange(date, options) {
                var result = { min: null, max: null };
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        result.max = options.includeToday ? date : addDays(date, -1);
                        result.min = addMonths(result.max, -options.duration);
                        break;
                    case RelativeDateQualifier.Current:
                        result = getCalendarMonth(date);
                        break;
                    case RelativeDateQualifier.Next:
                        result.min = options.includeToday ? date : addDays(date, 1);
                        result.max = addMonths(result.min, options.duration);
                        break;
                }
                return result;
            }
            function getCalendarMonthRange(date, options) {
                var result = { min: null, max: null };
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        result.min = new Date(date.getFullYear(), date.getMonth() - options.duration, 1);
                        result.max = new Date(date.getFullYear(), date.getMonth(), 0);
                        break;
                    case RelativeDateQualifier.Current:
                        result = getCalendarMonth(date);
                        break;
                    case RelativeDateQualifier.Next:
                        result.min = new Date(date.getFullYear(), date.getMonth() + 1, 1);
                        result.max = new Date(date.getFullYear(), date.getMonth() + 1 + options.duration, 0);
                        break;
                }
                return result;
            }
            function getYearRange(date, options) {
                var result = { min: null, max: null };
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        result.max = options.includeToday ? date : addDays(date, -1);
                        result.min = addYears(result.max, -options.duration);
                        break;
                    case RelativeDateQualifier.Current:
                        result = getCalendarYear(date);
                        break;
                    case RelativeDateQualifier.Next:
                        result.min = options.includeToday ? date : addDays(date, 1);
                        result.max = addYears(result.min, options.duration);
                        break;
                }
                return result;
            }
            function getCalendarYearRange(date, options) {
                var result = { min: null, max: null };
                switch (options.relativeQualifier) {
                    case RelativeDateQualifier.Last:
                        result.min = new Date(date.getFullYear() - options.duration, 0, 1);
                        result.max = new Date(date.getFullYear() - 1, 11, 31);
                        break;
                    case RelativeDateQualifier.Current:
                        result = getCalendarYear(date);
                        break;
                    case RelativeDateQualifier.Next:
                        result.min = new Date(date.getFullYear() + 1, 0, 1);
                        result.max = new Date(date.getFullYear() + options.duration, 11, 31);
                        break;
                }
                return result;
            }
            function getDateRangeRestatement(range) {
                return powerbi.formattingService.format("{0:d} - {1:d}", [range.min, range.max]);
            }
            RelativeDateRangeHelper.getDateRangeRestatement = getDateRangeRestatement;
            function getRestatement(options) {
                // The SQ Now converts current datetime to UTC so we need to use the same logic in restatement
                var now = new Date();
                var nowInUTC = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
                var range = getDateRange(nowInUTC, options);
                return getDateRangeRestatement(range);
            }
            RelativeDateRangeHelper.getRestatement = getRestatement;
            // Date math
            function addDays(date, days) {
                return new Date(date.getFullYear(), date.getMonth(), date.getDate() + days);
            }
            RelativeDateRangeHelper.addDays = addDays;
            function addMonths(date, months) {
                if (months === 0) {
                    return date;
                }
                var offset = months > 0 ? 1 : -1;
                var dayOfMonth = date.getDate() - offset;
                var result;
                result = new Date(date.getFullYear(), date.getMonth() + months, dayOfMonth);
                // We need to check the case of 29,30,31st of Feb, and 31st Apr, Jun, Sep, Nov
                if (result.getDate() !== dayOfMonth && dayOfMonth > 0) {
                    if (months > 0) {
                        // Next N months - if day overflows the month we need to lower it to last day of the month
                        result = new Date(date.getFullYear(), date.getMonth() + months + 1, 0);
                    }
                    else {
                        // Last N months - if day overflows the month we need to lower it to first day of the month
                        result = new Date(date.getFullYear(), date.getMonth() + months + 1, 1);
                    }
                }
                return result;
            }
            RelativeDateRangeHelper.addMonths = addMonths;
            function addYears(date, years) {
                return addMonths(date, years * 12);
            }
            RelativeDateRangeHelper.addYears = addYears;
            function getDurationMax(qualifier, unit) {
                if (qualifier === RelativeDateQualifier.Current) {
                    return 1;
                }
                switch (unit) {
                    case RelativeDateUnit.Year:
                    case RelativeDateUnit.CalendarYear:
                        return 100;
                    case RelativeDateUnit.Month:
                    case RelativeDateUnit.CalendarMonth:
                    case RelativeDateUnit.CalendarWeek:
                    case RelativeDateUnit.Week:
                        return 1000;
                    default:
                    case RelativeDateUnit.Day:
                        return 10000;
                }
            }
            RelativeDateRangeHelper.getDurationMax = getDurationMax;
            // Calendar helpers
            function getCalendarWeek(date) {
                var dayOfWeek = date.getDay();
                var firstDayOfWeek = addDays(date, -dayOfWeek);
                return {
                    min: firstDayOfWeek,
                    max: addDays(firstDayOfWeek, 6)
                };
            }
            function getCalendarMonth(date) {
                return {
                    min: new Date(date.getFullYear(), date.getMonth(), 1),
                    max: new Date(date.getFullYear(), date.getMonth() + 1, 0),
                };
            }
            function getCalendarYear(date) {
                return {
                    min: new Date(date.getFullYear(), 0, 1),
                    max: new Date(date.getFullYear(), 11, 31),
                };
            }
        })(RelativeDateRangeHelper = data.RelativeDateRangeHelper || (data.RelativeDateRangeHelper = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var valueFormatter;
        (function (valueFormatter) {
            var StringExtensions = jsCommon.StringExtensions;
            var BeautifiedFormat = {
                '0.00 %;-0.00 %;0.00 %': 'Percentage',
                '0.0 %;-0.0 %;0.0 %': 'Percentage1',
            };
            valueFormatter.DefaultIntegerFormat = 'g';
            valueFormatter.DefaultNumericFormat = '#,0.00';
            valueFormatter.DefaultDateFormat = 'd';
            var defaultLocalizedStrings = {
                'NullValue': '(Blank)',
                'BooleanTrue': 'True',
                'BooleanFalse': 'False',
                'NaNValue': 'NaN',
                'InfinityValue': '+Infinity',
                'NegativeInfinityValue': '-Infinity',
                'RestatementComma': '{0}, {1}',
                'RestatementCompoundAnd': '{0} and {1}',
                'RestatementCompoundOr': '{0} or {1}',
                'DisplayUnitSystem_EAuto_Title': 'Auto',
                'DisplayUnitSystem_E0_Title': 'None',
                'DisplayUnitSystem_E3_LabelFormat': '{0}K',
                'DisplayUnitSystem_E3_Title': 'Thousands',
                'DisplayUnitSystem_E6_LabelFormat': '{0}M',
                'DisplayUnitSystem_E6_Title': 'Millions',
                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
                'DisplayUnitSystem_E9_Title': 'Billions',
                'DisplayUnitSystem_E12_LabelFormat': '{0}T',
                'DisplayUnitSystem_E12_Title': 'Trillions',
                'Percentage': '#,0.##%',
                'Percentage1': '#,0.#%',
                'TableTotalLabel': 'Total',
                'Tooltip_HighlightedValueDisplayName': 'Highlighted',
                'Funnel_PercentOfFirst': 'Percent of first',
                'Funnel_PercentOfPrevious': 'Percent of previous',
                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',
                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',
                // Geotagging strings
                'GeotaggingString_Continent': 'continent',
                'GeotaggingString_Continents': 'continents',
                'GeotaggingString_Country': 'country',
                'GeotaggingString_Countries': 'countries',
                'GeotaggingString_State': 'state',
                'GeotaggingString_States': 'states',
                'GeotaggingString_City': 'city',
                'GeotaggingString_Cities': 'cities',
                'GeotaggingString_Town': 'town',
                'GeotaggingString_Towns': 'towns',
                'GeotaggingString_Province': 'province',
                'GeotaggingString_Provinces': 'provinces',
                'GeotaggingString_County': 'county',
                'GeotaggingString_Counties': 'counties',
                'GeotaggingString_Village': 'village',
                'GeotaggingString_Villages': 'villages',
                'GeotaggingString_Post': 'post',
                'GeotaggingString_Zip': 'zip',
                'GeotaggingString_Code': 'code',
                'GeotaggingString_Place': 'place',
                'GeotaggingString_Places': 'places',
                'GeotaggingString_Address': 'address',
                'GeotaggingString_Addresses': 'addresses',
                'GeotaggingString_Street': 'street',
                'GeotaggingString_Streets': 'streets',
                'GeotaggingString_Longitude': 'longitude',
                'GeotaggingString_Longitude_Short': 'lon',
                'GeotaggingString_Longitude_Short2': 'long',
                'GeotaggingString_Latitude': 'latitude',
                'GeotaggingString_Latitude_Short': 'lat',
                'GeotaggingString_PostalCode': 'postal code',
                'GeotaggingString_PostalCodes': 'postal codes',
                'GeotaggingString_ZipCode': 'zip code',
                'GeotaggingString_ZipCodes': 'zip codes',
                'GeotaggingString_Territory': 'territory',
                'GeotaggingString_Territories': 'territories',
            };
            function beautify(format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            }
            function describeUnit(exponent) {
                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            }
            function getLocalizedString(stringId) {
                return defaultLocalizedStrings[stringId];
            }
            valueFormatter.getLocalizedString = getLocalizedString;
            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.
            var locale = {
                null: defaultLocalizedStrings['NullValue'],
                true: defaultLocalizedStrings['BooleanTrue'],
                false: defaultLocalizedStrings['BooleanFalse'],
                NaN: defaultLocalizedStrings['NaNValue'],
                infinity: defaultLocalizedStrings['InfinityValue'],
                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                beautify: function (format) { return beautify(format); },
                describe: function (exponent) { return describeUnit(exponent); },
                restatementComma: defaultLocalizedStrings['RestatementComma'],
                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],
                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],
            };
            var MaxScaledDecimalPlaces = 2;
            var MaxValueForDisplayUnitRounding = 1000;
            var MinIntegerValueForDisplayUnits = 10000;
            var MinPrecisionForDisplayUnits = 2;
            var DateTimeMetadataColumn = {
                displayName: '',
                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(7 /* DateTime */),
            };
            function getFormatMetadata(format) {
                return powerbi.NumberFormat.getCustomFormatMetadata(format);
            }
            valueFormatter.getFormatMetadata = getFormatMetadata;
            function setLocaleOptions(options) {
                debug.assertValue(options, 'options');
                locale = options;
                powerbi.DefaultDisplayUnitSystem.reset();
                powerbi.WholeUnitsDisplayUnitSystem.reset();
            }
            valueFormatter.setLocaleOptions = setLocaleOptions;
            function createDefaultFormatter(formatString, allowFormatBeautification) {
                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }
                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;
                return {
                    format: function (value) {
                        if (value == null)
                            return locale.null;
                        return formatCore(value, formatBeaut);
                    }
                };
            }
            valueFormatter.createDefaultFormatter = createDefaultFormatter;
            /** Creates an IValueFormatter to be used for a range of values. */
            function create(options) {
                debug.assertValue(options, 'options');
                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;
                if (shouldUseNumericDisplayUnits(options)) {
                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);
                    var singleValueFormattingMode_1 = !!options.formatSingleValues;
                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));
                    var forcePrecision_1 = options.precision != null;
                    var decimals_1;
                    if (forcePrecision_1)
                        decimals_1 = -options.precision;
                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)
                        decimals_1 = -MaxScaledDecimalPlaces;
                    return {
                        format: function (value) {
                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);
                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                                return formattedValue;
                            var valueNumber = Number(value);
                            // Round to Double.DEFAULT_PRECISION
                            if (valueNumber && !displayUnitSystem_1.isScalingUnit() && Math.abs(valueNumber) < MaxValueForDisplayUnitRounding && !forcePrecision_1)
                                value = powerbi.Double.roundToPrecision(valueNumber);
                            return singleValueFormattingMode_1 ?
                                displayUnitSystem_1.formatSingleValue(valueNumber, format, decimals_1, forcePrecision_1) :
                                displayUnitSystem_1.format(valueNumber, format, decimals_1, forcePrecision_1);
                        },
                        displayUnit: displayUnitSystem_1.displayUnit,
                        options: options
                    };
                }
                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {
                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);
                    return {
                        format: function (value) {
                            if (value == null)
                                return locale.null;
                            var formatString = powerbi.formattingService.dateFormatString(unit_1);
                            return formatCore(value, formatString);
                        },
                        options: options
                    };
                }
                return createDefaultFormatter(format);
            }
            valueFormatter.create = create;
            function format(value, format, allowFormatBeautification) {
                if (value == null)
                    return locale.null;
                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);
            }
            valueFormatter.format = format;
            /**
             * Value formatting function to handle variant measures.
             * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number
             * @param {any} value Value to be formatted
             * @param {DataViewMetadataColumn} column Field which the value belongs to
             * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID
             * @param {boolean} nullsAreBlank? Whether to show "(Blank)" instead of empty string for null values
             * @returns Formatted value
             */
            function formatVariantMeasureValue(value, column, formatStringProp, nullsAreBlank) {
                return formatVariantMeasureValueWithDataPointObjects(value, undefined, column, formatStringProp, nullsAreBlank);
            }
            valueFormatter.formatVariantMeasureValue = formatVariantMeasureValue;
            /**
             * Evolution of @formatVariantMeasureValue that also supports data point level @DataViewObjects.
             */
            function formatVariantMeasureValueWithDataPointObjects(value, dataPointObjects, column, formatStringProp, nullsAreBlank) {
                // If column type is not datetime, but the value is of time datetime,
                // then use the default date format string
                if (!(column && column.type && column.type.dateTime) && value instanceof Date) {
                    var valueFormat = getFormatString(DateTimeMetadataColumn, null, false);
                    return formatCore(value, valueFormat, nullsAreBlank);
                }
                else {
                    return formatCore(value, getFormatStringWithDataPointObjects(dataPointObjects, column, formatStringProp), nullsAreBlank);
                }
            }
            valueFormatter.formatVariantMeasureValueWithDataPointObjects = formatVariantMeasureValueWithDataPointObjects;
            function createDisplayUnitSystem(displayUnitSystemType) {
                if (displayUnitSystemType == null)
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                switch (displayUnitSystemType) {
                    case powerbi.DisplayUnitSystemType.Default:
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                    case powerbi.DisplayUnitSystemType.WholeUnits:
                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);
                    case powerbi.DisplayUnitSystemType.Verbose:
                        return new powerbi.NoDisplayUnitSystem();
                    case powerbi.DisplayUnitSystemType.DataLabels:
                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);
                    default:
                        debug.assertFail('Unknown display unit system type');
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                }
            }
            valueFormatter.createDisplayUnitSystem = createDisplayUnitSystem;
            function shouldUseNumericDisplayUnits(options) {
                var value = options.value;
                var value2 = options.value2;
                var format = options.format;
                var columnType = options.columnType;
                // For singleValue visuals like card and gauge, we don't want to roundoff data to the nearest thousands.
                // Format the whole number, integers below 10K should not use display units
                if (options.formatSingleValues && format) {
                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {
                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);
                        if (isCustomFormat) {
                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;
                            if (precision < MinPrecisionForDisplayUnits)
                                return false;
                        }
                        else if (powerbi.Double.isInteger(value))
                            return false;
                    }
                }
                if ((typeof value === 'number') || (typeof value2 === 'number')) {
                    if (columnType && columnType.temporal && columnType.temporal.year)
                        return false;
                    else
                        return true;
                }
            }
            function shouldUseDateUnits(value, value2, tickCount) {
                // must check both value and value2 because we'll need to get an interval for date units
                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);
            }
            /*
             * Get the column format. Order of precedence is:
             *  1. Column format
             *  2. Default PowerView policy for column type
             */
            function getFormatString(column, formatStringProperty, suppressTypeFallback) {
                if (column) {
                    if (formatStringProperty) {
                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);
                        if (propertyValue)
                            return propertyValue;
                    }
                    if (!suppressTypeFallback) {
                        var columnType = column.type;
                        if (columnType) {
                            if (columnType.dateTime)
                                return valueFormatter.DefaultDateFormat;
                            if (columnType.integer) {
                                if (columnType.temporal && columnType.temporal.year)
                                    return "0";
                                return valueFormatter.DefaultIntegerFormat;
                            }
                            if (columnType.numeric)
                                return valueFormatter.DefaultNumericFormat;
                        }
                    }
                }
            }
            valueFormatter.getFormatString = getFormatString;
            /**
             * Get the data point format. Order of precedence is:
             *  1. Cell format
             *  2. Column format
             *  3. Default PowerView policy for column type
             */
            function getFormatStringWithDataPointObjects(dataPointObjects, column, formatStringProperty, suppressTypeFallback) {
                if (dataPointObjects) {
                    var propertyValue = powerbi.DataViewObjects.getValue(dataPointObjects, formatStringProperty);
                    if (propertyValue)
                        return propertyValue;
                }
                return getFormatString(column, formatStringProperty, suppressTypeFallback);
            }
            valueFormatter.getFormatStringWithDataPointObjects = getFormatStringWithDataPointObjects;
            function formatListCompound(strings, conjunction) {
                var result;
                if (!strings) {
                    return null;
                }
                var length = strings.length;
                if (length > 0) {
                    result = strings[0];
                    var lastIndex = length - 1;
                    for (var i = 1, len = lastIndex; i < len; i++) {
                        var value = strings[i];
                        result = StringExtensions.format(locale.restatementComma, result, value);
                    }
                    if (length > 1) {
                        var value = strings[lastIndex];
                        result = StringExtensions.format(conjunction, result, value);
                    }
                }
                else {
                    result = null;
                }
                return result;
            }
            /** The returned string will look like 'A, B, ..., and C'  */
            function formatListAnd(strings) {
                return formatListCompound(strings, locale.restatementCompoundAnd);
            }
            valueFormatter.formatListAnd = formatListAnd;
            /** The returned string will look like 'A, B, ..., or C' */
            function formatListOr(strings) {
                return formatListCompound(strings, locale.restatementCompoundOr);
            }
            valueFormatter.formatListOr = formatListOr;
            function formatCore(value, format, nullsAreBlank) {
                var formattedValue = getStringFormat(value, nullsAreBlank ? nullsAreBlank : false /*nullsAreBlank*/);
                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                    return formattedValue;
                return powerbi.formattingService.formatValue(value, format);
            }
            function getStringFormat(value, nullsAreBlank) {
                if (value == null && nullsAreBlank)
                    return locale.null;
                if (value === true)
                    return locale.true;
                if (value === false)
                    return locale.false;
                if (typeof value === 'number' && isNaN(value))
                    return locale.NaN;
                if (value === Number.NEGATIVE_INFINITY)
                    return locale.negativeInfinity;
                if (value === Number.POSITIVE_INFINITY)
                    return locale.infinity;
                return '';
            }
            function getDisplayUnits(displayUnitSystemType) {
                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);
                return displayUnitSystem.units;
            }
            valueFormatter.getDisplayUnits = getDisplayUnits;
        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** Enumeration of DateTimeUnits */
    var DateTimeUnit;
    (function (DateTimeUnit) {
        DateTimeUnit[DateTimeUnit["Year"] = 0] = "Year";
        DateTimeUnit[DateTimeUnit["Month"] = 1] = "Month";
        DateTimeUnit[DateTimeUnit["Week"] = 2] = "Week";
        DateTimeUnit[DateTimeUnit["Day"] = 3] = "Day";
        DateTimeUnit[DateTimeUnit["Hour"] = 4] = "Hour";
        DateTimeUnit[DateTimeUnit["Minute"] = 5] = "Minute";
        DateTimeUnit[DateTimeUnit["Second"] = 6] = "Second";
        DateTimeUnit[DateTimeUnit["Millisecond"] = 7] = "Millisecond";
    })(DateTimeUnit = powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewCategoricalUtils;
        (function (DataViewCategoricalUtils) {
            function getCategoriesDataViewObjects(categories) {
                debug.assertValue(categories, 'categories');
                // See comments on setCategoriesDataViewObjects(...)
                return !_.isEmpty(categories) && categories[0].objects;
            }
            DataViewCategoricalUtils.getCategoriesDataViewObjects = getCategoriesDataViewObjects;
            /**
             * In DataViewCategorical.categories, all columns have the same identity array, but any applicable DataViewObjects would be added to the first column only.
             *
             * If prototypeCategories is non-empty and is not an inherited object, returns the inherited version of prototypeCategories that has the objects set on its first column.
             * Else, if prototypeCategories is non-empty and is already an inherited object, returns prototypeCategories that has the objects set on its first column.
             * Else, if prototypeCategories is an empty array, returns undefined.
             *
             * Related code: DataViewTransform.findSelectedCategoricalColumn(...)
             */
            function setCategoriesDataViewObjects(prototypeCategories, objects) {
                debug.assertValue(prototypeCategories, 'prototypeCategories');
                debug.assertValue(objects, 'objects');
                if (!_.isEmpty(prototypeCategories)) {
                    var transformedCategories = inheritSingle(prototypeCategories);
                    var firstCategoryColumn = transformedCategories[0] = inheritSingle(transformedCategories[0]);
                    firstCategoryColumn.objects = objects;
                    return transformedCategories;
                }
            }
            DataViewCategoricalUtils.setCategoriesDataViewObjects = setCategoriesDataViewObjects;
            function getRowCount(dataViewCategorical) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                var rowCount = !_.isEmpty(dataViewCategorical.categories) ? dataViewCategorical.categories[0].values.length :
                    !_.isEmpty(dataViewCategorical.values) ? dataViewCategorical.values[0].values.length :
                        0;
                debug.assert(_.every(dataViewCategorical.categories, (function (categoryColumn) { return categoryColumn.values.length === rowCount; })), 'Invariant: every category column is expected to have the same number of values.');
                debug.assert(_.every(dataViewCategorical.categories, (function (categoryColumn) { return categoryColumn.identity.length === rowCount; })), 'Invariant: every category column is expected to have the same number of identities as there are values.');
                debug.assert(_.every(dataViewCategorical.values, (function (valueColumn) { return valueColumn.values.length === rowCount; })), 'Invariant: every value column is expected to have the same number of values.');
                return rowCount;
            }
            DataViewCategoricalUtils.getRowCount = getRowCount;
        })(DataViewCategoricalUtils = data.DataViewCategoricalUtils || (data.DataViewCategoricalUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inherit = powerbi.Prototype.inherit;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataViewMatrixUtils;
        (function (DataViewMatrixUtils) {
            function isLeafNode(node) {
                debug.assertValue(node, 'node');
                return _.isEmpty(node.children);
            }
            DataViewMatrixUtils.isLeafNode = isLeafNode;
            /**
             * Invokes the specified callback once per node in the node tree starting from the specified rootNodes in depth-first order.
             *
             * If rootNodes is null or undefined or empty, the specified callback will not get invoked.
             *
             * The traversalPath parameter in the callback is an ordered set of nodes that form the path from the specified
             * rootNodes down to the callback node argument itself.  If callback node is one of the specified rootNodes,
             * then traversalPath will be an array of length 1 containing that very node.
             *
             * IMPORTANT: The traversalPath array passed to the callback will be modified after the callback function returns!
             * If your callback needs to retain a copy of the traversalPath, please clone the array before returning.
             */
            function forEachNodeDepthFirst(rootNodes, callback) {
                debug.assertAnyValue(rootNodes, 'rootNodes');
                debug.assertValue(callback, 'callback');
                // Note: Don't do "if (!_.isEmpty(rootNodes))" for checking whether rootNodes is an empty array DataViewMatrixNode[],
                // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, 
                // for the fact that all the properties on DataViewMatrixNode are optional...
                if (rootNodes) {
                    if (isNodeArray(rootNodes)) {
                        for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {
                            var rootNode = rootNodes_1[_i];
                            if (rootNode) {
                                forEachNodeDepthFirstRecursive(rootNode, [], callback);
                            }
                        }
                    }
                    else {
                        forEachNodeDepthFirstRecursive(rootNodes, [], callback);
                    }
                }
            }
            DataViewMatrixUtils.forEachNodeDepthFirst = forEachNodeDepthFirst;
            /**
             * @traversalPath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).
             */
            function forEachNodeDepthFirstRecursive(matrixNode, traversalPath, callback) {
                debug.assertValue(matrixNode, 'matrixNode');
                debug.assertValue(traversalPath, 'traversalPath');
                debug.assertValue(callback, 'callback');
                // If traversalPath already contains matrixNode, then either one of the following errors has happened:
                // 1. the caller code mistakenly added matrixNode to traversalPath, or
                // 2. the callback modified traversalPath by adding a node to it, or
                // 3. the matrix hierarchy contains a cyclical node reference.
                debug.assert(!_.contains(traversalPath, matrixNode), 'pre-condition: traversalPath must not already contain matrixNode');
                traversalPath.push(matrixNode);
                var traversalResult = callback(matrixNode, traversalPath);
                var shouldContinue = traversalResult != null &&
                    traversalResult !== 0 /* stop */;
                if (traversalResult === 1 /* continueToChildNodes */) {
                    var childNodes = matrixNode.children;
                    if (!_.isEmpty(childNodes)) {
                        for (var _i = 0, childNodes_1 = childNodes; _i < childNodes_1.length; _i++) {
                            var nextChild = childNodes_1[_i];
                            if (nextChild) {
                                shouldContinue = forEachNodeDepthFirstRecursive(nextChild, traversalPath, callback);
                                if (!shouldContinue) {
                                    break;
                                }
                            }
                        }
                    }
                }
                debug.assert(_.last(traversalPath) === matrixNode, 'pre-condition: the callback given to forEachNodeDepthFirst() is not supposed to modify the traversalPath argument array.');
                traversalPath.pop();
                return shouldContinue;
            }
            /**
             * Invokes the specified callback once per leaf node (including root-level leaves and descendent leaves) of the
             * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the
             * particular leaf node in the context of this forEachLeafNode(...) invocation.
             *
             * If rootNodes is null or undefined or empty, the specified callback will not get invoked.
             *
             * The traversalPath parameter in the callback is an ordered set of nodes that form the path from the specified
             * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,
             * then traversalPath will be an array of length 1 containing that very node.
             *
             * IMPORTANT: The traversalPath array passed to the callback will be modified after the callback function returns!
             * If your callback needs to retain a copy of the traversalPath, please clone the array before returning.
             */
            function forEachLeafNode(rootNodes, callback) {
                debug.assertAnyValue(rootNodes, 'rootNodes');
                debug.assertValue(callback, 'callback');
                var nextLeafNodeIndex = 0;
                forEachNodeDepthFirst(rootNodes, (function (node, traversalPath) {
                    if (isLeafNode(node)) {
                        callback(node, nextLeafNodeIndex, traversalPath);
                        nextLeafNodeIndex++;
                    }
                    return 1 /* continueToChildNodes */;
                }));
            }
            DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;
            function isNodeArray(nodeOrNodeArray) {
                return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);
            }
            /**
             * Invokes the specified callback once for each node at the specified targetLevel in the node tree.
             *
             * Note: Be aware that in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode
             * for the Grand Total column in the column hierarchy can have children nodes where level > (parent.level + 1):
             *  {
             *      "level": 0,
             *      "isSubtotal": true,
             *      "children": [
             *          { "level": 2, "isSubtotal": true },
             *          { "level": 2, "levelSourceIndex": 1, "isSubtotal": true }
             *      ]
             *  }
             */
            function forEachNodeAtLevel(node, targetLevel, callback) {
                debug.assertValue(node, 'node');
                debug.assert(targetLevel >= 0, 'targetLevel >= 0');
                debug.assertValue(callback, 'callback');
                if (node.level === targetLevel) {
                    callback(node);
                    return;
                }
                var children = node.children;
                if (children && children.length > 0) {
                    for (var i = 0, ilen = children.length; i < ilen; i++)
                        forEachNodeAtLevel(children[i], targetLevel, callback);
                }
            }
            DataViewMatrixUtils.forEachNodeAtLevel = forEachNodeAtLevel;
            /**
             * Returned an object tree where each node and its children property are inherited from the specified node
             * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.
             *
             * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array
             * property, i.e. its children property is the same array object referenced in the input node's object tree.
             *
             * @param node The input node with the hierarchy object tree.
             * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.
             * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is
             * not already an inherited object. Same goes for the node's children property.  This is useful for creating
             * "visual DataView" objects from "query DataView" objects, as object inheritance is the mechanism for
             * "visual DataView" to override properties in "query DataView", and that "query DataView" never contains
             * inherited objects.
             */
            function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {
                debug.assertValue(node, 'node');
                debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');
                debug.assertValue(useInheritSingle, 'useInheritSingle');
                var returnNode = node;
                // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.
                // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode
                // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):
                //  {
                //    "level": 0,
                //    "isSubtotal": true,
                //    "children": [
                //      { "level": 2, "isSubtotal": true },
                //      { "level": 2, "levelSourceIndex": 1, "isSubtotal": true }
                //    ]
                //  }
                var isRootNode = node.level === undefined;
                var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);
                if (shouldInheritCurrentNode) {
                    var inheritFunc = useInheritSingle ? inheritSingle : inherit;
                    var inheritedNode = inheritFunc(node);
                    var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);
                    if (shouldInheritChildNodes && !_.isEmpty(node.children)) {
                        inheritedNode.children = inheritFunc(node.children); // first, make an inherited array
                        for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {
                            inheritedNode.children[i] =
                                inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);
                        }
                    }
                    returnNode = inheritedNode;
                }
                return returnNode;
            }
            DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;
            /**
             * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.
             * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have
             * Year === 2016, Quarter === 'Qtr 1', Month === 1.
             *
             * Returns false if the specified matrixOrHierarchy does not contain any composite group,
             * or if matrixOrHierarchy is null or undefined.
             */
            function containsCompositeGroup(matrixOrHierarchy) {
                debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');
                var hasCompositeGroup = false;
                if (matrixOrHierarchy) {
                    if (isMatrix(matrixOrHierarchy)) {
                        hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||
                            containsCompositeGroup(matrixOrHierarchy.columns);
                    }
                    else {
                        var hierarchyLevels = matrixOrHierarchy.levels;
                        if (!_.isEmpty(hierarchyLevels)) {
                            for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {
                                var level = hierarchyLevels_1[_i];
                                // it takes at least 2 columns at the same hierarchy level to form a composite group...
                                if (level.sources && (level.sources.length >= 2)) {
                                    debug.assert(_.every(level.sources, (function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; })), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');
                                    // Measure headers are not group
                                    var isMeasureHeadersLevel = level.sources[0].isMeasure;
                                    if (!isMeasureHeadersLevel) {
                                        hasCompositeGroup = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                return hasCompositeGroup;
            }
            DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;
            function extractSelectIndices(matrix) {
                debug.assertValue(matrix, 'matrix');
                var rowsLevels = matrix.rows && matrix.rows.levels;
                var columnsLevels = matrix.columns && matrix.columns.levels;
                var valueSources = matrix.valueSources;
                var dataRegionSelectIndices = {
                    primaryAxis: !_.isEmpty(rowsLevels) && extractSelectIndicesFromHierarchyLevels(rowsLevels),
                    secondaryAxis: !_.isEmpty(columnsLevels) && extractSelectIndicesFromHierarchyLevels(columnsLevels),
                    intersection: !_.isEmpty(valueSources) && _.map(valueSources, (function (source) { return source.index; })),
                };
                return dataRegionSelectIndices;
            }
            DataViewMatrixUtils.extractSelectIndices = extractSelectIndices;
            function extractSelectIndicesFromHierarchyLevels(levels) {
                debug.assertValue(levels, 'levels');
                return _.map(levels, (function (level) {
                    var sources = level.sources;
                    var groupLevel = {
                        selectIndices: _.map(sources, (function (source) { return source.index; })),
                    };
                    return groupLevel;
                }));
            }
            /**
             * Returns the number of levels on the Row grouping
             * @param {DataViewMatrix} matrix Matrix DataView
             */
            function getRowGroupingLevelsCount(matrix) {
                if (!matrix || !matrix.rows || _.isEmpty(matrix.rows.levels))
                    return 0;
                return matrix.rows.levels.length;
            }
            DataViewMatrixUtils.getRowGroupingLevelsCount = getRowGroupingLevelsCount;
            /**
             * Returns the number of levels on the Column grouping
             * @param {DataViewHierarchy} columns Matrix DataView hierarchy
             */
            function getColumnGroupingLevelsCount(columns) {
                if (!columns || _.isEmpty(columns.levels))
                    return 0;
                return columns.levels.length - (data.DataViewMatrixMeasureHeaders.hasMeasureHeadersLevel(columns.levels) ? 1 : 0);
            }
            DataViewMatrixUtils.getColumnGroupingLevelsCount = getColumnGroupingLevelsCount;
            function isMatrix(matrixOrHierarchy) {
                return 'rows' in matrixOrHierarchy &&
                    'columns' in matrixOrHierarchy &&
                    'valueSources' in matrixOrHierarchy;
            }
            /**
             * Get the leaf nodes of the hierarchy starting from the root
             * @param {DataViewMatrixNode} root Root node of the hierarchy
             * @returns
             */
            function getLeafNodesPath(root) {
                if (!root || _.isEmpty(root.children))
                    return;
                var leaves = [];
                forEachLeafNode(root, (function (leaf, index, path) {
                    leaves.push(_.clone(path));
                }));
                return leaves;
            }
            DataViewMatrixUtils.getLeafNodesPath = getLeafNodesPath;
        })(DataViewMatrixUtils = data.DataViewMatrixUtils || (data.DataViewMatrixUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewMetadataColumnUtils;
        (function (DataViewMetadataColumnUtils) {
            /**
             * Returns true iff the specified metadataColumn is assigned to the specified targetRole.
             */
            function isForRole(metadataColumn, targetRole) {
                debug.assertValue(metadataColumn, 'metadataColumn');
                debug.assertValue(targetRole, 'targetRole');
                var roles = metadataColumn.roles;
                return !!roles && !!roles[targetRole];
            }
            DataViewMetadataColumnUtils.isForRole = isForRole;
            /**
             * Returns true iff the specified metadataColumn is assigned to any one of the specified targetRoles.
             */
            function isForAnyRole(metadataColumn, targetRoles) {
                debug.assertValue(metadataColumn, 'metadataColumn');
                debug.assertValue(targetRoles, 'targetRoles');
                var roles = metadataColumn.roles;
                return !!roles && _.any(targetRoles, (function (targetRole) { return roles[targetRole]; }));
            }
            DataViewMetadataColumnUtils.isForAnyRole = isForAnyRole;
            /** Return true if the specified roles is for the specified targetRole only. */
            function isExactMatchRole(roles, targetRole) {
                debug.assertAnyValue(roles, 'roles');
                debug.assertValue(targetRole, 'targetRole');
                if (!roles) {
                    return false;
                }
                if (!roles[targetRole]) {
                    return false;
                }
                if (_.size(roles) >= 2) {
                    for (var roleName in roles) {
                        if (roleName !== targetRole && !!roles[roleName]) {
                            return false;
                        }
                    }
                }
                return true;
            }
            DataViewMetadataColumnUtils.isExactMatchRole = isExactMatchRole;
            /**
             * Left-joins each metadata column (filtered by filterByRoles if specified) in the specified columnSources
             * with projection ordering index into a wrapper object.
             *
             * The filterByRoles is just an optimization to avoid joining the irrevalent elements in columnSources.
             * If filterByRoles is undefined, then every non-projected source in columnSources will result in a corresponding element with
             * undefined projectionOrderIndex in the return value.
             * If filterByRoles is specified, then only the non-projected sources in columnSources that have any one of those roles will
             * result in corresponding elements with undefined projectionOrderIndex in the return value.
             *
             * If a metadata column passes the filterByRoles check and its select index is not projected, the projectionOrderIndex property
             * in that MetadataColumnAndProjectionIndex object will be undefined.
             *
             * If a metadata column passes the filterByRoles check and its select index is projected more than once, that metadata column
             * will be included in multiple MetadataColumnAndProjectionIndex objects, once per occurrence in projection.
             *
             * If the specified projectionOrdering does not contain duplicate values, then the returned objects will be in the same order
             * as their corresponding metadata column object appears in the specified columnSources.
             *
             * Note: In order for this function to reliably calculate the "source index" of a particular column, the
             * specified columnSources must be a non-filtered array of column sources from the DataView, such as
             * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.
             *
             * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...
             * @param projectionOrdering The select indices in projection ordering.  It should be the ordering for the specified filterByRoles.
             * @param filterByRoles The roles for filtering out the irrevalent columns in columnSources. Optional.
             */
            function leftJoinMetadataColumnsAndProjectionOrder(columnSources, projectionOrdering, filterByRoles) {
                debug.assertAnyValue(columnSources, 'columnSources');
                debug.assertValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(filterByRoles, 'filterByRoles');
                var jointResult = [];
                if (!_.isEmpty(columnSources)) {
                    var selectIndexToProjectionIndicesMap = createSelectIndexToProjectionOrderIndicesMapping(projectionOrdering);
                    for (var j = 0, jlen = columnSources.length; j < jlen; j++) {
                        var column = columnSources[j];
                        if (!filterByRoles || isForAnyRole(column, filterByRoles)) {
                            var projectionIndices = selectIndexToProjectionIndicesMap[column.index];
                            if (!_.isEmpty(projectionIndices)) {
                                for (var _i = 0, projectionIndices_1 = projectionIndices; _i < projectionIndices_1.length; _i++) {
                                    var projectionIndex = projectionIndices_1[_i];
                                    var jointColumnInfo = {
                                        metadataColumn: column,
                                        sourceIndex: j,
                                        projectionOrderIndex: projectionIndex,
                                    };
                                    jointResult.push(jointColumnInfo);
                                }
                            }
                            else {
                                var jointColumnInfo = {
                                    metadataColumn: column,
                                    sourceIndex: j,
                                    projectionOrderIndex: undefined,
                                };
                                jointResult.push(jointColumnInfo);
                            }
                        }
                    }
                }
                return jointResult;
            }
            DataViewMetadataColumnUtils.leftJoinMetadataColumnsAndProjectionOrder = leftJoinMetadataColumnsAndProjectionOrder;
            function getHierarchyVariationProperty(metadataCols) {
                var hierarchyColumn = _.find(metadataCols, (function (mc) { return mc.expr && data.SQExpr.isHierarchyLevel(mc.expr); }));
                if (hierarchyColumn) {
                    var hierarchyLevelExpr = hierarchyColumn.expr;
                    var hierarchyExpr = hierarchyLevelExpr.arg;
                    if (data.SQExpr.isHierarchy(hierarchyExpr)) {
                        var variationSourceExpr = hierarchyExpr.arg;
                        if (data.SQExpr.isPropertyVariationSource(variationSourceExpr)) {
                            return variationSourceExpr.property;
                        }
                    }
                }
            }
            DataViewMetadataColumnUtils.getHierarchyVariationProperty = getHierarchyVariationProperty;
            function createSelectIndexToProjectionOrderIndicesMapping(selectIndicesByProjectionOrder) {
                debug.assertValue(selectIndicesByProjectionOrder, 'selectIndicesByProjectionOrder');
                var selectIndexToProjectionIndicesMap = {};
                for (var i = 0, ilen = selectIndicesByProjectionOrder.length; i < ilen; i++) {
                    var selectIndex = selectIndicesByProjectionOrder[i];
                    var projectionOrders = selectIndexToProjectionIndicesMap[selectIndex];
                    if (!projectionOrders) {
                        projectionOrders = selectIndexToProjectionIndicesMap[selectIndex] = [];
                    }
                    projectionOrders.push(i);
                }
                return selectIndexToProjectionIndicesMap;
            }
        })(DataViewMetadataColumnUtils = data.DataViewMetadataColumnUtils || (data.DataViewMetadataColumnUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        data.scalarKeyMinPropertyIdentifier = { objectName: 'scalarKey', propertyName: 'min' };
        var ScalarKeyUtils;
        (function (ScalarKeyUtils) {
            function getScalarKeys(dataViewCategoricalColumn, scalarKeyMinProperty) {
                var columnObjects;
                if (dataViewCategoricalColumn)
                    columnObjects = dataViewCategoricalColumn.objects;
                if (!_.isEmpty(columnObjects)) {
                    var scalarKeys = void 0;
                    var columnObjectsLength = columnObjects.length;
                    for (var i = 0; i < columnObjectsLength; i++) {
                        var categoryObjects = columnObjects[i];
                        var scalarKey = powerbi.DataViewObjects.getValue(categoryObjects, scalarKeyMinProperty);
                        if (scalarKey !== undefined) {
                            if (!scalarKeys) {
                                scalarKeys = {
                                    values: new Array(columnObjectsLength)
                                };
                            }
                            var key = { min: scalarKey };
                            scalarKeys.values[i] = key;
                        }
                    }
                    return scalarKeys;
                }
            }
            ScalarKeyUtils.getScalarKeys = getScalarKeys;
            function hasScalarKeys(mapping) {
                var usingScalarKey = false;
                var categoryMapping = mapping.categories;
                data.CompiledDataViewMapping.visitCategoricalCategories(categoryMapping, {
                    visitRole: function (role) {
                        usingScalarKey = usingScalarKey || _.any(role.items, (function (item) { return item.scalarKeyInfo && item.scalarKeyInfo.hasScalarKey; }));
                    }
                });
                return usingScalarKey;
            }
            ScalarKeyUtils.hasScalarKeys = hasScalarKeys;
        })(ScalarKeyUtils = data.ScalarKeyUtils || (data.ScalarKeyUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var CompiledDataViewMapping;
        (function (CompiledDataViewMapping) {
            function visitMapping(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var categorical = mapping.categorical;
                if (categorical)
                    visitCategorical(categorical, visitor);
                var table = mapping.table;
                if (table)
                    visitTable(table, visitor);
                var matrix = mapping.matrix;
                if (matrix)
                    visitMatrix(matrix, visitor);
                var tree = mapping.tree;
                if (tree)
                    visitTree(tree, visitor);
                var single = mapping.single;
                if (single)
                    visitSingle(single, visitor);
            }
            CompiledDataViewMapping.visitMapping = visitMapping;
            function visitCategorical(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                visitCategoricalCategories(mapping.categories, visitor);
                var values = mapping.values;
                visitCategoricalValues(values, visitor);
                visitGrouped(values, visitor);
                visitReduction(mapping, visitor);
            }
            function visitCategoricalCategories(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (mapping) {
                    visitBind(mapping, visitor);
                    visitFor(mapping, visitor);
                    visitList(mapping, visitor);
                    visitReduction(mapping, visitor);
                }
            }
            CompiledDataViewMapping.visitCategoricalCategories = visitCategoricalCategories;
            function visitCategoricalValues(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (mapping) {
                    visitBind(mapping, visitor, 0 /* CategoricalValue */);
                    visitFor(mapping, visitor, 0 /* CategoricalValue */);
                    visitList(mapping, visitor, 0 /* CategoricalValue */);
                    var group = mapping.group;
                    if (group) {
                        for (var _i = 0, _a = group.select; _i < _a.length; _i++) {
                            var item = _a[_i];
                            visitBind(item, visitor, 1 /* CategoricalValueGroup */);
                            visitFor(item, visitor, 1 /* CategoricalValueGroup */);
                        }
                    }
                }
            }
            CompiledDataViewMapping.visitCategoricalValues = visitCategoricalValues;
            function visitTable(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var rows = mapping.rows;
                visitBind(rows, visitor);
                visitFor(rows, visitor);
                visitList(rows, visitor);
                visitReduction(rows, visitor);
            }
            CompiledDataViewMapping.visitTable = visitTable;
            function visitMatrix(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                visitMatrixRows(mapping.rows, visitor);
                visitMatrixColumns(mapping.columns, visitor);
                visitMatrixValues(mapping.values, visitor);
            }
            function visitMatrixRows(mapping, visitor) {
                visitMatrixItemsWithComposite(mapping, visitor);
            }
            CompiledDataViewMapping.visitMatrixRows = visitMatrixRows;
            function visitMatrixColumns(mapping, visitor) {
                // Currently, QueryGenerator does not support composite group on matrix columns because there is no scenario for it yet.
                visitMatrixItems(mapping, visitor);
            }
            CompiledDataViewMapping.visitMatrixColumns = visitMatrixColumns;
            function visitMatrixValues(mapping, visitor) {
                visitMatrixItems(mapping, visitor);
            }
            CompiledDataViewMapping.visitMatrixValues = visitMatrixValues;
            function visitMatrixItemsWithComposite(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (mapping) {
                    visitFor(mapping, visitor);
                    visitListWithComposite(mapping, visitor);
                    visitReduction(mapping, visitor);
                }
            }
            /**
             * For visiting CompiledDataViewMatrixMapping.columns or CompiledDataViewMatrixMapping.values, where the composite keyword is not supported.
             */
            function visitMatrixItems(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (mapping) {
                    visitFor(mapping, visitor);
                    visitList(mapping, visitor);
                    visitReduction(mapping, visitor);
                }
            }
            function visitTree(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                visitTreeNodes(mapping.nodes, visitor);
                visitTreeValues(mapping.values, visitor);
            }
            function visitTreeNodes(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (mapping) {
                    visitFor(mapping, visitor);
                    visitReduction(mapping, visitor);
                }
            }
            CompiledDataViewMapping.visitTreeNodes = visitTreeNodes;
            function visitTreeValues(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (mapping) {
                    visitFor(mapping, visitor);
                }
            }
            CompiledDataViewMapping.visitTreeValues = visitTreeValues;
            function visitBind(mapping, visitor, context) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var bind = mapping.bind;
                if (bind) {
                    if (context != null)
                        visitor.visitRole(bind.to, context);
                    else
                        visitor.visitRole(bind.to);
                }
            }
            function visitFor(mapping, visitor, context) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var forValue = mapping.for;
                if (forValue) {
                    if (context != null)
                        visitor.visitRole(forValue.in, context);
                    else
                        visitor.visitRole(forValue.in);
                }
            }
            function visitComposite(mapping, visitor, context) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var compositeValues = mapping.composite;
                if (compositeValues) {
                    if (visitor.enterComposite)
                        visitor.enterComposite();
                    for (var _i = 0, compositeValues_1 = compositeValues; _i < compositeValues_1.length; _i++) {
                        var value = compositeValues_1[_i];
                        visitBind(value, visitor, context);
                        visitFor(value, visitor, context);
                    }
                    if (visitor.exitComposite)
                        visitor.exitComposite();
                }
            }
            function visitList(mapping, visitor, context) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var select = mapping.select;
                if (select) {
                    for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {
                        var item = select_1[_i];
                        visitBind(item, visitor, context);
                        visitFor(item, visitor, context);
                    }
                }
            }
            function visitListWithComposite(mapping, visitor, context) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                var select = mapping.select;
                if (select) {
                    for (var _i = 0, select_2 = select; _i < select_2.length; _i++) {
                        var item = select_2[_i];
                        visitBind(item, visitor, context);
                        visitFor(item, visitor, context);
                        visitComposite(item, visitor, context);
                    }
                }
            }
            function visitGrouped(mapping, visitor) {
                debug.assertAnyValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (!mapping)
                    return;
                var group = mapping.group;
                if (group) {
                    visitor.visitRole(group.by);
                    visitReduction(group, visitor);
                }
            }
            CompiledDataViewMapping.visitGrouped = visitGrouped;
            function visitReduction(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                if (visitor.visitReduction) {
                    var reductionAlgorithm = mapping.dataReductionAlgorithm;
                    if (reductionAlgorithm) {
                        visitor.visitReduction(reductionAlgorithm);
                    }
                }
            }
            function visitSingle(mapping, visitor) {
                debug.assertValue(mapping, 'mapping');
                debug.assertValue(visitor, 'visitor');
                visitor.visitRole(mapping.role);
            }
        })(CompiledDataViewMapping = data.CompiledDataViewMapping || (data.CompiledDataViewMapping = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataRoleHelper;
        (function (DataRoleHelper) {
            function getMeasureIndexOfRole(grouped, roleName) {
                if (!_.isEmpty(grouped)) {
                    var firstGroup = grouped[0];
                    if (firstGroup.values && firstGroup.values.length > 0) {
                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {
                            var value = firstGroup.values[i];
                            if (value && value.source) {
                                if (hasRole(value.source, roleName))
                                    return i;
                            }
                        }
                    }
                }
                return -1;
            }
            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;
            function getCategoryIndexOfRole(categories, roleName) {
                if (!_.isEmpty(categories)) {
                    for (var i = 0, ilen = categories.length; i < ilen; i++) {
                        if (hasRole(categories[i].source, roleName))
                            return i;
                    }
                }
                return -1;
            }
            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;
            function getCategoryIndexesOfRole(categories, roleName) {
                var indexes = [];
                if (!_.isEmpty(categories)) {
                    for (var i = 0, ilen = categories.length; i < ilen; i++) {
                        if (hasRole(categories[i].source, roleName))
                            indexes.push(i);
                    }
                }
                return indexes;
            }
            DataRoleHelper.getCategoryIndexesOfRole = getCategoryIndexesOfRole;
            function hasRole(column, name) {
                var roles = column.roles;
                return roles && roles[name];
            }
            DataRoleHelper.hasRole = hasRole;
            function hasRoleInDataView(dataView, name) {
                return dataView != null
                    && dataView.metadata != null
                    && dataView.metadata.columns
                    && _.any(dataView.metadata.columns, (function (c) { return c.roles && c.roles[name] !== undefined; }));
            }
            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;
            function hasRoleInValueColumn(valueColumn, name) {
                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);
            }
            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;
        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var StringExtensions = jsCommon.StringExtensions;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewHierarchyLevelBackfill;
        (function (DataViewHierarchyLevelBackfill) {
            function apply(prototype, quarterPrefix) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(quarterPrefix, 'quarterPrefix');
                var categorical = prototype.categorical;
                if (!categorical || _.isEmpty(categorical.categories))
                    return prototype;
                var categories = categorical.categories;
                var scalarKeys = data.ScalarKeyUtils.getScalarKeys(categories[0], data.scalarKeyMinPropertyIdentifier);
                if (!scalarKeys || _.isEmpty(scalarKeys.values))
                    return prototype;
                var transformedDataView;
                var transformedCategorical;
                var transformedCategories;
                // First dimention is value, second dimention is category, i.e. [[Y, Q, M, D],[Y, Q, M, D]....[Y, Q, M, D]]
                // Expressions created only for values were backfilled, starting from firstBackfilledIndex.
                var backfilledCategoryValueExpr = [];
                var firstBackfilledIndex;
                for (var catIndex = 0, catLen = categories.length; catIndex < catLen; catIndex++) {
                    var category = categories[catIndex];
                    var type = category.source.type;
                    var categoryValues = category.values;
                    var transformedCategory = void 0;
                    var transformedCategoryValues = void 0;
                    for (var valIndex = 0, categoryValuesLen = _.size(categoryValues); valIndex < categoryValuesLen; valIndex++) {
                        var categoryValue = categoryValues[valIndex];
                        var scalarKeyValue = scalarKeys.values[valIndex];
                        // check for category value to be null or undefined and scalar key to be defined and not null for the given category value index
                        if (categoryValue == null && scalarKeyValue != null) {
                            if (!transformedDataView) {
                                transformedDataView = inheritSingle(prototype);
                                transformedCategorical = transformedDataView.categorical = inheritSingle(categorical);
                                transformedCategories = transformedCategorical.categories = inheritSingle(categories);
                            }
                            if (!transformedCategory) {
                                transformedCategory = transformedCategories[catIndex] = inheritSingle(category);
                                transformedCategoryValues = transformedCategory.values = inheritSingle(categoryValues);
                            }
                            var levelValue = createDateHierarchyLevelFromScalarKey(scalarKeyValue.min, type, quarterPrefix);
                            transformedCategoryValues[valIndex] = levelValue;
                            if (!backfilledCategoryValueExpr[valIndex]) {
                                if (!firstBackfilledIndex)
                                    firstBackfilledIndex = valIndex;
                                backfilledCategoryValueExpr[valIndex] = [];
                            }
                            backfilledCategoryValueExpr[valIndex][catIndex] = data.SQExprBuilder.typedConstant(levelValue, type);
                        }
                    }
                }
                // rebuild category identity for backfilled items
                for (var catIndex = 0, catLen = _.size(transformedCategories); catIndex < catLen; catIndex++) {
                    var category = transformedCategories[catIndex];
                    for (var backfillIndex = firstBackfilledIndex, catIdentityLen = _.size(category.identity); backfillIndex < catIdentityLen; backfillIndex++) {
                        // update backfilled categories with SQConstantExpr for existing 
                        var values = backfilledCategoryValueExpr[backfillIndex];
                        if (values) {
                            debug.assert(values.length === category.identityFields.length, "category values must match category identities");
                            category.identity[backfillIndex] = data.createDataViewScopeIdentity(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(category.identityFields, values));
                        }
                    }
                }
                return transformedDataView || prototype;
            }
            DataViewHierarchyLevelBackfill.apply = apply;
            function createDateHierarchyLevelFromScalarKey(scalarKey, type, quarterPrefix) {
                debug.assertValue(type, "Category type is not specified");
                if (!_.isDate(scalarKey) || !type || !type.temporal)
                    return null;
                var scalarKeyDate = scalarKey;
                if (type.temporal.year)
                    return getYear(scalarKeyDate);
                if (type.temporal.quarter)
                    return getQuarter(scalarKeyDate, quarterPrefix);
                if (type.temporal.month)
                    return getMonth(scalarKeyDate);
                if (type.temporal.day)
                    return getDay(scalarKeyDate);
            }
            function getYear(date) {
                debug.assertValue(date, 'date');
                return date.getFullYear();
            }
            function getQuarter(date, quarterPrefix) {
                debug.assertValue(date, 'date');
                var monthsPerQuarter = 3;
                var quarter = Math.floor((date.getMonth() + monthsPerQuarter) / monthsPerQuarter);
                // The format should be localized quarter prefix, if any, and quarter number, i.e. "Qtr 1"
                return StringExtensions.format(quarterPrefix, quarter.toLocaleString());
            }
            function getMonth(date) {
                debug.assertValue(date, 'date');
                // The format should be full month, i.e. "July". Use full reference to fomratting service (dont' import) to make sure it's initialized before this call.
                return powerbi.formattingService.formatValue(date, 'MMMM');
            }
            function getDay(date) {
                debug.assertValue(date, 'date');
                return date.getDate();
            }
        })(DataViewHierarchyLevelBackfill = data.DataViewHierarchyLevelBackfill || (data.DataViewHierarchyLevelBackfill = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inherit = powerbi.Prototype.inherit;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var valueFormatter = powerbi.visuals.valueFormatter;
        var DataViewConcatenateCategoricalColumns;
        (function (DataViewConcatenateCategoricalColumns) {
            function detectAndApply(dataView, objectDescriptors, applicableRoleMappings, projectionOrdering, projectionActiveItems) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertAnyValue(applicableRoleMappings, 'applicableRoleMappings');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(projectionActiveItems, 'projectionActiveItems');
                var result = dataView;
                var dataViewCategorical = dataView.categorical;
                if (dataViewCategorical) {
                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, applicableRoleMappings);
                    var hierarchyVariationProperty = data.DataViewMetadataColumnUtils.getHierarchyVariationProperty(dataView.metadata.columns);
                    // If we have a Date Table hierarchy we need to adjust the column display name to include the active projection.
                    // no need to concatenate unless we have multiple columns, or we are a datetime Date Table hierarchy
                    if (concatenationSource && (concatenationSource.categories.length >= 2 || hierarchyVariationProperty)) {
                        var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems && projectionActiveItems[concatenationSource.roleName])
                            .filter((function (activeItemInfo) { return activeItemInfo.suppressConcat; }))
                            .map((function (activeItemInfo) { return activeItemInfo.queryRef; }))
                            .value();
                        result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, concatenationSource.categories, activeItemsToIgnoreInConcatenation, hierarchyVariationProperty);
                    }
                }
                return result;
            }
            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;
            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */
            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {
                debug.assertValue(metadata, 'metadata');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(categorical, 'categorical');
                var result;
                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {
                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.
                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.
                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),
                    // use inherit() rather than inheritSingle() here.
                    var transformingColumns_1 = inherit(metadata.columns);
                    var transformingMetadata = inherit(metadata, (function (m) { m.columns = transformingColumns_1; }));
                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };
                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);
                }
                else {
                    result = { metadata: metadata, categorical: categorical };
                }
                return result;
            }
            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;
            /**
             * Returns the role and its assocated category columns (from dataViewCategorical.categories)
             * that should be concatenated for the case of hierarchical group.
             *
             * Note: In the future if we support sibling hierarchical groups in categorical,
             * change the return type to CategoryColumnsByRole[] and update detection logic.
             */
            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, applicableRoleMappings) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertAnyValue(applicableRoleMappings, 'applicableRoleMappings');
                var result;
                // The following code will choose a role name only if all applicableRoleMappings share the same role for Categorical Category and
                // that role has a { max: 1 } restriction in visual capabilities role mapping conditions.
                // Handling multiple applicableRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:
                // 1. combo chart with a field for both Line and Column values, and
                // 2. chart with regression line enabled.
                // In case 1, you can pretty much get exactly the one from applicableRoleMappings for which this code is currently processing for,
                // by looking at the index of the current split in DataViewTransformActions.splits.  But matching by this array index is not robust, 
                // and the long term solution is to give a name or ID to each DataViewMapping, and have a split refer to that name or ID.
                // In case 2, this code will filter out the DataViewMapping for regression line.
                var categoricalRoleMappings = _.chain(applicableRoleMappings)
                    .filter((function (mapping) { return !powerbi.DataViewMapping.getRegressionUsage(mapping); }))
                    .map((function (mapping) { return mapping.categorical; }))
                    .value();
                var isEveryRoleMappingForCategorical = !_.isEmpty(categoricalRoleMappings) &&
                    _.every(categoricalRoleMappings, (function (mapping) { return !!mapping; }));
                // Consider: In the rest of DataViewTransform, it is more common to perform a transform if *any* (rather than if *all*) 
                // of the applicable role mappings targets the particular DataView type (in this case, categorial).
                if (isEveryRoleMappingForCategorical) {
                    var targetRoleName_1 = getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings);
                    if (targetRoleName_1 &&
                        isVisualExpectingMaxOneCategoryColumn(targetRoleName_1, applicableRoleMappings)) {
                        var categoryColumnsForTargetRole_1 = _.filter(dataViewCategorical.categories, (function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; }));
                        if (!_.isEmpty(categoryColumnsForTargetRole_1)) {
                            // At least for now, we expect all category columns for the same role to have the same number of value entries.
                            // If that's not the case, we won't run the concatenate logic for that role at all...
                            var areValuesCountsEqual = _.every(categoryColumnsForTargetRole_1, (function (categoryColumn) { return categoryColumn.values.length === categoryColumnsForTargetRole_1[0].values.length; }));
                            if (areValuesCountsEqual) {
                                result = {
                                    roleName: targetRoleName_1,
                                    categories: categoryColumnsForTargetRole_1,
                                };
                            }
                        }
                    }
                }
                return result;
            }
            /**
             * If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name.
             * Else, returns undefined.
             */
            function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings) {
                debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');
                debug.assert(_.every(categoricalRoleMappings, (function (roleMapping) { return !!roleMapping; })), 'categoricalRoleMappings must not contain falsy element');
                // With "list" in role mapping, it is possible to have multiple role names for category.
                // For now, proceed to concatenate category columns only when categories are bound to exactly 1 Role.
                // We can change this if we want to support independent (sibling) group hierarchies in categorical.
                var categoryRoles = powerbi.DataViewMapping.getRolesIfSameInAllCategoricalMappings(categoricalRoleMappings, powerbi.DataViewMapping.getAllRolesInCategories);
                if (_.size(categoryRoles) === 1)
                    return _.first(categoryRoles);
            }
            /**
             * Returns true if every one of specified roleMappings has non-empty 'conditions', and that every one of their conditions
             * has a { max: 1 } restriction for the specified categoricalRoleName.
            */
            function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName, roleMappings) {
                debug.assertValue(categoricalRoleName, 'categoricalRoleName');
                debug.assertNonEmpty(roleMappings, 'roleMappings');
                debug.assert(_.every(roleMappings, (function (mapping) { return mapping.categorical; })), 'All specified roleMappings are expected to target categorical');
                var isVisualExpectingMaxOneCategoryColumn = _.every(roleMappings, (function (roleMapping) {
                    return !_.isEmpty(roleMapping.conditions) &&
                        _.every(roleMapping.conditions, (function (condition) { return condition[categoricalRoleName] && condition[categoricalRoleName].max === 1; }));
                }));
                return isVisualExpectingMaxOneCategoryColumn;
            }
            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore, hierarchyVariationProperty) {
                debug.assert(dataView && dataView.categorical && _.size(dataView.categorical.categories) >= 1, 'dataView && dataView.categorical && _.size(dataView.categorical.categories) >= 1');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(roleName, 'roleName');
                debug.assert(!_.isEmpty(columnsSortedByProjectionOrdering), '!_.isEmpty(columnsSortedByProjectionOrdering)');
                debug.assert(_.every(columnsSortedByProjectionOrdering, (function (column) { return _.contains(dataView.categorical.categories, column); })), 'every column in columnsSortedByProjectionOrdering should exist in dataView.categorical.categories');
                // We first filter the columns in order to ignore those that are higher up in the hierarchy
                var columnsToConcatenate = _.filter(columnsSortedByProjectionOrdering, (function (column) { return !_.contains(queryRefsToIgnore, column.source.queryName); }));
                var concatenatedValues;
                var valueType;
                // If there are no columns to concatenate it's important to keep values as they should be.
                if (columnsSortedByProjectionOrdering.length === 1) {
                    concatenatedValues = columnsToConcatenate[0].values;
                    valueType = columnsToConcatenate[0].source.type;
                }
                else {
                    var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);
                    concatenatedValues = concatenateValues(columnsToConcatenate, formatStringPropId);
                    valueType = powerbi.ValueType.fromDescriptor({ text: true });
                }
                var columnsSourceSortedByProjectionOrdering = _.map(columnsToConcatenate, (function (categoryColumn) { return categoryColumn.source; }));
                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, valueType, hierarchyVariationProperty);
                var transformedDataView = inheritSingle(dataView);
                addToMetadata(transformedDataView, concatenatedColumnMetadata);
                var dataViewCategorical = dataView.categorical;
                var dataViewObjects = data.DataViewCategoricalUtils.getCategoriesDataViewObjects(dataViewCategorical.categories);
                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsToConcatenate, concatenatedColumnMetadata, concatenatedValues, dataViewObjects);
                // It is important to maintain the column order because we always assume they are sorted
                var lastColumn = _.last(columnsSortedByProjectionOrdering);
                var insertIndex = _.findIndex(dataViewCategorical.categories, (function (category) { return category === lastColumn; }));
                var transformedCategoricalCategories = inheritSingle(dataViewCategorical.categories);
                transformedCategoricalCategories.splice(insertIndex, 0, concatenatedCategoryColumn);
                var _loop_2 = function (i) {
                    if (_.find(columnsSortedByProjectionOrdering, (function (column) { return column === transformedCategoricalCategories[i]; }))) {
                        transformedCategoricalCategories.splice(i, 1);
                    }
                };
                // Erase all the columnsSortedByProjectionOrdering from the transformedCategoricalCategories
                for (var i = transformedCategoricalCategories.length - 1; i >= 0; i--) {
                    _loop_2(i);
                }
                var transformedCategorical = inheritSingle(dataViewCategorical);
                transformedCategorical.categories = transformedCategoricalCategories;
                transformedDataView.categorical = transformedCategorical;
                return transformedDataView;
            }
            function concatenateHierarchyAndCurrentLevelDisplayName(hierarchyVariationProperty, currentHierarchyLevelName) {
                return hierarchyVariationProperty + ' ' + currentHierarchyLevelName;
            }
            function concatenateValues(columnsSortedByProjectionOrdering, formatStringPropId) {
                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');
                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');
                var concatenatedValues = [];
                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]
                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {
                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];
                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);
                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {
                        var value = categoryColumn.values && categoryColumn.values[i];
                        var formattedValue = valueFormatter.format(value, formatString);
                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (concatenatedValues[i] + ' ' + formattedValue);
                    }
                }
                return concatenatedValues;
            }
            /**
             * Creates the column metadata that will back the column with the concatenated values.
             * Columns are concatented for categorical data view when composite values are encountered
             * For other data views, columns aren't concatenated when composite values are encountered
             * Ideally we should create a transform and have the visual apply it when we have more use cases
             * where columns aren't concatenated when composite values are encountered
             */
            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, valueType, hierarchyVariationProperty) {
                debug.assertValue(roleName, 'roleName');
                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');
                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map((function (c) { return c.isMeasure; })).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');
                var concatenatedDisplayName;
                // TODO: support RTL concatentation
                if (hierarchyVariationProperty) {
                    // This is the case when we have a Date Hierarchy
                    // show as "[fieldName] [currentDateLevel]" e.g. "Sales Date Year"
                    var currentHierarchyLevelName = _.last(sourceColumnsSortedByProjectionOrdering).displayName;
                    concatenatedDisplayName = concatenateHierarchyAndCurrentLevelDisplayName(hierarchyVariationProperty, currentHierarchyLevelName);
                }
                else {
                    // concatenate all hierarchy field names
                    for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {
                        var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];
                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (concatenatedDisplayName + ' ' + columnSource.displayName);
                    }
                }
                var newRoles = {};
                newRoles[roleName] = true;
                var newColumnMetadata = {
                    displayName: concatenatedDisplayName,
                    roles: newRoles,
                    type: valueType,
                };
                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);
                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {
                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;
                }
                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.
                // If queryName is not set at all, the column chart visual will only render column for the first group instance.
                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).
                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;
                return newColumnMetadata;
            }
            DataViewConcatenateCategoricalColumns.createConcatenatedColumnMetadata = createConcatenatedColumnMetadata;
            function addToMetadata(transformedDataView, newColumn) {
                debug.assertValue(transformedDataView, 'transformedDataView');
                debug.assertValue(newColumn, 'newColumn');
                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);
                transformedColumns.push(newColumn);
                var transformedMetadata = inheritSingle(transformedDataView.metadata);
                transformedMetadata.columns = transformedColumns;
                transformedDataView.metadata = transformedMetadata;
            }
            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues, dataViewObjects) {
                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 1, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 1');
                debug.assertValue(columnMetadata, 'columnMetadata');
                debug.assertValue(concatenatedValues, 'concatenatedValues');
                debug.assertAnyValue(dataViewObjects, 'dataViewObjects');
                var newCategoryColumn = {
                    source: columnMetadata,
                    values: concatenatedValues
                };
                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.
                // So, we'll just take the identities and identityFields from the first column
                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];
                if (firstColumn.identity) {
                    newCategoryColumn.identity = firstColumn.identity;
                }
                if (firstColumn.identityFields) {
                    newCategoryColumn.identityFields = firstColumn.identityFields;
                }
                if (dataViewObjects) {
                    newCategoryColumn.objects = dataViewObjects;
                }
                return newCategoryColumn;
            }
        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var ArrayExtensions = jsCommon.ArrayExtensions;
    var DataViewMapping;
    (function (DataViewMapping) {
        /**
         * Returns dataViewMapping.usage.regression if defined.  Else, returns undefined.
         */
        function getRegressionUsage(dataViewMapping) {
            var regressionUsage = dataViewMapping &&
                dataViewMapping.usage &&
                dataViewMapping.usage.regression;
            // normalize falsy value to undefined
            return regressionUsage || undefined;
        }
        DataViewMapping.getRegressionUsage = getRegressionUsage;
        function getRoles(dataViewMappingPart, visitorFunc) {
            debug.assertAnyValue(dataViewMappingPart, 'dataViewMappingPart');
            debug.assertValue(visitorFunc, 'visitorFunc');
            var roles = [];
            if (dataViewMappingPart) {
                var visitorCallback = {
                    visitRole: function (role) {
                        roles.push(role);
                    }
                };
                visitorFunc(dataViewMappingPart, visitorCallback);
            }
            return roles;
        }
        DataViewMapping.getRoles = getRoles;
        /**
         * Returns true dataViewMapping.usage.forecast if defined.  Else, returns false.
         */
        function isForecastDefined(dataViewMapping) {
            var forecastUsage = dataViewMapping &&
                dataViewMapping.usage &&
                dataViewMapping.usage.forecast;
            return !!forecastUsage;
        }
        DataViewMapping.isForecastDefined = isForecastDefined;
        /**
         * Returns the parameter columns.
         */
        function getParameterColumns(dataViewMapping) {
            var result = [];
            if (dataViewMapping && dataViewMapping.metadata) {
                var metaDataColumns = dataViewMapping.metadata.columns;
                for (var _i = 0, metaDataColumns_1 = metaDataColumns; _i < metaDataColumns_1.length; _i++) {
                    var metaDataColumn = metaDataColumns_1[_i];
                    if (metaDataColumn.parameter)
                        result.push(metaDataColumn);
                }
            }
            return result;
        }
        DataViewMapping.getParameterColumns = getParameterColumns;
        /**
         * Returns the role names returned by the specified rolesGetter if they are the same for all specified roleMappings.
         * Else, returns undefined.
         *
         * @rolesGetter returns all the roles in one of the grouping hierarchy axes (categories or series) or in the measures.
         */
        function getRolesIfSameInAllCategoricalMappings(categoricalRoleMappings, rolesGetter) {
            debug.assertValue(categoricalRoleMappings, 'categoricalRoleMappings');
            debug.assertValue(rolesGetter, 'rolesGetter');
            if (_.size(categoricalRoleMappings) === 0)
                return;
            var rolesOfEachMapping = _.map(categoricalRoleMappings, (function (roleMapping) { return rolesGetter(roleMapping); }));
            var rolesOfFirstMapping = rolesOfEachMapping[0];
            if (rolesOfEachMapping.length >= 2 &&
                !_.every(rolesOfEachMapping, (function (roles) { return ArrayExtensions.sequenceEqual(roles, rolesOfFirstMapping, (function (role1, role2) { return role1 === role2; })); }))) {
                // cannot narrow down to a single projection order...
                return;
            }
            return rolesOfFirstMapping;
        }
        DataViewMapping.getRolesIfSameInAllCategoricalMappings = getRolesIfSameInAllCategoricalMappings;
        /**
         * Returns the array of role names that are mapped to categorical categories.
         * Returns an empty array if none exists.
         */
        function getAllRolesInCategories(categoricalRoleMapping) {
            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');
            // DataViewCategoricalMapping.categories is an optional property.  If undefined, it means no role for categories. 
            if (!categoricalRoleMapping.categories)
                return [];
            var roleNames = [];
            DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {
                visitRole: function (roleName) {
                    roleNames.push(roleName);
                }
            });
            return roleNames;
        }
        DataViewMapping.getAllRolesInCategories = getAllRolesInCategories;
        function targetDataViewKinds(roleMappings) {
            debug.assertAnyValue(roleMappings, 'roleMappings');
            if (!roleMappings)
                return 0 /* None */;
            var result = 0 /* None */;
            for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {
                var roleMapping = roleMappings_1[_i];
                if (roleMapping.categorical)
                    result |= 1 /* Categorical */;
                if (roleMapping.matrix)
                    result |= 2 /* Matrix */;
                if (roleMapping.single)
                    result |= 4 /* Single */;
                if (roleMapping.table)
                    result |= 8 /* Table */;
                if (roleMapping.tree)
                    result |= 16 /* Tree */;
            }
            return result;
        }
        DataViewMapping.targetDataViewKinds = targetDataViewKinds;
    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewMapping;
    (function (DataViewMapping) {
        function visitMapping(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var categorical = mapping.categorical;
            if (categorical)
                visitCategorical(categorical, visitor);
            var table = mapping.table;
            if (table)
                visitTable(table, visitor);
            var matrix = mapping.matrix;
            if (matrix)
                visitMatrix(matrix, visitor);
            var tree = mapping.tree;
            if (tree)
                visitTree(tree, visitor);
            var single = mapping.single;
            if (single)
                visitSingle(single, visitor);
        }
        DataViewMapping.visitMapping = visitMapping;
        function visitCategorical(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitCategoricalCategories(mapping.categories, visitor);
            var values = mapping.values;
            visitCategoricalValues(values, visitor);
            visitGrouped(values, visitor);
            visitReduction(mapping, visitor);
        }
        DataViewMapping.visitCategorical = visitCategorical;
        function visitCategoricalCategories(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitBind(mapping, visitor);
                visitFor(mapping, visitor);
                visitList(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;
        function visitCategoricalValues(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitBind(mapping, visitor, 0 /* CategoricalValue */);
                visitFor(mapping, visitor, 0 /* CategoricalValue */);
                visitList(mapping, visitor, 0 /* CategoricalValue */);
                var group = mapping.group;
                if (group) {
                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {
                        var item = _a[_i];
                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);
                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);
                    }
                }
            }
        }
        DataViewMapping.visitCategoricalValues = visitCategoricalValues;
        function visitTable(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var rows = mapping.rows;
            visitBind(rows, visitor);
            visitFor(rows, visitor);
            visitList(rows, visitor);
            visitReduction(rows, visitor);
        }
        DataViewMapping.visitTable = visitTable;
        function visitMatrix(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitMatrixRows(mapping.rows, visitor);
            visitMatrixColumns(mapping.columns, visitor);
            visitMatrixValues(mapping.values, visitor);
        }
        /**
         * For visiting DataViewMatrixMapping.rows.
         *
         * @param mapping Must be DataViewMatrixMapping.rows.
         * @param visitor The visitor.
         */
        function visitMatrixRows(mapping, visitor) {
            visitMatrixItemsWithComposite(mapping, visitor);
        }
        DataViewMapping.visitMatrixRows = visitMatrixRows;
        /**
         * For visiting DataViewMatrixMapping.columns.
         *
         * @param mapping Must be DataViewMatrixMapping.columns.
         * @param visitor The visitor.
         */
        function visitMatrixColumns(mapping, visitor) {
            // Currently, QueryGenerator does not support composite group on matrix columns because there is no scenario for it yet.
            visitMatrixItems(mapping, visitor);
        }
        DataViewMapping.visitMatrixColumns = visitMatrixColumns;
        /**
         * For visiting DataViewMatrixMapping.values.
         *
         * @param mapping Must be DataViewMatrixMapping.values.
         * @param visitor The visitor.
         */
        function visitMatrixValues(mapping, visitor) {
            visitMatrixItems(mapping, visitor);
        }
        DataViewMapping.visitMatrixValues = visitMatrixValues;
        function visitMatrixItemsWithComposite(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
                visitListWithComposite(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        /**
         * For visiting DataViewMatrixMapping.columns or DataViewMatrixMapping.values, where the composite keyword is not supported.
         */
        function visitMatrixItems(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
                visitList(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        function visitTree(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitTreeNodes(mapping.nodes, visitor);
            visitTreeValues(mapping.values, visitor);
        }
        function visitTreeNodes(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        DataViewMapping.visitTreeNodes = visitTreeNodes;
        function visitTreeValues(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
            }
        }
        DataViewMapping.visitTreeValues = visitTreeValues;
        function visitBind(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var bind = mapping.bind;
            if (bind) {
                if (context != null)
                    visitor.visitRole(bind.to, context);
                else
                    visitor.visitRole(bind.to);
            }
        }
        function visitFor(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var forValue = mapping.for;
            if (forValue) {
                if (context != null)
                    visitor.visitRole(forValue.in, context);
                else
                    visitor.visitRole(forValue.in);
            }
        }
        function visitComposite(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var compositeValues = mapping.composite;
            if (compositeValues) {
                if (visitor.enterComposite)
                    visitor.enterComposite();
                for (var _i = 0, compositeValues_2 = compositeValues; _i < compositeValues_2.length; _i++) {
                    var value = compositeValues_2[_i];
                    visitBind(value, visitor, context);
                    visitFor(value, visitor, context);
                }
                if (visitor.exitComposite)
                    visitor.exitComposite();
            }
        }
        function visitList(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var select = mapping.select;
            if (select) {
                for (var _i = 0, select_3 = select; _i < select_3.length; _i++) {
                    var item = select_3[_i];
                    visitBind(item, visitor, context);
                    visitFor(item, visitor, context);
                }
            }
        }
        function visitListWithComposite(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var select = mapping.select;
            if (select) {
                for (var _i = 0, select_4 = select; _i < select_4.length; _i++) {
                    var item = select_4[_i];
                    visitBind(item, visitor, context);
                    visitFor(item, visitor, context);
                    visitComposite(item, visitor, context);
                }
            }
        }
        function visitGrouped(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (!mapping)
                return;
            var group = mapping.group;
            if (group) {
                visitor.visitRole(group.by);
                visitReduction(group, visitor);
            }
        }
        DataViewMapping.visitGrouped = visitGrouped;
        function visitReduction(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (visitor.visitReduction) {
                var reductionAlgorithm = mapping.dataReductionAlgorithm;
                if (reductionAlgorithm) {
                    visitor.visitReduction(reductionAlgorithm);
                }
            }
        }
        function visitSingle(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitor.visitRole(mapping.role);
        }
    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewNormalizeValues;
        (function (DataViewNormalizeValues) {
            function apply(options) {
                debug.assertValue(options, 'options');
                var rolesToNormalize = _.filter(options.dataRoles, (function (role) { return !_.isEmpty(role.requiredTypes); }));
                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);
            }
            DataViewNormalizeValues.apply = apply;
            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {
                debug.assertValue(dataview, 'dataview');
                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))
                    return;
                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);
                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);
                var usedMappings = {};
                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {
                    var dataViewMapping = dataViewMappings_1[_i];
                    // Get dataview specified in mappings which are also in dataview
                    for (var dataViewMappingProp in dataViewMapping) {
                        if (dataview[dataViewMappingProp] != null)
                            usedMappings[dataViewMappingProp] = true;
                    }
                }
                if (usedMappings['categorical'])
                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);
                if (usedMappings['table'])
                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);
                if (usedMappings['tree'])
                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);
                if (usedMappings['matrix'])
                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);
                if (usedMappings['single'])
                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);
            }
            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;
            function generateMetadataColumnFilter(columns, rolesToNormalize) {
                if (!columns || !rolesToNormalize)
                    return function () { return false; };
                var columnsToNormalize = {};
                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    var roles = column.roles;
                    if (!roles)
                        continue;
                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {
                        var role = rolesToNormalize_1[_a];
                        if (!roles[role.name])
                            continue;
                        columnsToNormalize[column.index] = true;
                        break;
                    }
                }
                return function (columnIndex) {
                    if (isNaN(columnIndex))
                        return false;
                    return !!columnsToNormalize[columnIndex];
                };
            }
            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;
            function generateValueFilter(columns, rolesToNormalize) {
                if (!columns || !rolesToNormalize)
                    return function () { return true; };
                var columnValueFilters = [];
                // Build columnValueFilters based on role requiredTypes
                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
                    var column = columns_2[_i];
                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);
                    if (columnValueFilter)
                        columnValueFilters[column.index] = columnValueFilter;
                }
                return function (columnIndex, value) {
                    if (columnValueFilters[columnIndex])
                        return columnValueFilters[columnIndex](value);
                    return true;
                };
            }
            DataViewNormalizeValues.generateValueFilter = generateValueFilter;
            function generateColumnValueFilter(column, rolesToNormalize) {
                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);
                if (_.isEmpty(requiredTypes))
                    return;
                return function (value) {
                    return doesValueMatchTypes(value, requiredTypes);
                };
            }
            function getColumnRequiredTypes(column, rolesToNormalize) {
                var requiredTypes = [];
                var columnRoles = column && column.roles;
                if (!columnRoles)
                    return requiredTypes;
                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {
                    var role = rolesToNormalize_2[_i];
                    if (!columnRoles[role.name])
                        continue;
                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {
                        var typeDescriptor = _b[_a];
                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);
                        requiredTypes.push(type);
                    }
                }
                return requiredTypes;
            }
            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;
            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {
                var values = dataview && dataview.values;
                if (!values)
                    return;
                var valuesGrouped = values.grouped();
                if (!valuesGrouped)
                    return;
                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {
                    var valueGroup = valuesGrouped_1[_i];
                    var valuesInGroup = valueGroup.values;
                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {
                        var valueColumn = valuesInGroup_1[_a];
                        var columnIndex = valueColumn.source.index;
                        if (!columnFilter(columnIndex))
                            continue;
                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {
                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);
                        }
                    }
                }
            }
            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {
                var columns = dataview && dataview.columns;
                if (!columns)
                    return;
                var filteredColumns = [];
                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {
                    var column = columns_3[_i];
                    if (columnFilter(column.index))
                        filteredColumns.push(column.index);
                }
                var rows = dataview.rows;
                for (var i = 0, ilen = rows.length; i < ilen; i++) {
                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {
                        var index = filteredColumns_1[_a];
                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);
                    }
                }
            }
            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {
                if (node.values) {
                    for (var columnIndex in node.values) {
                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value
                        if (columnFilter(columnIndex)) {
                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.
                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))
                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);
                            else
                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);
                        }
                    }
                }
                else if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);
                    }
                }
            }
            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {
                var root = dataview && dataview.rows && dataview.rows.root;
                if (!root)
                    return;
                // Recurse into rows.children
                // e.g. rows.children -> .children -> .children.values
                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);
            }
            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {
                if (node.values) {
                    for (var id in node.values) {
                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.
                        var nodeValue = node.values[id];
                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value
                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;
                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata
                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;
                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {
                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);
                        }
                    }
                }
                else if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);
                    }
                }
            }
            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {
                if (!dataview.single)
                    return;
                var roleNames = [];
                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {
                    var role = rolesToNormalize_3[_i];
                    if (role.name)
                        roleNames.push(role.name);
                }
                var columns = dataview.metadata.columns;
                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {
                    var dataViewMapping = dataViewMappings_2[_a];
                    var roleName = dataViewMapping.single.role;
                    if (roleNames.indexOf(roleName) !== -1) {
                        var column = firstColumnByRoleName(columns, roleName);
                        if (column)
                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);
                        return;
                    }
                }
            }
            function normalizeVariant(object, key, columnIndex, valueFilter) {
                if (!object)
                    return;
                var value = object[key];
                if (value !== null && !valueFilter(columnIndex, value)) {
                    object = inheritSingle(object);
                    object[key] = null;
                }
                return object;
            }
            DataViewNormalizeValues.normalizeVariant = normalizeVariant;
            function doesValueMatchTypes(value, types) {
                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
                    var type = types_1[_i];
                    if (type.numeric || type.integer)
                        return typeof (value) === 'number';
                }
                return false;
            }
            function firstColumnByRoleName(columns, roleName) {
                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {
                    var column = columns_4[_i];
                    var columnRoles = column && column.roles;
                    if (columnRoles && columnRoles[roleName])
                        return column;
                }
            }
        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewObjects;
    (function (DataViewObjects) {
        /** Gets the value of the given object/property pair. */
        function getValue(objects, propertyId, defaultValue) {
            debug.assertAnyValue(objects, 'objects');
            debug.assertValue(propertyId, 'propertyId');
            debug.assert(propertyId.propertyName.charAt(0) !== '$', 'Properties starting with $ are reserved.');
            if (!objects)
                return defaultValue;
            var object = objects[propertyId.objectName];
            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);
        }
        DataViewObjects.getValue = getValue;
        /** Gets an object from objects. */
        function getObject(objects, objectName, defaultValue) {
            if (objects && objects[objectName]) {
                var object = objects[objectName];
                return object;
            }
            else {
                return defaultValue;
            }
        }
        DataViewObjects.getObject = getObject;
        /** Gets a map of user-defined objects. */
        function getUserDefinedObjects(objects, objectName) {
            var object = getObject(objects, objectName);
            if (!object)
                return;
            return object.$instances;
        }
        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;
        /** Gets the solid color from a fill property. */
        function getFillColor(objects, propertyId, defaultColor) {
            var value = getValue(objects, propertyId);
            if (!value || !value.solid)
                return defaultColor;
            return value.solid.color;
        }
        DataViewObjects.getFillColor = getFillColor;
        /**
         * Merges source DataViewObjects with and into destination
         * Destination will be mutated such that any matching object name and property name will be overwritten
         */
        function mergeObjects(destination, source, selectorId) {
            debug.assertValue(destination, 'DataViewObjects.mergeObjects - destination');
            debug.assertValue(source, 'DataViewObjects.mergeObjects - source');
            for (var objectName in source) {
                var sourceObject = source[objectName];
                if (sourceObject == null)
                    continue;
                var destinationObject = destination[objectName];
                if (!destinationObject) {
                    if (selectorId == null)
                        destination[objectName] = sourceObject;
                    else
                        destination[objectName] = { $instances: (_a = {}, _a[selectorId] = sourceObject, _a) };
                    continue;
                }
                mergeObject(destinationObject, sourceObject, selectorId);
            }
            var _a;
        }
        DataViewObjects.mergeObjects = mergeObjects;
        function mergeObject(destination, source, selectorId) {
            debug.assertValue(destination, 'DataViewObjects.mergeObject - destination');
            debug.assertValue(source, 'DataViewObjects.mergeObject - source');
            debug.assert(source.$instances == null, 'DataViewObjects.mergeObject - source should not include $instances');
            if (selectorId) {
                // Ensure $instances and $instances[id] are there, then merge
                var destinationInstances = destination.$instances;
                if (destinationInstances == null)
                    destinationInstances = destination.$instances = {};
                var destinationObject = destinationInstances[selectorId];
                if (!destinationObject)
                    destinationObject = destinationInstances[selectorId] = {};
                mergeObject(destinationObject, source, null);
            }
            else {
                for (var propertyName in source) {
                    if (propertyName === '$instances')
                        continue;
                    var sourceProperty = source[propertyName];
                    if (sourceProperty != null) {
                        // Set property value or overwrite existing one
                        destination[propertyName] = source[propertyName];
                    }
                }
            }
        }
    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));
    var DataViewObject;
    (function (DataViewObject) {
        function getValue(object, propertyName, defaultValue) {
            debug.assertAnyValue(object, 'object');
            debug.assertValue(propertyName, 'propertyName');
            if (!object)
                return defaultValue;
            var propertyValue = object[propertyName];
            if (propertyValue === undefined)
                return defaultValue;
            return propertyValue;
        }
        DataViewObject.getValue = getValue;
        /** Gets the solid color from a fill property using only a propertyName */
        function getFillColorByPropertyName(object, propertyName, defaultColor) {
            var value = getValue(object, propertyName);
            if (!value || !value.solid)
                return defaultColor;
            return value.solid.color;
        }
        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;
    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));
    var DataViewObjectProperty;
    (function (DataViewObjectProperty) {
        function propertyIdentifiersEqual(a, b) {
            if (a === b)
                return true;
            if (a == null || b == null)
                return false;
            return (a.objectName === b.objectName) && (a.propertyName === b.propertyName);
        }
        DataViewObjectProperty.propertyIdentifiersEqual = propertyIdentifiersEqual;
    })(DataViewObjectProperty = powerbi.DataViewObjectProperty || (powerbi.DataViewObjectProperty = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var JsonComparer = jsCommon.JsonComparer;
        var DataViewObjectDefinitions;
        (function (DataViewObjectDefinitions) {
            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */
            function ensure(defns, objectName, selector) {
                debug.assertValue(defns, 'defns');
                var defnsForObject = defns[objectName];
                if (!defnsForObject)
                    defns[objectName] = defnsForObject = [];
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector))
                        return defn;
                }
                var newDefn = {
                    selector: selector,
                    properties: {},
                };
                defnsForObject.push(newDefn);
                return newDefn;
            }
            DataViewObjectDefinitions.ensure = ensure;
            function updateSelector(defns, objectName, oldSelector, newSelector) {
                debug.assertValue(defns, 'defns');
                var defn = _.find(defns[objectName], (function (defn) { return data.Selector.equals(defn.selector, oldSelector); }));
                if (defn)
                    defn.selector = newSelector;
            }
            DataViewObjectDefinitions.updateSelector = updateSelector;
            /**
             * Delete a object definition from Defns if it matches objName + selector
             * @param {DataViewObjectDefinitions} defns
             * @param {string} objectName
             * @param {Selector} selector
             */
            function deleteObjectDefinition(defns, objectName, selector) {
                debug.assertValue(defns, 'defns');
                var defnsForObject = defns[objectName];
                if (!defnsForObject)
                    return false;
                var wasObjectDeleted = _.remove(defnsForObject, (function (defn) { return data.Selector.equals(defn.selector, selector); })).length > 0;
                if (_.isEmpty(defnsForObject))
                    delete defns[objectName];
                return wasObjectDeleted;
            }
            DataViewObjectDefinitions.deleteObjectDefinition = deleteObjectDefinition;
            /**
             * Removes every property defined in targetDefns from sourceDefns if exists.
             * Properties are matches using ObjectName, Selector, and PropertyName.
             * @param {DataViewObjectDefinition} targetDefns Defenitions to remove properties from
             * @param {DataViewObjectDefinition} sourceDefns Defenitions to match properties against
             */
            function deleteProperties(targetDefns, sourceDefns) {
                if (!targetDefns || !sourceDefns)
                    return;
                for (var objName in sourceDefns) {
                    var objDefns = sourceDefns[objName];
                    for (var _i = 0, objDefns_1 = objDefns; _i < objDefns_1.length; _i++) {
                        var defn = objDefns_1[_i];
                        for (var propName in defn.properties) {
                            deleteProperty(targetDefns, objName, defn.selector, propName);
                        }
                    }
                }
            }
            DataViewObjectDefinitions.deleteProperties = deleteProperties;
            /**
             * Fills in missing properties with default ones, mutating the first definitions.
             * Properties are matched against defaultDefns using ObjectName, Selector, and PropertyName.
             * It just fills missing properties, it doesn't overwrite existing ones.
             * Any property already in targetDefns will not change.
             * Any property in defaultDefns but not in targetDefns will be added by reference.
             * @param {DataViewObjectDefinitions} targetDefns Default definitions. Will be mutated. Expected to be defined
             * @param {DataViewObjectDefinitions} defaultDefns Definitions to fill inside targetDefns
             */
            function extend(targetDefns, defaultDefns) {
                debug.assertValue(targetDefns, "Trying to cascade into undefined DataViewObjectDefinitions");
                if (!targetDefns) {
                    return;
                }
                if (!defaultDefns) {
                    // No need to change targetDefns
                    return;
                }
                for (var objName in defaultDefns) {
                    var defaultObjDefns = defaultDefns[objName];
                    if (!defaultObjDefns) {
                        continue;
                    }
                    var targetObjDefns = targetDefns[objName];
                    if (!targetObjDefns) {
                        targetObjDefns = targetDefns[objName] = [];
                    }
                    extendObjectDefinitions(targetObjDefns, defaultObjDefns);
                }
            }
            DataViewObjectDefinitions.extend = extend;
            function moveProperty(objects, sourceObjectName, selector, propertyName, targetObjectName) {
                var sourceObjectDefinition = getObjectDefinition(objects, sourceObjectName, selector);
                if (!sourceObjectDefinition)
                    return;
                var property = sourceObjectDefinition.properties[propertyName];
                if (property) {
                    var targetObjectDefinition = ensure(objects, targetObjectName, selector);
                    targetObjectDefinition.properties[propertyName] = property;
                    delete sourceObjectDefinition.properties[propertyName];
                }
            }
            DataViewObjectDefinitions.moveProperty = moveProperty;
            function extendObjectDefinitions(targetObjDefns, defaultObjDefns) {
                var found;
                for (var _i = 0, defaultObjDefns_1 = defaultObjDefns; _i < defaultObjDefns_1.length; _i++) {
                    var defaultObjDefn = defaultObjDefns_1[_i];
                    found = false;
                    for (var _a = 0, targetObjDefns_1 = targetObjDefns; _a < targetObjDefns_1.length; _a++) {
                        var targetObjDefn = targetObjDefns_1[_a];
                        if (data.Selector.equals(targetObjDefn.selector, defaultObjDefn.selector)) {
                            extendPropDefns(targetObjDefn.properties, defaultObjDefn.properties);
                            found = true;
                            break; // We are assuming a single match
                        }
                    }
                    if (!found) {
                        var newObjDefn = {
                            selector: defaultObjDefn.selector,
                            properties: {},
                        };
                        extendPropDefns(newObjDefn.properties, defaultObjDefn.properties);
                        targetObjDefns.push(newObjDefn);
                    }
                }
            }
            function extendPropDefns(targetPropDefns, defaultPropDefns) {
                for (var propName in defaultPropDefns) {
                    var defaultPropDefn = defaultPropDefns[propName];
                    // This case handles when a PropertyDefinition is there just to clear existing property
                    if (!defaultPropDefn) {
                        continue;
                    }
                    var targetPropDefn = targetPropDefns[propName];
                    if (!targetPropDefn) {
                        // Copy the Property Definition into propDefns1
                        targetPropDefns[propName] = defaultPropDefn;
                    }
                }
            }
            /**
             * Delete the first matching property from the Defns if it matches objName + selector + propertyName
             * @param {DataViewObjectDefinitions} defns
             * @param {string} objectName
             * @param {Selector} selector
             * @param {string} propertyName
             */
            function deleteProperty(defns, objectName, selector, propertyName) {
                debug.assertValue(defns, 'defns');
                var match = getObjectDefinition(defns, objectName, selector);
                if (match)
                    return DataViewObjectDefinition.deleteSingleProperty(match, propertyName);
            }
            DataViewObjectDefinitions.deleteProperty = deleteProperty;
            /**
             *
             * @param {DataViewObjectDefinitions} defns
             * @param {DataViewObjectPropertyIdentifier} propertyId
             * @param {Selector} selector
             * @param {DataViewObjectPropertyDefinition} value
             */
            function setValue(defns, propertyId, selector, value) {
                debug.assertValue(defns, 'defns');
                debug.assertValue(propertyId, 'propertyId');
                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;
            }
            DataViewObjectDefinitions.setValue = setValue;
            /**
             *
             * @param {DataViewObjectDefinitions} defns
             * @param {DataViewObjectPropertyIdentifier} propertyId
             * @param {Selector} selector
             * @returns
             */
            function getValue(defns, propertyId, selector) {
                var properties = getPropertyContainer(defns, propertyId, selector);
                if (!properties)
                    return;
                return properties[propertyId.propertyName];
            }
            DataViewObjectDefinitions.getValue = getValue;
            function getPropertyContainer(defns, propertyId, selector) {
                var defn = getObjectDefinition(defns, propertyId.objectName, selector);
                if (!defn)
                    return;
                return defn.properties;
            }
            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;
            /**
             * Get the first DataViewObjectDefinition that match selector and objectName
             * @param {DataViewObjectDefinitions} defns DataViewObjectDefinitions to search
             * @param {string} objectName objectName to match
             * @param {Selector} selector selector to match
             * @returns The first match, if any. If no match, returns undefined
             */
            function getObjectDefinition(defns, objectName, selector) {
                debug.assertAnyValue(defns, 'defns');
                debug.assertValue(objectName, 'objectName');
                debug.assertAnyValue(selector, 'selector');
                if (!defns)
                    return;
                var defnsForObject = defns[objectName];
                if (!defnsForObject)
                    return;
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector))
                        return defn;
                }
            }
            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;
            function propertiesAreEqual(a, b) {
                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {
                    return data.SemanticFilter.isSameFilter(a, b);
                }
                return JsonComparer.equals(a, b);
            }
            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;
            function allPropertiesAreEqual(a, b) {
                debug.assertValue(a, 'a');
                debug.assertValue(b, 'b');
                if (Object.keys(a).length !== Object.keys(b).length)
                    return false;
                for (var property in a) {
                    if (!propertiesAreEqual(a[property], b[property]))
                        return false;
                }
                return true;
            }
            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;
            function getUnequalProperties(a, b) {
                debug.assertValue(a, 'a');
                debug.assertValue(b, 'b');
                var unequalProperties = [];
                for (var property in a) {
                    if (!propertiesAreEqual(a[property], b[property])) {
                        unequalProperties.push(property);
                    }
                }
                for (var property in b) {
                    if (_.contains(unequalProperties, property)) {
                        continue;
                    }
                    if (!propertiesAreEqual(a[property], b[property])) {
                        unequalProperties.push(property);
                    }
                }
                return unequalProperties;
            }
            DataViewObjectDefinitions.getUnequalProperties = getUnequalProperties;
            function encodePropertyValue(value, valueTypeDescriptor) {
                debug.assertAnyValue(value, 'value');
                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');
                if (valueTypeDescriptor.bool) {
                    if (typeof (value) !== 'boolean')
                        value = false; // This is fallback, which doesn't really belong here.
                    return data.SQExprBuilder.boolean(value);
                }
                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {
                    return data.SQExprBuilder.text(value);
                }
                else if (valueTypeDescriptor.numeric) {
                    if ($.isNumeric(value))
                        return data.SQExprBuilder.double(+value);
                }
                else if (valueTypeDescriptor.integer) {
                    if ($.isNumeric(value))
                        return data.SQExprBuilder.integer(Math.floor(+value));
                }
                else if (valueTypeDescriptor.fill) {
                    if (value) {
                        return {
                            solid: { color: data.SQExprBuilder.text(value) }
                        };
                    }
                }
                else if (valueTypeDescriptor.formatting) {
                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {
                        return data.SQExprBuilder.double(+value);
                    }
                    else {
                        return data.SQExprBuilder.text(value);
                    }
                }
                else if (valueTypeDescriptor.enumeration) {
                    if ($.isNumeric(value))
                        return data.SQExprBuilder.double(+value);
                    else
                        return data.SQExprBuilder.text(value);
                }
                else if (valueTypeDescriptor.misc) {
                    if (value) {
                        value = data.SQExprBuilder.text(value);
                    }
                    else {
                        value = null;
                    }
                }
                else if (valueTypeDescriptor.dateTime) {
                    if (value) {
                        value = data.SQExprBuilder.dateTime(value);
                    }
                    else {
                        value = null;
                    }
                }
                else if (valueTypeDescriptor.image) {
                    if (value) {
                        var imageValue = value;
                        var imageDefinition = {
                            name: data.SQExprBuilder.text(imageValue.name),
                            url: data.SQExprBuilder.text(imageValue.url),
                        };
                        if (imageValue.scaling)
                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);
                        return imageDefinition;
                    }
                }
                else if (valueTypeDescriptor.geoJson) {
                    if (value) {
                        var geoJsonValue = value;
                        var geoJsonDefinition = {
                            type: data.SQExprBuilder.text(geoJsonValue.type),
                            name: data.SQExprBuilder.text(geoJsonValue.name),
                            content: !geoJsonValue.content ? data.SQExprBuilder.nullConstant() : data.SQExprBuilder.text(geoJsonValue.content),
                        };
                        return geoJsonDefinition;
                    }
                }
                // TODO: Defect 10568573:TS2.4 Upgrade - dataViewObjectDefinition - encodePropertyValue - Type 'DataViewPropertyValue' is not assignable to type 'DataViewObjectPropertyDefinition'.
                return value;
            }
            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;
            function clone(original) {
                debug.assertValue(original, 'original');
                var cloned = {};
                for (var objectName in original) {
                    var originalDefns = original[objectName];
                    if (_.isEmpty(originalDefns))
                        continue;
                    var clonedDefns = [];
                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {
                        var originalDefn = originalDefns_1[_i];
                        clonedDefns.push({
                            properties: cloneProperties(originalDefn.properties),
                            selector: originalDefn.selector,
                        });
                    }
                    cloned[objectName] = clonedDefns;
                }
                return cloned;
            }
            DataViewObjectDefinitions.clone = clone;
            function cloneProperties(original) {
                debug.assertValue(original, 'original');
                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.
                return _.clone(original);
            }
            function visitPropertyExprs(options) {
                var definitions = options.definitions;
                var descriptors = options.descriptors;
                var visitor = options.visitor;
                debug.assertValue(definitions, "definitions");
                debug.assertValue(visitor, "visitor");
                var propertyPath = [];
                var visitorState = {
                    stopVisiting: false,
                };
                function visit(container, key, propertyType) {
                    var value = container[key];
                    if (value instanceof data.SQExpr) {
                        visitor(value, container, key, propertyType, propertyPath, visitorState);
                    }
                    else if (typeof value === "object") {
                        for (var subkey in value) {
                            if (visitorState.stopVisiting)
                                return;
                            propertyPath.push(subkey);
                            visit(value, subkey, propertyType);
                            propertyPath.pop();
                        }
                    }
                }
                for (var objectName in definitions) {
                    if (!_.isEmpty(definitions[objectName])) {
                        var objectDescriptor = descriptors && descriptors[objectName];
                        for (var _i = 0, _a = definitions[objectName]; _i < _a.length; _i++) {
                            var objectDefinition = _a[_i];
                            var objectProperties = objectDefinition.properties;
                            if (objectProperties) {
                                for (var propertyName in objectProperties) {
                                    if (visitorState.stopVisiting)
                                        return;
                                    var propertyDescriptor = objectDescriptor && objectDescriptor.properties[propertyName];
                                    visit(objectProperties, propertyName, propertyDescriptor && propertyDescriptor.type);
                                }
                            }
                        }
                    }
                }
            }
            DataViewObjectDefinitions.visitPropertyExprs = visitPropertyExprs;
        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));
        var DataViewObjectDefinition;
        (function (DataViewObjectDefinition) {
            function deleteSingleProperty(defn, propertyName) {
                var properties = defn.properties;
                if (propertyName in properties) {
                    // NOTE: We decided that delete is acceptable here and that we don't need optimization here
                    delete defn.properties[propertyName];
                    return true;
                }
            }
            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;
            /**
             * Determines if a given property name is valid.
             */
            function isValidPropertyName(propertyName) {
                // Property names starting with the '$' character are reserved for internal use, e.g. $instances.
                return !_.startsWith(propertyName, '$');
            }
            DataViewObjectDefinition.isValidPropertyName = isValidPropertyName;
        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewObjectDescriptors;
        (function (DataViewObjectDescriptors) {
            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */
            function findFormatString(descriptors) {
                return findProperty(descriptors, (function (propDesc) {
                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;
                    return formattingTypeDesc && formattingTypeDesc.formatString;
                }));
            }
            DataViewObjectDescriptors.findFormatString = findFormatString;
            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */
            function findFilterOutput(descriptors) {
                return findProperty(descriptors, (function (propDesc) {
                    var propType = propDesc.type;
                    return propType && propType.filter && !propType.filter.selfFilter;
                }));
            }
            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;
            /** Attempts to find the self filter property. */
            function findSelfFilter(descriptors) {
                return findProperty(descriptors, isSelfFilter);
            }
            DataViewObjectDescriptors.findSelfFilter = findSelfFilter;
            function isSelfFilter(descriptor) {
                var propType = descriptor && descriptor.type;
                return propType && propType.filter && propType.filter.selfFilter;
            }
            DataViewObjectDescriptors.isSelfFilter = isSelfFilter;
            /** Attempts to find the self filter enabled property. */
            function findSelfFilterEnabled(descriptors) {
                return findProperty(descriptors, (function (propDesc) {
                    var propType = propDesc.type;
                    return propType && propType.operations && propType.operations.searchEnabled;
                }));
            }
            DataViewObjectDescriptors.findSelfFilterEnabled = findSelfFilterEnabled;
            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */
            function findDefaultValue(descriptors) {
                return findProperty(descriptors, (function (propDesc) {
                    var propType = propDesc.type;
                    return propType && !!propType.expression && propType.expression.defaultValue;
                }));
            }
            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;
            /**
             * Finds the property descriptor by Property Identifier
             */
            function findPropertyById(descriptors, propertyId) {
                debug.assertValue(descriptors, 'descriptors');
                debug.assertValue(propertyId, 'propertyId');
                if (_.isEmpty(descriptors))
                    return;
                var objectDescriptor = descriptors[propertyId.objectName];
                if (!objectDescriptor || _.isEmpty(objectDescriptor.properties))
                    return;
                return objectDescriptor.properties[propertyId.propertyName];
            }
            DataViewObjectDescriptors.findPropertyById = findPropertyById;
            function findProperty(descriptors, propPredicate) {
                debug.assertAnyValue(descriptors, 'descriptors');
                debug.assertAnyValue(propPredicate, 'propPredicate');
                if (!descriptors)
                    return;
                for (var objectName in descriptors) {
                    var objPropDescs = descriptors[objectName].properties;
                    for (var propertyName in objPropDescs) {
                        if (propPredicate(objPropDescs[propertyName])) {
                            return {
                                objectName: objectName,
                                propertyName: propertyName,
                            };
                        }
                    }
                }
            }
        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
 *  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
*
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewObjectEvaluationUtils;
        (function (DataViewObjectEvaluationUtils) {
            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefns, 'objectDefns');
                var objects;
                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {
                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;
                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);
                    if (!evaluatedObject)
                        continue;
                    if (!objects)
                        objects = {};
                    // NOTE: this currently has last-object-wins semantics.
                    objects[objectName] = evaluatedObject;
                }
                return objects;
            }
            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;
            function groupObjectsBySelector(objectDefinitions) {
                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');
                var grouped = {
                    data: [],
                };
                if (objectDefinitions) {
                    for (var objectName in objectDefinitions) {
                        var objectDefnList = objectDefinitions[objectName];
                        for (var i = 0, len = objectDefnList.length; i < len; i++) {
                            var objectDefn = objectDefnList[i];
                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({
                                name: objectName,
                                properties: objectDefn.properties,
                            });
                        }
                    }
                }
                return grouped;
            }
            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;
            function ensureDefinitionListForSelector(grouped, selector) {
                debug.assertValue(grouped, 'grouped');
                debug.assertAnyValue(selector, 'selector');
                var groupedObjects;
                if (selector && selector.data) {
                    groupedObjects = grouped.data;
                }
                else if (selector && selector.metadata) {
                    if (!grouped.metadata)
                        grouped.metadata = [];
                    groupedObjects = grouped.metadata;
                }
                else {
                    if (!grouped.metadataOnce)
                        grouped.metadataOnce = [];
                    groupedObjects = grouped.metadataOnce;
                }
                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');
                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {
                    var item_1 = groupedObjects_1[_i];
                    if (data.Selector.equals(selector, item_1.selector))
                        return item_1;
                }
                var item = {
                    selector: selector,
                    objects: [],
                };
                groupedObjects.push(item);
                return item;
            }
            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(columns, 'columns');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                if (selectTransforms) {
                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);
                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);
                }
            }
            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;
            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(columns, 'columns');
                debug.assertValue(selectTransforms, 'selectTransforms');
                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);
                if (!formatStringProp)
                    return;
                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {
                    var selectTransform = selectTransforms[selectIdx];
                    if (!selectTransform)
                        continue;
                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');
                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));
                }
            }
            /** Registers properties for default value, if the properties are not explicitly provided. */
            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(columns, 'columns');
                debug.assertValue(selectTransforms, 'selectTransforms');
                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);
                if (!defaultValueProp)
                    return;
                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {
                    var selectTransform = selectTransforms_1[_i];
                    if (!selectTransform)
                        continue;
                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');
                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);
                }
            }
            function getColumnFormatForIndex(columns, selectIdx) {
                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {
                    var column = columns[columnIdx];
                    if (!column || column.index !== selectIdx)
                        continue;
                    return column.format;
                }
            }
            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {
                if (!formatStringValue)
                    return;
                // There is a format string specified -- apply it as an object property, if there is not already one specified.
                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));
            }
            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {
                if (!defaultValue)
                    return;
                // There is a default value specified -- apply it as an object property, if there is not already one specified.
                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);
            }
            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {
                var objectDefns;
                if (selector) {
                    var metadataObjects = objectsForAllSelectors.metadata;
                    if (!metadataObjects)
                        metadataObjects = objectsForAllSelectors.metadata = [];
                    objectDefns = metadataObjects;
                }
                else {
                    var metadataOnce = objectsForAllSelectors.metadataOnce;
                    if (!metadataOnce)
                        metadataOnce = objectsForAllSelectors.metadataOnce = [{ selector: selector, objects: [] }];
                    objectDefns = metadataOnce;
                }
                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);
                var targetObjectDefn;
                if (targetMetadataObject) {
                    var targetObjectDefns = targetMetadataObject.objects;
                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);
                    if (targetObjectDefn) {
                        if (targetObjectDefn.properties[propertyId.propertyName])
                            return;
                    }
                    else {
                        targetObjectDefn = {
                            name: propertyId.objectName,
                            properties: {},
                        };
                        targetObjectDefns.push(targetObjectDefn);
                    }
                }
                else {
                    targetObjectDefn = {
                        name: propertyId.objectName,
                        properties: {}
                    };
                    objectDefns.push({
                        selector: selector,
                        objects: [targetObjectDefn],
                    });
                }
                targetObjectDefn.properties[propertyId.propertyName] = value;
            }
            function findWithMatchingSelector(objects, selector) {
                debug.assertValue(objects, 'objects');
                debug.assertAnyValue(selector, 'selector');
                for (var i = 0, len = objects.length; i < len; i++) {
                    var object = objects[i];
                    if (data.Selector.equals(object.selector, selector))
                        return object;
                }
            }
            function findExistingObject(objectDefns, objectName) {
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(objectName, 'objectName');
                for (var i = 0, len = objectDefns.length; i < len; i++) {
                    var objectDefn = objectDefns[i];
                    if (objectDefn.name === objectName)
                        return objectDefn;
                }
            }
        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var Color = jsCommon.Color;
        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */
        var DataViewObjectEvaluator;
        (function (DataViewObjectEvaluator) {
            var boolType = powerbi.ValueType.fromDescriptor({ bool: true });
            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });
            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });
            var textType = powerbi.ValueType.fromDescriptor({ text: true });
            var nullStrategyType = powerbi.ValueType.fromDescriptor({ enumeration: powerbi.NullStrategy.type });
            var fillColorType = { fill: { solid: { color: true } } };
            function run(evalContext, objectDescriptor, propertyDefinitions) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');
                debug.assertValue(propertyDefinitions, 'propertyDefinitions');
                if (!objectDescriptor)
                    return;
                var object, propertyDescriptors = objectDescriptor.properties;
                for (var propertyName in propertyDefinitions) {
                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];
                    if (!propertyDescriptor)
                        continue;
                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);
                    if (propertyValue === undefined)
                        continue;
                    if (!object)
                        object = {};
                    object[propertyName] = propertyValue;
                }
                return object;
            }
            DataViewObjectEvaluator.run = run;
            /** Note: Exported for testability */
            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(propertyDescriptor, 'propertyDescriptor');
                debug.assertValue(propertyDefinition, 'propertyDefinition');
                var structuralType = propertyDescriptor.type;
                if (structuralType && structuralType.expression)
                    return propertyDefinition;
                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));
                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))
                    return value;
                return evaluateFill(evalContext, propertyDefinition, structuralType)
                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)
                    || evaluateImage(evalContext, propertyDefinition, structuralType)
                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)
                    || evaluateGeoJson(evalContext, propertyDefinition, structuralType)
                    || evaluateDataBars(evalContext, propertyDefinition, structuralType)
                    || propertyDefinition;
            }
            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;
            function evaluateFill(evalContext, fillDefn, type) {
                var fillType = type.fill;
                if (!fillType)
                    return;
                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {
                    return {
                        solid: {
                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(19664897 /* Color */)),
                        }
                    };
                }
            }
            // Exported for testability
            function evaluateFillRule(evalContext, fillRuleDefn, type) {
                if (!type.fillRule)
                    return;
                var output;
                if (fillRuleDefn.linearGradient2) {
                    var input = fillRuleDefn.linearGradient2;
                    output = {
                        linearGradient2: {
                            min: evaluateColorStop(evalContext, input.min),
                            max: evaluateColorStop(evalContext, input.max),
                        }
                    };
                    var strategy = evaluateNullStrategy(evalContext, input.nullColoringStrategy);
                    if (strategy)
                        output.linearGradient2.nullColoringStrategy = strategy;
                }
                else if (fillRuleDefn.linearGradient3) {
                    var input = fillRuleDefn.linearGradient3;
                    output = {
                        linearGradient3: {
                            min: evaluateColorStop(evalContext, input.min),
                            mid: evaluateColorStop(evalContext, input.mid),
                            max: evaluateColorStop(evalContext, input.max),
                        }
                    };
                    var strategy = evaluateNullStrategy(evalContext, input.nullColoringStrategy);
                    if (strategy)
                        output.linearGradient3.nullColoringStrategy = strategy;
                }
                return output;
            }
            DataViewObjectEvaluator.evaluateFillRule = evaluateFillRule;
            function evaluateColorStop(evalContext, colorStop) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(colorStop, 'colorStop');
                var step = {
                    color: evaulateColor(evalContext, colorStop.color),
                };
                var value = evaluateValue(evalContext, colorStop.value, numericType);
                if (value != null)
                    step.value = value;
                return step;
            }
            function evaulateColor(evalContext, color) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(color, 'evaulateColor - color');
                return evaluateValue(evalContext, color, colorValueType);
            }
            function evaluateNullStrategy(evalContext, input) {
                if (!input)
                    return;
                debug.assertValue(evalContext, 'evaluateNullStrategy - undefined evalContext');
                debug.assertValue(input.strategy, 'evaluateNullStrategy - undefined strategy');
                var output = {
                    strategy: evaluateValue(evalContext, input.strategy, nullStrategyType),
                };
                if (input.color)
                    output.color = evaulateColor(evalContext, input.color);
                return output;
            }
            function evaluateImage(evalContext, definition, type) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(definition, 'definition');
                debug.assertValue(type, 'type');
                if (!type.image || !definition)
                    return;
                var value = {
                    name: evaluateValue(evalContext, definition.name, textType),
                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),
                };
                if (definition.scaling)
                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);
                return value;
            }
            function evaluateParagraphs(evalContext, definition, type) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(definition, 'definition');
                debug.assertValue(type, 'type');
                if (!type.paragraphs || !definition)
                    return;
                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);
            }
            function evaluateParagraph(evalContext, definition) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(definition, 'definition');
                var evaluated;
                var definitionTextRuns = definition.textRuns;
                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);
                if (definitionTextRuns !== evaluatedTextRuns) {
                    evaluated = _.clone(definition);
                    evaluated.textRuns = evaluatedTextRuns;
                }
                return evaluated || definition;
            }
            function evaluateTextRun(evalContext, definition) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(definition, 'definition');
                var evaluated;
                var definitionValue = definition.value;
                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);
                if (evaluatedValue !== undefined) {
                    evaluated = _.clone(definition);
                    evaluated.value = evaluatedValue;
                    evaluated.valueExpr = definitionValue;
                }
                return evaluated || definition;
            }
            function evaluateGeoJson(evalContext, definition, type) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(definition, 'definition');
                debug.assertValue(type, 'type');
                if (!type.geoJson || !definition)
                    return;
                var value = {
                    name: evaluateValue(evalContext, definition.name, textType),
                    type: evaluateValue(evalContext, definition.type, textType),
                    content: evaluateValue(evalContext, definition.content, textType),
                };
                return value;
            }
            function evaluateDataBars(evalContext, dataBarsDefn, type) {
                var dataBarsType = type.dataBars;
                if (!dataBarsType)
                    return;
                return {
                    minValue: evaluateValue(evalContext, dataBarsDefn.minValue, numericType),
                    maxValue: evaluateValue(evalContext, dataBarsDefn.maxValue, numericType),
                    positiveColor: evaluateFill(evalContext, dataBarsDefn.positiveColor, fillColorType),
                    negativeColor: evaluateFill(evalContext, dataBarsDefn.negativeColor, fillColorType),
                    axisColor: evaluateFill(evalContext, dataBarsDefn.axisColor, fillColorType),
                    reverseDirection: evaluateValue(evalContext, dataBarsDefn.reverseDirection, boolType),
                    hideText: evaluateValue(evalContext, dataBarsDefn.hideText, boolType),
                };
            }
            /**
             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something
             * other than the input to it.
             */
            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(definitions, 'definitions');
                debug.assertValue(evaluator, 'evaluator');
                var evaluatedValues;
                for (var i = 0, len = definitions.length; i < len; i++) {
                    var definition = definitions[i];
                    var evaluated = evaluator(evalContext, definition);
                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship
                    // between TEvaluated & TDefinition
                    if (!evaluatedValues && definition !== evaluated) {
                        evaluatedValues = _.take(definitions, i);
                    }
                    if (evaluatedValues) {
                        evaluatedValues.push(evaluated);
                    }
                }
                return evaluatedValues || definitions;
            }
            function evaluateValue(evalContext, definition, valueType) {
                if (definition instanceof data.SQExpr)
                    return ExpressionEvaluator.evaluate(definition, evalContext);
                if (definition instanceof data.RuleEvaluation)
                    return definition.evaluate(evalContext);
            }
            DataViewObjectEvaluator.evaluateValue = evaluateValue;
            /** Responsible for evaluating SQExprs into values. */
            var ExpressionEvaluator = /** @class */ (function (_super) {
                __extends(ExpressionEvaluator, _super);
                function ExpressionEvaluator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                ExpressionEvaluator.evaluate = function (expr, evalContext) {
                    if (expr == null)
                        return;
                    return expr.accept(ExpressionEvaluator.instance, evalContext);
                };
                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {
                    return expr.value;
                };
                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {
                    var inputValue = expr.input.accept(this, evalContext);
                    if (inputValue !== undefined) {
                        var colorAllocator = evalContext.getColorAllocator(expr);
                        if (colorAllocator) {
                            return colorAllocator.color(inputValue);
                        }
                    }
                };
                ExpressionEvaluator.prototype.visitPercentile = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitSelectRef = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitThemeColor = function (expr, evalContext) {
                    var baseColor = evalContext.getThemeColor(expr.color);
                    if (baseColor)
                        return Color.shadeColor(baseColor, expr.percent);
                };
                ExpressionEvaluator.prototype.visitAnd = function (expr, evalContext) {
                    return expr.left.accept(ExpressionEvaluator.instance, evalContext) &&
                        expr.right.accept(ExpressionEvaluator.instance, evalContext);
                };
                ExpressionEvaluator.prototype.visitCompare = function (expr, evalContext) {
                    // Comparing NaN against anything, even itself, fails
                    var leftValue = ExpressionEvaluator.evaluate(expr.left, evalContext);
                    if (_.isNaN(leftValue))
                        return false;
                    var rightValue = ExpressionEvaluator.evaluate(expr.right, evalContext);
                    if (_.isNaN(rightValue))
                        return false;
                    var comparison = expr.comparison;
                    // Comparing NULL succeeds iff with equality against NULL
                    if (rightValue === null || leftValue === null)
                        return rightValue === leftValue &&
                            (comparison === 0 /* Equal */ ||
                                comparison === 2 /* GreaterThanOrEqual */ ||
                                comparison === 4 /* LessThanOrEqual */);
                    switch (comparison) {
                        case 0 /* Equal */:
                            return leftValue === rightValue;
                        case 1 /* GreaterThan */:
                            return leftValue > rightValue;
                        case 2 /* GreaterThanOrEqual */:
                            return leftValue >= rightValue;
                        case 3 /* LessThan */:
                            return leftValue < rightValue;
                        case 4 /* LessThanOrEqual */:
                            return leftValue <= rightValue;
                    }
                };
                /**
                 *  Evaluates the Conditional SQExpr by finding the first Case that would be evaluated to TRUE and return its Value
                 */
                ExpressionEvaluator.prototype.visitConditional = function (expr, evalContext) {
                    var cases = expr.cases;
                    debug.assertNonEmpty(cases, 'ExpressionEvaluator.visitConditional - Empty cases');
                    if (!_.isEmpty(cases)) {
                        for (var _i = 0, cases_1 = cases; _i < cases_1.length; _i++) {
                            var conditionalCase = cases_1[_i];
                            var condition = conditionalCase.condition;
                            var value = conditionalCase.value;
                            if (ExpressionEvaluator.evaluate(condition, evalContext) === true)
                                return ExpressionEvaluator.evaluate(value, evalContext);
                        }
                    }
                    return ExpressionEvaluator.evaluate(expr.defaultValue, evalContext);
                };
                ExpressionEvaluator.instance = new ExpressionEvaluator();
                return ExpressionEvaluator;
            }(data.DefaultSQExprVisitorWithArg));
        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inheritSingle = powerbi.Prototype.inheritSingle;
        /** Responsible for evaluating and setting DataViewCategorical's values grouped() function. */
        var DataViewCategoricalEvalGrouped;
        (function (DataViewCategoricalEvalGrouped) {
            function apply(categorical) {
                debug.assertValue(categorical, 'categorical');
                var valueColumns = categorical.values;
                if (!valueColumns)
                    return;
                var isDynamicSeries = !!valueColumns.source;
                // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property
                var valueGroups;
                if (isDynamicSeries) {
                    // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.
                    // Also, exclude any column that belongs to a static series.
                    valueGroups = inheritSingle(valueColumns.grouped());
                    // This function gets invoked twice, 1st time after column sources have been rewritten, and 2nd time if values column gets removed or reordered by projection. 
                    // When a DataViewCategorical has no data (i.e. empty data source or everything gets filtered out), there is no way to distinguish
                    // whether a measure column is for the dynamic or static series scope, because its identity is undefined.
                    // But in the no-data case, it is OK to err on the side of putting the measure in the empty dynamic series group instance, because:
                    // 1) If this is a categorical with scalarKeys, then in the 1st invocation the empty scalarKeys column will get incorrectly grouped under the empty dynamic value group,
                    //    but on 2nd invocation it will get removed anyway because the column has no roles.
                    // 2) If this is the "column values split" of a categorical for combo chart, then any static series measure will just get removed before the 2nd invocation.
                    // 3) If this is the "line values split" of a categorical for combo chart, then any secondary axis field and dynamic series measures will get removed before the 2nd invocation.
                    var isDataEmpty = data.DataViewCategoricalUtils.getRowCount(categorical) === 0;
                    var isFirstColumnInDynamicSeries = valueColumns.length >= 1 &&
                        (isDataEmpty || _.first(valueColumns).identity !== undefined);
                    if (!_.isEmpty(valueColumns) && isFirstColumnInDynamicSeries) {
                        var nextSeriesGroupIndex = 0;
                        var currentSeriesGroup = void 0;
                        for (var i = 0, ilen = valueColumns.length; i < ilen; i++) {
                            var currentValueColumn = valueColumns[i];
                            if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {
                                var existingSeriesGroup = valueGroups[nextSeriesGroupIndex];
                                if (existingSeriesGroup) {
                                    currentSeriesGroup = inheritSingle(existingSeriesGroup);
                                }
                                else {
                                    debug.assert(!currentValueColumn.identity, '!currentValueColumn.identity -- Extra valueGroup items should be statics (no identity).');
                                    currentSeriesGroup = existingSeriesGroup = valueGroups[nextSeriesGroupIndex] = { values: null };
                                }
                                valueGroups[nextSeriesGroupIndex] = currentSeriesGroup;
                                currentSeriesGroup.values = [];
                                nextSeriesGroupIndex++;
                                debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');
                            }
                            currentSeriesGroup.values.push(currentValueColumn);
                        }
                    }
                    else {
                        // If there are no measures under dynamic series, just make sure that the .values of each valueGroup is empty.
                        for (var i = 0, ilen = valueGroups.length; i < ilen; i++) {
                            var group = valueGroups[i];
                            if (!_.isEmpty(group.values)) {
                                valueGroups[i] = group = inheritSingle(group);
                                group.values = [];
                            }
                        }
                    }
                }
                else {
                    // We are in a static series, so we should throw away the grouped and recreate it using the static values
                    //   which have already been filtered
                    valueGroups = [{ values: valueColumns }];
                }
                valueColumns.grouped = function () { return valueGroups; };
                categorical.values = valueColumns;
            }
            DataViewCategoricalEvalGrouped.apply = apply;
        })(DataViewCategoricalEvalGrouped = data.DataViewCategoricalEvalGrouped || (data.DataViewCategoricalEvalGrouped = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewMatrixProjectionOrder;
        (function (DataViewMatrixProjectionOrder) {
            function apply(prototype, matrixMapping, projectionOrdering, context) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(matrixMapping, 'matrixMapping');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertValue(context, 'context');
                var transformingMatrix = prototype;
                if (projectionOrdering) {
                    transformingMatrix = projectMeasures(transformingMatrix, matrixMapping, projectionOrdering, context);
                    transformingMatrix = reorderCompositeGroups(transformingMatrix, matrixMapping, projectionOrdering);
                }
                return transformingMatrix;
            }
            DataViewMatrixProjectionOrder.apply = apply;
            /**
             * Re-orders matrix intersection values and measure headers, by projection ordering.
             */
            function projectMeasures(prototype, matrixRoleMapping, projectionOrdering, context) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(matrixRoleMapping, 'matrixRoleMapping');
                debug.assertValue(projectionOrdering, 'projectionOrdering');
                debug.assertValue(context, 'context');
                if (!projectionOrdering)
                    return prototype;
                var valuesRoleNames = powerbi.DataViewMapping.getRoles(matrixRoleMapping.values, powerbi.DataViewMapping.visitMatrixValues);
                if (_.isEmpty(valuesRoleNames)) {
                    return prototype;
                }
                var valueSources = prototype.valueSources;
                var projectionOrderingForValuesRoles = getCombinedProjectionOrdering(projectionOrdering, valuesRoleNames);
                if (_.isEmpty(valueSources) || isEqualProjectionOrdering(prototype.valueSources, projectionOrderingForValuesRoles)) {
                    return prototype;
                }
                var jointMetadataColumns = data.DataViewMetadataColumnUtils
                    .leftJoinMetadataColumnsAndProjectionOrder(valueSources, projectionOrderingForValuesRoles, valuesRoleNames);
                var jointMetadataColumnsOrderedByProjection = _.chain(jointMetadataColumns)
                    .filter((function (column) { return column.projectionOrderIndex !== undefined; }))
                    .sortBy((function (column) { return column.projectionOrderIndex; }))
                    .value();
                var matrix = inheritSingle(prototype);
                // project values in each intersection row
                matrix.rows = projectIntersectionValues(matrix.rows, /* originalValueSources */ matrix.valueSources, jointMetadataColumnsOrderedByProjection);
                // fix up valueSources
                var projectedValueSources = _.map(jointMetadataColumnsOrderedByProjection, (function (jointMetadataColumn) { return jointMetadataColumn.metadataColumn; }));
                matrix.valueSources = projectedValueSources;
                // fix up measure headers
                matrix.columns = DataViewMatrixMeasureHeaders.update(matrix.columns, projectedValueSources.slice());
                context.hierarchyTreesRewritten = true;
                return matrix;
            }
            function getCombinedProjectionOrdering(projectionOrdering, roles) {
                debug.assertValue(projectionOrdering, 'projectionOrdering');
                debug.assertValue(roles, 'roles');
                var combinedOrdering = [];
                for (var _i = 0, roles_1 = roles; _i < roles_1.length; _i++) {
                    var role = roles_1[_i];
                    var roleProjectionOrdering = projectionOrdering[role];
                    if (!_.isEmpty(roleProjectionOrdering)) {
                        combinedOrdering.push.apply(combinedOrdering, roleProjectionOrdering);
                    }
                }
                return combinedOrdering;
            }
            function isEqualProjectionOrdering(valueSources, valueProjectionOrdering) {
                debug.assertValue(valueSources, 'valueSources');
                debug.assertValue(valueProjectionOrdering, 'valueProjectionOrdering');
                var currentSelectIndices = _.map(valueSources, (function (valueSource) { return valueSource.index; }));
                return ArrayExtensions.sequenceEqual(currentSelectIndices, valueProjectionOrdering, (function (a, b) { return a === b; }));
            }
            function projectIntersectionValues(prototypeRowHierarchy, originalValueSources, projectedValueSourceEntries) {
                debug.assertValue(prototypeRowHierarchy, 'prototypeRowHierarchy');
                debug.assertNonEmpty(originalValueSources, 'originalValueSources'); // otherwise this code can get a divide-by-zero error
                debug.assertValue(projectedValueSourceEntries, 'projectedValueSourceEntries');
                var originalValueSourcesLength = originalValueSources.length;
                var projectingValueSourcesLength = projectedValueSourceEntries.length;
                var columnGroupInstanceCount;
                var rowHierarchy = inheritSingle(prototypeRowHierarchy);
                rowHierarchy.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(rowHierarchy.root, (function (node) {
                    var originalValues = node.values;
                    if (!originalValues)
                        return;
                    // calculate columnGroupInstanceCount on first leaf node:
                    if (columnGroupInstanceCount === undefined) {
                        debug.assert(Object.keys(node.values).length % originalValueSourcesLength === 0, 'expecting the intersection values to have one value per measure column per column group instance');
                        columnGroupInstanceCount = Object.keys(node.values).length / originalValueSourcesLength;
                    }
                    debug.assert(columnGroupInstanceCount === (Object.keys(node.values).length / originalValueSourcesLength), 'expecting every interaction values collection to have the same length');
                    if (projectingValueSourcesLength > 0) {
                        // if at least one measure column is being projected...
                        var projectedValues = {};
                        // for each column group instance (e.g. 'Canada', 'US', ...)
                        for (var columnGroupInstanceIndex = 0; columnGroupInstanceIndex < columnGroupInstanceCount; columnGroupInstanceIndex++) {
                            var offsetInOriginalValues = columnGroupInstanceIndex * originalValueSourcesLength;
                            var offsetInProjectedValues = columnGroupInstanceIndex * projectingValueSourcesLength;
                            // for each measure value source being projected (e.g. Revenue, Quantity, ...) 
                            for (var projectingValueSourceIndex = 0; projectingValueSourceIndex < projectingValueSourcesLength; projectingValueSourceIndex++) {
                                var originalValueSourceIndex = projectedValueSourceEntries[projectingValueSourceIndex].sourceIndex;
                                var nodeValue = originalValues[offsetInOriginalValues + originalValueSourceIndex];
                                if (projectingValueSourceIndex !== (nodeValue.valueSourceIndex || 0)) {
                                    nodeValue = inheritSingle(nodeValue);
                                    nodeValue.valueSourceIndex = projectingValueSourceIndex || undefined;
                                }
                                projectedValues[offsetInProjectedValues + projectingValueSourceIndex] = nodeValue;
                            }
                        }
                        node.values = projectedValues;
                    }
                    else {
                        // if no measure column is being projected...
                        node.values = undefined;
                    }
                }));
                return rowHierarchy;
            }
            /**
             * Reorder columns inside composite group(s) by projection order.
             *
             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels
             * and values re-ordered by projection ordering.
             * Returns undefined if no re-ordering under the specified prototype is necessary.
             *
             * There are 3 scenarios that need reordering of columns inside a matrix composite group level:
             * 1) See Data matrix of a chart visual with hierarchical drill down on its category:
             *    The matrix will have a composite row hierarchy level, all columns of which belong to the same role.
             * 2) One of the DataViewMappings for map visual, where the row hierarchy consists of 2 levels and 2 roles (Series and Category), the latter of which is drillable.
             *    The outer row hierarchy level for Series has exactly one column, and the inner row hierarchy level is for Category and can be composite.
             *    Specifically, if Categrory role consists of a hierarchy and user has drilled down on group instance or expanded on level (NOT drill down level),
             *    then the inner level will be composite.
             * 3) Another of the DataViewMappings for map visual, where the row hierarchy consists of 2 levels and 3 roles (Series, X, and Y).
             *    The outer row hierarchy level for Series has exactly one column, and the inner row hierarchy level is always composite, with one column for each of role X and Y.
             */
            function reorderCompositeGroups(prototype, applicableDataViewMapping, projectionOrdering) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(applicableDataViewMapping, 'applicableDataViewMapping');
                debug.assertValue(projectionOrdering, 'projectionOrdering');
                // reorder levelValues in any composite groups in rows hierarchy
                var rowsRoles = powerbi.DataViewMapping.getRoles(applicableDataViewMapping.rows, powerbi.DataViewMapping.visitMatrixRows);
                var rowsProjections = getCombinedProjectionOrdering(projectionOrdering, rowsRoles);
                var transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(prototype.rows, rowsProjections);
                // reorder levelValues in any composite groups in columns hierarchy
                // Note: matrix.columns cannot have a composite group across multiple roles because DataViewMapping does not support it yet.
                // But in theory, matrix.columns can still have a composite group level that belong to a single role.
                // Today, there is no scenario that uses composite grouping on secondary axis, but I will leave this code here because it already exists...   
                var columnsRoles = powerbi.DataViewMapping.getRoles(applicableDataViewMapping.columns, powerbi.DataViewMapping.visitMatrixColumns);
                var columnsProjections = getCombinedProjectionOrdering(projectionOrdering, columnsRoles);
                var transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(prototype.columns, columnsProjections);
                var transformedDataView;
                if (transformedRowsHierarchy || transformedColumnsHierarchy) {
                    transformedDataView = inheritSingle(prototype);
                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;
                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;
                }
                return transformedDataView || prototype;
            }
            /**
             * Reorders the columns in any composite group level in the specified matrixHierarchy, by projection order.
             *
             * This function does NOT do the following:
             * - reorder hierarchy levels (because it is difficult, not useful in general, and we do not have any meaningful scenario that requires it).
             * - duplicating or removing columns in matrix hierarchy by projection order (because we do not have any meaningful scenario that requires it).
             *
             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and
             * values re-ordered by projection ordering.
             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.
             */
            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, projectionOrdering) {
                debug.assertValue(matrixHierarchy, 'matrixHierarchy');
                debug.assertValue(projectionOrdering, 'projectionOrdering');
                var levels = matrixHierarchy.levels;
                var transformedHierarchy;
                // reordering on a hierarchy level may need to happen only if the hierarchy level with multiple column sources
                var levelIndicesWithMultipleSources = _.chain(levels)
                    .map((function (level, index) { return index; })) // Note: do not move filter() above map(), or else the index will be from the filtered collection 
                    .filter((function (index) {
                    var level = levels[index];
                    return _.size(level.sources) >= 2 && !DataViewMatrixMeasureHeaders.isMeasureHeadersLevel(level);
                }))
                    .value();
                if (_.isEmpty(levelIndicesWithMultipleSources)) {
                    return;
                }
                // This code does not support projecting the same field multiple times in a matrix hierarchy, but it can still
                // sort the columns in a composite group even if a column is getting projected multiple times.
                var uniqueHierarchyProjection = _.uniq(projectionOrdering);
                // iterating over levelIndicesWithMultipleSources in reverse order, so that 
                // the body of this loop will only need to clone once on the part of the hierarchy that is getting modified
                for (var i = levelIndicesWithMultipleSources.length - 1; i >= 0; i--) {
                    var levelIndex = levelIndicesWithMultipleSources[i];
                    var hierarchyLevel = matrixHierarchy.levels[levelIndex];
                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering
                    var levelSourceIndexMappings = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, uniqueHierarchyProjection);
                    if (!_.isEmpty(levelSourceIndexMappings)) {
                        if (transformedHierarchy === undefined) {
                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,
                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...
                            transformedHierarchy = inheritSingle(matrixHierarchy);
                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);
                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,
                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to
                            // happen in other hierarchy levels in the later iterations of this for-loop.
                            transformedHierarchy.root = data.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, levelIndex, true);
                        }
                        // reorder the metadata columns in the sources array at that level
                        var transformingHierarchyLevel = inheritSingle(hierarchyLevel); // inherit at most once during the whole dataViewTransform for this obj...
                        transformedHierarchy.levels[levelIndex] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, levelSourceIndexMappings);
                        // reorder the level values in the composite group nodes at the current hierarchy level
                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, levelIndex, levelSourceIndexMappings);
                    }
                }
                return transformedHierarchy;
            }
            /**
             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),
             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.
             *
             * The returned value maps level source indices from the new target order (calculated from projection order)
             * back to the original order as they appear in the specified hierarchyLevel's sources.
             *
             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.
             *
             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.
             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.
             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.
             */
            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyProjection) {
                debug.assertValue(hierarchyLevel, 'hierarchyLevel');
                debug.assertValue(hierarchyProjection, 'hierarchyProjection');
                var levelSourceIndexMappings;
                var levelSourceColumns = hierarchyLevel.sources;
                if (levelSourceColumns && levelSourceColumns.length >= 2) {
                    // The hierarchy level has multiple columns, go on to check other conditions...
                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.DataViewMetadataColumnUtils.leftJoinMetadataColumnsAndProjectionOrder(levelSourceColumns, hierarchyProjection);
                    debug.assert(_.every(columnsForHierarchyRoleOrderedByLevelSourceIndex, (function (projectedColumn) { return projectedColumn.projectionOrderIndex !== undefined; })), 'pre-condition: The projection order for the specified hierarchy is expected to contain the Select Index of every metadata column for that role in levelSourceColumns.' +
                        ' In other words, removing column from a matrix grouping hierarchy via projection ordering is not supported nor expected.');
                    var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, (function (columnInfo) { return columnInfo.projectionOrderIndex; }));
                    levelSourceIndexMappings = _.map(columnsForHierarchyRoleOrderedByProjection, (function (value, i) {
                        var entry = {
                            originalSourceIndex: value.sourceIndex,
                            newSourceIndex: i,
                        };
                        return entry;
                    }));
                }
                return levelSourceIndexMappings;
            }
            /**
             * Applies re-ordering on the specified transformingHierarchyLevel's sources.
             * Returns the same object as the specified transformingHierarchyLevel.
             */
            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, levelSourceIndexMappings) {
                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');
                debug.assertNonEmpty(levelSourceIndexMappings, 'levelSourceIndexMappings');
                var originalLevelSources = transformingHierarchyLevel.sources;
                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.
                for (var _i = 0, levelSourceIndexMappings_1 = levelSourceIndexMappings; _i < levelSourceIndexMappings_1.length; _i++) {
                    var mapping = levelSourceIndexMappings_1[_i];
                    debug.assert(mapping.originalSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');
                    transformingHierarchyLevel.sources[mapping.newSourceIndex] = originalLevelSources[mapping.originalSourceIndex];
                }
                return transformingHierarchyLevel;
            }
            /**
             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,
             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.
             *
             * Returns the same object as the specified transformingHierarchyRootNode.
             */
            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, levelSourceIndexMappings) {
                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');
                debug.assertNonEmpty(levelSourceIndexMappings, 'levelSourceIndexMappings');
                debug.assert(levelSourceIndexMappings.length === _.uniq(levelSourceIndexMappings, (function (mapping) { return mapping.originalSourceIndex; })).length, 'levelSourceIndexMappings must not contain duplicate originalSourceIndex');
                var mappingsByOriginalLevelSourceIndex = _.reduce(levelSourceIndexMappings, (function (mappingsByOriginalLevelSourceIndex, value) {
                    mappingsByOriginalLevelSourceIndex[value.originalSourceIndex] = value;
                    return mappingsByOriginalLevelSourceIndex;
                }), {});
                data.DataViewMatrixUtils.forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (function (transformingMatrixNode) {
                    var originalLevelValues = transformingMatrixNode.levelValues;
                    // Note: Technically this function is incomplete, and cannot be until DataViewProjectionOrdering can express select indices per composite group (as opposed to per role).
                    // The driving source of the new LevelValues should be the "projection for this composite group", a concept that isn't yet implemented in DataViewProjectionOrdering.
                    // The following code isn't correct in the special case where a column is projected twice in this composite group,
                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.
                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.
                    if (!_.isEmpty(originalLevelValues)) {
                        debug.assert(_.every(originalLevelValues, (function (levelValue) { return !!mappingsByOriginalLevelSourceIndex[levelValue.levelSourceIndex]; })), 'Invalid levelSourceIndexMappings or transformingHierarchyRootNode: levelSourceIndexMappings should contain an entry for every levelSourceIndex in the matrix hierarchy.');
                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.
                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)
                        // because we don't want to accidentally modify the array AND its value references in Query DataView
                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, (function (levelValue) {
                            var mapping = mappingsByOriginalLevelSourceIndex[levelValue.levelSourceIndex];
                            return mapping && mapping.newSourceIndex;
                        }));
                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {
                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);
                            var mapping = mappingsByOriginalLevelSourceIndex[transformingLevelValue.levelSourceIndex];
                            transformingLevelValue.levelSourceIndex = mapping && mapping.newSourceIndex;
                            newlyOrderedLevelValues[i] = transformingLevelValue;
                        }
                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;
                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,
                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.
                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);
                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {
                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;
                        }
                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {
                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;
                        }
                    }
                }));
                return transformingHierarchyRootNode;
            }
        })(DataViewMatrixProjectionOrder = data.DataViewMatrixProjectionOrder || (data.DataViewMatrixProjectionOrder = {}));
        var DataViewMatrixMeasureHeaders;
        (function (DataViewMatrixMeasureHeaders) {
            /**
             * Inherits and updates the measure headers properties in the column hierarchy to match the specified newValueSources.
             */
            function update(prototypeColumnHierarchy, newValueSources) {
                debug.assertValue(prototypeColumnHierarchy, 'prototypeColumnHierarchy');
                debug.assertValue(newValueSources, 'newValueSources');
                var prototypeColumnHierarchyLevels = prototypeColumnHierarchy.levels;
                var hasExistingMeasureHeaders = hasMeasureHeadersLevel(prototypeColumnHierarchyLevels);
                var hasDynamicColumnGroupLevel = hasExistingMeasureHeaders ?
                    _.size(prototypeColumnHierarchyLevels) >= 2 :
                    _.size(prototypeColumnHierarchyLevels) >= 1;
                var isMeasureHeadersLevelNeeded = hasDynamicColumnGroupLevel ?
                    newValueSources.length >= 2 :
                    newValueSources.length >= 1;
                var columnHierarchy;
                if (hasExistingMeasureHeaders) {
                    if (isMeasureHeadersLevelNeeded) {
                        columnHierarchy = updateExistingMeasureHeaders(prototypeColumnHierarchy, newValueSources);
                    }
                    else {
                        columnHierarchy = removeMeasureHeaders(prototypeColumnHierarchy);
                    }
                }
                else {
                    if (isMeasureHeadersLevelNeeded) {
                        columnHierarchy = addMeasureHeaders(prototypeColumnHierarchy, newValueSources);
                    }
                    else {
                        columnHierarchy = prototypeColumnHierarchy;
                    }
                }
                return columnHierarchy;
            }
            DataViewMatrixMeasureHeaders.update = update;
            function hasMeasureHeadersLevel(columnHierarchyLevels) {
                debug.assertAnyValue(columnHierarchyLevels, 'columnHierarchyLevels');
                return !_.isEmpty(columnHierarchyLevels) &&
                    isMeasureHeadersLevel(_.last(columnHierarchyLevels));
            }
            DataViewMatrixMeasureHeaders.hasMeasureHeadersLevel = hasMeasureHeadersLevel;
            function isMeasureHeadersLevel(columnHierarchyLevel) {
                debug.assertAnyValue(columnHierarchyLevel, 'columnHierarchyLevel');
                return columnHierarchyLevel &&
                    _.every(columnHierarchyLevel.sources, (function (source) { return source.isMeasure; }));
            }
            DataViewMatrixMeasureHeaders.isMeasureHeadersLevel = isMeasureHeadersLevel;
            function updateExistingMeasureHeaders(prototypeColumnHierarchy, newValueSources) {
                debug.assert(prototypeColumnHierarchy && hasMeasureHeadersLevel(prototypeColumnHierarchy.levels), 'prototypeColumnHierarchy && hasExistingMeasureHeadersLevel(prototypeColumnHierarchy.levels)');
                debug.assertValue(newValueSources, 'newValueSources');
                // create inherited objects under columnHierarchy.levels for updating:
                var columnHierarchy = inheritSingle(prototypeColumnHierarchy);
                var columnHierarchyLevels = columnHierarchy.levels =
                    inheritSingle(columnHierarchy.levels);
                var measureHeaderLevelIndex = columnHierarchyLevels.length - 1;
                var measureHeadersLevel = columnHierarchyLevels[measureHeaderLevelIndex] =
                    inheritSingle(columnHierarchyLevels[measureHeaderLevelIndex]);
                // update the column sources under columnHierarchy.levels:
                measureHeadersLevel.sources = newValueSources;
                // create inherited objects under columnHierarchy.root for updating:
                columnHierarchy.root = data.DataViewMatrixUtils.
                    inheritMatrixNodeHierarchy(columnHierarchy.root, measureHeaderLevelIndex, /* useInheritSingle */ true);
                // update the measure header nodes under columnHierarchy.root:
                data.DataViewMatrixUtils.forEachNodeDepthFirst(columnHierarchy.root, (function (node) {
                    if (isParentOfMeasureHeaders(node, measureHeaderLevelIndex)) {
                        node.children = createMeasureHeaderNodes(measureHeaderLevelIndex, newValueSources.length, node.isSubtotal);
                        return 2 /* skipDescendantNodes */;
                    }
                    else {
                        return 1 /* continueToChildNodes */;
                    }
                }));
                return columnHierarchy;
            }
            function removeMeasureHeaders(prototypeColumnHierarchy) {
                debug.assert(prototypeColumnHierarchy && hasMeasureHeadersLevel(prototypeColumnHierarchy.levels), 'prototypeColumnHierarchy && hasExistingMeasureHeadersLevel(prototypeColumnHierarchy.levels)');
                // create inherited objects under columnHierarchy.levels for updating:
                var columnHierarchy = inheritSingle(prototypeColumnHierarchy);
                var columnHierarchyLevels = columnHierarchy.levels =
                    inheritSingle(columnHierarchy.levels);
                var measureHeaderLevelIndex = columnHierarchyLevels.length - 1;
                // remove the hierarch level under columnHierarchy.levels:
                columnHierarchyLevels.splice(measureHeaderLevelIndex, 1);
                // create inherited objects under columnHierarchy.root for updating:
                columnHierarchy.root = data.DataViewMatrixUtils.
                    inheritMatrixNodeHierarchy(columnHierarchy.root, measureHeaderLevelIndex, /* useInheritSingle */ true);
                // remove the measure header nodes under columnHierarchy.root:
                data.DataViewMatrixUtils.forEachNodeDepthFirst(columnHierarchy.root, (function (node) {
                    if (isParentOfMeasureHeaders(node, measureHeaderLevelIndex)) {
                        node.children = undefined;
                        return 2 /* skipDescendantNodes */;
                    }
                    else {
                        return 1 /* continueToChildNodes */;
                    }
                }));
                return columnHierarchy;
            }
            function addMeasureHeaders(prototypeColumnHierarchy, newValueSources) {
                debug.assert(prototypeColumnHierarchy && !hasMeasureHeadersLevel(prototypeColumnHierarchy.levels), 'prototypeColumnHierarchy && !hasExistingMeasureHeadersLevel(prototypeColumnHierarchy.levels)');
                debug.assertValue(newValueSources, 'newValueSources');
                // create inherited objects under columnHierarchy.levels for updating:
                var columnHierarchy = inheritSingle(prototypeColumnHierarchy);
                var columnHierarchyLevels = columnHierarchy.levels =
                    inheritSingle(columnHierarchy.levels);
                // add a new level under columnHierarchy.levels:
                var measureHeaderLevel = {
                    sources: newValueSources,
                };
                columnHierarchyLevels.push(measureHeaderLevel);
                var measureHeaderLevelIndex = columnHierarchyLevels.length - 1;
                // create inherited objects under columnHierarchy.root for updating:
                columnHierarchy.root = data.DataViewMatrixUtils.
                    inheritMatrixNodeHierarchy(columnHierarchy.root, measureHeaderLevelIndex, /* useInheritSingle */ true);
                // add measure header nodes under columnHierarchy.root:
                data.DataViewMatrixUtils.forEachNodeDepthFirst(columnHierarchy.root, (function (node) {
                    if (data.DataViewMatrixUtils.isLeafNode(node)) {
                        node.children = createMeasureHeaderNodes(measureHeaderLevelIndex, newValueSources.length, node.isSubtotal);
                        return 2 /* skipDescendantNodes */;
                    }
                    else {
                        return 1 /* continueToChildNodes */;
                    }
                }));
                return columnHierarchy;
            }
            function isParentOfMeasureHeaders(node, measureHeadersLevelIndex) {
                debug.assert(node && _.every(node.children, (function (childNode) { return childNode.level === node.children[0].level; })), 'node must be defined and all of its child nodes must have the same level value.');
                debug.assertValue(measureHeadersLevelIndex, 'measureHeadersLevelIndex');
                // Note related to VSTS 7426900: In a matrix with 3+ levels in column hierarchy and 2+ measure fields,
                // under the grand total branch of the hierarchy tree, the parent node at level 0 will have
                // direct child nodes with level > 1.  Hence, for locating the parent node of measure headers, 
                // this code cannot simply check node.level === measureHeadersLevelIndex - 1.
                var childNodes = node.children;
                return !_.isEmpty(childNodes) &&
                    childNodes[0].level === measureHeadersLevelIndex;
            }
            function createMeasureHeaderNodes(level, measureFieldCount, isSubtotal) {
                var measureHeaderNodes = [];
                for (var i = 0, ilen = measureFieldCount; i < ilen; i++) {
                    var measureHeaderNode = {
                        level: level,
                    };
                    if (i > 0) {
                        measureHeaderNode.levelSourceIndex = i;
                    }
                    if (isSubtotal) {
                        measureHeaderNode.isSubtotal = true;
                    }
                    measureHeaderNodes.push(measureHeaderNode);
                }
                return measureHeaderNodes;
            }
        })(DataViewMatrixMeasureHeaders = data.DataViewMatrixMeasureHeaders || (data.DataViewMatrixMeasureHeaders = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inherit = powerbi.Prototype.inherit;
        var DataViewPivotCategorical;
        (function (DataViewPivotCategorical) {
            /**
             * Pivots categories in a categorical DataView into valueGroupings.
             * In other words, this function will pivot the sole primary axis group to secondary axis in dataView.categorical.
             * This is akin to a mathematical matrix transpose.
             */
            function apply(dataView) {
                debug.assertValue(dataView, 'dataView');
                var categorical = dataView.categorical;
                if (!categorical)
                    return null;
                var categories = categorical.categories;
                if (!categories || categories.length !== 1)
                    return null;
                var values = categorical.values;
                if (_.isEmpty(values) || values.source)
                    return null;
                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];
                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {
                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];
                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {
                        var value = values[colIdx], pivotedColumn = inherit(value.source);
                        // A value has a series group, which is not implemented for pivoting -- just give up.
                        if (value.identity)
                            return null;
                        pivotedColumn.groupName = categoryValue;
                        var pivotedValue = {
                            source: pivotedColumn,
                            values: [value.values[rowIdx]],
                            identity: categoryIdentity,
                            min: value.min,
                            max: value.max,
                            subtotal: value.subtotal
                        };
                        var highlights = value.highlights;
                        if (highlights) {
                            pivotedValue.highlights = [highlights[rowIdx]];
                        }
                        pivotedColumns.push(pivotedColumn);
                        pivotedValues.push(pivotedValue);
                    }
                }
                var pivotedMetadata = inherit(dataView.metadata);
                pivotedMetadata.columns = pivotedColumns;
                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);
                return {
                    metadata: pivotedMetadata,
                    categorical: {
                        values: values,
                    },
                    matrix: dataView.matrix
                };
            }
            DataViewPivotCategorical.apply = apply;
        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewPivotMatrix;
        (function (DataViewPivotMatrix) {
            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */
            function apply(dataViewMatrix, context) {
                debug.assertValue(dataViewMatrix, 'dataViewMatrix');
                if (!context.columnHierarchyRewritten)
                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);
                var columns = dataViewMatrix.columns;
                if (!context.rowHierarchyRewritten)
                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);
                var rows = dataViewMatrix.rows;
                if (columns.levels.length > 1)
                    return;
                var pivotedRowNode = {
                    level: 0
                };
                var columnLeafNodes = columns.root.children;
                var measureCount = columnLeafNodes.length;
                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.
                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))
                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' 
                // in a matrix with 2+ column fields and 2+ measure fields.
                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result
                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.
                var pivotResultMeasureHeaderLevel = rows.levels.length;
                if (measureCount > 0) {
                    var index_1 = 0;
                    var callback = function (node) {
                        // Collect values and remove them from row leaves
                        if (node.values) {
                            if (!pivotedRowNode.values)
                                pivotedRowNode.values = {};
                            for (var i = 0; i < measureCount; i++)
                                pivotedRowNode.values[index_1++] = node.values[i];
                            node.values = undefined;
                        }
                        // Create measure headers if there are more than one measures
                        if (measureCount > 1) {
                            if (!node.children)
                                node.children = [];
                            for (var j = 0; j < measureCount; j++) {
                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };
                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)
                                var columnLeafNode = columnLeafNodes[j];
                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;
                                if (node.isSubtotal)
                                    measureHeaderLeaf.isSubtotal = true;
                                node.children.push(measureHeaderLeaf);
                            }
                        }
                    };
                    if (context.hierarchyTreesRewritten) {
                        forEachLeaf(rows.root, callback);
                    }
                    else {
                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);
                    }
                }
                else {
                    if (!context.hierarchyTreesRewritten) {
                        dataViewMatrix.columns.root = cloneTree(rows.root);
                    }
                }
                if (measureCount > 1) {
                    // Keep measure headers, but move them to the innermost level
                    var level = { sources: columns.levels[0].sources };
                    rows.levels.push(level);
                    columns.levels.length = 0;
                }
                if (context.hierarchyTreesRewritten) {
                    dataViewMatrix.columns.root = rows.root;
                    dataViewMatrix.rows.root = {
                        children: [pivotedRowNode]
                    };
                }
                else {
                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);
                    updatedRowRoot.children = [pivotedRowNode];
                    dataViewMatrix.rows.root = updatedRowRoot;
                }
                dataViewMatrix.columns.levels = rows.levels;
                dataViewMatrix.rows.levels = [];
            }
            DataViewPivotMatrix.apply = apply;
            function forEachLeaf(root, callback) {
                var children = root.children;
                if (children && children.length > 0) {
                    for (var i = 0, ilen = children.length; i < ilen; i++)
                        forEachLeaf(children[i], callback);
                    return;
                }
                callback(root);
            }
            function cloneTree(node) {
                return cloneTreeExecuteOnLeaf(node);
            }
            DataViewPivotMatrix.cloneTree = cloneTree;
            function cloneTreeExecuteOnLeaf(node, callback) {
                var updatedNode = powerbi.Prototype.inherit(node);
                var children = node.children;
                if (children && children.length > 0) {
                    var newChildren = [];
                    for (var i = 0, ilen = children.length; i < ilen; i++) {
                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);
                        newChildren.push(updatedChild);
                    }
                    updatedNode.children = newChildren;
                }
                else {
                    if (callback)
                        callback(updatedNode);
                }
                return updatedNode;
            }
            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;
        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewPivotMatrixToPrimaryGroups;
        (function (DataViewPivotMatrixToPrimaryGroups) {
            /**
             * Converts a matrix data view where category is a row grouping and series is a column grouping into
             * a matrix where Series and category are both row groupings. Series is the outer row grouping while Categories is the inner.
             * This transform handles the back-compat cases for Scatter chart which used to request categorical data view with the groupings on different axis.
             * The new matrix Data View form is more efficient data structure for Scatter Chart in terms of memory.
             * Its efficient in terms of perf as well as the visual shouldn't need to traverse empty spaces
             *
             * Example:
             * Input Matrix:
             * {
             *     rows: {
             *         levels: [ sources: [categoryCol]],
             *         root: {
             *             children: [ categoryValues ]
             *         }
             *     },
             *     columns: {
             *         levels: [ sources: [seriesCol]],
             *         root: {
             *             children: [ seriesValues ]
             *         }
             *     },
             *     valueSources: [XValuesCol, YValuesCol, SizeValuesCol]
             * }
             * Output Matrix:
             * {
             *     rows: {
             *         levels: [ sources: [seriesCol, categoryCol]],
             *         root: {
             *             children: [ seriesValues (categoryValues are nested under their respective Series) ]
             *         }
             *     },
             *     columns: {
             *         levels: [],
             *         root: {
             *             children: []
             *         }
             *     },
             *     valueSources: [XValuesCol, YValuesCol, SizeValuesCol]
             * }         *
             * @param oldDataView
             * @param selects
             * @param roleKindByQueryRef
             * @param queryProjectionsByRole
             * @param drillableRoles
             * @param applicableRoleMappings
             */
            function pivot(oldDataView, selects, roleKindByQueryRef, queryProjectionsByRole, drillableRoles, applicableRoleMappings) {
                if (!inferPivotTransform(oldDataView, selects, roleKindByQueryRef, queryProjectionsByRole, applicableRoleMappings, drillableRoles))
                    return oldDataView;
                // This returns a subsetted version of the DataView rather than using prototypal inheritance because
                // any dataviews in the old one (including ones invented after this code is written) will correspond
                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the
                // querying code made.
                var newDataView = {
                    metadata: {
                        columns: oldDataView.metadata.columns.slice(),
                    },
                };
                // preserve view types that aren't affected by pivoting
                if (oldDataView.single)
                    newDataView.single = oldDataView.single;
                if (oldDataView.table)
                    newDataView.table = oldDataView.table;
                if (oldDataView.matrix) {
                    var newDataViewMatrix = pivotMatrix(oldDataView.metadata, oldDataView.matrix);
                    // matrix only if there's data
                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {
                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is 
                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.
                        // this.canPivotCategorical() would have returned false in the first place for this query.
                        var hasCompositeGroupInSeries = data.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);
                        if (!hasCompositeGroupInSeries) {
                            newDataView.matrix = newDataViewMatrix;
                        }
                    }
                }
                return newDataView;
            }
            DataViewPivotMatrixToPrimaryGroups.pivot = pivot;
            /**
             * Infer from the query result and the visual mappings whether the query was pivoted.
             * Check 1: Matrix DataView's Row Hierarchy & Column Hierarchy each has grouping projections (Category on Row, Series on Column)
             * Check 2: Target DataViewMapping wants matrix with both grouping projections (Series, Category) on Row Hierarchy
             * Narrowly targets scatter chart scenario for now to keep code simple
             */
            function inferPivotTransform(dataView, selects, roleKindByQueryRef, queryProjectionsByRole, applicableRoleMappings, drillableRoles) {
                if (_.isEmpty(selects) || !dataView || _.isEmpty(applicableRoleMappings))
                    return false;
                // query will have produced a matrix
                var matrix = dataView.matrix;
                if (!matrix)
                    return false;
                // matrix dataview must have at least a row level (for category) & a column level (for series)
                if (!matrix.rows
                    || _.isEmpty(matrix.rows.levels)
                    || !matrix.columns
                    || _.isEmpty(matrix.columns.levels))
                    return false;
                var metadataColGroups = [];
                for (var _i = 0, _a = matrix.columns.levels; _i < _a.length; _i++) {
                    var level = _a[_i];
                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {
                        var source = _c[_b];
                        if (!source.isMeasure)
                            metadataColGroups.push(source);
                    }
                }
                var metadataRowGroups = [];
                for (var _d = 0, _e = matrix.rows.levels; _d < _e.length; _d++) {
                    var level = _e[_d];
                    for (var _f = 0, _g = level.sources; _f < _g.length; _f++) {
                        var source = _g[_f];
                        if (!source.isMeasure)
                            metadataRowGroups.push(source);
                    }
                }
                var metadataRowMeasures = [];
                for (var _h = 0, _j = matrix.rows.levels; _h < _j.length; _h++) {
                    var level = _j[_h];
                    for (var _k = 0, _l = level.sources; _k < _l.length; _k++) {
                        var source = _l[_k];
                        if (source.isMeasure)
                            metadataRowMeasures.push(source);
                    }
                }
                if (!_.isEmpty(metadataRowMeasures))
                    return false;
                // there can be many row groups with drill down
                if (metadataColGroups.length !== 1 || metadataRowGroups.length < 1)
                    return false;
                var applicableRoleMappingWithoutRegression = _.filter(applicableRoleMappings, (function (mapping) { return !powerbi.DataViewMapping.getRegressionUsage(mapping); }));
                if (applicableRoleMappingWithoutRegression.length !== 1)
                    return false;
                var targetDataViewKinds = powerbi.DataViewMapping.targetDataViewKinds(applicableRoleMappingWithoutRegression);
                if (targetDataViewKinds !== 2 /* Matrix */)
                    return false;
                var matrixMapping = applicableRoleMappingWithoutRegression[0].matrix;
                if (!matrixMapping)
                    return false;
                // get row and column grouping projection refs from the mapping
                var mappingRowRoles = powerbi.DataViewMapping.getRoles(matrixMapping.rows, powerbi.DataViewMapping.visitMatrixRows);
                var mappingColumnRoles = powerbi.DataViewMapping.getRoles(matrixMapping.columns, powerbi.DataViewMapping.visitMatrixColumns);
                // row groupings can be more than 2 due to drill down
                if (_.size(mappingRowRoles) < 2 || _.size(mappingColumnRoles) !== 0)
                    return false;
                // get the unique roles for metadata columns in matrix rows and columns
                var metadataRowRoles = _.uniq([].concat.apply([], _.map(metadataRowGroups, (function (metadataColumn) { return Object.keys(selects[metadataColumn.index].roles); }))));
                var metadataColRoles = _.uniq([].concat.apply([], _.map(metadataColGroups, (function (metadataColumn) { return Object.keys(selects[metadataColumn.index].roles); }))));
                return _.isEqual(mappingRowRoles, [].concat(metadataColRoles, metadataRowRoles)) && _.isEqual(drillableRoles, metadataRowRoles);
            }
            /**
             * Transform a matrix where the columns contains one grouping (series) to a matrix where the rows have both/all the groups
             * (series & category) with series being the outer grouping.
             */
            function pivotMatrix(oldMetadata, oldMatrix) {
                var oldRows = oldMatrix.rows;
                var oldColumns = oldMatrix.columns;
                var oldRowsRoot = oldRows.root;
                var oldRowsChildren = oldRowsRoot.children;
                debug.assert(oldRows.levels.length === 1, 'oldRows.levels.length ===1');
                // Current Matrix DataView has measures always added to secondary level sources even though children aren't present
                debug.assert(oldColumns.levels.length >= 1, 'oldColumns.levels.length >=1');
                debug.assert(oldColumns.levels[0].sources.length === 1, 'oldColumns.levels[0].sources.length === 1');
                var newRows = {
                    levels: [],
                    root: {
                        children: [],
                    }
                };
                var newColumns = {
                    levels: [],
                    root: {
                        children: [],
                    }
                };
                var newMatrix = {
                    rows: newRows,
                    columns: newColumns,
                    valueSources: oldMatrix.valueSources
                };
                // populate series from oldColumns
                var newSeries = newRows.root.children;
                newRows.levels.push(oldColumns.levels[0]);
                newRows.root.childIdentityFields = oldColumns.root.childIdentityFields;
                for (var _i = 0, _a = oldColumns.root.children; _i < _a.length; _i++) {
                    var colNode = _a[_i];
                    if (colNode.levelValues !== undefined && colNode.value !== undefined) {
                        newSeries.push({
                            children: [],
                            value: colNode.value,
                            levelValues: colNode.levelValues,
                            identity: colNode.identity,
                            level: 0,
                        });
                    }
                }
                var valueSourcesCount = _.size(oldMatrix.valueSources);
                newRows.levels.push(oldRows.levels[0]);
                // Don't add rowNodes under SeriesNodes if there aren't any
                if (_.isEmpty(newSeries))
                    return newMatrix;
                for (var oldRowNodeIndex in oldRowsChildren) {
                    var oldRowNode = oldRowsChildren[oldRowNodeIndex];
                    // Split values from oldRowNode into each newRowNode for the respective Series     
                    // Example: 
                    // Before: Series nodes are present in columns.root.children, so rows.children node's (category) values hold values of a category across all series.
                    // rows: {
                    //     levels: [ {sources: [categoryCol]}],
                    //     root: {
                    //         children: [ {
                    //             ...
                    //             values: [{ value: categoryValueWhenSeries0 }, {value: categoryValueWhenSeries1}, {value: categoryValueWhenSeries2}]
                    //             ...
                    //         } ]
                    //     }
                    // },
                    // cols: {
                    //     levels: [ { sources: [seriesCol] } ]    
                    //     root: {
                    //         children: [ {
                    //             ...
                    //             values: [{ value: series0 }, {value: series1}, {value: series2}]
                    //             ...
                    //         } ]
                    //     }
                    // }
                    // After: now Series nodes are present in rows.root.children and each category value is pushed under its corresponding series
                    // rows: {
                    //     levels: [ { sources: [seriesCol]}, { sources: [categoryCols]} ],
                    //     root: {
                    //         children: [ 
                    //             children: [{
                    //                 ...
                    //                 values: [{ value: categoryValueWhenSeries0 }]
                    //                 ...
                    //             }
                    //         }]                       
                    //     }
                    // },
                    // cols: {
                    //     levels: []    
                    //     root: {
                    //         children: []
                    //     }
                    // }
                    for (var index in oldRowNode.values) {
                        var seriesIndex = Math.floor(index / valueSourcesCount);
                        var seriesNode = newSeries[seriesIndex];
                        if (!seriesNode.childIdentityFields)
                            seriesNode.childIdentityFields = oldRowsRoot.childIdentityFields;
                        var value = oldRowNode.values[index];
                        if (value != null) {
                            var newRowNode = seriesNode.children[oldRowNodeIndex];
                            if (!newRowNode) {
                                newRowNode = {
                                    level: seriesNode.level + 1,
                                    value: oldRowNode.value,
                                    levelValues: oldRowNode.levelValues,
                                    values: {},
                                    identity: oldRowNode.identity
                                };
                                seriesNode.children.push(newRowNode);
                            }
                            newRowNode.values[index % valueSourcesCount] = value;
                        }
                    }
                }
                return newMatrix;
            }
        })(DataViewPivotMatrixToPrimaryGroups = data.DataViewPivotMatrixToPrimaryGroups || (data.DataViewPivotMatrixToPrimaryGroups = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewSelfCrossJoin;
        (function (DataViewSelfCrossJoin) {
            /**
             * Returns a new DataView based on the original, with a single DataViewCategorical category that is "cross joined"
             * to itself as a value grouping.
             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.
             */
            function apply(dataView, selfCrossJoinCategory) {
                debug.assertValue(dataView, 'dataView');
                debug.assert(!selfCrossJoinCategory || _.contains(dataView.categorical.categories, selfCrossJoinCategory), '!selfCrossJoinCategory || _.contains(dataView.categorical.categories, selfCrossJoinCategory)');
                if (!dataView.categorical || !selfCrossJoinCategory)
                    return;
                var dataViewCategorical = dataView.categorical;
                if (_.isEmpty(dataViewCategorical.categories))
                    return;
                if (dataViewCategorical.values && dataViewCategorical.values.source) {
                    // The dataView already has a series (secondary axis) grouping field
                    return;
                }
                var seriesGroupIdentityFields = getSeriesGroupIdentityFields(dataViewCategorical, selfCrossJoinCategory);
                if (_.isEmpty(seriesGroupIdentityFields)) {
                    return;
                }
                return applyCategorical(dataView.metadata, dataViewCategorical, selfCrossJoinCategory, seriesGroupIdentityFields);
            }
            DataViewSelfCrossJoin.apply = apply;
            /**
             * Returns the identity field exprs for the series (secondary axis) grouping field that will be generated from self-cross-joining.
             * Returns undefined if it is impossible to obtain that information with the given dataView.
             */
            function getSeriesGroupIdentityFields(dataViewCategorical, selfCrossJoinCategory) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertValue(selfCrossJoinCategory, 'selfCrossJoinCategory');
                debug.assert(_.contains(dataViewCategorical.categories, selfCrossJoinCategory), '_.contains(dataViewCategorical.categories, selfCrossJoinCategory)');
                // the source.identityExprs value is available in DSR since CY16SU09
                var identityExprs = selfCrossJoinCategory.source.identityExprs;
                if (identityExprs) {
                    return identityExprs;
                }
                // With older DSR, the only way to get the identity field exprs for the series group field is
                // to use selfCrossJoinCategory.identityFields.  However, if the dataView has more than one category column,
                // then all the columns will have composite identities and the identityFields will includes all fields in the composite identity,
                // which is not the correct identity fields for the series group.
                if (dataViewCategorical.categories.length === 1) {
                    return selfCrossJoinCategory.identityFields;
                }
                // else, it is impossible to obtain the identity field exprs for the series group
            }
            function applyCategorical(dataViewMetadata, dataViewCategorical, selfCrossJoinCategory, seriesGroupIdentityFields) {
                debug.assertValue(dataViewMetadata, 'dataViewMetadata');
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');
                debug.assertValue(selfCrossJoinCategory, 'selfCrossJoinCategory');
                debug.assert(_.size(selfCrossJoinCategory.values) === _.size(selfCrossJoinCategory.identity), '_.size(selfCrossJoinCategory.values) === _.size(selfCrossJoinCategory.identity)');
                debug.assertValue(seriesGroupIdentityFields, 'seriesGroupIdentityFields');
                var categoryValues = selfCrossJoinCategory.values, categoryLength = categoryValues.length;
                if (categoryLength === 0)
                    return;
                var valuesArray = dataViewCategorical.values
                    ? dataViewCategorical.values.grouped()[0].values
                    : [];
                var groupValuesOptions = createGroupedValues(selfCrossJoinCategory, categoryLength, valuesArray, seriesGroupIdentityFields);
                if (!groupValuesOptions)
                    return;
                var transformedDataView = data.createCategoricalDataViewBuilder()
                    .withCategories(dataViewCategorical.categories)
                    .withGroupedValues(groupValuesOptions)
                    .build();
                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadata.columns = transformedDataView.metadata.columns;
                return {
                    metadata: dataViewMetadata,
                    categorical: transformedDataView.categorical,
                };
            }
            function createGroupedValues(category, categoryLength, measureColumns, seriesGroupIdentityFields) {
                debug.assertValue(category, 'category');
                debug.assertValue(categoryLength, 'categoryLength');
                debug.assertValue(measureColumns, 'measures');
                debug.assertValue(seriesGroupIdentityFields, 'seriesGroupIdentityFields');
                var nullValuesArray = createNullValues(categoryLength);
                var seriesGroups = extractSeriesGroups(category, seriesGroupIdentityFields);
                if (_.isEmpty(seriesGroups))
                    return;
                // the 1st dimension is on series instance, the 2nd dimension is on measure column
                var seriesData = _.map(seriesGroups, (function (seriesGroup) {
                    var valueRowIndices = seriesGroup.valueRowIndices;
                    var allMeasureColumnsInSeriesGroup = _.map(measureColumns, (function (measureColumn) {
                        var measureColumnInSeriesGroup = {
                            values: inheritArrayWithValues(nullValuesArray, measureColumn.values, valueRowIndices),
                        };
                        if (measureColumn.highlights) {
                            measureColumnInSeriesGroup.highlights = inheritArrayWithValues(nullValuesArray, measureColumn.highlights, valueRowIndices);
                        }
                        return measureColumnInSeriesGroup;
                    }));
                    return allMeasureColumnsInSeriesGroup;
                }));
                return {
                    groupColumn: {
                        source: category.source,
                        identityFrom: {
                            fields: seriesGroupIdentityFields,
                            identities: _.map(seriesGroups, (function (instance) { return instance.identity; })),
                        },
                        values: _.map(seriesGroups, (function (instance) { return instance.groupValue; })),
                    },
                    valueColumns: _.map(measureColumns, (function (v) { return ({ source: v.source }); })),
                    data: seriesData,
                };
            }
        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));
        function extractSeriesGroups(category, seriesGroupIdentityFields) {
            debug.assertValue(category, 'category');
            debug.assert(_.size(category.values) === _.size(category.identity), '_.size(category.values) === _.size(category.identity)');
            debug.assertValue(!_.isEmpty(seriesGroupIdentityFields), '!_.isEmpty(seriesGroupIdentityFields)');
            var identities = category.identity;
            var categoryValues = category.values;
            var seriesGroups = [];
            var seriesGroupKeyToIndexMapping = {};
            for (var i = 0, ilen = _.size(identities); i < ilen; i++) {
                var identity = identities[i];
                var seriesGroupIdentityExpr = data.ScopeIdentityExtractor.getSubset(identity.expr, seriesGroupIdentityFields);
                var seriesGroupIdentity = seriesGroupIdentityExpr && data.createDataViewScopeIdentity(seriesGroupIdentityExpr);
                var seriesGroupIdentityKey = seriesGroupIdentity && seriesGroupIdentity.key;
                var seriesGroupIndex = seriesGroupKeyToIndexMapping[seriesGroupIdentityKey];
                var seriesGroup = void 0;
                if (seriesGroupIndex === undefined) {
                    // create a new instance
                    seriesGroup = {
                        identity: seriesGroupIdentity,
                        groupValue: categoryValues[i],
                        groupIndex: seriesGroups.length,
                        valueRowIndices: [],
                    };
                    seriesGroups.push(seriesGroup);
                    seriesGroupKeyToIndexMapping[seriesGroupIdentityKey] = seriesGroup.groupIndex;
                }
                else {
                    seriesGroup = seriesGroups[seriesGroupIndex];
                }
                seriesGroup.valueRowIndices.push(i);
            }
            debug.assert(jsCommon.ArrayExtensions.isSorted(seriesGroups, (function (a, b) { return a.groupIndex - b.groupIndex; })), 'post-condition: seriesGroups is sorted by group index');
            return seriesGroups;
        }
        function createNullValues(length) {
            debug.assertValue(length, 'length');
            var array = new Array(length);
            for (var i = 0; i < length; i++)
                array[i] = null;
            return array;
        }
        function inheritArrayWithValues(nullValues, original, indices) {
            var inherited = powerbi.Prototype.inherit(nullValues);
            for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {
                var index = indices_1[_i];
                inherited[index] = original[index];
            }
            return inherited;
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewPivotCategoricalToPrimaryGroups;
        (function (DataViewPivotCategoricalToPrimaryGroups) {
            /**
             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to
             * pivot the secondary before the primary.
             */
            function pivotBinding(binding, allMappings, finalMapping, selects, defaultDataVolume, overrideDataVolume) {
                // unpivot is inferred from result in DataViewTransform.apply but it does not have the
                // compiled mappings available, let alone the merged mapping, only the original
                // DataViewMappings. to keep that inference easy, only apply pivot when there's
                // only one matching mapping
                if (!allMappings || allMappings.length !== 1)
                    return;
                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)
                    return;
                if (!binding)
                    return;
                if (!canPivotCategorical(binding, finalMapping))
                    return;
                // pivot secondary onto front of primary
                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];
                binding.Secondary = undefined;
                // set primary to pivot reduction
                binding.DataReduction = {
                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm, selects),
                    DataVolume: overrideDataVolume || finalMapping.categorical.dataVolume || defaultDataVolume,
                };
            }
            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;
            /** narrowly targets scatter chart scenario for now to keep code simple */
            function isPivotableAxis(axis) {
                return axis
                    && axis.Groupings
                    && axis.Groupings.length === 1
                    && !_.isEmpty(axis.Groupings[0].Projections)
                    && !axis.Groupings[0].Subtotal
                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);
            }
            function canPivotCategorical(binding, mapping) {
                if (!isPivotableAxis(binding.Primary))
                    return false;
                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)
                    return false;
                // don't pivot if either axis or intersection has a data reduction
                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary || binding.DataReduction.Intersection))
                    return false;
                return true;
            }
            function unpivotResult(oldDataView, selects, roleKindByQueryRef, queryProjectionsByRole, applicableRoleMappings) {
                if (!inferUnpivotTransform(oldDataView, selects, roleKindByQueryRef, queryProjectionsByRole, applicableRoleMappings))
                    return oldDataView;
                // This returns a subsetted version of the DataView rather than using prototypal inheritance because
                // any dataviews in the old one (including ones invented after this code is written) will correspond
                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the
                // querying code made.
                var newDataView = {
                    metadata: {
                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),
                    },
                };
                // preserve view types that aren't affected by pivoting
                if (oldDataView.single)
                    newDataView.single = oldDataView.single;
                if (oldDataView.table)
                    newDataView.table = oldDataView.table;
                // other views are derived from matrix
                if (oldDataView.matrix) {
                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);
                    // categorical only if there's data
                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {
                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is 
                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.
                        // this.canPivotCategorical() would have returned false in the first place for this query.
                        var hasCompositeGroupInSeries = data.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);
                        if (!hasCompositeGroupInSeries) {
                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);
                        }
                    }
                }
                return newDataView;
            }
            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;
            /**
             * Infer from the query result and the visual mappings whether the query was pivoted.
             * Narrowly targets scatter chart scenario for now to keep code simple
             */
            function inferUnpivotTransform(dataView, selects, roleKindByQueryRef, queryProjectionsByRole, applicableRoleMappings) {
                if (_.isEmpty(selects) || !dataView || _.isEmpty(applicableRoleMappings))
                    return false;
                var applicableRoleMappingWithoutRegression = _.filter(applicableRoleMappings, (function (mapping) { return !powerbi.DataViewMapping.getRegressionUsage(mapping); }));
                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical
                if (applicableRoleMappingWithoutRegression.length !== 1)
                    return false;
                var categoricalMapping = applicableRoleMappingWithoutRegression[0].categorical;
                if (!categoricalMapping)
                    return false;
                // pivoted query will have produced a matrix
                var matrixDataview = dataView.matrix;
                if (!matrixDataview)
                    return false;
                // matrix must have two levels of grouping
                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)
                    return false;
                // get category and value grouping roles
                var categoryGroups = [];
                var valueGroups = [];
                var addGroupingRole = function (roleName, groups) {
                    var roleProjections = queryProjectionsByRole[roleName];
                    if (!roleProjections)
                        return;
                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {
                        var roleProjection = _a[_i];
                        if (roleKindByQueryRef[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)
                            groups.push(roleProjection.queryRef);
                    }
                };
                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {
                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }
                });
                powerbi.DataViewMapping.visitGrouped(categoricalMapping.values, {
                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }
                });
                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {
                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }
                });
                // need both for pivot to have been done
                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))
                    return false;
                // if there was a pivot, there won't be any measures left in the columns
                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {
                    var level = _a[_i];
                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {
                        var source = _c[_b];
                        if (!source.isMeasure)
                            return false;
                    }
                }
                return true;
            }
            /**
             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.
             * this function changes that so that the categories become the rows and the series the columns.
             *
             * In other words, this function will pivot the primary axis group at level 0 to secondary axis,
             * and the primary axis group at level 1 becomes the new level 0, in dataView.matrix.
             */
            function unpivotMatrix(oldMatrix) {
                var oldRows = oldMatrix.rows;
                var oldRoot = oldRows.root;
                var oldChildren = oldRoot.children;
                // series are the outer grouping
                var series = [];
                var seriesIdLevel = oldRows.levels[0];
                var seriesIdFields = oldRoot.childIdentityFields;
                // categories are the inner grouping. 
                var categoryIndex = {};
                var categories = [];
                var categoryIdLevel = oldRows.levels[1];
                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;
                var measureCount = oldMatrix.valueSources.length;
                // within each series value, the category list may not be complete so cannot simply use the inner loop index
                // to reference it.
                var findCategory = function (identity) {
                    var index = categoryIndex[identity.key];
                    debug.assert(index !== undefined, "findcat() !== undefined");
                    return index;
                };
                // collect series and categories from the row hierarchy
                if (oldChildren) {
                    var addCategory = function (categoryNode) {
                        var key = categoryNode.identity.key;
                        var index = categoryIndex[key];
                        if (index === undefined) {
                            index = categories.length;
                            categoryIndex[key] = index;
                            categories.push(categoryNode);
                        }
                    };
                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {
                        var seriesNode = oldChildren_1[_i];
                        series.push(seriesNode);
                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {
                            var categoryNode = _b[_a];
                            addCategory(categoryNode);
                        }
                    }
                }
                // extract intersection values from pivoted matrix
                // values will be indexed by categories then series
                var matrixValues = new Array(categories.length);
                for (var j = 0; j < series.length; ++j) {
                    var seriesNode = oldChildren[j];
                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {
                        var categoryNode = _d[_c];
                        var i = findCategory(categoryNode.identity); // must lookup actual category index
                        if (!matrixValues[i])
                            matrixValues[i] = new Array(series.length);
                        matrixValues[i][j] = categoryNode.values;
                    }
                }
                // columns of the unpivoted matrix are the series
                var newColumns = {
                    root: {
                        children: _.map(series, (function (s) {
                            var inheritedNode = inheritSingle(s);
                            inheritedNode.level = 0; // s.level should already be 0, but just in case...
                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function
                            inheritedNode.childIdentityFields = undefined;
                            return inheritedNode;
                        })),
                        childIdentityFields: seriesIdFields,
                    },
                    levels: [
                        seriesIdLevel,
                    ],
                };
                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns
                if (measureCount > 0) {
                    var newColChildren = _.map(oldMatrix.columns.root.children, (function (srcnode) {
                        var dstnode = { level: 1 };
                        if (srcnode.levelSourceIndex)
                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;
                        return dstnode;
                    }));
                    for (var _e = 0, _f = newColumns.root.children; _e < _f.length; _e++) {
                        var child = _f[_e];
                        child.children = newColChildren;
                    }
                    newColumns.levels.push(oldMatrix.columns.levels[0]);
                }
                // rows of the unpivoted matrix are the categories
                var newRows = {
                    root: {
                        children: _.map(categories, (function (c) {
                            var inheritedNode = inheritSingle(c);
                            inheritedNode.level = 0;
                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...
                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...
                            return inheritedNode;
                        })),
                        childIdentityFields: categoryIdFields,
                    },
                    levels: [
                        categoryIdLevel,
                    ],
                };
                // put values into rows
                if (measureCount > 0) {
                    for (var i = 0; i < categories.length; ++i) {
                        var row = newRows.root.children[i];
                        var rowValues = {};
                        for (var j = 0; j < series.length; ++j) {
                            var mvalues = matrixValues[i] && matrixValues[i][j];
                            for (var k = 0; k < measureCount; ++k) {
                                var l = j * measureCount + k;
                                rowValues[l] = !mvalues
                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })
                                    : mvalues[k];
                            }
                        }
                        row.values = rowValues;
                    }
                }
                var newMatrix = {
                    rows: newRows,
                    columns: newColumns,
                    valueSources: oldMatrix.valueSources,
                };
                return newMatrix;
            }
            /** build a categorical data view from an unpivoted matrix. */
            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {
                var seriesCount = matrix.columns.root.children.length;
                var measureMetadata = matrix.valueSources;
                var measureCount = measureMetadata.length;
                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);
                // create grouped values
                var groups = [];
                for (var j = 0; j < seriesCount; ++j) {
                    var seriesColumn = matrix.columns.root.children[j];
                    var group = {
                        values: [],
                        identity: seriesColumn.identity,
                        name: seriesColumn.value != null ? seriesColumn.value : null,
                    };
                    groups.push(group);
                    for (var k = 0; k < measureCount; ++k) {
                        var valueColumnMetadataSrc = measureMetadata[k];
                        var valueColumnMetadataDst = {};
                        for (var key in valueColumnMetadataSrc)
                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];
                        valueColumnMetadataDst.groupName = group.name;
                        columnMetadata.push(valueColumnMetadataDst);
                        var valueColumn = {
                            source: valueColumnMetadataDst,
                            values: [],
                            identity: group.identity,
                        };
                        group.values.push(valueColumn);
                        // grab measure values in the group from across rows of matrix
                        var index = k + j * measureCount;
                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {
                            var categoryNode = _a[_i];
                            var value = categoryNode.values[index].value;
                            valueColumn.values.push(value);
                        }
                    }
                }
                // and now ungrouped
                var values = [];
                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {
                    var group = groups_1[_b];
                    for (var k = 0; k < measureCount; ++k) {
                        values.push(group.values[k]);
                    }
                }
                values.grouped = function () { return groups; };
                values.identityFields = matrix.columns.root.childIdentityFields;
                values.source = matrix.columns.levels[0].sources[0];
                // final assembly
                var categorical = {
                    categories: categories,
                    values: values,
                };
                return categorical;
            }
            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {
                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');
                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');
                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the 
                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the 
                // same amongst the resulting DataViewCategoryColumns.
                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, (function (x) { return x.identity; }));
                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;
                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;
                var categories = [];
                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {
                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, (function (categoryNode) {
                        var levelValues = categoryNode.levelValues;
                        // Please refer to the interface comments on when this is undefined... But in today's code
                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. 
                        if (levelValues !== undefined) {
                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');
                            return levelValues[i].value;
                        }
                    }));
                    categories.push({
                        source: categorySourceColumns[i],
                        values: groupLevelValues,
                        identity: categoryIdentity,
                        identityFields: categoryIdentityFields,
                    });
                }
                return categories;
            }
        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewMapping = powerbi.DataViewMapping;
        var DataViewTransformContext;
        (function (DataViewTransformContext) {
            /**
             * Creates an object that all properties in the DataViewTransformContext interface.
             *
             * @param queryDataViewMetadata The metadata property of the query DataView.
             * @param objectDescriptors From Visual Capabilities.  Can be undefined.
             * @param dataViewMappings From Visual Capabilities.  Can be undefined.
             * @param dataRoles From Visual Capabilities.  Can be undefined.
             * @param transforms
             * @param colorAllocatorFactory
             */
            function create(queryDataViewMetadata, objectDescriptors, dataViewMappings, dataRoles, drillCapabilities, transforms, colorAllocatorFactory) {
                debug.assertValue(queryDataViewMetadata, 'queryDataViewMetadata');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');
                debug.assertAnyValue(dataRoles, 'dataRoles');
                debug.assertAnyValue(drillCapabilities, 'drillCapabilities');
                debug.assertValue(transforms, 'transforms');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                var selectTransforms = transforms.selects;
                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;
                var roleKindByQueryRef = !_.isEmpty(selectTransforms) ?
                    data.DataViewSelectTransform.createRoleKindFromMetadata(selectTransforms, queryDataViewMetadata) :
                    {};
                var queryProjectionsByRole = data.DataViewSelectTransform.projectionsFromSelects(selectTransforms, projectionActiveItems);
                var dataViewMappingResult = powerbi.DataViewAnalysis.chooseDataViewMappings(queryProjectionsByRole, dataViewMappings, roleKindByQueryRef, objectDescriptors, transforms.objects);
                var applicableRoleMappings = dataViewMappingResult.supportedMappings;
                var context = {
                    queryDataViewMetadata: queryDataViewMetadata,
                    objectDescriptors: objectDescriptors,
                    dataRoles: dataRoles,
                    drillCapabilities: drillCapabilities,
                    transforms: transforms,
                    colorAllocatorFactory: colorAllocatorFactory,
                    selectTransforms: selectTransforms,
                    projectionOrdering: transforms.roles && transforms.roles.ordering,
                    projectionActiveItems: projectionActiveItems,
                    roleKindByQueryRef: roleKindByQueryRef,
                    queryProjectionsByRole: queryProjectionsByRole,
                    visualCapabilitiesRoleMappings: dataViewMappings,
                    visualCapabilitiesDataViewKinds: DataViewMapping.targetDataViewKinds(dataViewMappings),
                    applicableRoleMappings: applicableRoleMappings,
                    applicableDataViewKinds: DataViewMapping.targetDataViewKinds(applicableRoleMappings),
                };
                return context;
            }
            DataViewTransformContext.create = create;
        })(DataViewTransformContext = data.DataViewTransformContext || (data.DataViewTransformContext = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataViewMetadataColumnUtils = powerbi.data.DataViewMetadataColumnUtils;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        /**
         * Responsible for applying projection order and split selects to DataViewCategorical.
         * If the specified prototype DataView needs to get transformed, the transformed DataView will be returned.
         * Else, the prototype DataView itself will be returned.
         *
         * Some terminologies that are used in this file (the exact wording might be different depending on who you talk to, but the concepts are the same):
         *
         * category columns / categories:
         *   The fields on primary axis.  If there are multiple, they will be in one composite level on the hierarchy.
         *
         * dynamic series measures:
         *   The measures that are under the scope of the secondary axis, repeated for every series group instance.  That implies there is a grouping field on the secondary axis.
         *
         * static series measures:
         *   The measures that are NOT under the scope of the secondary axis.  In query DataView, it is possible to have static series measures
         *   even if there is a grouping field on the secondary axis (e.g. the line measures in a combo chart.)
         *
         * valueGroups:
         *   If the secondary axis has a grouping field, then valueGroups refers to the instances of that group.
         *   Otherwise, the secondary axis has no grouping field, and valueGroups will contain the single static instance that contains the static series measures.
         */
        var DataViewCategoricalProjectionOrder;
        (function (DataViewCategoricalProjectionOrder) {
            function apply(prototype, applicableRoleMappings, dataRoles, projectionOrdering, splitSelects) {
                debug.assertValue(prototype, 'prototype');
                debug.assertAnyValue(applicableRoleMappings, 'applicableRoleMappings');
                debug.assertAnyValue(dataRoles, 'dataRoles');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                var transformedDataView;
                var categoricalRoleMappingsWithoutRegression = _.chain(applicableRoleMappings)
                    .filter((function (mapping) { return mapping.categorical && !powerbi.DataViewMapping.getRegressionUsage(mapping); }))
                    .map((function (mapping) { return mapping.categorical; }))
                    .value();
                if (prototype.categorical && categoricalRoleMappingsWithoutRegression.length >= 1) {
                    var prototypeCategorical = prototype.categorical;
                    // Apply projection order and split selects to categories.
                    var transformedCategorical = applyToCategories(prototypeCategorical, categoricalRoleMappingsWithoutRegression, projectionOrdering, splitSelects);
                    // Apply split selects to secondary axis and measures.
                    transformedCategorical = applyToValuesAndGroups(transformedCategorical || prototypeCategorical, dataRoles, projectionOrdering, splitSelects);
                    // Finally, if the categorical has been transformed, create an inherited dataView:
                    if (transformedCategorical) {
                        transformedDataView = inheritSingle(prototype);
                        transformedDataView.categorical = transformedCategorical;
                    }
                }
                return transformedDataView || prototype;
            }
            DataViewCategoricalProjectionOrder.apply = apply;
            /**
             * Returns the combined projection ordering of the specified roles, filtered by splitSelects if specified.
             * Returns empty array if the columns for all category columns should get removed.
             * Returns undefined if projection order cannot be computed.
             */
            function combineProjectionOrderAndSplitSelects(roles, projectionOrdering, splitSelects) {
                debug.assertValue(roles, 'roles');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                // If projectionOrdering is undefined, do not apply it.
                // But if projectionOrdering for roles is an empty array, this module should make sure nothing gets projected (by returning empty projection order).
                if (!projectionOrdering)
                    return;
                var combinedProjectionOrder = _.reduce(roles, (function (combinedProjectionOrder, nextRole) {
                    var projectionOrderOfNextRole = _.filter(projectionOrdering[nextRole], (function (selectIndex) { return (!splitSelects || splitSelects[selectIndex]); }));
                    combinedProjectionOrder.push.apply(combinedProjectionOrder, projectionOrderOfNextRole);
                    return combinedProjectionOrder;
                }), []);
                return combinedProjectionOrder;
            }
            /**
             * If the specified prototypeCategorical.categories is not consistent with projectionOrder and splitSelects, apply them and return the result.
             * Else, returns undefined.
             */
            function applyToCategories(prototypeCategorical, categoricalRoleMappingsWithoutRegression, projectionOrdering, splitSelects) {
                debug.assertValue(prototypeCategorical, 'prototypeCategorical');
                debug.assertValue(categoricalRoleMappingsWithoutRegression, 'categoricalRoleMappingsWithoutRegression');
                debug.assert(_.every(categoricalRoleMappingsWithoutRegression, (function (roleMapping) { return !!roleMapping; })), 'categoricalRoleMappingsWithoutRegression must not contain falsy elements');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                if (!_.isEmpty(prototypeCategorical.categories)) {
                    var categoryRoles = powerbi.DataViewMapping.getRolesIfSameInAllCategoricalMappings(categoricalRoleMappingsWithoutRegression, powerbi.DataViewMapping.getAllRolesInCategories);
                    // if all applicable categorical role mappings have the same roles for categories (even if empty array)...
                    if (categoryRoles) {
                        var projectionOrderFilteredBySplit = combineProjectionOrderAndSplitSelects(categoryRoles, projectionOrdering, splitSelects);
                        // apply projectionOrderFilteredBySplit as long as it is defined, even if it is empty array
                        if (projectionOrderFilteredBySplit) {
                            return applyProjectionOrderToCategories(prototypeCategorical, projectionOrderFilteredBySplit, categoryRoles);
                        }
                    }
                }
            }
            /**
             * If the specified prototypeCategorical.categories is not consistent with projectionOrder, apply projectionOrder and return the result.
             * Else, returns undefined.
             */
            function applyProjectionOrderToCategories(prototypeCategorical, projectionOrder, categoryRoles) {
                debug.assertValue(prototypeCategorical, 'prototypeCategorical');
                debug.assertValue(projectionOrder, 'projectionOrder');
                debug.assertValue(categoryRoles, 'categoryRoles');
                var prototypeCategories = prototypeCategorical.categories;
                if (_.isEmpty(prototypeCategories)) {
                    debug.assert(_.isEmpty(projectionOrder), 'If DataViewCategory.categories is empty but projectionOrder of primary axis is non-empty, then something went wrong when projectionOrder was getting deserialized or reconstructed.  If projectionOrder for primary axis is truly non-empty, then the DSR and DataView should have some data there.');
                    return;
                }
                if (isSelectIndexOrderEqual(prototypeCategories, projectionOrder))
                    return;
                var originalMetadataColumns = _.map(prototypeCategories, (function (category) { return category.source; }));
                var originalColumnInfos = DataViewMetadataColumnUtils.leftJoinMetadataColumnsAndProjectionOrder(originalMetadataColumns, projectionOrder, categoryRoles);
                // filter out the non-projected columns and sort the remaining ones by projection order:
                var projectionTargetColumnInfos = _.chain(originalColumnInfos)
                    .filter((function (columnInfo) { return columnInfo.projectionOrderIndex !== undefined; }))
                    .sortBy((function (columnInfo) { return columnInfo.projectionOrderIndex; }))
                    .value();
                // construct a new array of category columns from the projection target array
                var transformedCategories = _.map(projectionTargetColumnInfos, (function (columnInfo) { return prototypeCategories[columnInfo.sourceIndex]; }));
                var transformedCategorical = inheritSingle(prototypeCategorical);
                if (!_.isEmpty(transformedCategories)) {
                    var dataViewObjects = data.DataViewCategoricalUtils.getCategoriesDataViewObjects(prototypeCategories);
                    if (dataViewObjects) {
                        transformedCategories =
                            data.DataViewCategoricalUtils.setCategoriesDataViewObjects(transformedCategories, dataViewObjects) || transformedCategories;
                    }
                    transformedCategorical.categories = transformedCategories;
                }
                else {
                    // if transformedCategories is an empty array, transformedCategorical.categories should become undefined
                    transformedCategorical.categories = undefined;
                }
                return transformedCategorical;
            }
            function isSelectIndexOrderEqual(categories, selectIndexOrder) {
                debug.assertValue(categories, 'categories');
                debug.assertValue(selectIndexOrder, 'selectIndexOrder');
                return (categories.length === selectIndexOrder.length) &&
                    _.every(selectIndexOrder, (function (selectIndex, i) { return categories[i].source.index === selectIndex; }));
            }
            /**
             * If the specified prototypeCategorical.values is not consistent with projectionOrder and splitSelects, apply them and return the result.
             * Else, returns undefined.
             */
            function applyToValuesAndGroups(prototypeCategorical, dataRoles, projectionOrdering, splitSelects) {
                debug.assertValue(prototypeCategorical, 'prototypeCategorical');
                debug.assertAnyValue(dataRoles, 'dataRoles');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                var prototypeValues = prototypeCategorical.values;
                // Note: Even if prototypeCategorical.values is an empty array, it may still have a field for dynamic series, in which case the split selects should still get applied.
                if (prototypeValues) {
                    // analyze the values and groups
                    var prototypeValueColumnsInfo = extractValueColumnsInfo(prototypeValues);
                    // compute the target projection order of the measures
                    var measureRolesProjectionOrder = computeMeasureRolesProjectionOrder(prototypeValueColumnsInfo, dataRoles, projectionOrdering, splitSelects);
                    // apply to measures
                    var transformedValues = applyProjectionOrderToMeasures(prototypeValues, prototypeValueColumnsInfo, measureRolesProjectionOrder);
                    // apply to properties related to secondary axis
                    transformedValues =
                        applySplitSelectsToValueGroups(transformedValues || prototypeValues, splitSelects) ||
                            transformedValues;
                    // finally, update transformedCategorical.values or its grouped() function based on the new state:
                    if (transformedValues) {
                        var hasRemainingDynamicSeries = !!transformedValues.source;
                        var hasRemainingMeasures = transformedValues.length > 0;
                        var transformedCategorical = inheritSingle(prototypeCategorical);
                        if (hasRemainingDynamicSeries || hasRemainingMeasures) {
                            transformedCategorical.values = transformedValues;
                            // Re-evaluate the return value of values.grouped() with the latest changes:
                            data.DataViewCategoricalEvalGrouped.apply(transformedCategorical);
                        }
                        else {
                            transformedCategorical.values = undefined;
                        }
                        return transformedCategorical;
                    }
                }
            }
            /**
             * Apply splitSelects on prototypeValues.
             *
             * If any transformation is performed, returns the transformed version of prototypeValues (potentially inherited).
             * Else, returns undefined.
             */
            function applySplitSelectsToValueGroups(prototypeValues, splitSelects) {
                debug.assertValue(prototypeValues, 'prototypeValues');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                // In the current code, there can be at most one select index in the secondary axis of a categorical, and whether it gets removed
                // is entirely controlled by DataViewTransformAction.splits.
                if (splitSelects && prototypeValues.source) {
                    var shouldExcludeSecondaryAxisSource = !splitSelects[prototypeValues.source.index];
                    if (shouldExcludeSecondaryAxisSource) {
                        // if processing a split and this is the split without series...
                        var transformingValues = inheritSingle(prototypeValues);
                        transformingValues.source = undefined;
                        transformingValues.identityFields = undefined;
                        return transformingValues;
                    }
                }
            }
            function computeMeasureRolesProjectionOrder(valueColumnsInfo, dataRoles, projectionOrdering, splitSelects) {
                debug.assertValue(valueColumnsInfo, 'valueColumnsInfo');
                debug.assertAnyValue(dataRoles, 'dataRoles');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                if (!projectionOrdering) {
                    return computeMeasureRolesProjectionOrderFallback(valueColumnsInfo, splitSelects);
                }
                // In order to get the projection order, this code needs to first figure out the measure roles, because projection order is keyed on role.
                // Ideally, the best way to figure out the measure roles is to get it from the applicable DataViewMapping from visual capabilities.
                // In the case of combo chart with splits, however, there will be multiple applicable DataViewMapping (one for each split),
                // and currently there is no robost way of looking up the corresponding DataViewMapping of a given split in DataViewTransformAction.splits.
                // In the long term, we might want to add a name or ID to each DataViewMapping, and tie that name or ID to each split.
                // But until then, this code will just get the value roles from DataViewCategorical.values...
                //
                // And because this code does not get the exact list of value roles from DataViewMapping, if user creates a combo chart where the same measure fields
                // are used for role Y and Y2 with different projection orders, this code cannot correctly pick the projection order for role Y2:
                // Shared Axis (Category): [Country]
                // Legend (Series): []
                // Column values (Y): [Sum(Sales), Sum(SalesQuantity)]
                // Line values (Y2): [Sum(SalesQuantity), Sum(Sales)]
                // Luckly, the projection order of measures for the Line values does not significantly affect their visualization (they'll just be 2 lines with different colors).
                // The projection order for the column measures are much more important.
                // Hence, the projection order of Y has precedence over that of Y2 in this function, and that order is derived from the dataRoles property in visual capabilities.
                // Another implication with this implementation is that this code will not project duplicate measures, which actually makes sense for charts.
                var rolePrecedenceOrder = _.reduce(dataRoles, (function (dataRolePrecedenceOrder, dataRole, i) {
                    var role = dataRole.name;
                    if (dataRolePrecedenceOrder[role] === undefined) {
                        dataRolePrecedenceOrder[role] = i;
                    }
                    return dataRolePrecedenceOrder;
                }), {});
                var dynamicMeasureSources = valueColumnsInfo.dynamicSeriesMeasureSources || [];
                var staticMeasureSources = valueColumnsInfo.staticSeriesMeasureSources || [];
                var measureSources = dynamicMeasureSources.concat(staticMeasureSources);
                var measureRoles = _.chain(measureSources)
                    .filter((function (columnSource) { return !splitSelects || !!splitSelects[columnSource.index]; }))
                    .uniq((function (columnSource) { return columnSource.index; }))
                    .map((function (columnSource) {
                    var roles = columnSource.roles;
                    return !!roles ? _.filter(Object.keys(roles), (function (role) { return roles[role]; })) : [];
                }))
                    .flatten()
                    .uniq()
                    .sortBy((function (role) { return rolePrecedenceOrder[role]; }))
                    .value();
                // By having measureRoles in precedence order (Y and then Y2) and then do a uniq() at the end,
                // the projection order of the Y measures will be correct, but the projection order of Y2 measures
                // could be wrong if some or all columns are used in both Y and Y2 roles under a static series.
                // This side-effect is OK for now; see the above block of comments for more details. 
                var projectionOrder = _.chain(measureRoles)
                    .map((function (role) { return projectionOrdering[role] || []; }))
                    .flatten()
                    .filter((function (selectIndex) { return !splitSelects || !!splitSelects[selectIndex]; }))
                    .uniq()
                    .value();
                return projectionOrder;
            }
            /**
             * projectionOrdering has always been an optional input to DataViewTransform,
             * but there is no documentation on when it can be undefined.
             * Also, there are also many test cases without projectionOrder, hence this code
             * will just fallback to using the current select order and filter by splitSelects.
             */
            function computeMeasureRolesProjectionOrderFallback(valueColumnsInfo, splitSelects) {
                debug.assertValue(valueColumnsInfo, 'valueColumnsInfo');
                debug.assertAnyValue(splitSelects, 'splitSelects');
                var dynamicMeasureSources = valueColumnsInfo.dynamicSeriesMeasureSources || [];
                var staticMeasureSources = valueColumnsInfo.staticSeriesMeasureSources || [];
                var measureSources = dynamicMeasureSources.concat(staticMeasureSources);
                var selectOrder = _.chain(measureSources)
                    .filter((function (columnSource) { return !splitSelects || !!splitSelects[columnSource.index]; }))
                    .map((function (columnSource) { return columnSource.index; }))
                    .uniq()
                    .value();
                return selectOrder;
            }
            /**
             * To exclude the values that are not in the currently transforming split, caller code should first filter the measure projection order
             * by the split select index and then pass that intersection as the measureRolesProjectionOrder argument.
             *
             * If any transformation is performed, returns the transformed version of prototypeValues (potentially inherited).
             * Else, returns undefined.
             */
            function applyProjectionOrderToMeasures(prototypeValues, prototypeValueColumnsInfo, measureRolesProjectionOrder) {
                debug.assertValue(prototypeValues, 'prototypeValues');
                debug.assertValue(prototypeValueColumnsInfo, 'prototypeValueColumnsInfo');
                debug.assertValue(measureRolesProjectionOrder, 'measureRolesProjectionOrder');
                // Separately compute the new measures under the dynamic scope and static scope: 
                var projectedDynamicSeriesMeasures = getDynamicSeriesMeasuresInProjectionOrder(prototypeValues, prototypeValueColumnsInfo, measureRolesProjectionOrder);
                var projectedStaticSeriesMeasures = getStaticSeriesMeasuresInProjectionOrder(prototypeValues, prototypeValueColumnsInfo, measureRolesProjectionOrder);
                // Updates the DataViewValueColumns object if needed: 
                if (projectedDynamicSeriesMeasures || projectedStaticSeriesMeasures) {
                    var transformedValues = inheritSingle(prototypeValues);
                    if (projectedDynamicSeriesMeasures) {
                        if (projectedStaticSeriesMeasures) {
                            // both dynamic series measures and static series measures got transformed...
                            debug.assert(_.isEmpty(projectedDynamicSeriesMeasures) || _.isEmpty(projectedStaticSeriesMeasures), 'At least one of the two arrays should be empty, because visual DataView should not have a mix of dynamic and static measures.');
                            transformedValues.splice(0, transformedValues.length);
                            transformedValues.push.apply(transformedValues, projectedDynamicSeriesMeasures);
                            transformedValues.push.apply(transformedValues, projectedStaticSeriesMeasures);
                        }
                        else {
                            // only dynamic series measures got transformed...
                            debug.assertValue(prototypeValueColumnsInfo.dynamicSeriesGroupCount, 'prototypeValueColumnsInfo.dynamicSeriesInstanceCount should have been populated if dynamic series measures got transformed');
                            debug.assertValue(prototypeValueColumnsInfo.dynamicSeriesMeasureSources, 'prototypeValueColumnsInfo.dynamicSeriesMeasureSources should have been populated if dynamic series measures got transformed');
                            var dynamicSeriesMeasureSourceCount = prototypeValueColumnsInfo.dynamicSeriesMeasureSources.length;
                            var dynamicSeriesMeasureColumnCount = dynamicSeriesMeasureSourceCount * prototypeValueColumnsInfo.dynamicSeriesGroupCount;
                            transformedValues.splice.apply(transformedValues, [0, dynamicSeriesMeasureColumnCount].concat(projectedDynamicSeriesMeasures));
                        }
                    }
                    else if (projectedStaticSeriesMeasures) {
                        // only static series measures got transformed...
                        debug.assertValue(prototypeValueColumnsInfo.staticSeriesMeasureSources, 'prototypeValueColumnsInfo.staticSeriesMeasureSources should have been populated if static series measures got transformed');
                        debug.assertValue(prototypeValueColumnsInfo.staticSeriesMeasureStartingIndex, 'prototypeValueColumnsInfo.staticSeriesMeasureStartingIndex should have been populated if static series measures got transformed');
                        var staticSeriesMeasureSourceCount = prototypeValueColumnsInfo.staticSeriesMeasureSources.length;
                        transformedValues.splice.apply(transformedValues, [prototypeValueColumnsInfo.staticSeriesMeasureStartingIndex,
                            staticSeriesMeasureSourceCount].concat(projectedStaticSeriesMeasures));
                    }
                    return transformedValues;
                }
            }
            /**
             * Returns an array containing the measures under dynamic series, ordered by projection order.
             * Returns an empty array of prototypeValues has dynamic series measures but they should be removed.
             * Returns undefined if prototypeValues already has all dyanmic series measure in the correct order.
             */
            function getDynamicSeriesMeasuresInProjectionOrder(prototypeValues, prototypeValueColumnsInfo, measureRolesProjectionOrder) {
                debug.assertValue(prototypeValues, 'prototypeValues');
                debug.assertValue(prototypeValueColumnsInfo, 'prototypeValueColumnsInfo');
                debug.assertValue(measureRolesProjectionOrder, 'measureRolesProjectionOrder');
                if (!prototypeValueColumnsInfo.dynamicSeriesGroupCount ||
                    _.isEmpty(prototypeValueColumnsInfo.dynamicSeriesMeasureSources)) {
                    return;
                }
                var projectedDynamicSeriesMeasureSources = computeProjectedSourcesIfNeeded(prototypeValueColumnsInfo.dynamicSeriesMeasureSources, measureRolesProjectionOrder);
                if (projectedDynamicSeriesMeasureSources) {
                    // number of measures under each of the dynamic series instance in the transformed values
                    var projectedMeasureSourcesCount = projectedDynamicSeriesMeasureSources.length;
                    if (projectedMeasureSourcesCount === 0) {
                        return [];
                    }
                    // number of measures under each of the dynamic series instance in the prototype values
                    var prototypeMeaureSourcesCount = prototypeValueColumnsInfo.dynamicSeriesMeasureSources.length;
                    var seriesCount = prototypeValueColumnsInfo.dynamicSeriesGroupCount;
                    var projectedValues = [];
                    // for each series group instance (e.g. 'Canada', 'US', ...)
                    for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                        var offsetInPrototypeValues = seriesIndex * prototypeMeaureSourcesCount;
                        // for each measure value source being projected (e.g. Revenue, Quantity, ...) 
                        for (var projectedMeasureIndex = 0; projectedMeasureIndex < projectedMeasureSourcesCount; projectedMeasureIndex++) {
                            var prototypeMeasureSourceIndex = projectedDynamicSeriesMeasureSources[projectedMeasureIndex].sourceIndex;
                            var valueColumn = prototypeValues[offsetInPrototypeValues + prototypeMeasureSourceIndex];
                            projectedValues.push(valueColumn);
                        }
                    }
                    return projectedValues;
                }
            }
            function getStaticSeriesMeasuresInProjectionOrder(prototypeValues, prototypeValueColumnsInfo, measureRolesProjectionOrder) {
                debug.assertValue(prototypeValues, 'prototypeValues');
                debug.assertValue(prototypeValueColumnsInfo, 'prototypeValueColumnsInfo');
                debug.assertValue(measureRolesProjectionOrder, 'measureRolesProjectionOrder');
                if (_.isEmpty(prototypeValueColumnsInfo.staticSeriesMeasureSources)) {
                    return;
                }
                var projectedStaticSeriesMeasureSources = computeProjectedSourcesIfNeeded(prototypeValueColumnsInfo.staticSeriesMeasureSources, measureRolesProjectionOrder);
                if (projectedStaticSeriesMeasureSources) {
                    // number of measures under the static series in the transformed values
                    var projectedMeasureSourcesCount = projectedStaticSeriesMeasureSources.length;
                    if (projectedMeasureSourcesCount === 0) {
                        return [];
                    }
                    var offsetInPrototypeValues = prototypeValueColumnsInfo.staticSeriesMeasureStartingIndex;
                    var projectedValues = [];
                    // for each measure value source being projected (e.g. Revenue, Quantity, ...) 
                    for (var projectedMeasureIndex = 0; projectedMeasureIndex < projectedMeasureSourcesCount; projectedMeasureIndex++) {
                        var prototypeMeasureSourceIndex = projectedStaticSeriesMeasureSources[projectedMeasureIndex].sourceIndex;
                        var valueColumn = prototypeValues[offsetInPrototypeValues + prototypeMeasureSourceIndex];
                        projectedValues.push(valueColumn);
                    }
                    return projectedValues;
                }
            }
            /**
             * Joins measureSources with projectionOrder and sorts the result by projection order.
             * If the resulting columns is in a different order than the specified measureSources, returns the result.
             * If the projection order indicates that the measures should be removed, returns an empty array.
             * Else, if measureSources is already in projection order, returns undefined.
             */
            function computeProjectedSourcesIfNeeded(measureSources, projectionOrder) {
                debug.assertValue(measureSources, 'measureSources');
                debug.assertValue(projectionOrder, 'projectionOrder');
                var jointMeasureSources = DataViewMetadataColumnUtils.leftJoinMetadataColumnsAndProjectionOrder(measureSources, projectionOrder);
                // sorts by projection order and filters out non-projected sources:
                jointMeasureSources = _.chain(jointMeasureSources)
                    .filter((function (column) { return column.projectionOrderIndex !== undefined; })) // filter out the non-projected sources
                    .sortBy((function (column) { return column.projectionOrderIndex; }))
                    .value();
                var isInProjectionOrder = ArrayExtensions.sequenceEqual(measureSources, jointMeasureSources, (function (a, b) { return a.index === b.metadataColumn.index; }));
                if (!isInProjectionOrder) {
                    return jointMeasureSources;
                }
            }
            function extractValueColumnsInfo(values) {
                debug.assertValue(values, 'values');
                var secondaryAxisSource = values.source;
                var dynamicSeriesGroupCount;
                var dynamicSeriesMeasureSources;
                var staticSeriesMeasureStartingIndex;
                var staticSeriesMeasureSources;
                var valueGroups = values.grouped();
                if (secondaryAxisSource) {
                    dynamicSeriesMeasureSources = getMeasureSourcesInFirstGroupInstance(valueGroups);
                    // Note that it is possible for a query DataView's categorical to have measure(s) under both dynamic series 
                    // and static series (e.g. for combo chart). In that case, the static series measures can be found in
                    // the values array after all dynamic series measures.
                    dynamicSeriesGroupCount = valueGroups.length;
                    var dynamicSeriesMeasureSourceCount = _.size(dynamicSeriesMeasureSources);
                    var dynamicSeriesMeasureColumnCount = dynamicSeriesGroupCount * dynamicSeriesMeasureSourceCount;
                    var staticSeriesMeasureColumnCount = values.length - dynamicSeriesMeasureColumnCount;
                    if (staticSeriesMeasureColumnCount > 0) {
                        staticSeriesMeasureStartingIndex = dynamicSeriesMeasureColumnCount;
                        staticSeriesMeasureSources = _.chain(values)
                            .takeRight(staticSeriesMeasureColumnCount)
                            .map((function (measureColumn) { return measureColumn.source; }))
                            .value();
                    }
                }
                else {
                    staticSeriesMeasureStartingIndex = 0;
                    staticSeriesMeasureSources = getMeasureSourcesInFirstGroupInstance(valueGroups);
                }
                return {
                    secondaryAxisSource: secondaryAxisSource,
                    dynamicSeriesGroupCount: dynamicSeriesGroupCount,
                    dynamicSeriesMeasureSources: dynamicSeriesMeasureSources,
                    staticSeriesMeasureStartingIndex: staticSeriesMeasureStartingIndex,
                    staticSeriesMeasureSources: staticSeriesMeasureSources,
                };
            }
            /**
             * If the specified series is non-empty, returns the DataViewMetadataColumn objects
             * from the measure columns in the first series instance.
             * If there is no measure under the series, returns empty array.
             * If the specified series is empty (i.e. there are no series instances), returns undefined.
             */
            function getMeasureSourcesInFirstGroupInstance(groups) {
                debug.assertValue(groups, 'groups');
                if (!_.isEmpty(groups)) {
                    var firstGroup = groups[0];
                    return _.map(firstGroup.values, (function (measureColumn) { return measureColumn.source; }));
                }
            }
        })(DataViewCategoricalProjectionOrder = data.DataViewCategoricalProjectionOrder || (data.DataViewCategoricalProjectionOrder = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var Prototype = powerbi.Prototype;
        var DataViewUpgradeFromCY16SU09Map;
        (function (DataViewUpgradeFromCY16SU09Map) {
            var CY16SU09MatrixRowsRoles1 = ['Series', 'Category'];
            /**
             * The order of the 'X' and 'Y' roles here must be consistent with the order as they appear in
             * map visual's DataViewMappings select array in BOTH the old CY16SU08 code and the new CY16SU09 code.
             */
            var CY16SU09MatrixRowsRoles2 = ['Series', 'X', 'Y'];
            function detectAndApply(prototype, transformActions, applicableRoleMappings, drillableRoles) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(transformActions, 'transformActions');
                debug.assertAnyValue(applicableRoleMappings, 'applicableRoleMappings');
                debug.assertAnyValue(drillableRoles, 'drillableRoles');
                if (!_.isEmpty(transformActions.splits)) {
                    return prototype;
                }
                var dataViewMatrix = prototype.matrix;
                if (!dataViewMatrix) {
                    return prototype;
                }
                // detect if DataViewTransform is targetting one of the upgraded DataViewMappings...
                var matchingUpgradeSourceRolesStructures = _.chain(applicableRoleMappings)
                    .map((function (mapping) { return getMatchingUpgradeSourceRolesStructure(mapping); }))
                    .filter((function (upgradeSourceRoles) { return !!upgradeSourceRoles; }))
                    .value();
                if (matchingUpgradeSourceRolesStructures.length !== 1) {
                    return prototype;
                }
                // detect if the current shape of the data is from the old version of the query (generated with the old version of map DataViewMappings)
                var dataViewSelectIndices = data.DataViewMatrixUtils.extractSelectIndices(dataViewMatrix);
                if (!shouldUpgrade(dataViewSelectIndices, transformActions, drillableRoles, matchingUpgradeSourceRolesStructures[0])) {
                    return prototype;
                }
                var transformedMatrix = pivotSecondaryAxisToOuterMostPrimaryAxis(dataViewMatrix);
                var transformedDataView = Prototype.inheritSingle(prototype);
                transformedDataView.matrix = transformedMatrix;
                return transformedDataView;
            }
            DataViewUpgradeFromCY16SU09Map.detectAndApply = detectAndApply;
            /**
             * If the specified dataViewMapping is one of the potential dataViewMappings that we want to upgrade for, returns an object containing the expected roles structure to upgrade from.
             * Else, returns undefined.
             */
            function getMatchingUpgradeSourceRolesStructure(dataViewMapping) {
                debug.assertValue(dataViewMapping, 'dataViewMapping');
                var matrix = dataViewMapping.matrix;
                if (matrix &&
                    matrix.rows &&
                    !matrix.columns &&
                    !matrix.values) {
                    // TODO VSTS 8253839: probably need to enhance this check when integrating with changes by davsets, to express that 'X' and 'Y' are in a composite group level.
                    var matrixRowsRoles = powerbi.DataViewMapping.getRoles(matrix.rows, powerbi.DataViewMapping.visitMatrixRows);
                    if (ArrayExtensions.sequenceEqual(matrixRowsRoles, CY16SU09MatrixRowsRoles1, (function (lhs, rhs) { return lhs === rhs; })) ||
                        ArrayExtensions.sequenceEqual(matrixRowsRoles, CY16SU09MatrixRowsRoles2, (function (lhs, rhs) { return lhs === rhs; }))) {
                        var upgradeFromRoleNames = {
                            primaryAxisRoles: matrixRowsRoles.slice(1),
                            secondaryAxisRole: matrixRowsRoles[0],
                        };
                        return upgradeFromRoleNames;
                    }
                }
                return;
            }
            function shouldUpgrade(dataViewSelectIndices, transformActions, drillableRoles, matchingUpgradeSourceRolesStructure) {
                debug.assertValue(dataViewSelectIndices, 'dataViewSelectIndices');
                debug.assertValue(transformActions, 'transformActions');
                debug.assertAnyValue(drillableRoles, 'drillableRoles');
                debug.assertValue(matchingUpgradeSourceRolesStructure, 'matchingUpgradeSourceRolesStructure');
                var dataViewPrimaryAxisLevels = dataViewSelectIndices.primaryAxis;
                var dataViewSecondaryAxisLevels = dataViewSelectIndices.secondaryAxis;
                // A dataView from the old query would contain no intersection, 1 level in primary axis, and 1 level in secondary axis
                if (!_.isEmpty(dataViewSelectIndices.intersection) ||
                    _.size(dataViewPrimaryAxisLevels) !== 1 ||
                    _.size(dataViewSecondaryAxisLevels) !== 1) {
                    return false;
                }
                var selectTransforms = transformActions.selects;
                // Except for drillable roles, the dataView from the old query would contain exactly one grouping field per role.
                // Check that on both primary axis and secondary axis.
                if (!isGroupingLevelFieldsAndRolesConsistent(dataViewPrimaryAxisLevels[0].selectIndices, selectTransforms, drillableRoles, matchingUpgradeSourceRolesStructure.primaryAxisRoles)) {
                    return false;
                }
                if (!isGroupingLevelFieldsAndRolesConsistent(dataViewSecondaryAxisLevels[0].selectIndices, selectTransforms, drillableRoles, [matchingUpgradeSourceRolesStructure.secondaryAxisRole])) {
                    return false;
                }
                return true;
            }
            /**
             * In order for groupingLevelSelectIndices to be considered consistent with the specified roles,
             * the former must have exactly 1 field for each of each non-drillable role in roles,
             * and it must have 1+ field for each drillable role in roles,
             * and it must contain no select for other roles.
             */
            function isGroupingLevelFieldsAndRolesConsistent(groupingLevelSelectIndices, selectTransforms, drillableRoles, rolesToMatch) {
                debug.assertValue(groupingLevelSelectIndices, 'groupingLevelSelectIndices');
                debug.assertValue(selectTransforms, 'selectTransforms');
                debug.assertAnyValue(drillableRoles, 'drillableRoles');
                debug.assertValue(rolesToMatch, 'rolesToMatch');
                var selectCountForAllMatchingRoles = 0;
                var selectLength = groupingLevelSelectIndices.length;
                for (var _i = 0, rolesToMatch_1 = rolesToMatch; _i < rolesToMatch_1.length; _i++) {
                    var roleToMatch = rolesToMatch_1[_i];
                    if (selectLength <= selectCountForAllMatchingRoles) {
                        return false;
                    }
                    var selectCountForRole = getCountOfContiguousSelectsForRole(groupingLevelSelectIndices, selectTransforms, roleToMatch);
                    if (selectCountForRole === 0) {
                        // there is no select for roleToMatch in the expected position in groupingLevelSelectIndices
                        return false;
                    }
                    else if (selectCountForRole >= 2) {
                        // if we have 2 or more selects for a role, then it is a match only if the role is drillable
                        if (!_.contains(drillableRoles, roleToMatch)) {
                            return false;
                        }
                    }
                    selectCountForAllMatchingRoles += selectCountForRole;
                }
                // if there is any additional select with role that are not in rolesToMatch...
                if (selectCountForAllMatchingRoles < selectLength) {
                    return false;
                }
                return true;
            }
            function getCountOfContiguousSelectsForRole(selectIndices, selectTransforms, roleToMatch) {
                debug.assertValue(selectIndices, 'selectIndices');
                debug.assertValue(selectTransforms, 'selectTransforms');
                debug.assertValue(roleToMatch, 'roleToMatch');
                var count = 0;
                for (var _i = 0, selectIndices_1 = selectIndices; _i < selectIndices_1.length; _i++) {
                    var selectIndex = selectIndices_1[_i];
                    var roles = selectTransforms[selectIndex] && selectTransforms[selectIndex].roles;
                    if (data.DataViewMetadataColumnUtils.isExactMatchRole(roles, roleToMatch)) {
                        count++;
                    }
                    else if (count > 0) {
                        // if we have previously encountered a select for roleTomatch, then the contiguous chunk of selects for the role has ended 
                        break;
                    }
                }
                return count;
            }
            /**
             * Note: This function is not a general-purpose pivoting function.
             * It is only good enough to handle the upgrade for the specific dataViewMatrix that results from the old query in CY16SU08 and prior.
             */
            function pivotSecondaryAxisToOuterMostPrimaryAxis(dataViewMatrix) {
                debug.assertValue(dataViewMatrix, 'dataViewMatrix');
                debug.assert(dataViewMatrix.columns.levels.length === 1, 'dataViewMatrix.columns.levels.length === 1');
                debug.assert(dataViewMatrix.rows.levels.length === 1, 'dataViewMatrix.rows.levels.length === 1');
                debug.assert(_.isEmpty(dataViewMatrix.valueSources), '_.isEmpty(dataViewMatrix.valueSources)');
                var transformingMatrix = Prototype.inheritSingle(dataViewMatrix);
                var transformingRows = transformingMatrix.rows
                    = Prototype.inheritSingle(dataViewMatrix.rows);
                var transformingColumns = transformingMatrix.columns
                    = Prototype.inheritSingle(dataViewMatrix.columns);
                // move levelSources from columns.levels[0] to rows.levels[0], bumping the origina rows.levels[0] to rows.levels[1]
                var transformingColumnsLevels = transformingColumns.levels
                    = Prototype.inheritSingle(transformingColumns.levels);
                var columnHierarchyLevel0Sources = transformingColumnsLevels.splice(0, 1)[0];
                var transformingRowsLevels = transformingRows.levels
                    = Prototype.inheritSingle(transformingRows.levels);
                transformingRowsLevels.splice(0, 0, columnHierarchyLevel0Sources);
                // move the root node of columns hierarchy to be the new root node on row hierarchy...
                var oldRowsRoot = dataViewMatrix.rows.root;
                var transformingNewRowsRoot = transformingRows.root
                    = Prototype.inheritSingle(transformingColumns.root);
                transformingColumns.root = {
                    children: [],
                };
                // and repeat the old rows hierarchy root under each child node of the new row hierarchy root.
                var transformedNewRowsRootChildren = Prototype.overrideArray(transformingNewRowsRoot.children, (function (newRowsLevel0Node) {
                    var transformingNewRowsLevel0Node = Prototype.inheritSingle(newRowsLevel0Node);
                    transformingNewRowsLevel0Node.childIdentityFields = oldRowsRoot.childIdentityFields;
                    // Do not share the same subtree of hierarchy nodes under multiple level-0 nodes, or else
                    // you will encounter problem if columns in a composite group level needs to be reordered by projection order
                    // and there is an even number of series instances. 
                    transformingNewRowsLevel0Node.children = inheritAndIncrementLevelIndex(oldRowsRoot.children);
                    return transformingNewRowsLevel0Node;
                }));
                if (transformedNewRowsRootChildren) {
                    transformingNewRowsRoot.children = transformedNewRowsRootChildren;
                }
                return transformingMatrix;
            }
            function inheritAndIncrementLevelIndex(nodes) {
                debug.assertAnyValue(nodes, 'nodes');
                if (!nodes) {
                    return nodes;
                }
                var transformedNodes = Prototype.overrideArray(nodes, (function (node) {
                    var transformingNode = Prototype.inherit(node);
                    transformingNode.level += 1;
                    return transformingNode;
                }));
                return transformedNodes || Prototype.inherit(nodes);
            }
        })(DataViewUpgradeFromCY16SU09Map = data.DataViewUpgradeFromCY16SU09Map || (data.DataViewUpgradeFromCY16SU09Map = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var data;
    (function (data_4) {
        var inherit = powerbi.Prototype.inherit;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var EnumExtensions = jsCommon.EnumExtensions;
        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.
        var DataViewTransform;
        (function (DataViewTransform) {
            var fillRulePropertyDescriptor = { type: { fillRule: {} } };
            // NOTE: Define default localization options, but these will be overriden by setLocalizationOptions.
            var localizationOptions = {
                quarterPrefix: 'Qtr {0}'
            };
            function setLocalizationOptions(options) {
                debug.assertValue(options, 'options');
                localizationOptions = options;
            }
            DataViewTransform.setLocalizationOptions = setLocalizationOptions;
            function apply(options) {
                debug.assertValue(options, 'options');
                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.
                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, transforms = options.transforms, colorAllocatorFactory = options.colorAllocatorFactory;
                if (!prototype)
                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);
                if (!transforms)
                    return [prototype];
                var transformContext = data_4.DataViewTransformContext.create(prototype.metadata, objectDescriptors, options.dataViewMappings, options.dataRoles, options.drillCapabilities, transforms, colorAllocatorFactory);
                // Pivot and upgrade dataView, if needed
                var pivotedAndUpgradedDataView = pivotAndUpgradeQueryDataView(prototype, transformContext);
                // Transform Query DataView to Visual DataView
                var visualDataViews = transformQueryToVisualDataView(pivotedAndUpgradedDataView, transformContext, options.bypassConcatenation);
                // Transform and generate derived visual DataViews
                visualDataViews = data_4.DataViewRegression.run({
                    visualDataViews: visualDataViews,
                    dataRoles: transformContext.dataRoles,
                    objectDescriptors: objectDescriptors,
                    objectDefinitions: transforms.objects,
                    colorAllocatorFactory: colorAllocatorFactory,
                    transformSelects: transforms.selects,
                    applicableDataViewMappings: transformContext.applicableRoleMappings,
                    roleKindByQueryRef: transformContext.roleKindByQueryRef,
                    queryProjectionsByRole: transformContext.queryProjectionsByRole,
                });
                return visualDataViews;
            }
            DataViewTransform.apply = apply;
            /**
             * Performs all necessary pivoting and upgrading on query DataView.  This step happens before the transformation from query DataView to visual DataView.
             */
            function pivotAndUpgradeQueryDataView(prototype, transformContext) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(transformContext, 'transformContext');
                var transformsActions = transformContext.transforms;
                var applicableRoleMappings = transformContext.applicableRoleMappings;
                // If the query was pivoted, we must unpivot the DataViewMatrix and convert it to DataViewCategorical before transformQueryToVisualDataView(...).
                // This is because the visual capability role mapping(s) actually targets a Categorical
                // but the DSR from such query cannot be parsed into a Categorical.  Hence, create the Categorical from Matrix
                // before handing the DataView to the rest of the transform pipeline, so that the Categorical can receive the relevant transforms.
                var newDataView = data_4.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transformContext.selectTransforms, transformContext.roleKindByQueryRef, transformContext.queryProjectionsByRole, applicableRoleMappings);
                newDataView = data_4.DataViewUpgradeFromCY16SU09Map.detectAndApply(newDataView, transformsActions, applicableRoleMappings, transformContext.drillCapabilities && transformContext.drillCapabilities.roles);
                newDataView = data_4.DataViewPivotMatrixToPrimaryGroups.pivot(newDataView, transformContext.selectTransforms, transformContext.roleKindByQueryRef, transformContext.queryProjectionsByRole, transformContext.drillCapabilities && transformContext.drillCapabilities.roles, applicableRoleMappings);
                return newDataView;
            }
            function transformQueryToVisualDataView(prototype, transformContext, bypassConcatenation) {
                debug.assertValue(transformContext, 'transformContext');
                var transformedDataViews = [];
                var splits = transformContext.transforms.splits;
                if (_.isEmpty(splits)) {
                    transformedDataViews.push(transformDataView(prototype, transformContext, null, bypassConcatenation));
                }
                else {
                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {
                        var split = splits_1[_i];
                        var transformed = transformDataView(prototype, transformContext, split.selects);
                        transformedDataViews.push(transformed);
                    }
                }
                return transformedDataViews;
            }
            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {
                if (transforms && transforms.objects) {
                    var emptyDataView = {
                        metadata: {
                            columns: [],
                        }
                    };
                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);
                    return [emptyDataView];
                }
                return [];
            }
            function transformDataView(prototype, transformContext, selectsToInclude, bypassConcatenation) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(transformContext, 'transformContext');
                debug.assert(!selectsToInclude ||
                    _.filter(Object.keys(selectsToInclude), (function (selectIndex) { return selectsToInclude[selectIndex] && (!transformContext.selectTransforms || !transformContext.selectTransforms[selectIndex]); }))
                        .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0
                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');
                var transformed = inherit(prototype);
                transformed.metadata = inherit(prototype.metadata);
                transformed = pruneNonApplicableDataViewKinds(transformed, transformContext);
                // TODO VSTS 7427800: Use applicableDataViewKinds/applicableRoleMappings instead of visualCapabilitiesDataViewKinds/visualCapabilitiesRoleMappings
                // when the input DataViewTransformActions becomes reliable.
                var targetDataViewKinds = transformContext.visualCapabilitiesDataViewKinds;
                var targetRoleMappings = transformContext.visualCapabilitiesRoleMappings;
                var selectTransforms = transformContext.selectTransforms;
                var objectDescriptors = transformContext.objectDescriptors;
                var projectionOrdering = transformContext.projectionOrdering;
                // The long term goal is to not have to track this set of states...
                var matrixTransformationContext = {
                    rowHierarchyRewritten: false,
                    columnHierarchyRewritten: false,
                    hierarchyTreesRewritten: false
                };
                var columnRewrites = [];
                transformed = transformSelects(transformed, targetDataViewKinds, targetRoleMappings, selectTransforms, projectionOrdering, columnRewrites, matrixTransformationContext);
                transformObjects(transformed, transformContext.visualCapabilitiesDataViewKinds, objectDescriptors, transformContext.transforms.objects, selectTransforms, transformContext.colorAllocatorFactory);
                // Note: Apply projection order after transformObjects(), because applying projection order will remove auto-insert role-less selects whose values need to get copied into DataViewObjects.
                transformed = applyProjectionOrder(transformed, transformContext, columnRewrites, matrixTransformationContext, selectsToInclude);
                // Note: Do this step after transformObjects() so we have scalarKeys populated
                transformed = data_4.DataViewHierarchyLevelBackfill.apply(transformed, localizationOptions.quarterPrefix);
                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated
                if (!bypassConcatenation) {
                    transformed = data_4.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, transformContext.applicableRoleMappings, projectionOrdering, transformContext.projectionActiveItems);
                }
                data_4.DataViewNormalizeValues.apply({
                    dataview: transformed,
                    dataViewMappings: targetRoleMappings,
                    dataRoles: transformContext.dataRoles,
                });
                return transformed;
            }
            function applyProjectionOrder(prototype, transformContext, columnRewrites, matrixTransformationContext, selectsToInclude) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(transformContext, 'transformContext');
                debug.assertValue(matrixTransformationContext, 'matrixTransformationContext');
                debug.assertAnyValue(selectsToInclude, 'selectsToInclude');
                var projectionOrdering = transformContext.projectionOrdering;
                var applicableRoleMappings = transformContext.applicableRoleMappings;
                var transformed = inheritSingle(prototype);
                if (transformed.table && EnumExtensions.hasFlag(transformContext.applicableDataViewKinds, 8 /* Table */)) {
                    applyProjectionReorderTable(transformed.table, projectionOrdering, columnRewrites);
                }
                // Don't perform this potentially expensive transform unless we actually have a matrix.
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (transformed.matrix && EnumExtensions.hasFlag(transformContext.applicableDataViewKinds, 2 /* Matrix */)) {
                    var roleMappingsWithMatrix = _.filter(applicableRoleMappings, (function (roleMapping) { return !!roleMapping.matrix; }));
                    debug.assertValue(roleMappingsWithMatrix.length !== 0, 'transformContext.applicableDataViewKinds should not have included Matrix if none of the applicableRoleMappings targets matrix.');
                    debug.assertValue(roleMappingsWithMatrix.length < 2, 'This logic needs to be enhanced if there is more than one applicable DataViewMapping that targets matrix.');
                    transformed.matrix = data_4.DataViewMatrixProjectionOrder.apply(transformed.matrix, roleMappingsWithMatrix[0].matrix, projectionOrdering, matrixTransformationContext);
                    if (shouldPivotMatrix(transformed.matrix, applicableRoleMappings))
                        data_4.DataViewPivotMatrix.apply(transformed.matrix, matrixTransformationContext);
                }
                transformed = data_4.DataViewCategoricalProjectionOrder.apply(transformed, applicableRoleMappings, transformContext.dataRoles, projectionOrdering, selectsToInclude);
                // TODO VSTS 7024199: separate out structural transformations on DataViewTable from dataViewTransform.transformSelects(...)
                return transformed;
            }
            function applyProjectionReorderTable(table, projectionOrdering, columnRewrites) {
                if (!projectionOrdering)
                    return table;
                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);
                if (!newToOldPositions)
                    return table;
                var reorder = function (row) {
                    var keys = Object.keys(newToOldPositions);
                    var newRow = new Array(keys.length);
                    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                        var key = keys_1[_i];
                        newRow[key] = row[newToOldPositions[key]];
                    }
                    return newRow;
                };
                table = inheritSingle(table);
                // Reorder the columns
                table.columns = reorder(table.columns);
                // Reorder the rows and their objects
                if (!_.isEmpty(table.rows)) {
                    table.rows = powerbi.Prototype.overrideArray(table.rows, (function (row) {
                        var newRow = reorder(row);
                        if (row.objects)
                            newRow.objects = reorder(row.objects);
                        return newRow;
                    }));
                }
                if (table.totals) {
                    var newTotal = reorder(table.totals);
                    if (table.totals.objects)
                        newTotal.objects = reorder(table.totals.objects);
                    table.totals = newTotal;
                }
                return table;
            }
            function pruneNonApplicableDataViewKinds(prototype, transformContext) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(transformContext, 'transformContext');
                // The main reason why non-applicable dataView types need to get pruned is NOT due to efficiency, even though it is our long term goal.
                // The main reason is actually for visual layer code to know which dataView type to read from, when there is more than one DataViewMapping 
                // in Visual Capabilities but only one of them is applicable.
                // E.g. Map visuals has DataViewMappings for Matrix and Categorical, and the visual code needs to know which one between matrix and categorical 
                // to read from in a given visual DataView. 
                // Due to fear of breaking custom visuals, for now this function will not prune any non-applicable dataView type when the visual capabilities only ask for one type.
                var visualCapabilitiesDataViewKindCount = EnumExtensions.getBitCount(transformContext.visualCapabilitiesDataViewKinds);
                if (visualCapabilitiesDataViewKindCount <= 1) {
                    return prototype;
                }
                var applicableDataViewKinds = transformContext.applicableDataViewKinds;
                var applicableDataViewKindCount = EnumExtensions.getBitCount(applicableDataViewKinds);
                if (applicableDataViewKindCount === 0) {
                    // TODO VSTS 7427800: applicableRoleMappings can be empty on first load in service due to a bug in DataViewTransformActionsSerializer.
                    // For now, do not do anything risky in such case.
                    return prototype;
                }
                // Technically, each "split" of dataViews can have only 1 dataView type and we should ideally prune each "split" according to the corresponding DataViewMapping.
                // Unfortunately, there is no robust way of associating a split with a DataViewMapping yet (e.g. adding an ID to DataViewMapping and have each split tie to a DataViewMapping by ID.)
                // For the map legend scenario, there is no splitting and therefore it is good enough to keep all applicable dataView types.
                var transformed = inheritSingle(prototype);
                if (transformed.categorical && !EnumExtensions.hasFlag(applicableDataViewKinds, 1 /* Categorical */)) {
                    transformed.categorical = undefined;
                }
                if (transformed.matrix && !EnumExtensions.hasFlag(applicableDataViewKinds, 2 /* Matrix */)) {
                    transformed.matrix = undefined;
                }
                if (transformed.table && !EnumExtensions.hasFlag(applicableDataViewKinds, 8 /* Table */)) {
                    transformed.table = undefined;
                }
                if (transformed.tree && !EnumExtensions.hasFlag(applicableDataViewKinds, 16 /* Tree */)) {
                    transformed.tree = undefined;
                }
                if (transformed.single && !EnumExtensions.hasFlag(applicableDataViewKinds, 4 /* Single */)) {
                    transformed.single = undefined;
                }
                return transformed;
            }
            /**
             * Apply transformSelects and fill in columnRewrites, which will be used in a later step (ApplyProjectionOrder)
             */
            function transformSelects(dataView, targetDataViewKinds, roleMappings, selectTransforms, projectionOrdering, columnRewrites, matrixTransformationContext) {
                debug.assertValue(dataView, 'prototype');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                debug.assert(targetDataViewKinds === 0 /* None */ || !_.isEmpty(roleMappings), 'if targetDataViewKinds !== None, then roleMappings must be non-empty');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertValue(columnRewrites, 'columnRewrites');
                debug.assertValue(matrixTransformationContext, 'matrixTransformationContext');
                columnRewrites.length = 0;
                if (selectTransforms) {
                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);
                    evaluateAggregateSources(dataView, selectTransforms);
                }
                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)
                if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {
                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites);
                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)
                    // NOTE: This is slightly DSR-specific.
                    dataView = pivotIfNecessary(dataView, roleMappings);
                }
                // Don't perform this potentially expensive transform unless we actually have a matrix.
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {
                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, projectionOrdering, matrixTransformationContext);
                }
                // Don't perform this potentially expensive transform unless we actually have a table.
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {
                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites);
                }
                if (dataView.single && EnumExtensions.hasFlag(targetDataViewKinds, 4 /* Single */)) {
                    dataView.single = applyRewritesToSingle(dataView.single, columnRewrites);
                }
                return dataView;
            }
            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {
                debug.assertValue(prototypeColumns, 'columns');
                if (!selects)
                    return prototypeColumns;
                // column may contain undefined entries
                var columns = inherit(prototypeColumns);
                var _loop_3 = function (i, len) {
                    var prototypeColumn = prototypeColumns[i];
                    var select = selects[prototypeColumn.index];
                    var column = prototypeColumn;
                    if (select) {
                        column = columns[i] = inheritColumnProperties(prototypeColumn, select);
                    }
                    else if (!_.any(prototypeColumns, (function (c) { return c.formatSource && c.formatSource.formatString === prototypeColumn; }))) {
                        return "continue";
                    }
                    rewrites.push({
                        from: prototypeColumn,
                        to: column,
                    });
                };
                for (var i = 0, len = prototypeColumns.length; i < len; i++) {
                    _loop_3(i, len);
                }
                debug.assert(_.every(rewrites, (function (rewrite) { return rewrite.from.index === rewrite.to.index; })), 'post-condition: DataViewMetadataColumn.index is not expected to be rewritten by select transforms.');
                return columns;
            }
            function inheritColumnProperties(prototypeColumn, select) {
                debug.assertValue(prototypeColumn, 'prototypeColumn');
                debug.assertValue(select, 'select');
                var column = inherit(prototypeColumn);
                if (select.roles)
                    column.roles = select.roles;
                if (select.type)
                    column.type = select.type;
                column.format = getFormatForColumn(select, column);
                if (select.displayName)
                    column.displayName = select.displayName;
                if (select.queryName)
                    column.queryName = select.queryName;
                if (select.expr)
                    column.expr = select.expr;
                if (select.kpi && select.kpi.graphic)
                    column.kpi = select.kpi;
                if (select.sort)
                    column.sort = select.sort;
                if (select.sortOrder != null)
                    column.sortOrder = select.sortOrder;
                if (select.discourageAggregationAcrossGroups)
                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;
                if (select.parameter)
                    column.parameter = select.parameter;
                return column;
            }
            function evaluateAggregateSources(dataView, selects) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selects, 'selects');
                if (!selects)
                    return;
                var columns = dataView.metadata.columns, evalContext;
                for (var selectIdx = 0, len = selects.length; selectIdx < len; selectIdx++) {
                    var select = selects[selectIdx];
                    var aggregateSources = select && select.aggregateSources;
                    if (!aggregateSources)
                        continue;
                    if (!evalContext)
                        evalContext = data_4.createStaticEvalContext(data_4.createColorAllocatorCache(), dataView, selects);
                    var column = findOrCreateColumn(columns, selectIdx, select);
                    var columnAggregates = column.aggregates = {};
                    var type = powerbi.ValueType.fromDescriptor(column.type);
                    var value = evaluateAggregate(evalContext, selects, type, aggregateSources.min);
                    if (value !== undefined)
                        columnAggregates.min = value;
                    value = evaluateAggregate(evalContext, selects, type, aggregateSources.max);
                    if (value !== undefined)
                        columnAggregates.max = value;
                }
            }
            function findOrCreateColumn(columns, selectIdx, select) {
                debug.assertValue(columns, 'columns');
                debug.assertValue(selectIdx, 'selectIdx');
                debug.assertValue(select, 'select');
                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {
                    var column = columns_5[_i];
                    if (column.index === selectIdx && column.groupName === undefined)
                        return column;
                }
                var newColumn = inheritColumnProperties({ displayName: select.displayName }, select);
                columns.push(newColumn);
                return newColumn;
            }
            function evaluateAggregate(evalContext, selects, type, source) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(selects, 'selects');
                debug.assertValue(type, 'type');
                debug.assertValue(source, 'source');
                var select = selects[source.index];
                if (select)
                    return data_4.DataViewObjectEvaluator.evaluateValue(evalContext, select.expr, type);
            }
            /**
             * Get the column format. Order of precendence is:
             *  1. Select format
             *  2. Column format
             */
            function getFormatForColumn(select, column) {
                // TODO: we already copied the select.Format to column.format, we probably don't need this check
                return select.format || column.format;
            }
            function applyRewritesToCategorical(prototype, columnRewrites) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(columnRewrites, 'columnRewrites');
                var categorical = inherit(prototype);
                function override(value) {
                    var rewrittenSource = findOverride(value.source, columnRewrites);
                    if (rewrittenSource) {
                        var rewritten = inherit(value);
                        rewritten.source = rewrittenSource;
                        return rewritten;
                    }
                }
                // apply metadata column rewrites to categories
                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);
                if (categories) {
                    categorical.categories = categories;
                }
                // apply metadata column rewrites to both series and measure
                // If there is no measure, prototype.values will be an empty array, but it can still have a dynamic series.
                if (prototype.values) {
                    var valueColumns = powerbi.Prototype.overrideArray(prototype.values, override) || inheritSingle(prototype.values);
                    categorical.values = valueColumns;
                    if (valueColumns.source) {
                        var rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);
                        if (rewrittenValuesSource)
                            valueColumns.source = rewrittenValuesSource;
                    }
                }
                data_4.DataViewCategoricalEvalGrouped.apply(categorical);
                return categorical;
            }
            function applyRewritesToTable(prototype, columnRewrites) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(columnRewrites, 'columnRewrites');
                var table = inherit(prototype);
                // Copy the rewritten columns into the table view
                var override = function (metadata) { return findOverride(metadata, columnRewrites); };
                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);
                if (columns)
                    table.columns = columns;
                return table;
            }
            function applyRewritesToSingle(prototype, columnRewrites) {
                var override = findOverride(prototype.column, columnRewrites);
                if (override) {
                    prototype = inheritSingle(prototype);
                    prototype.column = override;
                }
                return prototype;
            }
            /** Creates a mapping of new position to original position. */
            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {
                var roles = Object.keys(projectionOrdering);
                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.
                if (roles.length !== 1)
                    return;
                var role = roles[0], originalOrder = _.map(columnRewrites, (function (rewrite) { return rewrite.from.index; })), newOrder = projectionOrdering[role];
                return createOrderMapping(originalOrder, newOrder);
            }
            function applyRewritesToMatrix(prototype, columnRewrites, projectionOrdering, context) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(columnRewrites, 'columnRewrites');
                var matrix = inherit(prototype);
                var override = function (metadata) { return findOverride(metadata, columnRewrites); };
                function overrideHierarchy(hierarchy) {
                    var rewrittenHierarchy = null;
                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, (function (level) {
                        var newLevel = null;
                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);
                        if (levelSources)
                            newLevel = ensureRewritten(newLevel, level, (function (h) { return h.sources = levelSources; }));
                        return newLevel;
                    }));
                    if (newLevels)
                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, (function (r) { return r.levels = newLevels; }));
                    return rewrittenHierarchy;
                }
                var rows = overrideHierarchy(matrix.rows);
                if (rows) {
                    matrix.rows = rows;
                    context.rowHierarchyRewritten = true;
                }
                var columns = overrideHierarchy(matrix.columns);
                if (columns) {
                    matrix.columns = columns;
                    context.columnHierarchyRewritten = true;
                }
                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);
                if (valueSources) {
                    matrix.valueSources = valueSources;
                }
                return matrix;
            }
            /**
             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified
             * originalOrder array.
             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue
             * under the context of the caller code), e.g. the Select Index in projection ordering array.
             * Also, the specified originalOrder must contain every value that exists in newOrder.
             *
             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of
             * key-value pair, each of which represents the new and old indices of a particular column:
             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array
             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array
             *
             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).
             *
             * If the specified originalOrder and newOrder are same, then this function returns undefined.
             *
             * @param originalOrder E.g. an array of metadata column "select indices", in the original order as they exist in Query DataView.
             * @param newOrder E.g. an array of metadata column "select indices", in rojection ordering.
             */
            function createOrderMapping(originalOrder, newOrder) {
                // Optimization: avoid rewriting if the current order is correct
                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (function (x, y) { return x === y; })))
                    return;
                var mapping = {};
                for (var i = 0, len = newOrder.length; i < len; ++i) {
                    var newPosition = newOrder[i];
                    mapping[i] = originalOrder.indexOf(newPosition);
                }
                return mapping;
            }
            function findOverride(source, columnRewrites) {
                var match = _.find(columnRewrites, (function (column) { return column.from === source; }));
                if (match)
                    return match.to;
            }
            function ensureRewritten(rewritten, prototype, callback) {
                if (!rewritten)
                    rewritten = inherit(prototype);
                if (callback)
                    callback(rewritten);
                return rewritten;
            }
            /**
             * Attempt to add DataViewObjectDefns for Dynamic Formatting, returning the same input dataView if not adding anything
             */
            function addDynamicFormattingDataViewObjectDefinitions(dataView, objectDescriptors, prototype) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertAnyValue(prototype, 'prototype');
                var formatStringPropertyId = data_4.DataViewObjectDescriptors.findFormatString(objectDescriptors);
                if (!formatStringPropertyId || !dataView.metadata || _.isEmpty(dataView.metadata.columns))
                    return;
                var added = false;
                var objDefns;
                for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    var queryName = column.queryName;
                    if (column.formatSource) {
                        if (!added) {
                            objDefns = prototype ? inheritSingle(prototype) : {};
                            added = true;
                        }
                        var selector = {
                            metadata: column.queryName,
                            data: [data_4.DataViewWildcard.create()],
                        };
                        var objDefn = data_4.SQExprBuilder.selectRef(queryName, 0 /* FormatString */);
                        data_4.DataViewObjectDefinitions.setValue(objDefns, formatStringPropertyId, selector, objDefn);
                    }
                    // When we do Dynamic culture info, we will need to add another DVOD, with same Selector, but different Expr
                }
                return objDefns;
            }
            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                if (!objectDescriptors)
                    return;
                // Dont add DynamicFormatString ObjectDefinition for Categorical DataView
                if (!EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {
                    var objectDefinitionsWithDynamicFormatting = addDynamicFormattingDataViewObjectDefinitions(dataView, objectDescriptors, objectDefinitions);
                    if (objectDefinitionsWithDynamicFormatting)
                        objectDefinitions = objectDefinitionsWithDynamicFormatting;
                }
                var objectsForAllSelectors = data_4.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);
                data_4.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);
                var metadataOnce = objectsForAllSelectors.metadataOnce;
                var dataObjects = objectsForAllSelectors.data;
                if (metadataOnce)
                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce, dataObjects, colorAllocatorFactory, targetDataViewKinds);
                var metadataObjects = objectsForAllSelectors.metadata;
                if (metadataObjects)
                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObjects, colorAllocatorFactory);
                if (dataObjects)
                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObjects, colorAllocatorFactory);
            }
            DataViewTransform.transformObjects = transformObjects;
            /** Evaluates and sets properties on the DataView metadata. */
            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefnsForSelector, dataObjects, colorAllocatorFactory, targetDataViewKinds) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'objectDefnsForSelector');
                debug.assertValue(dataObjects, 'dataObjects');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefnsForSelector, colorAllocatorFactory);
                for (var _i = 0, objectDefnsForSelector_1 = objectDefnsForSelector; _i < objectDefnsForSelector_1.length; _i++) {
                    var objectDefnForSelector = objectDefnsForSelector_1[_i];
                    var selectorId = objectDefnForSelector.selector && objectDefnForSelector.selector.id;
                    var objectDefns = objectDefnForSelector.objects;
                    debug.assertValue(!_.isEmpty(objectDefns), 'objectDefns');
                    var evalContext = data_4.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);
                    var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                    if (objects) {
                        var metadataObjects = dataView.metadata.objects;
                        if (!metadataObjects) {
                            metadataObjects = dataView.metadata.objects = {};
                        }
                        powerbi.DataViewObjects.mergeObjects(metadataObjects, objects, selectorId);
                        for (var objectName in objects) {
                            var object = objects[objectName];
                            var objectDesc = objectDescriptors[objectName];
                            for (var propertyName in object) {
                                var propertyDesc = objectDesc.properties[propertyName];
                                var ruleDesc = propertyDesc.rule;
                                if (!ruleDesc)
                                    continue;
                                var definitions = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type, targetDataViewKinds);
                                if (_.isEmpty(definitions))
                                    continue;
                                dataObjects.push.apply(dataObjects, definitions);
                            }
                        }
                    }
                }
            }
            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType, targetDataViewKinds) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(ruleDesc, 'ruleDesc');
                debug.assertValue(propertyValue, 'propertyValue');
                debug.assertValue(ruleType, 'ruleType');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                var ruleOutput = ruleDesc.output;
                if (!ruleOutput)
                    return;
                var selectorsToCreate = findSelectorsForRuleInput(ruleOutput.selector);
                if (ruleType.fillRule) {
                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorsToCreate, objectName, propertyValue);
                }
            }
            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorsToCreate, objectName, propertyValue) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(ruleDesc, 'ruleDesc');
                debug.assertValue(selectorsToCreate, 'selectorsToCreate');
                debug.assertValue(propertyValue, 'propertyValue');
                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);
                if (!colorAllocator)
                    return;
                var rule = new data_4.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);
                var fillRuleProperties = {};
                // TODO Defect 10568647:TS2.4 Upgrade -dataViewTransform - createRuleEvaluationInstanceFillRule - Type '{ solid: { color: ColorRuleEvaluation; }; }' is not assignable to type 'DataViewObjectPropertyDefinition'.
                // TODO: remove unchecked casting and fix: Type '{ solid: { color: ColorRuleEvaluation; }; }' is not assignable to type 'DataViewObjectPropertyDefinition'.
                fillRuleProperties[ruleDesc.output.property] = {
                    solid: { color: rule }
                };
                var objectDefinitions = [];
                for (var selectorIndex = 0, selectorCount = selectorsToCreate.length; selectorIndex < selectorCount; selectorIndex++) {
                    objectDefinitions.push({
                        selector: selectorsToCreate[selectorIndex],
                        rules: [rule],
                        objects: [{
                                name: objectName,
                                properties: fillRuleProperties,
                            }]
                    });
                }
                return objectDefinitions;
            }
            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                debug.assertValue(propertyValue, 'propertyValue');
                if (propertyValue.linearGradient2)
                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);
                if (propertyValue.linearGradient3)
                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);
            }
            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                debug.assertValue(linearGradient2, 'linearGradient2');
                linearGradient2 = propertyValueFillRule.linearGradient2;
                if (linearGradient2.min.value === undefined || linearGradient2.max.value === undefined) {
                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);
                    if (!inputRange)
                        return;
                    if (linearGradient2.min.value === undefined)
                        linearGradient2.min.value = inputRange.min;
                    if (linearGradient2.max.value === undefined)
                        linearGradient2.max.value = inputRange.max;
                }
                // If we are still missing one of the values, return
                if (linearGradient2.min.value === undefined || linearGradient2.max.value === undefined)
                    return;
                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);
            }
            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                debug.assertValue(linearGradient3, 'linearGradient3');
                var splitScales;
                linearGradient3 = propertyValueFillRule.linearGradient3;
                if (linearGradient3.min.value === undefined || linearGradient3.max.value === undefined) {
                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);
                    if (!inputRange)
                        return;
                    splitScales =
                        linearGradient3.min.value === undefined &&
                            linearGradient3.max.value === undefined &&
                            linearGradient3.mid.value !== undefined;
                    if (linearGradient3.min.value === undefined)
                        linearGradient3.min.value = inputRange.min;
                    if (linearGradient3.max.value === undefined)
                        linearGradient3.max.value = inputRange.max;
                }
                // If we are still missing one of the values, return
                if (linearGradient3.min.value === undefined || linearGradient3.max.value === undefined)
                    return;
                if (linearGradient3.mid.value === undefined) {
                    linearGradient3.mid.value = (linearGradient3.max.value + linearGradient3.min.value) / 2;
                }
                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);
            }
            function populateColorAllocatorCache(dataView, selectTransforms, objectDefinitionsForSelector, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDefinitionsForSelector, 'objectDefinitionsForSelector');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                var cache = data_4.createColorAllocatorCache();
                var staticEvalContext = data_4.createStaticEvalContext();
                for (var _i = 0, objectDefinitionsForSelector_1 = objectDefinitionsForSelector; _i < objectDefinitionsForSelector_1.length; _i++) {
                    var objectDefinitionForSelector = objectDefinitionsForSelector_1[_i];
                    var objectDefns = objectDefinitionForSelector.objects;
                    debug.assert(!_.isEmpty(objectDefns), 'populateColorAllocatorCache - Empty DataViewObjectDefns');
                    for (var _a = 0, objectDefns_1 = objectDefns; _a < objectDefns_1.length; _a++) {
                        var objectDefn = objectDefns_1[_a];
                        var objectDefnProperties = objectDefn.properties;
                        for (var propertyName in objectDefnProperties) {
                            var fillProperty = objectDefnProperties[propertyName];
                            if (fillProperty &&
                                fillProperty.solid &&
                                fillProperty.solid.color &&
                                fillProperty.solid.color.kind === 24 /* FillRule */) {
                                var fillRuleExpr = fillProperty.solid.color;
                                var inputExprQueryName = data_4.DataViewSelectTransform.findExprQueryName(fillRuleExpr.input, selectTransforms);
                                if (!inputExprQueryName)
                                    continue;
                                var fillRule = data_4.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);
                                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);
                                if (colorAllocator)
                                    cache.register(fillRuleExpr, colorAllocator);
                            }
                        }
                    }
                }
                return cache;
            }
            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'dataViewObjectDefnsForSelector');
                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefnsForSelector, colorAllocatorFactory);
                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');
                var dataViewCategorical = dataView.categorical;
                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {
                    evaluateDataRepetitionCategorical(dataViewCategorical, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorCache);
                    // Consider capturing diagnostics for unmatched selectors to help debugging.
                }
                var dataViewMatrix = dataView.matrix;
                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {
                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, objectDefnsForSelector, colorAllocatorCache);
                    if (rewrittenMatrix) {
                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                        // revisit this, likely when we do lazy evaluation of DataView.
                        dataView.matrix = rewrittenMatrix;
                    }
                    // Consider capturing diagnostics for unmatched selectors to help debugging.
                }
                var dataViewTable = dataView.table;
                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {
                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorCache);
                    if (rewrittenTable) {
                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                        // revisit this, likely when we do lazy evaluation of DataView.
                        dataView.table = rewrittenTable;
                    }
                    // Consider capturing diagnostics for unmatched selectors to help debugging.
                }
                var dataViewSingle = dataView.single;
                if (dataViewSingle && dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 4 /* Single */)) {
                    debug.assert(!!dataViewTable, 'DataViewTable should be always present with DataViewSingle');
                    var rewrittenSingle = evaluateDataRepetitionSingle(dataView, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorCache);
                    if (rewrittenSingle) {
                        dataView.single = rewrittenSingle;
                    }
                }
            }
            // ToDo: Move rewriting RoleWildcardSelector to Selector namespace
            function rewriteTableRoleSelector(dataViewTable, selector) {
                if (data_4.Selector.hasRoleWildcard(selector)) {
                    selector = findSelectorForRoleWildcard(selector, (function (r) { return getIdentityExprsForRolesOnTable(r, dataViewTable); }));
                }
                return selector;
            }
            function rewriteMatrixRoleSelector(dataViewMatrix, selector) {
                if (data_4.Selector.hasRoleWildcard(selector)) {
                    selector = findSelectorForRoleWildcard(selector, (function (r) { return getIdentityExprsForRolesOnMatrix(r, dataViewMatrix); }));
                }
                return selector;
            }
            function rewriteCategoricalRoleSelector(dataViewCategorical, selector) {
                if (data_4.Selector.hasRoleWildcard(selector)) {
                    selector = findSelectorForRoleWildcard(selector, (function (r) { return getIdentityExprsForRolesOnCategorical(r, dataViewCategorical); }));
                }
                return selector;
            }
            /**
             * Returns the generated selectors for the given roles
             * @param selector The input selector (rule)
             * @param getIdentityKeysForRoles A function to obtain the identity keys from the given roles; may return composite identities if
             * they exist in the hierarchy.  Each returned element represents a different level in the hierarchy.
             */
            function findSelectorForRoleWildcard(selector, getIdentityKeysForRoles) {
                var resultingSelector = {
                    data: [],
                    id: selector.id,
                    metadata: selector.metadata
                };
                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {
                    var dataSelector = _a[_i];
                    if (data_4.Selector.isRoleWildcard(dataSelector)) {
                        var identityKeys = getIdentityKeysForRoles(dataSelector.roles);
                        if (!_.isEmpty(identityKeys)) {
                            for (var _b = 0, identityKeys_1 = identityKeys; _b < identityKeys_1.length; _b++) {
                                var exprs = identityKeys_1[_b];
                                resultingSelector.data.push(data_4.DataViewScopeWildcard.fromExprs(exprs));
                            }
                            continue;
                        }
                    }
                }
                return resultingSelector;
            }
            function getIdentityExprsForRolesOnTable(roles, dataViewTable) {
                if (!roles)
                    return [];
                var identityExprs = [];
                // TODO: should return the identityFields property of the DataViewTable, not individual columns
                for (var _i = 0, _a = dataViewTable.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    // Make sure the column has an identity (i.e. not a measure)
                    // and that it has one of the roles
                    if (column.identityExprs && allColumnsBelongToRoles([column], roles))
                        identityExprs.push(column.identityExprs.slice());
                }
                return identityExprs;
            }
            function getIdentityExprsForRolesOnMatrix(roles, dataViewMatrix) {
                if (!dataViewMatrix)
                    return;
                var identityExprs = [];
                identityExprs.push.apply(identityExprs, getIdentityExprsForRolesOnMatrixHierarchy(roles, dataViewMatrix.rows));
                identityExprs.push.apply(identityExprs, getIdentityExprsForRolesOnMatrixHierarchy(roles, dataViewMatrix.columns));
                return identityExprs;
            }
            // this function will get the identity expressions, where each expression represents a single level of the hierarchy (e.g., composite groupings will return And exprs)
            function getIdentityExprsForRolesOnMatrixHierarchy(roles, hierarchy) {
                if (!roles || !hierarchy)
                    return [];
                var identityExprs = [];
                for (var _i = 0, _a = hierarchy.levels; _i < _a.length; _i++) {
                    var level = _a[_i];
                    // collect all matching columns within a row
                    var levelExprs = [];
                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {
                        var column = _c[_b];
                        // Make sure the column has an identity (i.e. not a measure)
                        // and that it has one of the roles
                        if (column.identityExprs && allColumnsBelongToRoles([column], roles))
                            levelExprs.push.apply(levelExprs, column.identityExprs);
                    }
                    if (!_.isEmpty(levelExprs)) {
                        identityExprs.push(levelExprs);
                    }
                }
                return identityExprs;
            }
            function getIdentityExprsForRolesOnCategorical(roles, dataViewCategorical) {
                // NOTE: Matching role wildcards on categorical value groups is not yet implemented because no scenarios need it at the time of this writing.
                if (dataViewCategorical.categories) {
                    for (var _i = 0, _a = dataViewCategorical.categories; _i < _a.length; _i++) {
                        var category = _a[_i];
                        if (category.source && allColumnsBelongToRoles([category.source], roles))
                            return [category.identityFields];
                    }
                }
            }
            function allColumnsBelongToRoles(columns, selectorRoles) {
                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {
                    var column = columns_6[_i];
                    var roles = column.roles;
                    if (!roles || !_.any(selectorRoles, (function (selectorRole) { return roles[selectorRole]; })))
                        return false;
                }
                return true;
            }
            function evaluateDataRepetitionCategorical(dataViewCategorical, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorCache) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'objectDefnsForSelector');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                for (var _i = 0, objectDefnsForSelector_2 = objectDefnsForSelector; _i < objectDefnsForSelector_2.length; _i++) {
                    var objectDefnForSelector = objectDefnsForSelector_2[_i];
                    var selector = objectDefnForSelector.selector;
                    var rules = objectDefnForSelector.rules;
                    var objectDefns = objectDefnForSelector.objects;
                    debug.assertValue(selector, 'selector');
                    debug.assertAnyValue(rules, 'rules');
                    debug.assertValue(objectDefns, 'objectDefns');
                    var containsWildcard = data_4.Selector.containsWildcard(selector);
                    selector = rewriteCategoricalRoleSelector(dataViewCategorical, selector);
                    // 1) Match against categories
                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);
                    // 2) Match against valueGrouping
                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);
                }
            }
            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(containsWildcard, 'containsWildcard');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)
                    return;
                var targetColumns = findSelectedCategoricalColumns(dataViewCategorical, selector);
                if (!targetColumns)
                    return;
                var identities = targetColumns.identities, foundMatch, evalContext = data_4.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical, selectTransforms);
                if (!identities)
                    return;
                for (var i = 0, len = identities.length; i < len; i++) {
                    var identity = identities[i];
                    if (containsWildcard || data_4.Selector.matchesData(selector, [identity])) {
                        evalContext.setCurrentRowIndex(i);
                        var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (objects) {
                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                            // revisit this, likely when we do lazy evaluation of DataView.
                            for (var _i = 0, _a = targetColumns.columns; _i < _a.length; _i++) {
                                var column = _a[_i];
                                var columnObjects = column.objects;
                                if (!columnObjects) {
                                    columnObjects = column.objects = new Array(len);
                                }
                                if (!columnObjects[i]) {
                                    columnObjects[i] = {};
                                }
                                powerbi.DataViewObjects.mergeObjects(columnObjects[i], objects, selector.id);
                            }
                        }
                        if (!containsWildcard)
                            return true;
                        foundMatch = true;
                    }
                }
                return foundMatch;
            }
            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(containsWildcard, 'containsWildcard');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                var dataViewCategoricalValues = dataViewCategorical.values;
                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)
                    return;
                if (!data_4.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))
                    return;
                var valuesGrouped = dataViewCategoricalValues.grouped();
                if (!valuesGrouped)
                    return;
                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).
                // This should be enhanced in the future.
                var evalContext = data_4.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical, selectTransforms);
                var foundMatch;
                for (var i = 0, len = valuesGrouped.length; i < len; i++) {
                    var valueGroup = valuesGrouped[i];
                    var selectorMetadata = selector.metadata;
                    var valuesInGroup = valueGroup.values;
                    if (containsWildcard || data_4.Selector.matchesData(selector, [valueGroup.identity])) {
                        var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (objects) {
                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                            // revisit this, likely when we do lazy evaluation of DataView.
                            if (selectorMetadata) {
                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {
                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;
                                    if (valueSource.queryName === selectorMetadata) {
                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);
                                        var valueColumnObjects = valueSourceOverwrite.objects;
                                        if (!valueColumnObjects) {
                                            valueColumnObjects = valueSourceOverwrite.objects = {};
                                        }
                                        powerbi.DataViewObjects.mergeObjects(valueColumnObjects, objects, selector.id);
                                        valueColumn.source = valueSourceOverwrite;
                                        foundMatch = true;
                                        break;
                                    }
                                }
                            }
                            else {
                                var valueGroupObjects = valueGroup.objects;
                                if (!valueGroupObjects) {
                                    valueGroupObjects = valueGroup.objects = {};
                                }
                                powerbi.DataViewObjects.mergeObjects(valueGroupObjects, objects, selector.id);
                                setGrouped(dataViewCategoricalValues, valuesGrouped);
                                foundMatch = true;
                            }
                        }
                        if (!containsWildcard)
                            return true;
                    }
                }
                return foundMatch;
            }
            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, objectDefnsForSelector, colorAllocatorCache) {
                debug.assertValue(dataViewMatrix, 'dataViewMatrix');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'objectDefnsForSelector');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                var valueSources = dataViewMatrix.valueSources;
                var valueSourcesCount = valueSources.length;
                var matrixRewritten = false;
                var columnLeavesPath = data_4.DataViewMatrixUtils.getLeafNodesPath(dataViewMatrix.columns.root);
                var evalContext = data_4.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);
                var rowHierarchyFields = getHierarchyFields(dataViewMatrix.rows);
                var columnHierarchyFields = getHierarchyFields(dataViewMatrix.columns);
                var valuesIdentityFields = [];
                valuesIdentityFields.push.apply(valuesIdentityFields, rowHierarchyFields);
                valuesIdentityFields.push.apply(valuesIdentityFields, columnHierarchyFields);
                var _loop_4 = function (objectDefnForSelector) {
                    var selector = objectDefnForSelector.selector;
                    var rules = objectDefnForSelector.rules;
                    var objectDefns = objectDefnForSelector.objects;
                    debug.assertValue(selector, 'selector');
                    debug.assertAnyValue(rules, 'rules');
                    debug.assertValue(objectDefns, 'objectDefns');
                    selector = rewriteMatrixRoleSelector(dataViewMatrix, selector);
                    var containsWildcard = data_4.Selector.containsWildcard(selector);
                    var isWildcardSelector = _.any(selector.data, (function (data) { return data_4.Selector.isWildcard(data); }));
                    // Selector for any row node should not have metadata
                    // ToDo: We should revisit the Selector matching for Matrix nodes to always include metadata
                    // having just the identity results in a large scope
                    var canMatchRowNode = selector.metadata == null && data_4.Selector.matchesKeys(selector, rowHierarchyFields, true);
                    // For single measure, Column nodes are matched without metadata,
                    // For multi-measure, Leaf column nodes are matched with metadata, non-leaf without
                    var canMatchColumnNode = (valueSourcesCount > 1 || valueSourcesCount <= 1 && selector.metadata == null) &&
                        data_4.Selector.matchesKeys(selector, columnHierarchyFields, true);
                    /* For evaluation the values, Selector must have:
                     *** metadata (value to be evaluated), needs to be one of the Value Sources
                     *** wildcard over all the rows and the columns fields, to match all identities
                     * Partial identities are not currently supported and still need to go through definition
                    */
                    var canMatchValueNode = selector.metadata
                        && valueSourcesCount > 0
                        && _.any(valueSources, (function (vs) { return vs.queryName === selector.metadata; }))
                        && data_4.Selector.matchesKeys(selector, valuesIdentityFields, false);
                    var rewrittenRows = void 0;
                    var rewrittenCols = void 0;
                    // ToDo: Use evalContext to hold the state for recursive calls (path to node, columnLeaves, valueSources, ... etc)
                    if (canMatchColumnNode) {
                        rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns);
                    }
                    if (canMatchValueNode) {
                        rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath);
                    }
                    else if (canMatchRowNode) {
                        rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns);
                    }
                    if (rewrittenRows || rewrittenCols) {
                        matrixRewritten = true;
                        dataViewMatrix = inheritSingle(dataViewMatrix);
                        if (rewrittenRows)
                            dataViewMatrix.rows = rewrittenRows;
                        if (rewrittenCols)
                            dataViewMatrix.columns = rewrittenCols;
                    }
                };
                for (var _i = 0, objectDefnsForSelector_3 = objectDefnsForSelector; _i < objectDefnsForSelector_3.length; _i++) {
                    var objectDefnForSelector = objectDefnsForSelector_3[_i];
                    _loop_4(objectDefnForSelector);
                }
                if (matrixRewritten)
                    return dataViewMatrix;
            }
            function getHierarchyFields(hierarchy) {
                if (!hierarchy)
                    return [];
                var fields = [];
                for (var _i = 0, _a = hierarchy.levels; _i < _a.length; _i++) {
                    var level = _a[_i];
                    var levelFields = [];
                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {
                        var column = _c[_b];
                        // Filtering out value sources which are put on the column hierarchy in some cases
                        if (column.identityExprs)
                            levelFields.push.apply(levelFields, column.identityExprs);
                    }
                    if (!_.isEmpty(levelFields))
                        fields.push(levelFields);
                }
                return fields;
            }
            /**
             * Evaluating the data repetition for the Hierarchy.
             * columnLeaves is only passed in case of handling a row heirarchy node.
             */
            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath) {
                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertValue(objectDefns, 'objectDefns');
                if (!dataViewMatrixHierarchy)
                    return;
                var root = dataViewMatrixHierarchy.root;
                if (!root)
                    return;
                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, [root], objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath);
                if (rewrittenRoot) {
                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);
                    rewrittenHierarchy.root = rewrittenRoot;
                    return rewrittenHierarchy;
                }
            }
            /**
             * Evaluating the data repetition for the Node.
             * columnLeaves is only passed in case of handling a row heirarchy node.
             */
            function evaluateDataRepetitionMatrixNode(evalContext, nodePath, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(nodePath, 'nodePath');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertValue(objectDefns, 'objectDefns');
                var dataViewNode = _.last(nodePath);
                var rewrittenNode;
                if (data_4.DataViewMatrixUtils.isLeafNode(dataViewNode)) {
                    if (columnLeavesPath == null || _.isEmpty(evalContext.getValueSourcesQueryNames()))
                        return;
                    rewrittenNode = evaluateDataRepetitionMatrixNodeValues(evalContext, nodePath, objectDescriptors, selector, containsWildcard, objectDefns, columnLeavesPath);
                }
                else {
                    rewrittenNode = evaluateDataRepetitionMatrixNodeChildren(evalContext, nodePath, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath);
                }
                return rewrittenNode;
            }
            /**
             * Evaluating the data repetition for the Node children.
             * We need this because the parent holds the identity of its children
             * columnLeaves is only passed in case of handling a row heirarchy node.
             */
            function evaluateDataRepetitionMatrixNodeChildren(evalContext, nodePath, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath) {
                var dataViewMatrix = evalContext.getDataView();
                var hierarchy;
                if (nodePath[0] === dataViewMatrix.rows.root)
                    hierarchy = dataViewMatrix.rows;
                else if (nodePath[0] === dataViewMatrix.columns.root)
                    hierarchy = dataViewMatrix.columns;
                else
                    debug.assertFail('dataViewTransform.evaluateDataRepetitionMatrixNodeChildren: incorrect nodePath');
                var dataViewNode = _.last(nodePath);
                var rewrittenNode;
                var rewrittenChildNode;
                var childNodes = dataViewNode.children;
                debug.assertNonEmpty(childNodes, "evaluateDataRepetitionMatrixNodeChildren - empty children list");
                // Optimization: If the children Identity fields are not compatible with the Selector,
                // We don't attempt to match the Selector against each child
                // exceptions:
                // * When the childIdentityFields are empty, but we are not on the Leaf level,
                // This means there is an extra level on the column hierarchy for multiple measures
                var shouldEvaluateChildrenObjects = false;
                var childIdentityFields = dataViewNode.childIdentityFields;
                // QueryNames of the children level. Only expected if the children level is the multi-measure extra level
                var childrenQueryNames = [];
                // If dataViewNode is the root, it will not have a level
                var childLevelIndex = childNodes[0].level;
                debug.assert(childLevelIndex === 0 || childLevelIndex < hierarchy.levels.length, 'evaluateDataRepetitionMatrixNodeChildren: childLevel exceeding hierarchy levels');
                var areChildrenMultiMeasure = dataViewMatrix.valueSources.length > 1 &&
                    hierarchy === dataViewMatrix.columns &&
                    childLevelIndex === hierarchy.levels.length - 1;
                // Having no row grouping will result in a Row Hierarchy with no levels            
                if (!_.isEmpty(hierarchy.levels)) {
                    var childrenLevelSources = hierarchy.levels[childLevelIndex].sources;
                    if (areChildrenMultiMeasure) {
                        // If we have more than one value source, and we are on the column hierachy level just above the Value levelSources
                        // We need to evaluate objects on Children if at least one value source would match Selector.metadata
                        childrenQueryNames = evalContext.getValueSourcesQueryNames();
                        var parentIdentity = _.compact(_.map(nodePath, (function (node) { return node.identity; })));
                        // if the multi-measure node is subtotal, the Selector must have a ScopeTotal expr
                        var parentTotalExprs = void 0;
                        if (dataViewNode.isSubtotal && nodePath.length > 1)
                            parentTotalExprs = nodePath[nodePath.length - 2].childIdentityFields;
                        shouldEvaluateChildrenObjects =
                            selector.metadata != null
                                && _.any(childrenQueryNames, (function (queryName) { return queryName === selector.metadata; }))
                                && data_4.Selector.matchesData(selector, parentIdentity, parentTotalExprs);
                    }
                    else if (!_.isEmpty(childIdentityFields)) {
                        // Normally, we attempt to evaluate objects on Nodes if the selector.data keys match the path identityFields
                        // For Columns nodes, Selector should not have metadata
                        // For Row nodes, Selector can have metadata to match a Value
                        childrenQueryNames = _.map(childrenLevelSources, (function (source) { return source.queryName; }));
                        shouldEvaluateChildrenObjects = (selector.metadata == null) && data_4.Selector.matchesKeys(selector, _.map(nodePath, (function (node) { return node.childIdentityFields; })));
                    }
                }
                for (var i = 0, len = childNodes.length; i < len; i++) {
                    var childNode = childNodes[i];
                    var childPath = nodePath.concat(childNode);
                    // Setting eval context
                    if (hierarchy === dataViewMatrix.rows) {
                        evalContext.setCurrentContext(
                        /* value node */ null, 
                        /* row path */ childPath, 
                        /* column path */ null, 
                        /* column leaf index */ null);
                    }
                    else if (hierarchy === dataViewMatrix.columns) {
                        // Column leaf index is needed only for Values evaluation
                        evalContext.setCurrentContext(
                        /* value node */ null, 
                        /* row path */ null, 
                        /* column path */ childPath, 
                        /* column leaf index */ null);
                    }
                    else {
                        debug.assertFail('dataViewTransform.evaluateDataRepetitionMatrixNodeChildren: incorrect nodePath');
                    }
                    var selectorMatched = false;
                    if (shouldEvaluateChildrenObjects) {
                        var childIdentity = [];
                        // Constructing the child identity from the path
                        // Dropping any node that doesn't have an identity (root / subtotal / multi-measure level)
                        for (var _i = 0, childPath_1 = childPath; _i < childPath_1.length; _i++) {
                            var node = childPath_1[_i];
                            if (node.identity)
                                childIdentity.push(node.identity);
                        }
                        var childQueryName = void 0;
                        if (!_.isEmpty(childrenQueryNames)) {
                            // Composite group
                            childQueryName = childrenQueryNames[childNode.levelSourceIndex || 0];
                        }
                        var totalLevelFields = void 0;
                        if (childNode.isSubtotal) {
                            if (!areChildrenMultiMeasure) {
                                // For subtotals not on the multi-measure level, parent has TotalExprs
                                totalLevelFields = childIdentityFields;
                            }
                            else if (nodePath.length > 1) {
                                // For multi-measure subtotal, the grand-parent has TotalExprs
                                totalLevelFields = nodePath[nodePath.length - 2].childIdentityFields;
                            }
                        }
                        // Checking if Selector matches the Child Node
                        // For Cell-Level formatting, Selector will be wildCard + metadata, which can match the column header
                        // Here we don't consider matching
                        var selectorMetadataMatches = selector.metadata == null ||
                            selector.metadata === childQueryName && !isWildcardSelector;
                        if (selectorMetadataMatches && data_4.Selector.matchesData(selector, childIdentity, totalLevelFields)) {
                            selectorMatched = true;
                            var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                            if (objects) {
                                rewrittenChildNode = inheritSingle(childNode);
                                if (!rewrittenChildNode.objects)
                                    rewrittenChildNode.objects = {};
                                powerbi.DataViewObjects.mergeObjects(rewrittenChildNode.objects, objects, selector.id);
                            }
                        }
                    }
                    // If the Selector matched one of the children, there is no need to traverse more in the tree, either to Children or to Values
                    // Unless the selector is a Wildcard, which can match different scopes
                    if (!selectorMatched || isWildcardSelector) {
                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childPath, objectDescriptors, selector, containsWildcard, isWildcardSelector, objectDefns, columnLeavesPath);
                    }
                    if (rewrittenChildNode) {
                        if (!rewrittenNode)
                            rewrittenNode = inheritNodeAndChildren(dataViewNode);
                        rewrittenNode.children[i] = rewrittenChildNode;
                        if (!containsWildcard) {
                            // NOTE: once we find a match for a non-wildcard selector, stop looking.
                            break;
                        }
                    }
                }
                return rewrittenNode;
            }
            function evaluateDataRepetitionMatrixNodeValues(evalContext, rowLeafPath, objectDescriptors, selector, containsWildCard, objectDefns, columnLeavesPath) {
                debug.assertNonEmpty(columnLeavesPath, "evaluateDataRepetitionMatrixNodeValues - no column leaves");
                var rewrittenNode;
                var rowLeaf = _.last(rowLeafPath);
                var valueNodes = rowLeaf.values;
                // If Matrix is empty
                if (_.isEmpty(valueNodes))
                    return;
                var valueSourcesQueryNames = evalContext.getValueSourcesQueryNames();
                for (var i = 0, len = columnLeavesPath.length; i < len; i++) {
                    var valueNode = valueNodes[i];
                    var columnLeafPath = columnLeavesPath[i];
                    if (!valueNode)
                        continue;
                    var queryName = valueSourcesQueryNames[valueNode.valueSourceIndex || 0];
                    if (!selectorMatchesMatrixNodeValue(selector, queryName, rowLeafPath, columnLeafPath))
                        continue;
                    var rewrittenValueNode = void 0;
                    evalContext.setCurrentContext(valueNode, rowLeafPath, columnLeafPath, i);
                    var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                    if (objects) {
                        rewrittenValueNode = inheritSingle(valueNode);
                        if (!rewrittenValueNode.objects)
                            rewrittenValueNode.objects = {};
                        powerbi.DataViewObjects.mergeObjects(rewrittenValueNode.objects, objects, selector.id);
                        if (!rewrittenNode)
                            rewrittenNode = inheritSingle(rowLeaf);
                        rewrittenNode.values[i] = rewrittenValueNode;
                    }
                    // Note: Don't break because we need to match all value nodes for that value source
                }
                return rewrittenNode;
            }
            function selectorMatchesMatrixNodeValue(selector, queryName, rowPath, columnPath) {
                // Make sure the value node is coming from the same column specified by the Selector
                if (queryName !== selector.metadata)
                    return false;
                // Making sure the ValueNode idenetity matches the Selector data
                var valueNodeIdentity = [];
                for (var _i = 0, rowPath_1 = rowPath; _i < rowPath_1.length; _i++) {
                    var node = rowPath_1[_i];
                    if (node.identity)
                        valueNodeIdentity.push(node.identity);
                }
                for (var _a = 0, columnPath_1 = columnPath; _a < columnPath_1.length; _a++) {
                    var node = columnPath_1[_a];
                    if (node.identity)
                        valueNodeIdentity.push(node.identity);
                }
                var valueNodeTotalExprs = [];
                if (_.last(rowPath).isSubtotal)
                    valueNodeTotalExprs.push.apply(valueNodeTotalExprs, getSubtotalIdentityFields(rowPath));
                if (_.last(columnPath).isSubtotal)
                    valueNodeTotalExprs.push.apply(valueNodeTotalExprs, getSubtotalIdentityFields(columnPath));
                if (_.isEmpty(valueNodeTotalExprs))
                    valueNodeTotalExprs = undefined;
                return data_4.Selector.matchesData(selector, valueNodeIdentity, valueNodeTotalExprs);
            }
            function getSubtotalIdentityFields(nodePath) {
                var subtotalParent = _.findLast(nodePath, (function (node) { return node.childIdentityFields != null; }));
                // In case there is no data, but subtotals are enabled, we get only grandTotal node
                // ToDo 10903649: remove the null check as the root should have childIdentityFields even if Matrix has no data points
                if (subtotalParent)
                    return subtotalParent.childIdentityFields;
                else
                    return [];
            }
            function inheritNodeAndChildren(node) {
                if (Object.getPrototypeOf(node) !== Object.prototype) {
                    return node;
                }
                var inherited = inheritSingle(node);
                inherited.children = inherit(node.children);
                return inherited;
            }
            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorCache) {
                debug.assertValue(dataViewTable, 'dataViewTable');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'objectDefnsForSelector');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                var tableRewritten = false;
                for (var _i = 0, objectDefnsForSelector_4 = objectDefnsForSelector; _i < objectDefnsForSelector_4.length; _i++) {
                    var objectDefnForSelector = objectDefnsForSelector_4[_i];
                    var selector = objectDefnForSelector.selector;
                    var objectDefns = objectDefnForSelector.objects;
                    debug.assertValue(selector, 'selector');
                    debug.assertValue(objectDefns, 'objectDefns');
                    var containsWildcard = data_4.Selector.containsWildcard(selector);
                    selector = rewriteTableRoleSelector(dataViewTable, selector);
                    var evalContext = data_4.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);
                    var rewrittenRows = void 0;
                    if (!_.isEmpty(dataViewTable.rows)) {
                        rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, containsWildcard, objectDefns);
                    }
                    var rewrittenTotal = void 0;
                    if (dataViewTable.totals) {
                        rewrittenTotal = evaluateDataRepetitionSingleRow(evalContext, dataViewTable.columns, dataViewTable.totals, dataViewTable.identityFields, objectDescriptors, selector, objectDefns);
                    }
                    if (rewrittenRows || rewrittenTotal) {
                        tableRewritten = true;
                        dataViewTable = inheritSingle(dataViewTable);
                        if (rewrittenRows)
                            dataViewTable.rows = rewrittenRows;
                        if (rewrittenTotal)
                            dataViewTable.totals = rewrittenTotal;
                    }
                }
                if (tableRewritten)
                    return dataViewTable;
            }
            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, containsWildcard, objectDefns) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(columns, 'columns');
                debug.assertValue(rows, 'rows');
                debug.assertAnyValue(identities, 'identities');
                debug.assertAnyValue(identityFields, 'identityFields');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertValue(objectDefns, 'objectDefns');
                // Invalid selector
                if (!selector.metadata || _.isEmpty(selector.data))
                    return;
                var colIdx = _.findIndex(columns, (function (col) { return col.queryName === selector.metadata; }));
                if (colIdx < 0)
                    return;
                // No hope of matching
                if (!data_4.Selector.matchesKeys(selector, [identityFields]))
                    return;
                var inheritedRows;
                if (_.all(columns, (function (c) { return c.isMeasure; }))) {
                    // Table with no groupings, it must have a single row
                    debug.assert(_.isEmpty(identities), 'table identity mismatch with identityFields');
                    debug.assert(_.isEmpty(identityFields), 'table identity mismatch with identityFields');
                    debug.assert(rows.length === 1, 'table without identity has incorrect row count');
                    var rewrittenRow = evaluateDataRepetitionSingleRow(evalContext, columns, rows[0], identityFields, objectDescriptors, selector, objectDefns);
                    if (rewrittenRow) {
                        inheritedRows = inheritSingle(rows);
                        inheritedRows[0] = rewrittenRow;
                    }
                }
                else {
                    // TotalsOnly Wildcard Selector, exiting for Perf
                    if (_.any(selector.data, (function (dataItem) {
                        return data_4.Selector.isWildcard(dataItem) && dataItem.matchingOption === 2 /* TotalsOnly */;
                    })))
                        return;
                    debug.assert(rows.length === identities.length, 'row length mismatch');
                    var colLen = columns.length;
                    for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {
                        var identity = identities[rowIdx];
                        if (containsWildcard || data_4.Selector.matchesData(selector, [identity])) {
                            evalContext.setCurrentRow(rows[rowIdx]);
                            var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                            if (objects) {
                                if (!inheritedRows)
                                    inheritedRows = inheritSingle(rows);
                                var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);
                                var rowObjects = inheritedRow.objects;
                                if (!rowObjects)
                                    inheritedRow.objects = rowObjects = new Array(colLen);
                                if (!rowObjects[colIdx])
                                    rowObjects[colIdx] = {};
                                powerbi.DataViewObjects.mergeObjects(rowObjects[colIdx], objects, selector.id);
                            }
                            if (!containsWildcard)
                                break;
                        }
                    }
                }
                return inheritedRows;
            }
            function evaluateDataRepetitionSingle(dataView, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorCache) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'objectDefnsForSelector');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                var inheritedSingle;
                var evalContext = data_4.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);
                for (var _i = 0, objectDefnsForSelector_5 = objectDefnsForSelector; _i < objectDefnsForSelector_5.length; _i++) {
                    var objectDefnForSelector = objectDefnsForSelector_5[_i];
                    var selector = objectDefnForSelector.selector;
                    var objectDefns = objectDefnForSelector.objects;
                    debug.assertValue(selector, 'selector');
                    debug.assertValue(objectDefns, 'objectDefns');
                    // Only DataViewWildcard selector is supported. Other selectors cannot be used because DataViewSingle
                    // does not have scope identities or totals.
                    if (selector.metadata === dataView.single.column.queryName && data_4.Selector.matchesData(selector, [])) {
                        var evaluatedObjects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (evaluatedObjects) {
                            if (!inheritedSingle) {
                                inheritedSingle = inheritSingle(dataView.single);
                            }
                            if (!inheritedSingle.objects) {
                                inheritedSingle.objects = {};
                            }
                            powerbi.DataViewObjects.mergeObjects(inheritedSingle.objects, evaluatedObjects, selector.id);
                        }
                    }
                }
                return inheritedSingle;
            }
            /**
             * Evaluate objects for Total row or the Single row when Table has no groups
             */
            function evaluateDataRepetitionSingleRow(evalContext, columns, row, identityFields, objectDescriptors, selector, objectDefns) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(columns, 'columns');
                debug.assertValue(row, 'row');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertValue(objectDefns, 'objectDefns');
                var identityExprs = !_.isEmpty(identityFields) ? identityFields : undefined;
                if (!selector.metadata || !data_4.Selector.matchesData(selector, [], identityExprs))
                    return;
                var colIdx = _.findIndex(columns, (function (col) { return col.queryName === selector.metadata; }));
                if (colIdx < 0)
                    return;
                var colLen = columns.length;
                var inheritedRow;
                evalContext.setCurrentRow(row);
                var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                if (objects) {
                    inheritedRow = inheritSingle(row);
                    var rowObjects = inheritedRow.objects;
                    if (!rowObjects)
                        inheritedRow.objects = rowObjects = new Array(colLen);
                    if (!rowObjects[colIdx])
                        rowObjects[colIdx] = {};
                    powerbi.DataViewObjects.mergeObjects(rowObjects[colIdx], objects);
                }
                return inheritedRow;
            }
            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, objectDefnsForSelector, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefnsForSelector, 'objectDefnsForSelector');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefnsForSelector, colorAllocatorFactory);
                for (var _i = 0, objectDefnsForSelector_6 = objectDefnsForSelector; _i < objectDefnsForSelector_6.length; _i++) {
                    var objectDefnForSelector = objectDefnsForSelector_6[_i];
                    var selector = objectDefnForSelector.selector;
                    var objectDefns = objectDefnForSelector.objects;
                    debug.assertValue(selector, 'selector');
                    debug.assertValue(objectDefns, 'objectDefns');
                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                    // revisit this, likely when we do lazy evaluation of DataView.
                    var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data_4.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);
                    for (var i = 0, len = columns.length; i < len; i++) {
                        var column = columns[i];
                        if (column.queryName === metadataId) {
                            var objects = data_4.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                            if (objects) {
                                if (!column.objects)
                                    column.objects = {};
                                powerbi.DataViewObjects.mergeObjects(column.objects, objects, selector.id);
                            }
                        }
                    }
                }
            }
            /** Attempts to find columns that can possibly match the selector. */
            function findSelectedCategoricalColumns(dataViewCategorical, selector) {
                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');
                var identities = dataViewCategorical.categories[0].identity;
                var targetColumns = [];
                for (var _i = 0, _a = dataViewCategorical.categories; _i < _a.length; _i++) {
                    var categoryColumn = _a[_i];
                    if (!categoryColumn.identityFields)
                        return;
                    if (!data_4.Selector.matchesKeys(selector, [categoryColumn.identityFields]))
                        return;
                    targetColumns.push(categoryColumn);
                }
                debug.assert(targetColumns.length === dataViewCategorical.categories.length, 'Column length mismatch');
                var selectedMetadataId = selector.metadata;
                if (selectedMetadataId) {
                    var valueColumns = dataViewCategorical.values;
                    if (valueColumns) {
                        for (var i = 0, len = valueColumns.length; i < len; i++) {
                            var valueColumn = valueColumns[i];
                            if (valueColumn.source.queryName === selectedMetadataId) {
                                targetColumns = [valueColumn];
                                break;
                            }
                        }
                    }
                }
                return {
                    columns: targetColumns,
                    identities: identities,
                };
            }
            function findSelectorsForRuleInput(selectorRoles) {
                debug.assertValue(selectorRoles, 'selectorRoles');
                return [{
                        data: [data_4.DataViewRoleWildcard.fromRoles(selectorRoles)]
                    }];
            }
            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */
            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                var columns = dataView.metadata.columns;
                for (var i = 0, len = columns.length; i < len; i++) {
                    var column = columns[i];
                    if (identifierKind === 1 /* Role */) {
                        var valueColRoles = column.roles;
                        if (!valueColRoles || !valueColRoles[identifier])
                            continue;
                    }
                    else {
                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');
                        if (column.queryName !== identifier || column.groupName !== undefined)
                            continue;
                    }
                    var aggregates = column.aggregates;
                    if (!aggregates)
                        continue;
                    var min = aggregates.min;
                    var max = aggregates.max;
                    return { min: min, max: max };
                }
            }
            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product
            function createValueColumns(values, valueIdentityFields, source) {
                if (values === void 0) { values = []; }
                var result = values;
                setGrouped(result);
                if (valueIdentityFields)
                    result.identityFields = valueIdentityFields;
                if (source)
                    result.source = source;
                return result;
            }
            DataViewTransform.createValueColumns = createValueColumns;
            function setGrouped(values, groupedResult) {
                values.grouped = groupedResult
                    ? function () { return groupedResult; }
                    : function () { return groupValues(values); };
            }
            DataViewTransform.setGrouped = setGrouped;
            /** Group together the values with a common identity. */
            function groupValues(values) {
                debug.assertValue(values, 'values');
                var groups = [], currentGroup;
                for (var i = 0, len = values.length; i < len; i++) {
                    var value = values[i];
                    if (!currentGroup || currentGroup.identity !== value.identity) {
                        currentGroup = {
                            values: []
                        };
                        if (value.identity) {
                            currentGroup.identity = value.identity;
                            var source = value.source;
                            // allow null, which will be formatted as (Blank).
                            if (source.groupName !== undefined)
                                currentGroup.name = source.groupName;
                            else if (source.displayName)
                                currentGroup.name = source.displayName;
                        }
                        groups.push(currentGroup);
                    }
                    currentGroup.values.push(value);
                }
                return groups;
            }
            function pivotIfNecessary(dataView, dataViewMappings) {
                debug.assertValue(dataView, 'dataView');
                var transformedDataView;
                var categoricalTransformTarget = determineCategoricalTransformation(dataView.categorical, dataViewMappings);
                if (categoricalTransformTarget) {
                    switch (categoricalTransformTarget.type) {
                        case 1 /* Pivot */:
                            transformedDataView = data_4.DataViewPivotCategorical.apply(dataView);
                            break;
                        case 2 /* SelfCrossJoin */:
                            debug.assertValue(categoricalTransformTarget.selfCrossJoinCategory, 'selfCrossJoinCategory is expected to be defined when type is SelfCrossJoin');
                            transformedDataView = data_4.DataViewSelfCrossJoin.apply(dataView, categoricalTransformTarget.selfCrossJoinCategory);
                            break;
                    }
                }
                return transformedDataView || dataView;
            }
            function determineCategoricalTransformation(categorical, dataViewMappings) {
                if (!categorical || _.isEmpty(dataViewMappings))
                    return;
                var categories = categorical.categories;
                if (_.isEmpty(categories))
                    return;
                var values = categorical.values;
                if (_.isEmpty(values))
                    return;
                if (values.grouped().some((function (vg) { return !!vg.identity; })))
                    return;
                var _loop_5 = function (i, len) {
                    var roleMappingCategorical = dataViewMappings[i].categorical;
                    if (!roleMappingCategorical)
                        return "continue";
                    debug.assert(_.filter(categories, (function (category) { return hasRolesGrouped(category.source.roles, roleMappingCategorical.values); })).length <= 1, 'There should never be more than one column with the secondary axis group role in a DataViewCategorical, let alone columns in DataViewCategorical.categories.');
                    for (var _i = 0, categories_1 = categories; _i < categories_1.length; _i++) {
                        var category = categories_1[_i];
                        var categoryRoles = category.source.roles;
                        if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))
                            continue;
                        // If we made it here, the DataView's category has the value grouping role.
                        var categoriesMapping = roleMappingCategorical.categories;
                        var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||
                            hasRolesFor(categoryRoles, categoriesMapping);
                        if (hasCategoryRole) {
                            return { value: {
                                    type: 2 /* SelfCrossJoin */,
                                    selfCrossJoinCategory: category,
                                } };
                        }
                        if (categories.length === 1) {
                            return { value: { type: 1 /* Pivot */ } };
                        }
                    }
                };
                // If we made it here, the DataView has at least one category and no valueGrouping.
                for (var i = 0, len = dataViewMappings.length; i < len; i++) {
                    var state_1 = _loop_5(i, len);
                    if (typeof state_1 === "object")
                        return state_1.value;
                }
            }
            function shouldPivotMatrix(matrix, dataViewMappings) {
                if (!matrix || _.isEmpty(dataViewMappings))
                    return;
                var rowLevels = matrix.rows.levels;
                if (rowLevels.length < 1)
                    return;
                var rows = matrix.rows.root.children;
                if (!rows || rows.length === 0)
                    return;
                var rowRoles = rowLevels[0].sources[0].roles;
                for (var i = 0, len = dataViewMappings.length; i < len; i++) {
                    var roleMappingMatrix = dataViewMappings[i].matrix;
                    if (!roleMappingMatrix)
                        continue;
                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&
                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {
                        return true;
                    }
                }
            }
            function hasRolesBind(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.bind)
                    return roles[roleMapping.bind.to];
            }
            function hasRolesFor(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.for)
                    return roles[roleMapping.for.in];
            }
            function hasRolesGrouped(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.group)
                    return roles[roleMapping.group.by];
            }
        })(DataViewTransform = data_4.DataViewTransform || (data_4.DataViewTransform = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createDisplayNameGetter(displayNameKey) {
            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };
        }
        data.createDisplayNameGetter = createDisplayNameGetter;
        function getDisplayName(displayNameGetter, resourceProvider) {
            if (typeof displayNameGetter === 'function')
                return displayNameGetter(resourceProvider);
            if (typeof displayNameGetter === 'string')
                return displayNameGetter;
        }
        data.getDisplayName = getDisplayName;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQFilterBuilder;
        (function (SQFilterBuilder) {
            function fromFilter(filterPattern) {
                var sqFilter = {
                    condition: FilterPattern.visit(filterPattern, FilterConditionToSQExprVisitor.instance)
                };
                if (!_.isEmpty(filterPattern.target))
                    sqFilter.target = _.map(filterPattern.target, (function (target) { return data.SQExprBuilder.fieldExpr(target); }));
                return sqFilter;
            }
            SQFilterBuilder.fromFilter = fromFilter;
            var FilterConditionToSQExprVisitor = /** @class */ (function () {
                function FilterConditionToSQExprVisitor() {
                }
                FilterConditionToSQExprVisitor.prototype.visitIn = function (inPattern) {
                    return data.SQExprBuilder.inValues(_.map(inPattern.args, (function (arg) { return data.SQExprBuilder.fieldExpr(arg); })), _.map(inPattern.values, (function (valueArray) { return _.map(valueArray, (function (value) { return data.SQExprBuilder.typedConstant(value.value, value.type); })); })));
                };
                FilterConditionToSQExprVisitor.instance = new FilterConditionToSQExprVisitor();
                return FilterConditionToSQExprVisitor;
            }());
        })(SQFilterBuilder = data.SQFilterBuilder || (data.SQFilterBuilder = {}));
        var SQFilterConverter;
        (function (SQFilterConverter) {
            // VSTS 7381488: schema is temporarily optional.  The schema should be a required parameter to this method and used
            // by FieldExprPatternBuilder.  However, due to VSTS 7381488, the schema is not always available.  As such, for
            // the moment
            function asFieldPattern(sqFilter, schema) {
                var conditionPattern = sqFilter.condition.accept(new FilterPatternBuilder());
                if (!conditionPattern)
                    return;
                var filterPattern = {
                    condition: conditionPattern
                };
                if (!_.isEmpty(sqFilter.target))
                    filterPattern.target = _.map(sqFilter.target, (function (target) { return data.SQExprConverter.asFieldPattern(target); }));
                return filterPattern;
            }
            SQFilterConverter.asFieldPattern = asFieldPattern;
            var FilterPatternBuilder = /** @class */ (function (_super) {
                __extends(FilterPatternBuilder, _super);
                function FilterPatternBuilder() {
                    return _super.call(this) || this;
                }
                FilterPatternBuilder.prototype.visitIn = function (expr) {
                    if (expr.table || !expr.values)
                        return;
                    return {
                        in: {
                            args: _.map(expr.args, (function (arg) { return data.SQExprConverter.asFieldPattern(arg); })),
                            values: _.map(expr.values, (function (valueArray) { return _.map(valueArray, (function (value, index) {
                                return {
                                    value: value.value,
                                    type: value.type,
                                };
                            })); }))
                        }
                    };
                };
                return FilterPatternBuilder;
            }(data.DefaultSQExprVisitor));
        })(SQFilterConverter = data.SQFilterConverter || (data.SQFilterConverter = {}));
        var FilterPattern;
        (function (FilterPattern) {
            function visit(filter, visitor) {
                debug.assertValue(filter, 'filter');
                debug.assertValue(visitor, 'visitor');
                var filterPattern = isSQFilter(filter) ? SQFilterConverter.asFieldPattern(filter) : filter;
                if (filterPattern.condition.in)
                    return visitIn(filterPattern.condition.in, visitor);
                debug.assertFail('Failed to visit filterPattern');
            }
            FilterPattern.visit = visit;
            function isSQFilter(filter) {
                return !!(filter && filter.condition && filter.condition instanceof data.SQExpr);
            }
            function visitIn(inPattern, visitor) {
                debug.assertValue(inPattern, 'inPattern');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitIn(inPattern);
            }
        })(FilterPattern = data.FilterPattern || (data.FilterPattern = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExprBuilder;
        (function (SQExprBuilder) {
            function fieldExpr(fieldExpr) {
                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);
                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');
                return sqExpr;
            }
            SQExprBuilder.fieldExpr = fieldExpr;
            function fromColumnAggr(columnAggr) {
                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);
            }
            SQExprBuilder.fromColumnAggr = fromColumnAggr;
            function fromColumn(column) {
                return SQExprBuilder.columnRef(fromEntity(column), column.name);
            }
            SQExprBuilder.fromColumn = fromColumn;
            function fromGroupingColumnAggr(columnAggr) {
                return SQExprBuilder.aggregate(SQExprBuilder.groupRef(columnAggr.name, fromEntity(columnAggr), asSQExpr(columnAggr.groupedColumns)), columnAggr.aggregate);
            }
            SQExprBuilder.fromGroupingColumnAggr = fromGroupingColumnAggr;
            function fromGroupingColumn(column) {
                return SQExprBuilder.groupRef(column.name, fromEntity(column), asSQExpr(column.groupedColumns));
            }
            SQExprBuilder.fromGroupingColumn = fromGroupingColumn;
            function fromEntity(entityPattern) {
                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);
            }
            SQExprBuilder.fromEntity = fromEntity;
            function fromEntityAggr(entityAggr) {
                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);
            }
            SQExprBuilder.fromEntityAggr = fromEntityAggr;
            function fromHierarchyLevelAggr(hierarchyLevelAggr) {
                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);
            }
            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;
            function fromHierarchyLevel(hierarchyLevelPattern) {
                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);
            }
            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;
            function fromHierarchy(hierarchyPattern) {
                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);
            }
            SQExprBuilder.fromHierarchy = fromHierarchy;
            function asSQExpr(fieldExprs) {
                return _.map(fieldExprs, (function (fieldExpr) { return SQExprBuilder.fieldExpr(fieldExpr); }));
            }
            var FieldExprToSQExprVisitor = /** @class */ (function () {
                function FieldExprToSQExprVisitor() {
                }
                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {
                    return fromColumn(column);
                };
                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {
                    return fromColumnAggr(columnAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitGroupingColumn = function (column) {
                    return fromGroupingColumn(column);
                };
                FieldExprToSQExprVisitor.prototype.visitGroupingColumnAggr = function (columnAggr) {
                    return fromGroupingColumnAggr(columnAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {
                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);
                };
                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {
                    return fromEntity(entityPattern);
                };
                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {
                    return fromEntityAggr(entityAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {
                    return fromHierarchy(hierarchyPattern);
                };
                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {
                    return fromHierarchyLevel(level);
                };
                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return fromHierarchyLevelAggr(hierarchyLevelAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {
                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);
                };
                FieldExprToSQExprVisitor.prototype.visitPercentile = function (percentile) {
                    var arg = SQExprBuilder.fieldExpr(percentile.arg);
                    return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);
                };
                FieldExprToSQExprVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {
                    var baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);
                    return SQExprBuilder.arithmetic(baseSQExpr, SQExprBuilder.scopedEval(baseSQExpr, []), 3 /* Divide */);
                };
                FieldExprToSQExprVisitor.prototype.visitPercentOfRoleTotal = function (percentOfRoleTotal) {
                    var baseSQExpr = SQExprBuilder.fieldExpr(percentOfRoleTotal.baseExpr);
                    return SQExprBuilder.arithmetic(baseSQExpr, SQExprBuilder.scopedEval(baseSQExpr, _.map(percentOfRoleTotal.roles, (function (role) { return SQExprBuilder.roleRef(role); }))), 3 /* Divide */);
                };
                FieldExprToSQExprVisitor.prototype.visitSelectRef = function (selectRef) {
                    return SQExprBuilder.selectRef(selectRef.expressionName);
                };
                FieldExprToSQExprVisitor.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                    return SQExprBuilder.transformOutputRoleRef(transformOutputRoleRef.expressionName);
                };
                FieldExprToSQExprVisitor.prototype.visitFilteredEval = function (filteredEval) {
                    return SQExprBuilder.filteredEval(SQExprBuilder.fieldExpr(filteredEval.baseExpr), _.map(filteredEval.filters, (function (filterPattern) { return data.SQFilterBuilder.fromFilter(filterPattern); })));
                };
                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();
                return FieldExprToSQExprVisitor;
            }());
        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));
        var SQExprConverter;
        (function (SQExprConverter) {
            // VSTS 7381488: schema is temporarily optional.  The schema should be a required parameter to this method and used
            // by FieldExprPatternBuilder.  However, due to VSTS 7381488, the schema is not always available.  As such, for
            // the moment, the builder returns wrong results for variations
            function asFieldPattern(sqExpr, schema) {
                return sqExpr.accept(new FieldExprPatternBuilder(schema));
            }
            SQExprConverter.asFieldPattern = asFieldPattern;
        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));
        var FieldExprPatternBuilder = /** @class */ (function (_super) {
            __extends(FieldExprPatternBuilder, _super);
            function FieldExprPatternBuilder(schema) {
                var _this = _super.call(this) || this;
                _this.schema = schema;
                return _this;
            }
            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {
                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);
                if (!sourceRef)
                    return;
                if (sourceRef.entity) {
                    var columnRef = sourceRef.entity;
                    columnRef.name = expr.ref;
                    return { column: columnRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {
                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);
                if (!sourceRef)
                    return;
                if (sourceRef.entity) {
                    var measureRef = sourceRef.entity;
                    measureRef.name = expr.ref;
                    return { measure: measureRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {
                var entityRef = {
                    schema: expr.schema,
                    entity: expr.entity
                };
                if (expr.variable)
                    entityRef.entityVar = expr.variable;
                return { entity: entityRef };
            };
            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {
                var fieldPattern = expr.arg.accept(this);
                if (fieldPattern) {
                    if (fieldPattern.column) {
                        var argAggr = fieldPattern.column;
                        argAggr.aggregate = expr.func;
                        return { columnAggr: argAggr };
                    }
                    else if (fieldPattern.columnAggr) {
                        var argAggr = fieldPattern.columnAggr;
                        argAggr.aggregate = expr.func;
                        return { columnAggr: argAggr };
                    }
                    else if (fieldPattern.groupingColumn) {
                        var argAggr = fieldPattern.groupingColumn;
                        argAggr.aggregate = expr.func;
                        return { groupingColumnAggr: argAggr };
                    }
                    else if (fieldPattern.groupingColumnAggr) {
                        var argAggr = fieldPattern.groupingColumnAggr;
                        argAggr.aggregate = expr.func;
                        return { groupingColumnAggr: argAggr };
                    }
                    else if (fieldPattern.hierarchyLevel) {
                        var argAggr = fieldPattern.hierarchyLevel;
                        argAggr.aggregate = expr.func;
                        return { hierarchyLevelAggr: argAggr };
                    }
                }
                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);
                if (sourcePattern && sourcePattern.entity) {
                    var argAggr = sourcePattern.entity;
                    argAggr.aggregate = expr.func;
                    return { entityAggr: argAggr };
                }
            };
            FieldExprPatternBuilder.prototype.visitPercentile = function (expr) {
                return {
                    percentile: {
                        arg: expr.arg.accept(this),
                        k: expr.k,
                        exclusive: expr.exclusive,
                    }
                };
            };
            FieldExprPatternBuilder.prototype.visitGroupRef = function (expr) {
                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);
                if (!sourceRef)
                    return;
                if (sourceRef.entity) {
                    var columnRef = sourceRef.entity;
                    columnRef.name = expr.ref;
                    columnRef.groupedColumns = [];
                    for (var _i = 0, _a = expr.groupedExprs; _i < _a.length; _i++) {
                        var groupedExpr = _a[_i];
                        var fieldExpr = groupedExpr.accept(this);
                        if (fieldExpr.column || fieldExpr.groupingColumn || fieldExpr.hierarchyLevel) {
                            columnRef.groupedColumns.push(fieldExpr);
                        }
                    }
                    return { groupingColumn: columnRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {
                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);
                if (sourcePattern && sourcePattern.entity) {
                    var hierarchyRef = (sourcePattern.entity);
                    hierarchyRef.name = expr.hierarchy;
                    return { hierarchy: hierarchyRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {
                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);
                if (!hierarchySourceExprPattern)
                    return;
                var hierarchyLevel;
                if (hierarchySourceExprPattern.hierarchy) {
                    hierarchyLevel = {
                        entity: hierarchySourceExprPattern.hierarchy.entity,
                        schema: hierarchySourceExprPattern.hierarchy.schema,
                        name: hierarchySourceExprPattern.hierarchy.name,
                        level: expr.level,
                    };
                }
                if (hierarchySourceExprPattern.variation) {
                    // Find the entity that holds the hierarchy definition.  This requires a lookup in the conceptual schema
                    // for the variation name.  If the schema is not available, this method returns wrong results, see VSTS 7381488.  When
                    // that issue is fixed, schema should be treated as required and the check for it removed.
                    if (this.schema) {
                        var variation = hierarchySourceExprPattern.variation;
                        var conceptualEntity = this.schema
                            .schema(hierarchySourceExprPattern.variation.column.schema)
                            .findTargetEntityOfVariation(hierarchyLevel.entity, variation.column.name, variation.variationName);
                        if (conceptualEntity)
                            hierarchyLevel.entity = conceptualEntity.name;
                    }
                    return {
                        columnHierarchyLevelVariation: {
                            source: {
                                entity: hierarchySourceExprPattern.variation.column.entity,
                                schema: hierarchySourceExprPattern.variation.column.schema,
                                name: hierarchySourceExprPattern.variation.column.name,
                            },
                            level: hierarchyLevel,
                            variationName: hierarchySourceExprPattern.variation.variationName,
                        }
                    };
                }
                return { hierarchyLevel: hierarchyLevel };
            };
            FieldExprPatternBuilder.prototype.visitArithmetic = function (expr) {
                var percentOfGrandTotalPattern = {
                    percentOfGrandTotal: {
                        baseExpr: expr.left.accept(this)
                    }
                };
                if (data.SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern)))
                    return percentOfGrandTotalPattern;
                var scope = data.SQExpr.isScopedEval(expr.right) && expr.right.scope;
                if (!_.isEmpty(scope) && _.all(scope, (function (scopeExpr) { return data.SQExpr.isRoleRef(scopeExpr); }))) {
                    return {
                        percentOfRoleTotal: {
                            baseExpr: expr.left.accept(this),
                            roles: _.map(scope, (function (scopeExpr) { return scopeExpr.role; }))
                        }
                    };
                }
            };
            FieldExprPatternBuilder.prototype.visitSelectRef = function (expr) {
                return {
                    selectRef: {
                        expressionName: expr.expressionName,
                    }
                };
            };
            FieldExprPatternBuilder.prototype.visitTransformOutputRoleRef = function (expr) {
                return {
                    transformOutputRoleRef: {
                        expressionName: expr.role
                    }
                };
            };
            FieldExprPatternBuilder.prototype.visitFilteredEval = function (expr) {
                var _this = this;
                return {
                    filteredEval: {
                        baseExpr: expr.expression.accept(this),
                        filters: _.map(expr.filters, (function (filterExpr) { return data.SQFilterConverter.asFieldPattern(filterExpr, _this.schema); }))
                    }
                };
            };
            return FieldExprPatternBuilder;
        }(data.DefaultSQExprVisitor));
        var SourceExprPatternBuilder = /** @class */ (function (_super) {
            __extends(SourceExprPatternBuilder, _super);
            function SourceExprPatternBuilder() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {
                var entityRef = {
                    schema: expr.schema,
                    entity: expr.entity
                };
                if (expr.variable)
                    entityRef.entityVar = expr.variable;
                return { entity: entityRef };
            };
            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {
                var entityExpr = expr.arg;
                if (entityExpr instanceof data.SQEntityExpr) {
                    var propertyVariationSource = {
                        schema: entityExpr.schema,
                        entity: entityExpr.entity,
                        name: expr.property,
                    };
                    if (entityExpr.variable)
                        propertyVariationSource.entityVar = entityExpr.variable;
                    return {
                        variation: {
                            column: propertyVariationSource,
                            variationName: expr.name,
                        }
                    };
                }
            };
            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();
            return SourceExprPatternBuilder;
        }(data.DefaultSQExprVisitor));
        var HierarchyExprPatternBuiler = /** @class */ (function (_super) {
            __extends(HierarchyExprPatternBuiler, _super);
            function HierarchyExprPatternBuiler() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {
                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);
                var hierarchyRef;
                var variationRef;
                if (exprPattern.variation) {
                    hierarchyRef = {
                        name: expr.hierarchy,
                        schema: exprPattern.variation.column.schema,
                        entity: exprPattern.variation.column.entity,
                    };
                    variationRef = exprPattern.variation;
                }
                else
                    hierarchyRef = {
                        name: expr.hierarchy,
                        schema: exprPattern.entity.schema,
                        entity: exprPattern.entity.entity,
                    };
                return {
                    hierarchy: hierarchyRef,
                    variation: variationRef
                };
            };
            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();
            return HierarchyExprPatternBuiler;
        }(data.DefaultSQExprVisitor));
        var FieldExprPattern;
        (function (FieldExprPattern) {
            function visit(expr, visitor) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(visitor, 'visitor');
                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;
                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');
                if (fieldExprPattern.column)
                    return visitColumn(fieldExprPattern.column, visitor);
                if (fieldExprPattern.columnAggr)
                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);
                if (fieldExprPattern.groupingColumn)
                    return visitGroupingColumn(fieldExprPattern.groupingColumn, visitor);
                if (fieldExprPattern.groupingColumnAggr)
                    return visitGroupingColumnAggr(fieldExprPattern.groupingColumnAggr, visitor);
                if (fieldExprPattern.columnHierarchyLevelVariation)
                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);
                if (fieldExprPattern.entity)
                    return visitEntity(fieldExprPattern.entity, visitor);
                if (fieldExprPattern.entityAggr)
                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);
                if (fieldExprPattern.hierarchy)
                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);
                if (fieldExprPattern.hierarchyLevel)
                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);
                if (fieldExprPattern.hierarchyLevelAggr)
                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);
                if (fieldExprPattern.measure)
                    return visitMeasure(fieldExprPattern.measure, visitor);
                if (fieldExprPattern.percentile)
                    return visitPercentile(fieldExprPattern.percentile, visitor);
                if (fieldExprPattern.percentOfGrandTotal)
                    return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);
                if (fieldExprPattern.percentOfRoleTotal)
                    return visitPercentOfRoleTotal(fieldExprPattern.percentOfRoleTotal, visitor);
                if (fieldExprPattern.selectRef)
                    return visitSelectRef(fieldExprPattern.selectRef, visitor);
                if (fieldExprPattern.transformOutputRoleRef)
                    return visitTransformOutputRoleRef(fieldExprPattern.transformOutputRoleRef, visitor);
                if (fieldExprPattern.filteredEval)
                    return visitFilteredEval(fieldExprPattern.filteredEval, visitor);
                debug.assertFail('failed to visit a fieldExprPattern.');
                return;
            }
            FieldExprPattern.visit = visit;
            function visitColumn(column, visitor) {
                debug.assertValue(column, 'column');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitColumn(column);
            }
            function visitColumnAggr(columnAggr, visitor) {
                debug.assertValue(columnAggr, 'columnAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitColumnAggr(columnAggr);
            }
            function visitGroupingColumn(column, visitor) {
                debug.assertValue(column, 'column');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitGroupingColumn(column);
            }
            function visitGroupingColumnAggr(columnAggr, visitor) {
                debug.assertValue(columnAggr, 'columnAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitGroupingColumnAggr(columnAggr);
            }
            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {
                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);
            }
            function visitEntity(entity, visitor) {
                debug.assertValue(entity, 'entity');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitEntity(entity);
            }
            function visitEntityAggr(entityAggr, visitor) {
                debug.assertValue(entityAggr, 'entityAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitEntityAggr(entityAggr);
            }
            function visitHierarchy(hierarchy, visitor) {
                debug.assertValue(hierarchy, 'hierarchy');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitHierarchy(hierarchy);
            }
            function visitHierarchyLevel(hierarchyLevel, visitor) {
                debug.assertValue(hierarchyLevel, 'hierarchyLevel');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitHierarchyLevel(hierarchyLevel);
            }
            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {
                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);
            }
            function visitMeasure(measure, visitor) {
                debug.assertValue(measure, 'measure');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitMeasure(measure);
            }
            function visitSelectRef(selectRef, visitor) {
                debug.assertValue(selectRef, 'selectRef');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitSelectRef(selectRef);
            }
            function visitPercentile(percentile, visitor) {
                debug.assertValue(percentile, 'percentile');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitPercentile(percentile);
            }
            function visitPercentOfGrandTotal(percentOfGrandTotal, visitor) {
                debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);
            }
            function visitPercentOfRoleTotal(percentOfRoleTotal, visitor) {
                debug.assertValue(percentOfRoleTotal, 'percentOfRoleTotal');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitPercentOfRoleTotal(percentOfRoleTotal);
            }
            function visitTransformOutputRoleRef(transformOutputRoleRef, visitor) {
                debug.assertValue(transformOutputRoleRef, 'transformOutputRoleRef');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitTransformOutputRoleRef(transformOutputRoleRef);
            }
            function visitFilteredEval(filteredEval, visitor) {
                debug.assertValue(filteredEval, 'filteredEval');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitFilteredEval(filteredEval);
            }
            function toColumnRefSQExpr(columnPattern) {
                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);
            }
            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;
            function getAggregate(fieldExpr) {
                debug.assertValue(fieldExpr, 'fieldExpr');
                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);
            }
            FieldExprPattern.getAggregate = getAggregate;
            function hasFieldExprName(fieldExpr) {
                return (fieldExpr.column ||
                    fieldExpr.columnAggr ||
                    fieldExpr.groupingColumn ||
                    fieldExpr.groupingColumnAggr ||
                    fieldExpr.measure) !== undefined;
            }
            FieldExprPattern.hasFieldExprName = hasFieldExprName;
            function getPropertyName(fieldExpr) {
                return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);
            }
            FieldExprPattern.getPropertyName = getPropertyName;
            function getHierarchyName(fieldExpr) {
                var hierarchy = fieldExpr.hierarchy;
                if (hierarchy)
                    return hierarchy.name;
            }
            FieldExprPattern.getHierarchyName = getHierarchyName;
            function getProperty(fieldExpr) {
                if (fieldExpr.columnHierarchyLevelVariation)
                    return fieldExpr.columnHierarchyLevelVariation.source;
                return fieldExpr.column || fieldExpr.groupingColumn || fieldExpr.groupingColumnAggr || fieldExpr.measure || fieldExpr.columnAggr;
            }
            FieldExprPattern.getProperty = getProperty;
            function getFieldExprName(fieldExpr) {
                var name = getPropertyName(fieldExpr);
                if (name)
                    return name;
                // In case it is an entity
                return toFieldExprEntityPattern(fieldExpr).entity;
            }
            FieldExprPattern.getFieldExprName = getFieldExprName;
            function getSchema(fieldExpr) {
                debug.assertValue(fieldExpr, 'fieldExpr');
                var item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');
                return item.schema;
            }
            FieldExprPattern.getSchema = getSchema;
            function toFieldExprEntityPattern(fieldExpr) {
                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);
            }
            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;
            function toFieldExprEntityItemPattern(fieldExpr) {
                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);
            }
            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;
            function isPercentRoleTotalExpr(expr) {
                debug.assertValue(expr, 'expr');
                return data.SQExpr.isArithmetic(expr) && data.SQExpr.isScopedEval(expr.right) && !_.isEmpty(expr.right.scope) && _.all(expr.right.scope, (function (scopeExpr) { return data.SQExpr.isRoleRef(scopeExpr); }));
            }
            FieldExprPattern.isPercentRoleTotalExpr = isPercentRoleTotalExpr;
            var FieldExprPatternAggregateVisitor = /** @class */ (function () {
                function FieldExprPatternAggregateVisitor() {
                }
                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {
                    return columnAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitGroupingColumn = function (column) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitGroupingColumnAggr = function (columnAggr) {
                    return columnAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {
                    return entityAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return hierarchyLevelAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitSelectRef = function (selectRef) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitPercentile = function (percentile) {
                    // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but
                    // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.
                    // This should be revisited when we have UI support for the Percentile aggregate.
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {
                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));
                };
                FieldExprPatternAggregateVisitor.prototype.visitPercentOfRoleTotal = function (percentOfRoleTotal) {
                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfRoleTotal.baseExpr));
                };
                FieldExprPatternAggregateVisitor.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitFilteredEval = function (filteredEval) {
                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(filteredEval.baseExpr));
                };
                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();
                return FieldExprPatternAggregateVisitor;
            }());
            var FieldExprToEntityExprPatternBuilder = /** @class */ (function () {
                function FieldExprToEntityExprPatternBuilder() {
                }
                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitGroupingColumn = function (column) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitGroupingColumnAggr = function (columnAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitSelectRef = function (selectRef) {
                    return;
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitPercentile = function (percentile) {
                    return FieldExprPattern.visit(percentile.arg, this);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {
                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitPercentOfRoleTotal = function (percentOfRoleTotal) {
                    return FieldExprPattern.visit(percentOfRoleTotal.baseExpr, this);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                    return;
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitFilteredEval = function (filteredEval) {
                    return FieldExprPattern.visit(filteredEval.baseExpr, this);
                };
                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {
                    debug.assertValue(exprPattern, 'exprPattern');
                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };
                    if (exprPattern.entityVar) {
                        pattern.entityVar = exprPattern.entityVar;
                    }
                    return pattern;
                };
                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();
                return FieldExprToEntityExprPatternBuilder;
            }());
            var FieldExprPropertyNameVisitor = /** @class */ (function () {
                function FieldExprPropertyNameVisitor() {
                }
                FieldExprPropertyNameVisitor.prototype.visitColumn = function (column) {
                    return column.name;
                };
                FieldExprPropertyNameVisitor.prototype.visitColumnAggr = function (columnAggr) {
                    return columnAggr.name;
                };
                FieldExprPropertyNameVisitor.prototype.visitGroupingColumn = function (column) {
                    return column.name;
                };
                FieldExprPropertyNameVisitor.prototype.visitGroupingColumnAggr = function (columnAggr) {
                    return columnAggr.name;
                };
                FieldExprPropertyNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitEntity = function (entity) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitEntityAggr = function (entityAggr) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitHierarchy = function (hierarchy) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitMeasure = function (measure) {
                    return measure.name;
                };
                FieldExprPropertyNameVisitor.prototype.visitSelectRef = function (selectRef) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitPercentile = function (percentile) {
                    return FieldExprPattern.visit(percentile.arg, this);
                };
                FieldExprPropertyNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {
                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);
                };
                FieldExprPropertyNameVisitor.prototype.visitPercentOfRoleTotal = function (percentOfRoleTotal) {
                    return FieldExprPattern.visit(percentOfRoleTotal.baseExpr, this);
                };
                FieldExprPropertyNameVisitor.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                    return;
                };
                FieldExprPropertyNameVisitor.prototype.visitFilteredEval = function (filteredEval) {
                    return FieldExprPattern.visit(filteredEval.baseExpr, this);
                };
                FieldExprPropertyNameVisitor.instance = new FieldExprPropertyNameVisitor();
                return FieldExprPropertyNameVisitor;
            }());
        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewAnalysis;
    (function (DataViewAnalysis) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
        var DataViewMappingMatchErrorCode;
        (function (DataViewMappingMatchErrorCode) {
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionRangeTooLarge"] = 0] = "conditionRangeTooLarge";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionRangeTooSmall"] = 1] = "conditionRangeTooSmall";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionKindExpectedMeasure"] = 2] = "conditionKindExpectedMeasure";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionKindExpectedGrouping"] = 3] = "conditionKindExpectedGrouping";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionKindExpectedGroupingOrMeasure"] = 4] = "conditionKindExpectedGroupingOrMeasure";
        })(DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));
        /** Reshapes the data view to match the provided schema if possible. If not, returns null */
        function validateAndReshape(dataView, dataViewMappings) {
            if (!dataViewMappings || dataViewMappings.length === 0)
                return { dataView: dataView, isValid: true };
            if (dataView) {
                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {
                    var dataViewMapping = dataViewMappings_3[_i];
                    // Keep the original when possible.
                    if (supports(dataView, dataViewMapping))
                        return { dataView: dataView, isValid: true };
                    if (dataViewMapping.categorical && dataView.categorical)
                        return reshapeCategorical(dataView, dataViewMapping);
                    if (dataViewMapping.tree && dataView.tree)
                        return reshapeTree(dataView, dataViewMapping.tree);
                    if (dataViewMapping.single && dataView.single)
                        return reshapeSingle(dataView, dataViewMapping.single);
                    if (dataViewMapping.table && dataView.table)
                        return reshapeTable(dataView, dataViewMapping.table);
                }
            }
            return { isValid: false };
        }
        DataViewAnalysis.validateAndReshape = validateAndReshape;
        function reshapeCategorical(dataView, dataViewMapping) {
            debug.assertValue(dataViewMapping, 'dataViewMapping');
            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.
            var categoryRoleMapping = dataViewMapping.categorical;
            var categorical = dataView.categorical;
            if (!categorical)
                return { isValid: false };
            var rowCount;
            if (categoryRoleMapping.rowCount) {
                rowCount = categoryRoleMapping.rowCount.supported;
                if (rowCount && rowCount.max) {
                    var updated = void 0;
                    var categories = categorical.categories;
                    var maxRowCount = rowCount.max;
                    var originalLength = void 0;
                    if (categories) {
                        for (var i = 0, len = categories.length; i < len; i++) {
                            var category = categories[i];
                            originalLength = category.values.length;
                            if (maxRowCount !== undefined && originalLength > maxRowCount) {
                                // Row count too large: Trim it to fit.
                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);
                                updated = updated || { categories: [] };
                                updated.categories.push({
                                    source: category.source,
                                    values: updatedCategories
                                });
                            }
                        }
                    }
                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {
                        if (!originalLength)
                            originalLength = categorical.values[0].values.length;
                        if (maxRowCount !== undefined && originalLength > maxRowCount) {
                            updated = updated || {};
                            updated.values = powerbi.data.DataViewTransform.createValueColumns();
                            for (var i = 0, len = categorical.values.length; i < len; i++) {
                                var column = categorical.values[i], updatedColumn = {
                                    source: column.source,
                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)
                                };
                                if (column.min !== undefined)
                                    updatedColumn.min = column.min;
                                if (column.max !== undefined)
                                    updatedColumn.max = column.max;
                                if (column.subtotal !== undefined)
                                    updatedColumn.subtotal = column.subtotal;
                                updated.values.push(updatedColumn);
                            }
                        }
                    }
                    if (updated) {
                        dataView = {
                            metadata: dataView.metadata,
                            categorical: updated,
                        };
                    }
                }
            }
            // TODO: Defect 10568566:TS2.4 Upgrade - dataViewAnalysis - reshapeCategorical - Type 'DataViewMapping' has no properties in common with type 'DataViewCategoricalMapping'.
            // TODO: fix and remove <any> casting, `dataViewMapping` is considered as incorrect type here since TS 2.4, 
            //see for more https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#weak-type-detection
            if (supportsCategorical(dataView, dataViewMapping))
                return { dataView: dataView, isValid: true };
            return null;
        }
        function reshapeSingle(dataView, singleRoleMapping) {
            debug.assertValue(dataView, 'dataView');
            debug.assertValue(singleRoleMapping, 'singleRoleMapping');
            if (dataView.single)
                return { dataView: dataView, isValid: true };
            return { isValid: false };
        }
        function reshapeTree(dataView, treeRoleMapping) {
            debug.assertValue(dataView, 'dataView');
            debug.assertValue(treeRoleMapping, 'treeRoleMapping');
            // TODO: Need to implement the reshaping of Tree
            if (supportsTree(dataView, treeRoleMapping)) {
                return { dataView: dataView, isValid: true };
            }
            return { isValid: false };
        }
        function reshapeTable(dataView, tableRoleMapping) {
            debug.assertValue(dataView, 'dataView');
            debug.assertValue(tableRoleMapping, 'tableRoleMapping');
            if (dataView.table)
                return { dataView: dataView, isValid: true };
            return { isValid: false };
        }
        function countGroups(columns) {
            var count = 0;
            for (var i = 0, len = columns.length; i < len; i++) {
                if (!columns[i].isMeasure)
                    ++count;
            }
            return count;
        }
        DataViewAnalysis.countGroups = countGroups;
        function countMeasures(columns) {
            var count = 0;
            for (var i = 0, len = columns.length; i < len; i++) {
                if (columns[i].isMeasure)
                    ++count;
            }
            return count;
        }
        DataViewAnalysis.countMeasures = countMeasures;
        /** Indicates whether the dataView conforms to the specified schema. */
        function supports(dataView, roleMapping, usePreferredDataViewSchema) {
            if (!roleMapping || !dataView)
                return false;
            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))
                return false;
            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))
                return false;
            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree, usePreferredDataViewSchema))
                return false;
            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))
                return false;
            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))
                return false;
            return true;
        }
        DataViewAnalysis.supports = supports;
        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');
            var dataViewCategorical = dataView.categorical;
            if (!dataViewCategorical)
                return false;
            // TODO: Disabling this implementation isn't right.
            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))
            //    return false;
            if (categoryRoleMapping.rowCount) {
                var rowCount = categoryRoleMapping.rowCount.supported;
                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)
                    rowCount = categoryRoleMapping.rowCount.preferred;
                if (rowCount) {
                    var len = 0;
                    if (dataViewCategorical.values && dataViewCategorical.values.length)
                        len = dataViewCategorical.values[0].values.length;
                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)
                        len = dataViewCategorical.categories[0].values.length;
                    if (validateRange(len, rowCount) != null)
                        return false;
                }
            }
            return true;
        }
        function supportsSingle(dataViewSingle, singleRoleMapping) {
            debug.assertValue(singleRoleMapping, 'singleRoleMapping');
            if (!dataViewSingle)
                return false;
            return true;
        }
        function supportsTree(dataView, treeRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(treeRoleMapping, 'treeRoleMapping');
            var metadata = dataView.metadata;
            var depth = treeRoleMapping.depth;
            var numberRange = depth && usePreferredDataViewSchema ? depth.preferred : depth.supported;
            return validateRange(countGroups(metadata.columns), numberRange) == null;
        }
        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(tableRoleMapping, 'tableRoleMapping');
            if (!dataViewTable)
                return false;
            if (tableRoleMapping.rowCount) {
                var rowCount = tableRoleMapping.rowCount.supported;
                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)
                    rowCount = tableRoleMapping.rowCount.preferred;
                if (rowCount) {
                    var len = 0;
                    if (dataViewTable.rows && dataViewTable.rows.length)
                        len = dataViewTable.rows.length;
                    if (validateRange(len, rowCount) != null)
                        return false;
                }
            }
            return true;
        }
        function supportsScriptResult(dataView, scriptResultRoleMapping) {
            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');
            if (!dataView)
                return false;
            if (!dataView.payloadBase64)
                return false;
            return true;
        }
        /**
         * Determines whether the value conforms to the range in the role condition, returning undefined
         * if so or an appropriate error code if not.
         */
        function validateRange(value, numberRange, ignoreMin) {
            debug.assertValue(value, 'value');
            if (!numberRange)
                return;
            if (!ignoreMin && numberRange.min !== undefined && numberRange.min > value)
                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;
            if (numberRange.max !== undefined && numberRange.max < value)
                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;
        }
        DataViewAnalysis.validateRange = validateRange;
        /**
         * Determines whether the value conforms to the kind in the role condition, returning undefined
         * if so or an appropriate error code if not.
         */
        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {
            if (!roleCondition || roleCondition.kind === undefined) {
                return;
            }
            var expectedKind = roleCondition.kind;
            var roleCollection = projections[roleName];
            if (roleCollection) {
                var roleProjections = roleCollection.all();
                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {
                    var roleProjection = roleProjections_1[_i];
                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {
                        switch (expectedKind) {
                            case powerbi.VisualDataRoleKind.Measure:
                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;
                            case powerbi.VisualDataRoleKind.Grouping:
                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;
                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:
                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;
                        }
                    }
                }
            }
        }
        /** Determines the appropriate DataViewMappings for the projections. */
        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {
            debug.assertValue(projections, 'projections');
            debug.assertAnyValue(mappings, 'mappings');
            debug.assert(_.all(mappings, (function (mapping) { return _.isPlainObject(mapping); })), 'precondition: prototypal inheritance on DataViewMapping is not supported by DataViewAnalysis');
            var supportedMappings = [];
            var errors = [];
            if (!_.isEmpty(mappings)) {
                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {
                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;
                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);
                    var conditionsMet = [];
                    if (!_.isEmpty(mappingConditions)) {
                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {
                            var condition = mappingConditions[conditionIndex];
                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);
                            if (!_.isEmpty(currentConditionErrors)) {
                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {
                                    var error = currentConditionErrors_1[_i];
                                    error.mappingIndex = mappingIndex;
                                    error.conditionIndex = conditionIndex;
                                    errors.push(error);
                                }
                            }
                            else
                                conditionsMet.push(condition);
                        }
                    }
                    else {
                        conditionsMet.push({});
                    }
                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {
                        var supportedMapping = _.cloneDeep(mapping); //note: _.cloneDeep() would not clone inherited properties
                        var updatedConditions = _.filter(conditionsMet, (function (condition) { return Object.keys(condition).length > 0; }));
                        if (!_.isEmpty(updatedConditions))
                            supportedMapping.conditions = updatedConditions;
                        supportedMappings.push(supportedMapping);
                    }
                }
            }
            return {
                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),
                mappingErrors: ArrayExtensions.emptyToNull(errors),
            };
        }
        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;
        function checkForConditionErrors(projections, condition, roleKindByQueryRef, useActiveInDrill) {
            debug.assertValue(projections, 'projections');
            debug.assertValue(condition, 'condition');
            var conditionRoles = Object.keys(condition);
            var errors = [];
            for (var i = 0, len = conditionRoles.length; i < len; i++) {
                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];
                var hasUseActiveInDrillSetting = useActiveInDrill !== undefined && useActiveInDrill !== null;
                var useActiveIfAvailable = hasUseActiveInDrillSetting ? useActiveInDrill : isDrillable;
                var roleCount = getPropertyCount(roleName, projections, useActiveIfAvailable);
                var rangeError = validateRange(roleCount, roleCondition);
                if (rangeError != null) {
                    errors.push({
                        code: rangeError,
                        roleName: roleName,
                    });
                }
                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);
                if (kindError != null) {
                    errors.push({
                        code: kindError,
                        roleName: roleName,
                    });
                }
            }
            return errors;
        }
        DataViewAnalysis.checkForConditionErrors = checkForConditionErrors;
        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {
            if (_.isEmpty(requiredProperties))
                return true;
            if (!objectDescriptors || !objectDefinitions)
                return false;
            var staticEvalContext = powerbi.data.createStaticEvalContext();
            return _.every(requiredProperties, (function (requiredProperty) {
                var objectDescriptorValue = null;
                var objectDefinitionProperty = objectDefinitions[requiredProperty.objectName];
                if (!objectDefinitionProperty)
                    return false;
                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];
                if (objectDescriptorProperty)
                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];
                var objectDefinitionValue;
                if (!_.isEmpty(objectDefinitionProperty) && objectDefinitionProperty[0])
                    objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, objectDefinitionProperty[0].selector);
                if (!objectDescriptorValue || !objectDefinitionValue)
                    return false;
                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);
            }));
        }
        function getPropertyCount(roleName, projections, useActiveIfAvailable) {
            debug.assertValue(roleName, 'roleName');
            debug.assertValue(projections, 'projections');
            var projectionsForRole = projections[roleName];
            if (projectionsForRole) {
                if (useActiveIfAvailable)
                    return 1;
                return projectionsForRole.all().length;
            }
            return 0;
        }
        DataViewAnalysis.getPropertyCount = getPropertyCount;
        function hasSameCategoryIdentity(dataView1, dataView2) {
            if (dataView1
                && dataView2
                && dataView1.categorical
                && dataView2.categorical) {
                var dv1Categories = dataView1.categorical.categories;
                var dv2Categories = dataView2.categorical.categories;
                if (dv1Categories
                    && dv2Categories
                    && dv1Categories.length === dv2Categories.length) {
                    for (var i = 0, len = dv1Categories.length; i < len; i++) {
                        var dv1Identity = dv1Categories[i].identity;
                        var dv2Identity = dv2Categories[i].identity;
                        var dv1Length = getLengthOptional(dv1Identity);
                        if (dv1Length !== getLengthOptional(dv2Identity))
                            return false;
                        for (var j = 0; j < dv1Length; j++) {
                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))
                                return false;
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;
        function getLengthOptional(identity) {
            if (identity)
                return identity.length;
            return 0;
        }
        function areMetadataColumnsEquivalent(column1, column2) {
            if (!column1 && !column2)
                return true;
            if (!column1 || !column2)
                return false;
            if (column1.displayName !== column2.displayName)
                return false;
            if (column1.queryName !== column2.queryName)
                return false;
            if (column1.isMeasure !== column2.isMeasure)
                return false;
            if (column1.type !== column2.type)
                return false;
            if (column1.sort !== column2.sort)
                return false;
            return true;
        }
        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;
        /* Returns true if the metadata columns at the same positions in the array are equivalent. */
        function isMetadataEquivalent(metadata1, metadata2) {
            if (!metadata1 && !metadata2)
                return true;
            if (!metadata1 || !metadata2)
                return false;
            var previousColumnsLength = metadata1.columns.length;
            var newColumnsLength = metadata2.columns.length;
            if (previousColumnsLength !== newColumnsLength)
                return false;
            for (var i = 0; i < newColumnsLength; i++) {
                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))
                    return false;
            }
            return true;
        }
        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;
    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var Lazy = jsCommon.Lazy;
        var DataViewRoleWildcard;
        (function (DataViewRoleWildcard) {
            function fromRoles(roles) {
                return new DataViewRoleWildcardImpl(roles);
            }
            DataViewRoleWildcard.fromRoles = fromRoles;
            function equals(firstRoleWildcard, secondRoleWildcard) {
                return firstRoleWildcard.key &&
                    secondRoleWildcard.key &&
                    firstRoleWildcard.key === secondRoleWildcard.key &&
                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, (function (role1, role2) { return role1 === role2; }));
            }
            DataViewRoleWildcard.equals = equals;
            var DataViewRoleWildcardImpl = /** @class */ (function () {
                function DataViewRoleWildcardImpl(roles) {
                    var _this = this;
                    this.kind = 0 /* RoleWildcard */;
                    debug.assertNonEmpty(roles, 'roles');
                    this._roles = roles;
                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });
                }
                Object.defineProperty(DataViewRoleWildcardImpl.prototype, "roles", {
                    get: function () {
                        return this._roles;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewRoleWildcardImpl.prototype, "key", {
                    get: function () {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewRoleWildcardImpl;
            }());
        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewScopeIdentity;
    (function (DataViewScopeIdentity) {
        /** Compares the two DataViewScopeIdentity values for equality. */
        function equals(x, y, ignoreCase) {
            // Normalize falsy to null
            x = x || null;
            y = y || null;
            if (x === y)
                return true;
            if (!x !== !y)
                return false;
            debug.assertValue(x, 'x');
            debug.assertValue(y, 'y');
            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);
        }
        DataViewScopeIdentity.equals = equals;
        function filterFromIdentity(identities, isNot) {
            if (_.isEmpty(identities))
                return;
            var exprs = [];
            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {
                var identity = identities_1[_i];
                exprs.push(identity.expr);
            }
            return filterFromExprs(exprs, isNot);
        }
        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;
        function filterFromExprs(orExprs, isNot) {
            if (_.isEmpty(orExprs))
                return;
            var resultExpr;
            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {
                var orExpr = orExprs_1[_i];
                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);
                if (resultExpr)
                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);
                else
                    resultExpr = inExpr || orExpr;
            }
            if (resultExpr) {
                if (isNot)
                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);
            }
            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);
        }
        DataViewScopeIdentity.filterFromExprs = filterFromExprs;
    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));
    var data;
    (function (data) {
        var Lazy = jsCommon.Lazy;
        function createDataViewScopeIdentity(expr) {
            return new DataViewScopeIdentityImpl(expr);
        }
        data.createDataViewScopeIdentity = createDataViewScopeIdentity;
        var DataViewScopeIdentityImpl = /** @class */ (function () {
            function DataViewScopeIdentityImpl(expr) {
                this.kind = 1 /* ScopeIdentity */;
                debug.assertValue(expr, 'expr');
                this._expr = expr;
                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });
            }
            Object.defineProperty(DataViewScopeIdentityImpl.prototype, "expr", {
                get: function () {
                    return this._expr;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataViewScopeIdentityImpl.prototype, "key", {
                get: function () {
                    return this._key.getValue();
                },
                enumerable: true,
                configurable: true
            });
            return DataViewScopeIdentityImpl;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var Lazy = jsCommon.Lazy;
        var DataViewScopeTotal;
        (function (DataViewScopeTotal) {
            /**
             * Check if the ScopeTotal matches a Total item expressed by they child identity fields of its parent
             * Ex: Total of Sales across States for a certain Country would have exprs = [State]
             * exprs is usually one item except for Table and for Matrix Hierarchy level that is a Composite Group
             * @param total ScopeTotal to match
             * @param exprs Identity Fields of the Total, usually the Child Identity Fields of its parent
             */
            function matches(total, exprs) {
                if (_.isEmpty(exprs))
                    return false;
                return data.SQExprUtils.sequenceEqual(total.exprs, exprs);
            }
            DataViewScopeTotal.matches = matches;
            function equals(x, y) {
                return x === y ||
                    data.SQExprUtils.sequenceEqual(x.exprs, y.exprs);
            }
            DataViewScopeTotal.equals = equals;
            function fromExprs(exprs) {
                return new DataViewScopeTotalImpl(exprs);
            }
            DataViewScopeTotal.fromExprs = fromExprs;
            var DataViewScopeTotalImpl = /** @class */ (function () {
                function DataViewScopeTotalImpl(exprs) {
                    this.kind = 2 /* ScopeTotal */;
                    debug.assertValue(exprs, 'scopeExprs');
                    this._exprs = exprs;
                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });
                }
                Object.defineProperty(DataViewScopeTotalImpl.prototype, "exprs", {
                    get: function () {
                        return this._exprs;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewScopeTotalImpl.prototype, "key", {
                    get: function () {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewScopeTotalImpl;
            }());
        })(DataViewScopeTotal = data.DataViewScopeTotal || (data.DataViewScopeTotal = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var Lazy = jsCommon.Lazy;
        var DataViewScopeWildcard;
        (function (DataViewScopeWildcard) {
            function matches(wildcard, instance) {
                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);
                if (!instanceExprs)
                    return false;
                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);
            }
            DataViewScopeWildcard.matches = matches;
            function equals(firstScopeWildcard, secondScopeWildcard) {
                return firstScopeWildcard === secondScopeWildcard ||
                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);
            }
            DataViewScopeWildcard.equals = equals;
            /**
             * @deprecated New code should use DataViewRoleWildcard.fromRoles(roles) instead of DataViewScopeWildcard.fromExprs(exprs),
             * because the latter has ambiguity for selecting any column that has group on key column(s).
             */
            function fromExprs(exprs) {
                return new DataViewScopeWildcardImpl(exprs);
            }
            DataViewScopeWildcard.fromExprs = fromExprs;
            var DataViewScopeWildcardImpl = /** @class */ (function () {
                function DataViewScopeWildcardImpl(exprs) {
                    this.kind = 3 /* ScopeWildcard */;
                    debug.assertValue(exprs, 'exprs');
                    this._exprs = exprs;
                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });
                }
                Object.defineProperty(DataViewScopeWildcardImpl.prototype, "exprs", {
                    get: function () {
                        return this._exprs;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewScopeWildcardImpl.prototype, "key", {
                    get: function () {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewScopeWildcardImpl;
            }());
        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var Lazy = jsCommon.Lazy;
        var DataViewWildcard;
        (function (DataViewWildcard) {
            /** Compares the two DataViewWildcard values for equality. */
            function equals(x, y) {
                if (!x && !y)
                    return true;
                if (!x || !y)
                    return false;
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return x === y
                    || x.matchingOption === y.matchingOption;
            }
            DataViewWildcard.equals = equals;
            /**
             * Check if the Wildcard matches an identity, that can be a subtotal
             */
            function matches(wildcard, isTotal) {
                debug.assertValue(wildcard, 'DataViewWildcard.matches - wildcard');
                switch (wildcard.matchingOption) {
                    case 0 /* InstancesAndTotals */:
                        return true;
                    case 1 /* InstancesOnly */:
                        return !isTotal;
                    case 2 /* TotalsOnly */:
                        return isTotal;
                    default:
                        debug.assertFail('DataViewWildcard.matches - Unsupported matchingOption');
                }
            }
            DataViewWildcard.matches = matches;
            /**
             * Create a new DataViewWildcard
             * @param matchingOption Default is InstancesAndTotals
             */
            function create(matchingOption) {
                if (matchingOption == null)
                    matchingOption = 0 /* InstancesAndTotals */;
                return new DataViewWildcardImpl(matchingOption);
            }
            DataViewWildcard.create = create;
            var DataViewWildcardImpl = /** @class */ (function () {
                function DataViewWildcardImpl(matchingOption) {
                    var _this = this;
                    this.kind = 4 /* Wildcard */;
                    debug.assertValue(matchingOption, 'matchingOption');
                    this._matchingOption = matchingOption;
                    this._key = new Lazy(function () { return JSON.stringify(_this._matchingOption); });
                }
                Object.defineProperty(DataViewWildcardImpl.prototype, "matchingOption", {
                    get: function () {
                        return this._matchingOption;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewWildcardImpl.prototype, "key", {
                    get: function () {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewWildcardImpl;
            }());
        })(DataViewWildcard = data.DataViewWildcard || (data.DataViewWildcard = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createColorAllocatorCache() {
            return new ColorAllocatorProvider();
        }
        data.createColorAllocatorCache = createColorAllocatorCache;
        var ColorAllocatorProvider = /** @class */ (function () {
            function ColorAllocatorProvider() {
                this.cache = [];
            }
            ColorAllocatorProvider.prototype.get = function (key) {
                debug.assertValue(key, 'key');
                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    if (entry.key === key)
                        return entry.allocator;
                }
            };
            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {
                debug.assertValue(key, 'key');
                debug.assertValue(colorAllocator, 'colorAllocator');
                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');
                this.cache.push({
                    key: key,
                    allocator: colorAllocator,
                });
                return this;
            };
            return ColorAllocatorProvider;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewMapping = powerbi.DataViewMapping;
        var DataViewRegression;
        (function (DataViewRegression) {
            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate
            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.
            var regressionXQueryName = 'RegressionX';
            var regressionSeriesQueryName = 'RegressionSeries';
            DataViewRegression.regressionYQueryName = 'RegressionY';
            function run(options) {
                debug.assertValue(options, 'options');
                var visualDataViews = options.visualDataViews;
                var dataRoles = options.dataRoles;
                var objectDescriptors = options.objectDescriptors;
                var objectDefinitions = options.objectDefinitions;
                var colorAllocatorFactory = options.colorAllocatorFactory;
                var transformSelects = options.transformSelects;
                var applicableDataViewMappings = options.applicableDataViewMappings;
                var roleKindByQueryRef = options.roleKindByQueryRef;
                var queryProjectionsByRole = options.queryProjectionsByRole;
                if (!_.isEmpty(visualDataViews) && transformSelects) {
                    // compute linear regression line if applicable
                    if (!roleKindByQueryRef || !queryProjectionsByRole || _.isEmpty(applicableDataViewMappings) || !objectDescriptors || !objectDefinitions)
                        return visualDataViews;
                    var regressionDataViewMapping = _.find(applicableDataViewMappings, (function (dataViewMapping) {
                        return !!DataViewMapping.getRegressionUsage(dataViewMapping);
                    }));
                    if (regressionDataViewMapping) {
                        var regressionDataViews = [];
                        for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {
                            var visualDataView = visualDataViews_1[_i];
                            var regressionDataView = linearRegressionTransform(visualDataView, applicableDataViewMappings, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                            if (regressionDataView)
                                regressionDataViews.push(regressionDataView);
                        }
                        if (!_.isEmpty(regressionDataViews))
                            visualDataViews.push.apply(visualDataViews, regressionDataViews);
                    }
                }
                return visualDataViews;
            }
            DataViewRegression.run = run;
            /**
             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.
             * It works on scalar axis only.
             * The algorithm is as follows
             *
             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles
             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.
             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept
             * If highlights values are present, repeat steps 2 & 3 using highlight values.
             * 4. Create the new dataView using the points computed above
             */
            function linearRegressionTransform(sourceDataView, applicableDataViewMappings, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                debug.assertValue(applicableDataViewMappings, 'applicableDataViewMappings');
                if (DataViewMapping.targetDataViewKinds(applicableDataViewMappings) === 2 /* Matrix */) {
                    return powerbi.requireSync('data/regression/matrix').apply(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                }
                else {
                    return powerbi.requireSync('data/regression/categorical').apply(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                }
            }
            DataViewRegression.linearRegressionTransform = linearRegressionTransform;
            powerbi.define('data/regression/matrix', (function (imports) {
                /**
                 * Expects to read a matrix which has Series as outer level in matrix rows
                 * Categories should be the inner row level
                 * {
                 *      rows: {
                 *         levels: [ sources: [seriesCol, categoryCol]],
                 *         root: {
                 *             children: [ seriesValues (categoryValues are nested under their respective Series) ]
                 *         }
                 *     },
                 *     columns: {
                 *         levels: [],
                 *         root: {
                 *             children: []
                 *         }
                 *     },
                 *     valueSources: [XValuesCol, YValuesCol, SizeValuesCol]
                 * }
                 */
                function transform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                    debug.assertValue(sourceDataView, 'sourceDataView');
                    debug.assertValue(sourceDataView.matrix, 'sourceDataView.matrix');
                    debug.assertValue(dataRoles, 'dataRoles');
                    debug.assertValue(objectDescriptors, 'objectDescriptors');
                    debug.assertValue(objectDefinitions, 'objectDefinitions');
                    debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                    // Don't compute regression when Matrix has no row children, if there are more than 2 levels, or if there are no value sources
                    var matrix = sourceDataView.matrix;
                    if (!matrix
                        || !matrix.rows
                        || !matrix.rows.root
                        || _.size(matrix.rows.root.children) === 0
                        || _.size(matrix.rows.levels) > 2
                        || _.isEmpty(matrix.valueSources))
                        return;
                    // Step 1
                    var valueSources = matrix.valueSources;
                    var xValuesIndex = getMetadataColumnsIndexWithRoleKind(0 /* X */, valueSources, dataRoles);
                    var yValuesIndex = getMetadataColumnsIndexWithRoleKind(1 /* Y */, valueSources, dataRoles);
                    if (xValuesIndex === -1 || yValuesIndex === -1)
                        return;
                    var xValuesCol = valueSources[xValuesIndex];
                    var yValuesCol = valueSources[yValuesIndex];
                    var valuesBySeries = getXYValues(sourceDataView, [xValuesIndex, yValuesIndex]);
                    var combineSeries = true;
                    var regressionUsage = DataViewMapping.getRegressionUsage(regressionDataViewMapping);
                    if (regressionUsage && sourceDataView.metadata.objects) {
                        var combineSeriesPropertyId = regressionUsage['combineSeries'];
                        if (combineSeriesPropertyId) {
                            combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);
                        }
                    }
                    // Step 2
                    var dataPointsBySeries = valuesBySeries;
                    if (combineSeries)
                        dataPointsBySeries = combineDataPointSets(valuesBySeries);
                    var lineDefSet = calculateLineDefinitions(dataPointsBySeries);
                    if (!areTrendLineDefinitionsValid(lineDefSet))
                        return;
                    var xMin = lineDefSet.xMin;
                    var xMax = lineDefSet.xMax;
                    // Step 3
                    var valuesByTrend = [];
                    for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {
                        var trend = _a[_i];
                        valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));
                    }
                    // Step 4
                    // Test category & Series on same axis
                    var groupValues;
                    if (combineSeries) {
                        groupValues = ['combinedRegressionSeries'];
                    }
                    else {
                        // If we are producing a trend line per series we need to maintain the group identities so that we can map between the
                        // trend line and the original series (to match the color for example).
                        if (matrix.rows.levels.length === 2) {
                            // Source data view has dynamic series which is the outer level in matrix rows
                            groupValues = _.chain(matrix.rows.root.children).filter((function (group) { return !group.isSubtotal; })).map((function (group) { return group.value; })).value();
                        }
                        else {
                            groupValues = ['combinedRegressionSeries'];
                        }
                    }
                    // Step 5
                    var regressionDataView = createRegressionDataView(xValuesCol, yValuesCol, groupValues, [xMin, xMax], valuesByTrend, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                    return regressionDataView;
                }
                function getMetadataColumnsIndexWithRoleKind(roleKind, columns, roles) {
                    if (_.isEmpty(columns))
                        return;
                    return _.findIndex(columns, (function (column) {
                        var _loop_6 = function (roleName) {
                            if (!column.roles[roleName])
                                return "continue";
                            var role = _.find(roles, (function (role) { return role.name === roleName; }));
                            if (role && role.cartesianKind === roleKind)
                                return { value: true };
                        };
                        for (var roleName in column.roles) {
                            var state_2 = _loop_6(roleName);
                            if (typeof state_2 === "object")
                                return state_2.value;
                        }
                        return;
                    }));
                }
                function getXYValues(dataview, targetValueSourceIndices) {
                    var matrix = dataview.matrix;
                    if (!matrix)
                        return;
                    var visitSeries = function (series, xyValues) {
                        if (!series.children)
                            return;
                        for (var _i = 0, _a = series.children; _i < _a.length; _i++) {
                            var category = _a[_i];
                            if (category.isSubtotal)
                                continue;
                            xyValues.xValues.push(category.values[targetValueSourceIndices[0]].value);
                            xyValues.yValues.push(category.values[targetValueSourceIndices[1]].value);
                        }
                    };
                    var values = [];
                    var matrixRows = matrix.rows;
                    // matrix rows will have two levels for a Scatter Chart with a category and Series
                    // and series will be the outer grouping and category will be the inner grouping
                    if (matrixRows.levels.length === 2) {
                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {
                            var series = _a[_i];
                            if (series.isSubtotal)
                                continue;
                            var categoryValues = { xValues: [], yValues: [] };
                            values.push(categoryValues);
                            visitSeries(series, categoryValues);
                        }
                    }
                    else if (matrixRows.levels.length === 1) {
                        var categoryValues = { xValues: [], yValues: [] };
                        values.push(categoryValues);
                        visitSeries(matrixRows.root, categoryValues);
                    }
                    return values;
                }
                function combineDataPointSets(xyValues) {
                    var dataPointsBySeries = [];
                    for (var _i = 0, xyValues_1 = xyValues; _i < xyValues_1.length; _i++) {
                        var xyValue = xyValues_1[_i];
                        if (!dataPointsBySeries[0] && xyValue.xValues.length > 0)
                            dataPointsBySeries.push({ xValues: [], yValues: [] });
                        (_a = dataPointsBySeries[0].xValues).push.apply(_a, xyValue.xValues);
                        (_b = dataPointsBySeries[0].yValues).push.apply(_b, xyValue.yValues);
                    }
                    return dataPointsBySeries;
                    var _a, _b;
                }
                function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                    debug.assertValue(xColumnSource, 'xColumnSource');
                    debug.assertValue(yColumnSource, 'yColumnSource');
                    debug.assertValue(categories, 'categories');
                    debug.assertValue(values, 'values');
                    debug.assertValue(objectDescriptors, 'objectDescriptors');
                    debug.assertValue(objectDefinitions, 'objectDefinitions');
                    debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                    var xRole = regressionDataViewMapping.matrix.rows.select[0].bind.to;
                    var seriesRole = regressionDataViewMapping.matrix.rows.select[1].bind.to;
                    var yRole = regressionDataViewMapping.matrix.values.select[0].for.in;
                    var categoricalRoles = (_a = {}, _a[xRole] = true, _a);
                    var valueRoles = (_b = {}, _b[yRole] = true, _b);
                    var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);
                    var metadata = {
                        columns: []
                    };
                    var columns;
                    var rows = { levels: [], root: { children: [] } };
                    var regressionDataView = {
                        metadata: metadata,
                        matrix: {
                            rows: rows,
                            columns: columns,
                            valueSources: []
                        },
                    };
                    var categoricalMetadata = getRegressionMetadataColumn(xColumnSource, regressionXQueryName, /*isMeasure*/ false, /* displayNamePostFix*/ '', categoricalRoles);
                    var seriesMetadata = getRegressionMetadataColumn(yColumnSource, regressionSeriesQueryName, /*isMeasure*/ yColumnSource.isMeasure, /* displayNamePostFix*/ 'Regression', seriesRoles);
                    var valuesMetadata = getRegressionMetadataColumn(yColumnSource, DataViewRegression.regressionYQueryName, /*isMeasure*/ yColumnSource.isMeasure, /* displayNamePostFix*/ '', valueRoles);
                    metadata.columns.push(seriesMetadata);
                    metadata.columns.push(categoricalMetadata);
                    metadata.columns.push(valuesMetadata);
                    rows.levels.push({ sources: [seriesMetadata] });
                    rows.levels.push({ sources: [categoricalMetadata] });
                    regressionDataView.matrix.valueSources.push(valuesMetadata);
                    var seriesId = data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries');
                    var categoryId = data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories');
                    for (var i = 0; i < groupValues.length; i++) {
                        var series = groupValues[i];
                        var seriesNode = {
                            level: 0,
                            value: series,
                            levelValues: [{ levelSourceIndex: 0, value: series }],
                            children: [],
                            childIdentityFields: [categoryId],
                            identity: data.createDataViewScopeIdentity(data.SQExprBuilder.and(seriesId, data.SQExprBuilder.typedConstant(series, seriesMetadata.type)))
                        };
                        if (_.isEmpty(rows.root.childIdentityFields))
                            rows.root.childIdentityFields = [seriesId];
                        rows.root.children.push(seriesNode);
                        for (var j = 0; j < categories.length; j++) {
                            var category = categories[j];
                            var categoryNode = {
                                level: 1,
                                value: category,
                                levelValues: [{ levelSourceIndex: 1, value: category }],
                                values: {},
                                identity: data.createDataViewScopeIdentity(data.SQExprBuilder.and(categoryId, data.SQExprBuilder.typedConstant(category, categoricalMetadata.type)))
                            };
                            categoryNode.values[0] = { value: values[i][j] };
                            seriesNode.children.push(categoryNode);
                        }
                    }
                    data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);
                    return regressionDataView;
                    var _a, _b, _c;
                }
                return {
                    apply: function (sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                        return transform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                    },
                };
            }));
            powerbi.define('data/regression/categorical', (function (imports) {
                function transform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                    debug.assertValue(sourceDataView, 'sourceDataView');
                    debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');
                    debug.assertValue(dataRoles, 'dataRoles');
                    debug.assertValue(objectDescriptors, 'objectDescriptors');
                    debug.assertValue(objectDefinitions, 'objectDefinitions');
                    debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                    if (!sourceDataView.categorical)
                        return;
                    // Step 1
                    var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);
                    var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);
                    if (_.isEmpty(xColumns) || _.isEmpty(yColumns))
                        return;
                    var xColumnSource = xColumns[0].source;
                    var yColumnSource = yColumns[0].source;
                    var combineSeries = true;
                    var regressionUsage = DataViewMapping.getRegressionUsage(regressionDataViewMapping);
                    if (regressionUsage && sourceDataView.metadata.objects) {
                        var combineSeriesPropertyId = regressionUsage['combineSeries'];
                        if (combineSeriesPropertyId) {
                            combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);
                        }
                    }
                    // Step 2
                    var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);
                    var lineDefSet = calculateLineDefinitions(dataPointsBySeries);
                    if (!areTrendLineDefinitionsValid(lineDefSet))
                        return;
                    var xMin = lineDefSet.xMin;
                    var xMax = lineDefSet.xMax;
                    var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);
                    var highlightsLineDefSet;
                    if (shouldComputeHightlights) {
                        var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);
                        highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);
                        if (areTrendLineDefinitionsValid(highlightsLineDefSet)) {
                            xMin = _.min([xMin, highlightsLineDefSet.xMin]);
                            xMax = _.max([xMax, highlightsLineDefSet.xMax]);
                        }
                        else {
                            shouldComputeHightlights = false;
                        }
                    }
                    // Step 3
                    var valuesByTrend = [];
                    for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {
                        var trend = _a[_i];
                        valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));
                    }
                    var highlightsByTrend;
                    if (shouldComputeHightlights) {
                        highlightsByTrend = [];
                        for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {
                            var trend = _c[_b];
                            highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));
                        }
                    }
                    // Step 4
                    var groupValues;
                    if (combineSeries) {
                        groupValues = ['combinedRegressionSeries'];
                    }
                    else {
                        // If we are producing a trend line per series we need to maintain the group identities so that we can map between the
                        // trend line and the original series (to match the color for example).
                        if (sourceDataView.categorical.values.source) {
                            // Source data view has dynamic series.
                            var groups = sourceDataView.categorical.values.grouped();
                            groupValues = _.map(groups, (function (group) { return group.name; }));
                        }
                        else {
                            // Source data view has static or no series.
                            groupValues = _.map(yColumns, (function (column) { return column.source.queryName; }));
                        }
                    }
                    // Step 5
                    var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                    return regressionDataView;
                }
                function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {
                    debug.assertValue(roleKind, 'roleKind');
                    debug.assertValue(categorical, 'categorical');
                    var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);
                    if (!_.isEmpty(columns))
                        return columns;
                    var categories = categorical.categories;
                    if (_.isEmpty(categories))
                        return;
                    var categoryColumn = categories[0];
                    var categoryColumns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);
                    if (!_.isEmpty(categoryColumns) &&
                        (categories.length === 1 || // not a composite category
                            _.isEmpty(categoryColumn.values) || // no rows (can't tell if there are scalar keys, but doesn't matter)
                            (!_.isEmpty(categoryColumn.objects) && getScalarKeyFromDataViewObjects(categoryColumn.objects[0]) !== undefined)) // scalar keys are available
                    ) {
                        return categoryColumns;
                    }
                }
                function getColumnsWithRoleKind(roleKind, columns, roles) {
                    if (_.isEmpty(columns))
                        return;
                    return _.filter(columns, (function (column) {
                        var _loop_7 = function (roleName) {
                            if (!column.source.roles[roleName])
                                return "continue";
                            var role = _.find(roles, (function (role) { return role.name === roleName; }));
                            if (role && role.cartesianKind === roleKind)
                                return { value: true };
                        };
                        for (var roleName in column.source.roles) {
                            var state_3 = _loop_7(roleName);
                            if (typeof state_3 === "object")
                                return state_3.value;
                        }
                        return false;
                    }));
                }
                function getScalarKeyFromDataViewObjects(objects) {
                    return powerbi.DataViewObjects.getValue(objects, data.scalarKeyMinPropertyIdentifier);
                }
                function getValuesFromColumn(column, preferHighlights) {
                    // If scalar keys are available, use them as the values for the trend line
                    var firstValue = _.head(column.objects);
                    if (firstValue && getScalarKeyFromDataViewObjects(firstValue)) {
                        return _.map(column.objects, (function (c) { return getScalarKeyFromDataViewObjects(c); }));
                    }
                    if (preferHighlights) {
                        // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.
                        var valueColumn = column;
                        if (valueColumn.highlights) {
                            return valueColumn.highlights;
                        }
                    }
                    return column.values;
                }
                function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {
                    var dataPointsBySeries = [];
                    var xValueArray = _.map(xColumns, (function (column) { return getValuesFromColumn(column, preferHighlights); }));
                    var seriesYValues = _.map(yColumns, (function (column) { return getValuesFromColumn(column, preferHighlights); }));
                    var multipleXValueColumns = xColumns.length > 1;
                    for (var i = 0; i < seriesYValues.length; i++) {
                        var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];
                        var yValues = seriesYValues[i];
                        if (combineSeries && dataPointsBySeries.length > 0) {
                            dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);
                            dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);
                        }
                        else {
                            dataPointsBySeries.push({
                                xValues: xValues,
                                yValues: yValues,
                            });
                        }
                    }
                    return dataPointsBySeries;
                }
                function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                    debug.assertValue(xColumnSource, 'xColumnSource');
                    debug.assertValue(yColumnSource, 'yColumnSource');
                    debug.assertValue(categories, 'categories');
                    debug.assertValue(values, 'values');
                    debug.assertValue(objectDescriptors, 'objectDescriptors');
                    debug.assertValue(objectDefinitions, 'objectDefinitions');
                    debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                    debug.assertAnyValue(highlights, 'highlights');
                    debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');
                    var xRole = regressionDataViewMapping.categorical.categories.for.in;
                    var grouped = regressionDataViewMapping.categorical.values.group;
                    var yRole;
                    var seriesRole;
                    if (grouped && !_.isEmpty(grouped.select)) {
                        yRole = grouped.select[0].for ?
                            grouped.select[0].for.in :
                            grouped.select[0].bind.to;
                        seriesRole = grouped.by;
                    }
                    if (!yRole || !seriesRole)
                        return;
                    var categoricalRoles = (_a = {}, _a[xRole] = true, _a);
                    var valueRoles = (_b = {}, _b[yRole] = true, _b);
                    var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);
                    var valuesBySeries = [];
                    for (var index in values) {
                        var seriesData = {
                            values: values[index],
                        };
                        if (highlights)
                            seriesData.highlights = highlights[index];
                        valuesBySeries.push([seriesData]);
                    }
                    var regressionDataView = data.createCategoricalDataViewBuilder()
                        .withCategory({
                        source: getRegressionMetadataColumn(xColumnSource, regressionXQueryName, /*isMeasure*/ false, /* displayNamePostFix*/ '', categoricalRoles),
                        values: categories,
                        identityFrom: {
                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],
                        },
                    })
                        .withGroupedValues({
                        groupColumn: {
                            source: getRegressionMetadataColumn(yColumnSource, regressionSeriesQueryName, /*isMeasure*/ yColumnSource.isMeasure, /* displayNamePostFix*/ 'Regression', seriesRoles),
                            values: groupValues,
                            identityFrom: {
                                fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],
                            }
                        },
                        valueColumns: [{
                                source: getRegressionMetadataColumn(yColumnSource, DataViewRegression.regressionYQueryName, /*isMeasure*/ yColumnSource.isMeasure, /* displayNamePostFix*/ '', valueRoles),
                            }],
                        data: valuesBySeries
                    })
                        .build();
                    data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);
                    return regressionDataView;
                    var _a, _b, _c;
                }
                function hasHighlightValues(columns) {
                    return _.any(columns, (function (column) {
                        var valueColumn = column;
                        return valueColumn.highlights != null;
                    }));
                }
                return {
                    apply: function (sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                        return transform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                    },
                };
            }));
            function getRegressionMetadataColumn(sourceColumn, queryName, isMeasure, displayNamePostFix, roles) {
                return {
                    displayName: sourceColumn.displayName + displayNamePostFix,
                    queryName: queryName,
                    type: sourceColumn.type,
                    isMeasure: isMeasure,
                    roles: roles
                };
            }
            function calculateLineDefinitions(dataPointsBySeries) {
                var xMin;
                var xMax;
                var lineDefs = [];
                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {
                    var dataPointSet = dataPointsBySeries_1[_i];
                    var unsortedXValues = dataPointSet.xValues;
                    var unsortedYValues = dataPointSet.yValues;
                    // For series where trend lines are not supported (like either X or Y is null for all values in a series - clustering),
                    // we should still push a null definition because these need to align with the source group values.
                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues)) {
                        lineDefs.push(null);
                        continue;
                    }
                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null
                    var xDataType = getDataType(unsortedXValues);
                    var yDataType = getDataType(unsortedYValues);
                    if (!xDataType || !yDataType) {
                        lineDefs.push(null);
                        continue;
                    }
                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);
                    if (!sortedDataPointSet || _.isEmpty(sortedDataPointSet.xValues) || _.isEmpty(sortedDataPointSet.yValues)) {
                        lineDefs.push(null);
                        continue;
                    }
                    var minCategoryValue = sortedDataPointSet.xValues[0];
                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];
                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);
                    xMin = _.min([xMin, minCategoryValue]);
                    xMax = _.max([xMax, maxCategoryValue]);
                    lineDefs.push(lineDef);
                }
                return {
                    lineDefs: lineDefs,
                    xMin: xMin,
                    xMax: xMax,
                };
            }
            function areTrendLineDefinitionsValid(lineDefSet) {
                return lineDefSet && !_.isEmpty(lineDefSet.lineDefs) && _.some(lineDefSet.lineDefs, (function (lineDef) { return lineDef; }));
            }
            function getDataType(values) {
                var firstNonNull = _.find(values, (function (value) { return value != null; }));
                if (firstNonNull == null)
                    return;
                var dataType = typeof firstNonNull;
                if (_.some(values, (function (value) { return value != null && typeof value !== dataType; })))
                    return;
                return dataType;
            }
            function sortValues(unsortedXValues, unsortedYValues) {
                debug.assertValue(unsortedXValues, 'unsortedXValues');
                debug.assertValue(unsortedYValues, 'unsortedYValues');
                var zippedValues = _.zip(unsortedXValues, unsortedYValues);
                var _a = _.chain(zippedValues)
                    .filter((function (valuePair) { return valuePair[0] != null && valuePair[1] != null; }))
                    .sortBy((function (valuePair) { return valuePair[0]; }))
                    .unzip()
                    .value(), xValues = _a[0], yValues = _a[1];
                return {
                    xValues: xValues,
                    yValues: yValues
                };
            }
            /**
             * Computes a line definition using linear regression.
             *   xBar: average of X values, yBar: average of Y values
             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2
             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)
             *   Slope: ssXY / ssXX
             *   Intercept: yBar - xBar * slope
             */
            function computeRegressionLine(xValues, yValues) {
                debug.assertValue(xValues, 'xValues');
                debug.assertValue(yValues, 'yValues');
                var xBar = _.sum(xValues) / xValues.length;
                var yBar = _.sum(yValues) / yValues.length;
                var ssXX = _.chain(xValues)
                    .map((function (x) {
                    return Math.pow((x - xBar), 2);
                }))
                    .sum();
                if (ssXX === 0)
                    return;
                var ssXY = _.chain(xValues)
                    .map((function (x, i) {
                    return (x - xBar) * (yValues[i] - yBar);
                }))
                    .sum();
                var slope = ssXY / ssXX;
                var intercept = yBar - (xBar * slope);
                return {
                    slope: slope,
                    intercept: intercept
                };
            }
            function computeLineYValues(lineDef, x1, x2) {
                return lineDef ? [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept] : [null, null];
            }
        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewSelectTransform;
        (function (DataViewSelectTransform) {
            /** Convert selection info to projections */
            function projectionsFromSelects(selects, projectionActiveItems) {
                debug.assertAnyValue(selects, "selects");
                debug.assertAnyValue(projectionActiveItems, "projectionActiveItems");
                if (_.isEmpty(selects))
                    return {};
                var projections = {};
                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {
                    var select = selects_1[_i];
                    if (!select)
                        continue;
                    var roles = select.roles;
                    if (!roles)
                        continue;
                    for (var roleName in roles) {
                        if (roles[roleName]) {
                            var qp = projections[roleName];
                            if (!qp)
                                qp = projections[roleName] = new data.QueryProjectionCollection([]);
                            qp.all().push({ queryRef: select.queryName });
                            if (projectionActiveItems && projectionActiveItems[roleName])
                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], (function (activeItem) { return activeItem.queryRef; }));
                        }
                    }
                }
                return projections;
            }
            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;
            /** Use selections and metadata to fashion query role kinds */
            function createRoleKindFromMetadata(selects, metadata) {
                var roleKindByQueryRef = {};
                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)
                        continue;
                    var select = selects[column.index];
                    if (select) {
                        var queryRef = select.queryName;
                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {
                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;
                        }
                    }
                }
                return roleKindByQueryRef;
            }
            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;
            function findExprQueryName(expr, selectTransforms) {
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(expr, 'expr');
                if (data.SQExpr.isSelectRef(expr))
                    return expr.expressionName;
                if (!selectTransforms)
                    return;
                var select = _.find(selectTransforms, (function (select) { return select.expr && data.SQExpr.equals(select.expr, expr); }));
                if (!select)
                    return;
                return select.queryName;
            }
            DataViewSelectTransform.findExprQueryName = findExprQueryName;
            function findExprSelectIndex(expr, selectTransforms) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(selectTransforms, 'selectTransforms');
                var queryName;
                if (data.SQExpr.isSelectRef(expr))
                    queryName = expr.expressionName;
                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {
                    var selectTransform = selectTransforms[selectIdx];
                    if (!selectTransform || (queryName && !selectTransform.queryName))
                        continue;
                    if (queryName) {
                        if (selectTransform.queryName === queryName)
                            return selectIdx;
                    }
                    else {
                        if (data.SQExpr.equals(selectTransform.expr, expr))
                            return selectIdx;
                    }
                }
                return -1;
            }
            DataViewSelectTransform.findExprSelectIndex = findExprSelectIndex;
        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical, selectTransforms) {
            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical, selectTransforms);
        }
        data.createCategoricalEvalContext = createCategoricalEvalContext;
        var CategoricalEvalContext = /** @class */ (function () {
            function CategoricalEvalContext(colorAllocatorProvider, dataView, selectTransforms) {
                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                this.colorAllocatorProvider = colorAllocatorProvider;
                this.dataView = dataView;
                this.selectTransforms = selectTransforms;
                this.columnsByRole = {};
            }
            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorProvider.get(expr);
            };
            CategoricalEvalContext.prototype.getExprValue = function (expr) {
                var rowIdx = this.index;
                if (!_.isNumber(rowIdx))
                    return;
                var selectTransforms = this.selectTransforms;
                if (!selectTransforms)
                    return;
                var selectIdx = data.DataViewSelectTransform.findExprSelectIndex(expr, selectTransforms);
                if (selectIdx === -1)
                    return;
                var dataView = this.dataView;
                var column = findValueColumn(dataView.values, selectIdx);
                if (!column)
                    return;
                return column.values[rowIdx];
            };
            CategoricalEvalContext.prototype.getRoleValues = function (roleName) {
                var _this = this;
                var columnsByRole = this.columnsByRole;
                var columns = columnsByRole[roleName];
                if (!columns)
                    columns = columnsByRole[roleName] = findRuleInputColumns(this.dataView, roleName);
                if (!columns)
                    return;
                var index = this.index;
                if (index != null)
                    return _.map(columns, (function (column) { return column.values[_this.index]; }));
            };
            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {
                debug.assertValue(index, 'index');
                this.index = index;
            };
            return CategoricalEvalContext;
        }());
        function findRuleInputColumns(dataViewCategorical, inputRole) {
            debug.assertValue(dataViewCategorical, 'dataViewCategorical');
            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||
                findRuleInputInColumns(dataViewCategorical.categories, inputRole);
        }
        function findRuleInputInColumns(columns, inputRole) {
            debug.assertAnyValue(columns, 'columns');
            if (!columns)
                return;
            var filteredColumns = [];
            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {
                var column = columns_7[_i];
                var roles = column.source.roles;
                if (!roles || !roles[inputRole])
                    continue;
                filteredColumns.push(column);
            }
            return filteredColumns;
        }
        function findValueColumn(columns, selectIdx) {
            debug.assertAnyValue(columns, 'columns');
            debug.assertValue(selectIdx, 'selectIdx');
            if (!columns)
                return;
            return _.find(columns, (function (column) { return !column.identity && column.source.index === selectIdx; }));
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {
            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);
        }
        data.createTableEvalContext = createTableEvalContext;
        var TableEvalContext = /** @class */ (function () {
            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {
                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(selectTransforms, 'selectTransforms');
                this.colorAllocatorProvider = colorAllocatorProvider;
                this.dataView = dataView;
                this.selectTransforms = selectTransforms;
            }
            TableEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorProvider.get(expr);
            };
            TableEvalContext.prototype.getExprValue = function (expr) {
                debug.assertValue(expr, 'expr');
                var row = this.row;
                if (row == null)
                    return;
                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView.columns, row);
            };
            TableEvalContext.prototype.getRoleValues = function (roleName) {
                return;
            };
            TableEvalContext.prototype.setCurrentRow = function (row) {
                debug.assertValue(row, 'row');
                this.row = row;
            };
            return TableEvalContext;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var RuleEvaluation = /** @class */ (function () {
            function RuleEvaluation() {
            }
            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.
            RuleEvaluation.prototype.evaluate = function (evalContext) {
                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');
            };
            return RuleEvaluation;
        }());
        data.RuleEvaluation = RuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ColorRuleEvaluation = /** @class */ (function (_super) {
            __extends(ColorRuleEvaluation, _super);
            function ColorRuleEvaluation(inputRole, allocator) {
                var _this = this;
                debug.assertValue(inputRole, 'inputRole');
                debug.assertValue(allocator, 'allocator');
                _this = _super.call(this) || this;
                _this.inputRole = inputRole;
                _this.allocator = allocator;
                return _this;
            }
            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {
                debug.assertValue(evalContext, 'evalContext');
                var roleValues = evalContext.getRoleValues(this.inputRole);
                debug.assert(_.size(roleValues) <= 1, 'Color Rule Evaluation can run with only one value');
                var value = _.first(roleValues);
                if (value !== undefined)
                    return this.allocator.color(value);
            };
            return ColorRuleEvaluation;
        }(data.RuleEvaluation));
        data.ColorRuleEvaluation = ColorRuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ConceptualSchema = /** @class */ (function () {
            function ConceptualSchema() {
            }
            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {
                var entity = this.entities.withName(entityName);
                if (!entity || _.isEmpty(entity.properties))
                    return;
                return entity.properties.withName(propertyName);
            };
            Object.defineProperty(ConceptualSchema.prototype, "isExtensionSchema", {
                get: function () {
                    // Extends can have a value of undefined, meaning the base (default) schema.  Therefore it's not sufficient
                    // to check for undefined.  Instead check for the existence of the property.
                    return this.hasOwnProperty("extends");
                },
                enumerable: true,
                configurable: true
            });
            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {
                var entity = this.entities.withName(entityName);
                if (!entity || _.isEmpty(entity.hierarchies))
                    return;
                return entity.hierarchies.withName(name);
            };
            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {
                var targetEntity = this.findTargetEntityOfVariation(variationEntityName, variationColumnName, variationName);
                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))
                    return;
                return targetEntity.hierarchies.withName(hierarchyName);
            };
            ConceptualSchema.prototype.findTargetEntityOfVariation = function (variationEntityName, variationColumnName, variationName) {
                var variationEntity = this.entities.withName(variationEntityName);
                if (!variationEntity || _.isEmpty(variationEntity.properties))
                    return;
                var variationProperty = variationEntity.properties.withName(variationColumnName);
                if (!variationProperty)
                    return;
                var variationColumn = variationProperty.column;
                if (!variationColumn || _.isEmpty(variationColumn.variations))
                    return;
                var variation = variationColumn.variations.withName(variationName);
                if (variation)
                    return variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;
            };
            /**
            * Returns the first property of the entity whose kpi is tied to kpiProperty
            */
            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {
                debug.assertValue(kpiProperty, 'kpiProperty');
                var entity = this.entities.withName(entityName);
                if (!entity || _.isEmpty(entity.properties))
                    return;
                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (prop &&
                        prop.measure &&
                        prop.measure.kpi &&
                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))
                        return prop;
                }
                return;
            };
            return ConceptualSchema;
        }());
        data.ConceptualSchema = ConceptualSchema;
        // TODO: Remove this (replaced by ValueType)
        var ConceptualDataCategory;
        (function (ConceptualDataCategory) {
            ConceptualDataCategory[ConceptualDataCategory["None"] = 0] = "None";
            ConceptualDataCategory[ConceptualDataCategory["Address"] = 1] = "Address";
            ConceptualDataCategory[ConceptualDataCategory["City"] = 2] = "City";
            ConceptualDataCategory[ConceptualDataCategory["Company"] = 3] = "Company";
            ConceptualDataCategory[ConceptualDataCategory["Continent"] = 4] = "Continent";
            ConceptualDataCategory[ConceptualDataCategory["Country"] = 5] = "Country";
            ConceptualDataCategory[ConceptualDataCategory["County"] = 6] = "County";
            ConceptualDataCategory[ConceptualDataCategory["Date"] = 7] = "Date";
            ConceptualDataCategory[ConceptualDataCategory["Image"] = 8] = "Image";
            ConceptualDataCategory[ConceptualDataCategory["ImageUrl"] = 9] = "ImageUrl";
            ConceptualDataCategory[ConceptualDataCategory["Latitude"] = 10] = "Latitude";
            ConceptualDataCategory[ConceptualDataCategory["Longitude"] = 11] = "Longitude";
            ConceptualDataCategory[ConceptualDataCategory["Organization"] = 12] = "Organization";
            ConceptualDataCategory[ConceptualDataCategory["Place"] = 13] = "Place";
            ConceptualDataCategory[ConceptualDataCategory["PostalCode"] = 14] = "PostalCode";
            ConceptualDataCategory[ConceptualDataCategory["Product"] = 15] = "Product";
            ConceptualDataCategory[ConceptualDataCategory["StateOrProvince"] = 16] = "StateOrProvince";
            ConceptualDataCategory[ConceptualDataCategory["WebUrl"] = 17] = "WebUrl";
        })(ConceptualDataCategory = data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var StringExtensions = jsCommon.StringExtensions;
    var FieldExprPattern = powerbi.data.FieldExprPattern;
    var ScriptResultUtil;
    (function (ScriptResultUtil) {
        var DefaultOutputType = 'png';
        function findScriptResultMapping(dataViewMappings) {
            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');
            if (dataViewMappings && dataViewMappings.length === 1 && dataViewMappings[0]) {
                return dataViewMappings[0].scriptResult;
            }
        }
        ScriptResultUtil.findScriptResultMapping = findScriptResultMapping;
        function extractScriptResult(dataViewMappings) {
            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');
            var scriptResultMapping = findScriptResultMapping(dataViewMappings);
            if (!scriptResultMapping)
                return;
            var objects = dataViewMappings[0].metadata && dataViewMappings[0].metadata.objects;
            return extractScriptResultFromDataViewObjects(scriptResultMapping, objects);
        }
        ScriptResultUtil.extractScriptResult = extractScriptResult;
        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {
            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');
            debug.assertAnyValue(objects, 'objects');
            if (!objects)
                return;
            var scriptResultMapping = findScriptResultMapping(dataViewMappings);
            if (!scriptResultMapping || !scriptResultMapping.script || !scriptResultMapping.script.source || !scriptResultMapping.script.provider)
                return;
            var sourceExpr = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResultMapping.script.source, null);
            var providerExpr = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResultMapping.script.provider, null);
            var source = sourceExpr ? sourceExpr.value : null;
            var provider = providerExpr ? providerExpr.value : null;
            return getScriptInfo(source, provider, scriptResultMapping.script.scriptOutputType);
        }
        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;
        function extractScriptResultDefaultFromDataViewMappings(dataViewMappings) {
            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');
            return extractScriptResultDefault(findScriptResultMapping(dataViewMappings));
        }
        ScriptResultUtil.extractScriptResultDefaultFromDataViewMappings = extractScriptResultDefaultFromDataViewMappings;
        function extractScriptResultFromDataViewObjects(scriptResultMapping, dataViewObjects) {
            if (!scriptResultMapping || !scriptResultMapping.script || !scriptResultMapping.script.source || !scriptResultMapping.script.provider || !dataViewObjects)
                return;
            var source = powerbi.DataViewObjects.getValue(dataViewObjects, scriptResultMapping.script.source);
            var provider = powerbi.DataViewObjects.getValue(dataViewObjects, scriptResultMapping.script.provider);
            return getScriptInfo(source, provider, scriptResultMapping.script.scriptOutputType);
        }
        function extractScriptResultDefault(scriptResultMapping) {
            return extractScriptResultDefaultFromDataViewMappingScriptDefinition(scriptResultMapping && scriptResultMapping.script);
        }
        function extractScriptResultDefaultFromDataViewMappingScriptDefinition(scriptMapping) {
            debug.assertAnyValue(scriptMapping, 'scriptMapping');
            if (!scriptMapping)
                return;
            var scriptSourceDefault = scriptMapping.scriptSourceDefault;
            var scriptProviderDefault = scriptMapping.scriptProviderDefault;
            var scriptOutputType = scriptMapping.scriptOutputType;
            return getScriptInfo(scriptSourceDefault, scriptProviderDefault, scriptOutputType);
        }
        ScriptResultUtil.extractScriptResultDefaultFromDataViewMappingScriptDefinition = extractScriptResultDefaultFromDataViewMappingScriptDefinition;
        function getScriptInfo(source, provider, scriptOutputType) {
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(source) || StringExtensions.isNullOrUndefinedOrWhiteSpaceString(provider))
                return;
            return {
                source: source,
                provider: provider,
                outputType: scriptOutputType || DefaultOutputType
            };
        }
        function getScriptInput(projections, selects, schema, mapping, objects) {
            if (mapping && mapping.script) {
                return getScriptInputFromScriptDefinition(projections, selects, schema, mapping.script, objects);
            }
        }
        ScriptResultUtil.getScriptInput = getScriptInput;
        function getScriptInputFromScriptDefinition(projections, selects, schema, scriptDefinition, objects) {
            debug.assertAnyValue(projections, 'projections');
            debug.assertAnyValue(selects, 'selects');
            debug.assertAnyValue(schema, 'schema');
            debug.assertAnyValue(scriptDefinition, 'scriptDefinition');
            var customRoleSupport = !!extractScriptResultDefaultFromDataViewMappingScriptDefinition(scriptDefinition);
            var scriptInput = {
                VariableName: "dataset",
                Columns: [],
                Parameters: []
            };
            // Go over all the projections, and create an input column according to the order
            // of the projections (including duplicate expressions)
            if (projections && selects && !_.isEmpty(selects)) {
                var scriptInputColumnNames = [];
                var scriptInputColumns = [];
                for (var role in projections) {
                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {
                        var projection = _a[_i];
                        var select = selects.withName(projection.queryRef);
                        if (select) {
                            var scriptInputColumn = {
                                QueryName: select.name
                            };
                            var name_1 = FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema));
                            if (customRoleSupport) {
                                scriptInputColumn.Role = role;
                                name_1 = role + "." + name_1;
                            }
                            scriptInputColumns.push(scriptInputColumn);
                            scriptInputColumnNames.push(name_1);
                        }
                    }
                }
                // Make sure the names of the columns are unique
                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);
                // Update the names of the columns
                for (var i = 0; i < scriptInputColumnNames.length; i++) {
                    var scriptInputColumn = scriptInputColumns[i];
                    scriptInputColumn.Name = scriptInputColumnNames[i];
                }
                scriptInput.Columns = scriptInputColumns;
            }
            scriptInput.Parameters = getScriptParameters(scriptDefinition, objects);
            return scriptInput;
        }
        ScriptResultUtil.getScriptInputFromScriptDefinition = getScriptInputFromScriptDefinition;
        function getScriptParameters(scriptDefinition, objects) {
            var parameters = [];
            if (objects) {
                for (var objectName in objects) {
                    var object = powerbi.DataViewObjects.getObject(objects, objectName);
                    if (object) {
                        for (var propertyName in object) {
                            var parameterValue = getParameterValue(scriptDefinition, object, objectName, propertyName);
                            if (parameterValue) {
                                var parameter = {
                                    ObjectName: objectName,
                                    PropertyName: propertyName,
                                    Value: parameterValue
                                };
                                parameters.push(parameter);
                            }
                        }
                    }
                }
            }
            return parameters;
        }
        function getParameterValue(scriptDefinition, object, objectName, propertyName) {
            // Ignore the script source code property
            if (scriptDefinition && scriptDefinition.source && scriptDefinition.source.objectName === objectName && scriptDefinition.source.propertyName === propertyName)
                return;
            // Ignore the script provider property
            if (scriptDefinition && scriptDefinition.provider && scriptDefinition.provider.objectName === objectName && scriptDefinition.provider.propertyName === propertyName)
                return;
            var colorValue = powerbi.DataViewObject.getFillColorByPropertyName(object, propertyName);
            if (colorValue) {
                return powerbi.data.PrimitiveValueEncoding.text(colorValue);
            }
            var value = powerbi.DataViewObject.getValue(object, propertyName);
            if (value === undefined || value === null)
                return;
            switch (typeof (value)) {
                case "string":
                    return powerbi.data.PrimitiveValueEncoding.text(value);
                case "number":
                    var numberValue = value;
                    if (powerbi.Double.isInteger(numberValue)) {
                        return powerbi.data.PrimitiveValueEncoding.integer(numberValue);
                    }
                    return powerbi.data.PrimitiveValueEncoding.double(numberValue);
                case "boolean":
                    return powerbi.data.PrimitiveValueEncoding.boolean(value);
            }
        }
        var ScriptInputColumnNameVisitor = /** @class */ (function () {
            function ScriptInputColumnNameVisitor(federatedSchema) {
                this.federatedSchema = federatedSchema;
            }
            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {
                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {
                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitGroupingColumn = function (column) {
                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitGroupingColumnAggr = function (columnAggr) {
                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {
                return entity.entity;
            };
            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {
                return entityAggr.entity;
            };
            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {
                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                /*Hierarchy levels are not supported yet*/
                return;
            };
            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {
                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitSelectRef = function (selectRef) {
                // TODO Defect 10568668:TS2.4 Upgrade - scriptResultUtil.ts - Argument of type 'FieldExprFilteredEvalPattern' is not assignable to parameter of type 'SQExpr | FieldExprPattern'.
                // TODO: fix and remove <any> casting, `selectRef` is considered as incorrect type here since TS 2.4,
                // see for more https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#weak-type-detection
                return FieldExprPattern.visit(selectRef, this);
            };
            ScriptInputColumnNameVisitor.prototype.visitPercentile = function (percentile) {
                return FieldExprPattern.visit(percentile.arg, this);
            };
            ScriptInputColumnNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {
                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);
            };
            ScriptInputColumnNameVisitor.prototype.visitPercentOfRoleTotal = function (percentOfRoleTotal) {
                return FieldExprPattern.visit(percentOfRoleTotal.baseExpr, this);
            };
            ScriptInputColumnNameVisitor.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                // TODO Defect 10568668:TS2.4 Upgrade - scriptResultUtil.ts - Argument of type 'FieldExprFilteredEvalPattern' is not assignable to parameter of type 'SQExpr | FieldExprPattern'.
                // TODO: fix and remove <any> casting, `transformOutputRoleRef` is considered as incorrect type here since TS 2.4,
                // see for more https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#weak-type-detection
                return FieldExprPattern.visit(transformOutputRoleRef, this);
            };
            ScriptInputColumnNameVisitor.prototype.visitFilteredEval = function (filteredEval) {
                // TODO Defect 10568668:TS2.4 Upgrade - scriptResultUtil.ts - Argument of type 'FieldExprFilteredEvalPattern' is not assignable to parameter of type 'SQExpr | FieldExprPattern'.
                // TODO: fix and remove <any> casting, `filteredEval` is considered as incorrect type here since TS 2.4,
                // see for more https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#weak-type-detection
                return FieldExprPattern.visit(filteredEval, this);
            };
            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {
                debug.assertValue(pattern, 'pattern');
                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);
                if (hierarchy)
                    return hierarchy.name;
            };
            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {
                debug.assertValue(pattern, 'pattern');
                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);
                if (property)
                    return property.name;
            };
            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {
                debug.assertValue(pattern, 'pattern');
                var source = pattern.source;
                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);
                if (!prop)
                    return;
                var variations = prop.column.variations;
                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {
                    var variation = variations_1[_i];
                    if (variation.name === pattern.variationName)
                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {
                            var level = _b[_a];
                            if (level.name === pattern.level.level)
                                return level.column.name;
                        }
                }
            };
            return ScriptInputColumnNameVisitor;
        }());
    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var segmentation;
        (function (segmentation) {
            var DataViewMerger;
            (function (DataViewMerger) {
                function mergeDataViews(source, segment) {
                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {
                        debug.assertFail("Cannot merge data views with different metadata columns");
                    }
                    // The last segment is complete. We mark the source as complete.
                    if (!segment.metadata.segment)
                        delete source.metadata.segment;
                    if (source.table && segment.table)
                        mergeTables(source.table, segment.table);
                    if (source.categorical && segment.categorical)
                        mergeCategorical(source.categorical, segment.categorical);
                    // Tree cannot support subtotals hence we can get into situations
                    // where a node has no children in one segment and more than 1 child
                    // in another segment.
                    if (source.tree && segment.tree)
                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);
                    if (source.matrix && segment.matrix)
                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);
                }
                DataViewMerger.mergeDataViews = mergeDataViews;
                /** Note: Public for testability */
                function mergeTables(source, segment) {
                    debug.assertValue(source, 'source');
                    debug.assertValue(segment, 'segment');
                    if (_.isEmpty(segment.rows))
                        return;
                    var mergeIndex = segment.lastMergeIndex + 1;
                    merge(source.rows, segment.rows, mergeIndex);
                    debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');
                    if (segment.identity)
                        merge(source.identity, segment.identity, mergeIndex);
                }
                DataViewMerger.mergeTables = mergeTables;
                /**
                 * Merge categories values and identities
                 *
                 * Note: Public for testability
                 */
                function mergeCategorical(source, segment) {
                    debug.assertValue(source, 'source');
                    debug.assertValue(segment, 'segment');
                    debug.assert(_.size(source.categories) === _.size(segment.categories), "pre-condition: source categories and segment categories should have the same length");
                    debug.assert(_.all(source.categories, (function (category) { return source.categories[0].identity === category.identity; })), 'pre-condition: the identity property of all category columns are expected to be the same array object');
                    // Merge categories values and identities
                    if (!_.isEmpty(source.categories) && !_.isEmpty(segment.categories)) {
                        var mergeIndex = segment.lastMergeIndex + 1;
                        var segmentCategoriesLength = segment.categories.length;
                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {
                            var segmentCategory = segment.categories[categoryIndex];
                            var sourceCategory = source.categories[categoryIndex];
                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), "Source and segment category have different sources.");
                            debug.assert(sourceCategory.values === undefined ? sourceCategory.identity === undefined : true, 'Source category is missing values but has identities.');
                            if (segmentCategory.values) {
                                merge(sourceCategory.values, segmentCategory.values, mergeIndex);
                            }
                        }
                        // the identity property of all category columns are expected to be the same array object,
                        // hence merge it at most once and only on the first category column
                        if (segment.categories[0].identity) {
                            merge(source.categories[0].identity, segment.categories[0].identity, mergeIndex);
                        }
                    }
                    // Merge values for each value column
                    if (source.values && segment.values) {
                        var segmentValuesLength = segment.values.length;
                        debug.assert(source.values.length === segmentValuesLength, "Source and segment values have different lengths.");
                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {
                            var segmentValue = segment.values[valueIndex];
                            var sourceValue = source.values[valueIndex];
                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), "Source and segment value have different sources.");
                            if (!sourceValue.values && segmentValue.values) {
                                sourceValue.values = [];
                            }
                            var mergeIndex = segment.lastMergeIndex + 1;
                            if (segmentValue.values) {
                                merge(sourceValue.values, segmentValue.values, mergeIndex);
                            }
                            if (segmentValue.highlights) {
                                merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);
                            }
                        }
                    }
                }
                DataViewMerger.mergeCategorical = mergeCategorical;
                /**
                 * Merges the segment array starting at the specified index into the source array
                 * and returns the segment slice that wasn't merged.
                 * The segment array is spliced up to specified index in the process.
                 */
                function merge(source, segment, index) {
                    if (index >= segment.length)
                        return segment;
                    var result = [];
                    if (index !== undefined)
                        result = segment.splice(0, index);
                    Array.prototype.push.apply(source, segment);
                    return result;
                }
                /** Note: Public for testability */
                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {
                    debug.assertValue(sourceRoot, 'sourceRoot');
                    debug.assertValue(segmentRoot, 'segmentRoot');
                    if (!segmentRoot.children || segmentRoot.children.length === 0)
                        return;
                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {
                        sourceRoot.children = segmentRoot.children;
                        return;
                    }
                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, "Source tree has different structure than segment.");
                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);
                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];
                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);
                    if (mergedChildren.length > 0)
                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);
                }
                DataViewMerger.mergeTreeNodes = mergeTreeNodes;
                function findFirstAppendIndex(children) {
                    if (children.length === 0)
                        return 0;
                    var i = 0;
                    for (; i < children.length; i++) {
                        var childSegment = children[i];
                        if (!childSegment.isMerge)
                            break;
                    }
                    return i;
                }
            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));
        })(segmentation = data.segmentation || (data.segmentation = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /** Rewrites an expression tree, including all descendant nodes. */
        var SQExprRewriter = /** @class */ (function () {
            function SQExprRewriter() {
            }
            SQExprRewriter.prototype.visitColumnRef = function (expr) {
                var origArg = expr.source, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);
            };
            SQExprRewriter.prototype.visitMeasureRef = function (expr) {
                var origArg = expr.source, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);
            };
            SQExprRewriter.prototype.visitAggr = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQAggregationExpr(rewrittenArg, expr.func);
            };
            SQExprRewriter.prototype.visitSelectRef = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitPercentile = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);
            };
            SQExprRewriter.prototype.visitGroupRef = function (expr) {
                var origSource = expr.source, rewrittenSource = expr.source.accept(this), origGroupedColumns = expr.groupedExprs;
                var rewrittenGroupedColumns = new Array(origGroupedColumns.length);
                for (var i = 0; i < origGroupedColumns.length; i++)
                    rewrittenGroupedColumns[i] = origGroupedColumns[i].accept(this);
                if (origSource === rewrittenSource && data.SQExprUtils.sequenceEqual(origGroupedColumns, rewrittenGroupedColumns))
                    return expr;
                return new data.SQGroupRefExpr(expr.ref, rewrittenSource, rewrittenGroupedColumns);
            };
            SQExprRewriter.prototype.visitHierarchy = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);
            };
            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);
            };
            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);
            };
            SQExprRewriter.prototype.visitEntity = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitSubqueryRef = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitNamedQueryRef = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitAnd = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitBetween = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);
                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)
                    return orig;
                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);
            };
            SQExprRewriter.prototype.visitIn = function (orig) {
                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues, origTable = orig.table, rewrittenTable = origTable;
                if (origValues) {
                    debug.assert(!origTable, "values and table cannot be both specified for the In operator");
                    for (var i = 0, len = origValues.length; i < len; i++) {
                        var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);
                        if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)
                            rewrittenValues = ArrayExtensions.take(origValues, i);
                        if (rewrittenValues)
                            rewrittenValues.push(rewrittenValueTuple);
                    }
                }
                if (origTable) {
                    debug.assert(!origValues, "values and table cannot be both specified for the In operator");
                    rewrittenTable = origTable.accept(this);
                }
                if (origArgs === rewrittenArgs && !rewrittenValues && origTable === rewrittenTable)
                    return orig;
                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues, rewrittenTable);
            };
            SQExprRewriter.prototype.rewriteAll = function (origExprs) {
                var _this = this;
                debug.assertValue(origExprs, 'origExprs');
                return ArrayExtensions.rewriteArray(origExprs, (function (expr) { return expr.accept(_this); }));
            };
            SQExprRewriter.prototype.visitOr = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitCompare = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitConditional = function (orig) {
                debug.assertNonEmpty(orig.cases, 'orig.cases');
                var origDefaultValue = orig.defaultValue;
                var rewrittenDefaultValue = origDefaultValue && origDefaultValue.accept(this);
                var origCases = orig.cases;
                var rewrittenCases;
                for (var i = 0, len = origCases.length; i < len; i++) {
                    var origCase = origCases[i], rewrittenCase = this.visitCase(origCase);
                    if (origCase !== rewrittenCase && !rewrittenCases)
                        rewrittenCases = ArrayExtensions.take(origCases, i);
                    if (rewrittenCases)
                        rewrittenCases.push(rewrittenCase);
                }
                if (!rewrittenCases)
                    rewrittenCases = origCases;
                if (rewrittenDefaultValue === origDefaultValue && rewrittenCases === origCases)
                    return orig;
                return new data.SQConditionalExpr(rewrittenCases, rewrittenDefaultValue);
            };
            SQExprRewriter.prototype.visitCase = function (orig) {
                var origCondition = orig.condition;
                var rewrittenCondition = origCondition.accept(this);
                var origValue = orig.value;
                var rewrittenValue = origValue.accept(this);
                if (origCondition === rewrittenCondition && origValue === rewrittenValue)
                    return orig;
                return {
                    condition: rewrittenCondition,
                    value: rewrittenValue,
                };
            };
            SQExprRewriter.prototype.visitContains = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitExists = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQExistsExpr(rewrittenArg);
            };
            SQExprRewriter.prototype.visitNot = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQNotExpr(rewrittenArg);
            };
            SQExprRewriter.prototype.visitStartsWith = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitConstant = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitFloor = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQFloorExpr(rewrittenArg, orig.size, orig.timeUnit);
            };
            SQExprRewriter.prototype.visitDateSpan = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);
            };
            SQExprRewriter.prototype.visitDateAdd = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);
            };
            SQExprRewriter.prototype.visitNow = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitDefaultValue = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitAnyValue = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitArithmetic = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);
            };
            SQExprRewriter.prototype.visitScopedEval = function (orig) {
                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);
                if (origExpression === rewrittenExpression && origScope === rewrittenScope)
                    return orig;
                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);
            };
            SQExprRewriter.prototype.visitFilteredEval = function (orig) {
                var origExpression = orig.expression;
                var rewrittenExpression = origExpression.accept(this);
                var areFiltersRewritten = false;
                var rewrittenFilters = [];
                for (var _i = 0, _a = orig.filters; _i < _a.length; _i++) {
                    var origFilter = _a[_i];
                    var target = origFilter.target;
                    var rewrittenTarget = void 0;
                    if (!_.isEmpty(target))
                        rewrittenTarget = this.rewriteAll(target);
                    var condition = origFilter.condition;
                    var rewrittenCondition = origFilter.condition.accept(this);
                    if (target !== rewrittenTarget || condition !== rewrittenCondition)
                        areFiltersRewritten = true;
                    rewrittenFilters.push({
                        target: rewrittenTarget,
                        condition: rewrittenCondition
                    });
                }
                if (origExpression === rewrittenExpression && !areFiltersRewritten)
                    return orig;
                return new data.SQFilteredEvalExpr(rewrittenExpression, rewrittenFilters);
            };
            SQExprRewriter.prototype.visitWithRef = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitTransformTableRef = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitTransformOutputRoleRef = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitRoleRef = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitFillRule = function (orig) {
                var origInput = orig.input, rewrittenInput = origInput.accept(this);
                var origRule = orig.rule;
                var origGradient2 = origRule.linearGradient2;
                var rewrittenGradient2 = origGradient2;
                if (origGradient2)
                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);
                var origGradient3 = origRule.linearGradient3;
                var rewrittenGradient3 = origGradient3;
                if (origGradient3)
                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);
                if (origInput !== rewrittenInput ||
                    origGradient2 !== rewrittenGradient2 ||
                    origGradient3 !== rewrittenGradient3) {
                    var rewrittenRule = {};
                    if (rewrittenGradient2)
                        rewrittenRule.linearGradient2 = rewrittenGradient2;
                    if (rewrittenGradient3)
                        rewrittenRule.linearGradient3 = rewrittenGradient3;
                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);
                }
                return orig;
            };
            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient) {
                debug.assertValue(origGradient, 'origGradient');
                var origMin = origGradient.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient.max, rewrittenMax = this.visitFillRuleStop(origMax), origNullStrategy = origGradient.nullColoringStrategy, rewrittenNullStrategy = this.visitFillNullStrategy(origNullStrategy);
                if (origMin !== rewrittenMin
                    || origMax !== rewrittenMax
                    || origNullStrategy !== rewrittenNullStrategy) {
                    var output = {
                        min: rewrittenMin,
                        max: rewrittenMax,
                    };
                    if (rewrittenNullStrategy)
                        output.nullColoringStrategy = rewrittenNullStrategy;
                    return output;
                }
                return origGradient;
            };
            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient) {
                debug.assertValue(origGradient, 'origGradient');
                var origMin = origGradient.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient.max, rewrittenMax = this.visitFillRuleStop(origMax), origNullStrategy = origGradient.nullColoringStrategy, rewrittenNullStrategy = this.visitFillNullStrategy(origNullStrategy);
                if (origMin !== rewrittenMin
                    || origMid !== rewrittenMid
                    || origMax !== rewrittenMax
                    || origNullStrategy !== rewrittenNullStrategy) {
                    var output = {
                        min: rewrittenMin,
                        mid: rewrittenMid,
                        max: rewrittenMax,
                    };
                    if (rewrittenNullStrategy)
                        output.nullColoringStrategy = rewrittenNullStrategy;
                    return output;
                }
                return origGradient;
            };
            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {
                debug.assertValue(stop, 'stop');
                var origColor = stop.color, rewrittenColor = stop.color.accept(this);
                var origValue = stop.value, rewrittenValue = origValue;
                if (origValue)
                    rewrittenValue = origValue.accept(this);
                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {
                    var rewrittenStop = {
                        color: rewrittenColor
                    };
                    if (rewrittenValue)
                        rewrittenStop.value = rewrittenValue;
                    return rewrittenStop;
                }
                return stop;
            };
            SQExprRewriter.prototype.visitFillNullStrategy = function (input) {
                if (!input)
                    return;
                var origStrategy = input.strategy, rewrittenStrategy = origStrategy.accept(this);
                var origColor = input.color, rewrittenColor = origColor;
                if (origColor)
                    rewrittenColor = origColor.accept(this);
                if (origStrategy !== rewrittenStrategy || origColor !== rewrittenColor) {
                    var output = {
                        strategy: rewrittenStrategy
                    };
                    if (rewrittenColor)
                        output.color = rewrittenColor;
                    return output;
                }
                return input;
            };
            SQExprRewriter.prototype.visitThemeColor = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitDiscretize = function (orig) {
                var rewritten = orig.source.accept(this);
                if (rewritten === orig.source)
                    return orig;
                return new data.SQDiscretizeExpr(rewritten, orig.count);
            };
            SQExprRewriter.prototype.visitMember = function (orig) {
                var rewritten = orig.source.accept(this);
                if (rewritten === orig.source)
                    return orig;
                return new data.SQMemberExpr(rewritten, orig.member);
            };
            return SQExprRewriter;
        }());
        data.SQExprRewriter = SQExprRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Responsible for writing equality comparisons against a field to an SQInExpr. */
        var EqualsToInRewriter;
        (function (EqualsToInRewriter) {
            function run(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(new Rewriter());
            }
            EqualsToInRewriter.run = run;
            var Rewriter = /** @class */ (function (_super) {
                __extends(Rewriter, _super);
                function Rewriter() {
                    return _super.call(this) || this;
                }
                Rewriter.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== 0 /* Equal */)
                        return this.visitUnsupported(expr);
                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))
                        return this.visitUnsupported(expr);
                    var leftIsComparand = this.isComparand(expr.left);
                    var rightIsComparand = this.isComparand(expr.right);
                    if (leftIsComparand === rightIsComparand)
                        return this.visitUnsupported(expr);
                    var operand = leftIsComparand
                        ? expr.left
                        : expr.right;
                    var value = leftIsComparand
                        ? expr.right
                        : expr.left;
                    var current = this.current;
                    if (!current) {
                        return data.SQExprBuilder.inValues([operand], [[value]]);
                    }
                    current.add(operand, value);
                    return expr;
                };
                Rewriter.prototype.visitOr = function (expr) {
                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))
                        return this.visitUnsupported(expr);
                    var current;
                    if (!this.current) {
                        current = this.current = new InBuilder();
                    }
                    expr.left.accept(this);
                    expr.right.accept(this);
                    if (current) {
                        this.current = null;
                        return current.complete() || expr;
                    }
                    return expr;
                };
                Rewriter.prototype.visitAnd = function (expr) {
                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))
                        return this.visitUnsupported(expr);
                    var current = this.current;
                    if (current) {
                        // NOTE: Composite keys are not supported by this algorithm.
                        current.cancel();
                        return expr;
                    }
                    return _super.prototype.visitAnd.call(this, expr);
                };
                Rewriter.prototype.visitUnsupported = function (expr) {
                    var current = this.current;
                    if (current)
                        current.cancel();
                    return expr;
                };
                Rewriter.prototype.isSupported = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return expr instanceof data.SQCompareExpr
                        || expr instanceof data.SQColumnRefExpr
                        || expr instanceof data.SQConstantExpr
                        || expr instanceof data.SQHierarchyLevelExpr
                        || expr instanceof data.SQOrExpr
                        || expr instanceof data.SQAndExpr;
                };
                Rewriter.prototype.isComparand = function (expr) {
                    return expr instanceof data.SQColumnRefExpr
                        || expr instanceof data.SQHierarchyLevelExpr;
                };
                return Rewriter;
            }(data.SQExprRewriter));
            var InBuilder = /** @class */ (function () {
                function InBuilder() {
                }
                InBuilder.prototype.add = function (operand, value) {
                    debug.assertValue(operand, 'operand');
                    debug.assertValue(value, 'value');
                    if (this.cancelled)
                        return;
                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {
                        this.cancel();
                        return;
                    }
                    this.operand = operand;
                    var values = this.values;
                    if (!values)
                        values = this.values = [];
                    values.push(value);
                };
                InBuilder.prototype.cancel = function () {
                    this.cancelled = true;
                };
                InBuilder.prototype.complete = function () {
                    if (this.cancelled || !this.operand)
                        return;
                    return data.SQExprBuilder.inValues([this.operand], _.map(this.values, (function (v) { return [v]; })));
                };
                return InBuilder;
            }());
        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var FilterKindDetector;
        (function (FilterKindDetector) {
            function run(expr) {
                debug.assertValue(expr, "expr");
                var detector = new FilterKindDetectionVisitor();
                expr.accept(detector);
                if (detector.sawSubquery)
                    return 3 /* TopN */;
                return detector.filterKind;
            }
            FilterKindDetector.run = run;
            /** Visitor detecting the filter kind based on the filter condition. */
            var FilterKindDetectionVisitor = /** @class */ (function (_super) {
                __extends(FilterKindDetectionVisitor, _super);
                function FilterKindDetectionVisitor() {
                    var _this = _super.call(this) || this;
                    _this.filterKind = 0 /* Column */;
                    _this.sawSubquery = false;
                    return _this;
                }
                FilterKindDetectionVisitor.prototype.visitMeasureRef = function (expr) {
                    this.filterKind = 1 /* Measure */;
                };
                FilterKindDetectionVisitor.prototype.visitExists = function (expr) {
                    this.filterKind = 2 /* Exists */;
                };
                FilterKindDetectionVisitor.prototype.visitAggr = function (expr) {
                    this.filterKind = 1 /* Measure */;
                };
                FilterKindDetectionVisitor.prototype.visitSubqueryRef = function (expr) {
                    this.sawSubquery = true;
                };
                return FilterKindDetectionVisitor;
            }(data.DefaultSQExprVisitorWithTraversal));
        })(FilterKindDetector = data.FilterKindDetector || (data.FilterKindDetector = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExprConverter;
        (function (SQExprConverter) {
            function asScopeIdsContainer(filter, fieldSQExprs) {
                debug.assertValue(filter, 'filter');
                debug.assertValue(fieldSQExprs, 'fieldSQExprs');
                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');
                var filterItems = filter.conditions();
                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');
                var filterItem = filterItems[0];
                if (filterItem) {
                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);
                    if (filterItem.accept(visitor))
                        return visitor.getResult();
                }
            }
            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;
            /** Gets a comparand value from the given DataViewScopeIdentity. */
            function getFirstComparandValue(identity) {
                debug.assertValue(identity, 'identity');
                var comparandExpr = identity.expr.accept(new FindComparandVisitor());
                if (comparandExpr)
                    return comparandExpr.value;
            }
            SQExprConverter.getFirstComparandValue = getFirstComparandValue;
            /** Gets a list of comparand values and expression represents column or hierarchy for each value from the given DataViewScopeIdentity. */
            function getAllComparands(identity) {
                debug.assertValue(identity, 'identity');
                return identity.expr.accept(new FindAllComparandsVisitor());
            }
            SQExprConverter.getAllComparands = getAllComparands;
        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));
        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/
        var FilterScopeIdsCollectorVisitor = /** @class */ (function (_super) {
            __extends(FilterScopeIdsCollectorVisitor, _super);
            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {
                var _this = _super.call(this) || this;
                _this.isRoot = true;
                _this.isNot = false;
                _this.keyExprsCount = null;
                _this.valueExprs = [];
                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to
                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will
                // need to drop it in order to use JsonComparer.
                _this.fieldExprs = [];
                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {
                    var field = fieldSQExprs_1[_i];
                    _this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));
                }
                return _this;
            }
            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {
                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');
                var valueExprs = this.valueExprs, scopeIds = [];
                var valueCount = this.keyExprsCount || 1;
                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {
                    var values = valueExprs.slice(startIndex, endIndex);
                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);
                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))
                        scopeIds.push(scopeId);
                    startIndex += valueCount;
                    endIndex += valueCount;
                }
                return {
                    isNot: this.isNot,
                    scopeIds: scopeIds,
                };
            };
            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {
                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');
                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');
                var compoundSQExpr;
                for (var i = 0, len = fieldExprs.length; i < len; i++) {
                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);
                    if (!compoundSQExpr)
                        compoundSQExpr = equalsExpr;
                    else
                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);
                }
                return data.createDataViewScopeIdentity(compoundSQExpr);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {
                if (this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.isRoot = false;
                return expr.left.accept(this) && expr.right.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {
                if (!this.isRoot)
                    return this.unsupportedSQExpr();
                this.isNot = true;
                return expr.arg.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {
                if (this.isRoot && expr.type.primitiveType === 0 /* Null */)
                    return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {
                if (this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.isRoot = false;
                if (expr.comparison !== 0 /* Equal */)
                    return this.unsupportedSQExpr();
                return expr.left.accept(this) && expr.right.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {
                if (!expr.values)
                    return false;
                this.keyExprsCount = 0;
                var result;
                this.isRoot = false;
                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    result = arg.accept(this);
                    if (!result)
                        return this.unsupportedSQExpr();
                    this.keyExprsCount++;
                }
                if (this.keyExprsCount !== this.fieldExprs.length)
                    return this.unsupportedSQExpr();
                var values = expr.values;
                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {
                    var valueTuple = values_1[_b];
                    var jlen = valueTuple.length;
                    debug.assert(jlen === this.keyExprsCount, "keys count and values count should match");
                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {
                        var value = valueTuple_1[_c];
                        result = value.accept(this);
                        if (!result)
                            return this.unsupportedSQExpr();
                    }
                }
                return result;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {
                if (this.isRoot)
                    return this.unsupportedSQExpr();
                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);
                if (this.keyExprsCount !== null)
                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);
                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {
                if (this.isRoot || this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {
                if (this.isRoot || this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {
                return this.unsupportedSQExpr();
            };
            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {
                return false;
            };
            return FilterScopeIdsCollectorVisitor;
        }(data.DefaultSQExprVisitor));
        var FindComparandVisitor = /** @class */ (function (_super) {
            __extends(FindComparandVisitor, _super);
            function FindComparandVisitor() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            FindComparandVisitor.prototype.visitAnd = function (expr) {
                return expr.left.accept(this) || expr.right.accept(this);
            };
            FindComparandVisitor.prototype.visitCompare = function (expr) {
                if (expr.comparison === 0 /* Equal */) {
                    if (expr.right instanceof data.SQConstantExpr)
                        return expr.right;
                    if (expr.left instanceof data.SQConstantExpr)
                        return expr.left;
                }
            };
            return FindComparandVisitor;
        }(data.DefaultSQExprVisitor));
        var FindAllComparandsVisitor = /** @class */ (function (_super) {
            __extends(FindAllComparandsVisitor, _super);
            function FindAllComparandsVisitor() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            FindAllComparandsVisitor.prototype.visitAnd = function (expr) {
                var comparandsList = [];
                comparandsList = comparandsList.concat(expr.left.accept(this));
                comparandsList = comparandsList.concat(expr.right.accept(this));
                return comparandsList;
            };
            FindAllComparandsVisitor.prototype.visitCompare = function (expr) {
                if (expr.comparison === 0 /* Equal */) {
                    var comparandsList = [];
                    if (expr.right instanceof data.SQConstantExpr)
                        comparandsList.push({ expr: expr.left, value: expr.right.value });
                    else if (expr.left instanceof data.SQConstantExpr)
                        comparandsList.push({ expr: expr.right, value: expr.left.value });
                    return comparandsList;
                }
            };
            return FindAllComparandsVisitor;
        }(data.DefaultSQExprVisitor));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var RelativeDateFilterPattern;
        (function (RelativeDateFilterPattern) {
            function buildSemanticFilter(params) {
                var condition = buildFilterCondition(params);
                return data.SemanticFilter.fromSQExpr(condition);
            }
            RelativeDateFilterPattern.buildSemanticFilter = buildSemanticFilter;
            function buildFilterCondition(params, dayIsCalendarUnit) {
                if (dayIsCalendarUnit === void 0) { dayIsCalendarUnit = false; }
                var field = params.field;
                var options = params.options;
                var condition = null;
                var now = data.SQExprBuilder.now();
                var timeUnit = toSemantiQueryTimeUnit(options.relativeUnit);
                var calendarPeriod = isCalendarPeriod(options.relativeUnit, dayIsCalendarUnit);
                switch (options.relativeQualifier) {
                    case data.RelativeDateQualifier.Current:
                        var current = data.SQExprBuilder.dateSpan(timeUnit, now);
                        condition = data.SQExprBuilder.compare(0 /* Equal */, field, current);
                        break;
                    case data.RelativeDateQualifier.Last:
                        if (calendarPeriod) {
                            condition = getCalendarPeriodSQExpr(-options.duration, -1, timeUnit, field);
                        }
                        else {
                            //If today is included, the upper bound will be today i.e Now. If not, then we filter up to yesterday. 
                            var upperBound = options.includeToday ? now : data.SQExprBuilder.dateAdd(0 /* Day */, -1, now);
                            var upper = data.SQExprBuilder.dateSpan(0 /* Day */, upperBound);
                            // DateAdd will take you back by 24 hours for every day you subtract. Assume today is Thursday and you want last 1 week starting NOW. DateAdd -1 week will take
                            // you back 24 * 7 i.e last Thursday now. We want to include the whole day as the minimum span and not the hours. Hence we do a dateSpan of day on lower and upper
                            // bounds. And for that you need filter from last Friday not Thursday. Hence for the lowerbound, we use the upperBound + 1 and then reduce the time unit.
                            var lower = data.SQExprBuilder.dateSpan(0 /* Day */, data.SQExprBuilder.dateAdd(timeUnit, -options.duration, data.SQExprBuilder.dateAdd(0 /* Day */, 1, upperBound)));
                            condition = data.SQExprBuilder.between(field, lower, upper);
                        }
                        break;
                    case data.RelativeDateQualifier.Next:
                        if (calendarPeriod) {
                            condition = getCalendarPeriodSQExpr(1, options.duration, timeUnit, field);
                        }
                        else {
                            //If today is included, the lower bound will be today i.e Now. If not, then we filter up to yesterday. 
                            var lowerBound = options.includeToday ? now : data.SQExprBuilder.dateAdd(0 /* Day */, 1, now);
                            var lower = data.SQExprBuilder.dateSpan(0 /* Day */, lowerBound);
                            // DateAdd will take you forward by 24 hours for every day you add. Assume today is Thursday and you want next 1 week starting NOW. DateAdd 1 week will take
                            // you ahead 24 * 7 i.e next Thursday now. We want to include the whole day as the minimum span and not the hours. Hence we do a dateSpan of day on lower and upper
                            // bounds. And for that you need filter upto next Wednesday for 1 week. Hence for the upperbound, we use the lowerbound - 1 and then add the time unit.
                            var upper = data.SQExprBuilder.dateSpan(0 /* Day */, data.SQExprBuilder.dateAdd(timeUnit, options.duration, data.SQExprBuilder.dateAdd(0 /* Day */, -1, lowerBound)));
                            condition = data.SQExprBuilder.between(field, lower, upper);
                        }
                        break;
                    default:
                        break;
                }
                return condition;
            }
            RelativeDateFilterPattern.buildFilterCondition = buildFilterCondition;
            function getCalendarPeriodSQExpr(lowerBound, upperBound, timeUnit, field) {
                var now = data.SQExprBuilder.now();
                var lower = data.SQExprBuilder.dateSpan(timeUnit, data.SQExprBuilder.dateAdd(timeUnit, lowerBound, now));
                var upper = data.SQExprBuilder.dateSpan(timeUnit, data.SQExprBuilder.dateAdd(timeUnit, upperBound, now));
                return data.SQExprBuilder.between(field, lower, upper);
            }
            function toSemantiQueryTimeUnit(relativeUnit) {
                switch (relativeUnit) {
                    case data.RelativeDateUnit.CalendarYear:
                    case data.RelativeDateUnit.Year:
                        return 3 /* Year */;
                    case data.RelativeDateUnit.CalendarMonth:
                    case data.RelativeDateUnit.Month:
                        return 2 /* Month */;
                    case data.RelativeDateUnit.CalendarWeek:
                    case data.RelativeDateUnit.Week:
                        return 1 /* Week */;
                    case data.RelativeDateUnit.Day:
                        return 0 /* Day */;
                    default:
                        debug.assertFail("Unsupported RelativeDateUnit");
                        return;
                }
            }
            RelativeDateFilterPattern.toSemantiQueryTimeUnit = toSemantiQueryTimeUnit;
            function isCalendarPeriod(relativeUnit, dayIsCalendarUnit) {
                if (dayIsCalendarUnit === void 0) { dayIsCalendarUnit = false; }
                switch (relativeUnit) {
                    case data.RelativeDateUnit.Year:
                    case data.RelativeDateUnit.Month:
                    case data.RelativeDateUnit.Week:
                        return false;
                    case data.RelativeDateUnit.Day:
                        return dayIsCalendarUnit;
                    case data.RelativeDateUnit.CalendarYear:
                    case data.RelativeDateUnit.CalendarMonth:
                    case data.RelativeDateUnit.CalendarWeek:
                        return true;
                    default:
                        debug.assertFail("Unsupported RelativeDateUnit");
                        return;
                }
            }
            RelativeDateFilterPattern.isCalendarPeriod = isCalendarPeriod;
            function toRelativeDateUnit(timeUnit, isCalendarPeriod) {
                switch (timeUnit) {
                    case 0 /* Day */:
                        return data.RelativeDateUnit.Day;
                    case 1 /* Week */:
                        return isCalendarPeriod ? data.RelativeDateUnit.CalendarWeek : data.RelativeDateUnit.Week;
                    case 2 /* Month */:
                        return isCalendarPeriod ? data.RelativeDateUnit.CalendarMonth : data.RelativeDateUnit.Month;
                    case 3 /* Year */:
                        return isCalendarPeriod ? data.RelativeDateUnit.CalendarYear : data.RelativeDateUnit.Year;
                    default:
                        return;
                }
            }
            RelativeDateFilterPattern.toRelativeDateUnit = toRelativeDateUnit;
            function extractParametersFromSemanticFilter(filter) {
                if (filter) {
                    var conditions = filter.conditions();
                    if (conditions && conditions.length === 1) {
                        return extractParametersFromCondition(conditions[0]);
                    }
                }
                return;
            }
            RelativeDateFilterPattern.extractParametersFromSemanticFilter = extractParametersFromSemanticFilter;
            function extractParametersFromCondition(condition) {
                var visitor = new RelativeDateFilterExtractor();
                if (visitor.tryExtractParametersFrom(condition)) {
                    return { field: visitor.field, options: visitor.options };
                }
                return;
            }
            RelativeDateFilterPattern.extractParametersFromCondition = extractParametersFromCondition;
            var RelativeDateFilterExtractor = /** @class */ (function () {
                function RelativeDateFilterExtractor() {
                }
                RelativeDateFilterExtractor.prototype.tryExtractParametersFrom = function (condition) {
                    return this.tryExtractCurrent(condition) ||
                        this.tryExtractLastOrNext(condition);
                };
                RelativeDateFilterExtractor.prototype.tryExtractCurrent = function (condition) {
                    if (data.SQExpr.isCompare(condition)) {
                        var comparison = condition;
                        if (data.SQExpr.isColumn(comparison.left)) {
                            this.field = comparison.left;
                            if (data.SQExpr.isDateSpan(comparison.right)) {
                                var dateSpan = comparison.right;
                                var unit = toRelativeDateUnit(dateSpan.unit, false);
                                if (unit !== undefined && data.SQExpr.isNow(dateSpan.arg)) {
                                    this.options = {
                                        duration: 1,
                                        includeToday: true,
                                        relativeQualifier: data.RelativeDateQualifier.Current,
                                        relativeUnit: toRelativeDateUnit(dateSpan.unit, false),
                                    };
                                    if (this.validateOptions(condition)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    return false;
                };
                RelativeDateFilterExtractor.prototype.tryExtractLastOrNext = function (condition) {
                    if (data.SQExpr.isBetween(condition)) {
                        var between = condition;
                        if (data.SQExpr.isColumn(between.arg)) {
                            this.field = between.arg;
                            if (data.SQExpr.isDateSpan(between.upper) && data.SQExpr.isDateSpan(between.lower)) {
                                this.options = this.getOptionsFromDateSpan(between.lower, data.RelativeDateQualifier.Last);
                                if (this.validateOptions(condition)) {
                                    return true;
                                }
                                this.options = this.getOptionsFromDateSpan(between.upper, data.RelativeDateQualifier.Next);
                                if (this.validateOptions(condition)) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                RelativeDateFilterExtractor.prototype.getOptionsFromDateSpan = function (expr, relativeQualifier) {
                    if (data.SQExpr.isDateSpan(expr)) {
                        var dateSpan = expr;
                        return this.getOptionsFromDateAdd(dateSpan.arg, dateSpan.unit, relativeQualifier);
                    }
                    return undefined;
                };
                RelativeDateFilterExtractor.prototype.getOptionsFromDateAdd = function (expr, dateSpanTimeUnit, relativeQualifier) {
                    if (data.SQExpr.isDateAdd(expr)) {
                        var dateAdd = expr;
                        var isCalendar = dateSpanTimeUnit === dateAdd.unit && dateSpanTimeUnit !== 0 /* Day */;
                        var includeToday = isCalendar ? true : this.getIncludeToday(dateAdd.arg);
                        switch (relativeQualifier) {
                            case data.RelativeDateQualifier.Last:
                                if (dateAdd.amount < 0) {
                                    return {
                                        duration: -dateAdd.amount,
                                        includeToday: includeToday,
                                        relativeQualifier: relativeQualifier,
                                        relativeUnit: toRelativeDateUnit(dateAdd.unit, isCalendar),
                                    };
                                }
                                break;
                            case data.RelativeDateQualifier.Next:
                                if (dateAdd.amount > 0) {
                                    return {
                                        duration: dateAdd.amount,
                                        includeToday: includeToday,
                                        relativeQualifier: relativeQualifier,
                                        relativeUnit: toRelativeDateUnit(dateAdd.unit, isCalendar),
                                    };
                                }
                                break;
                        }
                    }
                    return undefined;
                };
                RelativeDateFilterExtractor.prototype.getIncludeToday = function (expr) {
                    if (data.SQExpr.isDateAdd(expr)) {
                        var dateAdd = expr;
                        return data.SQExpr.isNow(dateAdd.arg);
                    }
                    return false;
                };
                RelativeDateFilterExtractor.prototype.validateOptions = function (condition) {
                    if (!this.field || !this.options) {
                        return false;
                    }
                    var params = { field: this.field, options: this.options };
                    return data.SQExpr.equals(condition, buildFilterCondition(params)) ||
                        (this.options.relativeUnit === data.RelativeDateUnit.Day && !this.options.includeToday && data.SQExpr.equals(condition, buildFilterCondition(params, true)));
                };
                return RelativeDateFilterExtractor;
            }());
        })(RelativeDateFilterPattern = data.RelativeDateFilterPattern || (data.RelativeDateFilterPattern = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */
        var ScopeIdentityExtractor;
        (function (ScopeIdentityExtractor) {
            function getKeys(expr) {
                var extractor = new ScopeIdKeysAndValuesExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed)
                    return null;
                return ArrayExtensions.emptyToNull(extractor.keys);
            }
            ScopeIdentityExtractor.getKeys = getKeys;
            function getValues(expr) {
                var extractor = new ScopeIdKeysAndValuesExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed)
                    return null;
                return ArrayExtensions.emptyToNull(extractor.values);
            }
            ScopeIdentityExtractor.getValues = getValues;
            function getKeyValuePairs(expr) {
                var extractor = new ScopeIdKeysAndValuesExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed)
                    return null;
                return ArrayExtensions.emptyToNull(extractor.pairs);
            }
            ScopeIdentityExtractor.getKeyValuePairs = getKeyValuePairs;
            function getInExpr(expr) {
                if (data.SQExpr.isIn(expr))
                    return expr;
                var extractor = new ScopeIdKeysAndValuesExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed)
                    return;
                var keys = ArrayExtensions.emptyToNull(extractor.keys);
                var keyValues = ArrayExtensions.emptyToNull(extractor.values);
                if (keys && keyValues)
                    return data.SQExprBuilder.inValues(keys, [keyValues]);
            }
            ScopeIdentityExtractor.getInExpr = getInExpr;
            /**
             * If all of the field exprs in subsetFieldExprs exists in the specified DataViewScopeIdentity expr,
             * then this function will return all of its SQCompareExpr objects, joint by SQAndExpr if necessary.
             *
             * Returns undefined if any one of subsetFieldExprs is missing in the specified DataViewScopeIdentity expr.
             */
            function getSubset(expr, subsetFieldExprs) {
                debug.assertValue(expr, 'expr');
                debug.assertNonEmpty(subsetFieldExprs, 'subsetFieldExprs');
                var extractor = new ScopeIdSubsetExtractorImpl(subsetFieldExprs);
                expr.accept(extractor);
                return extractor.getResult();
            }
            ScopeIdentityExtractor.getSubset = getSubset;
            /**
             * Recognizes expressions of the form:
             * 1) Equals(ColRef, Constant)
             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))
             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..
             */
            var ScopeIdKeysAndValuesExtractorImpl = /** @class */ (function (_super) {
                __extends(ScopeIdKeysAndValuesExtractorImpl, _super);
                function ScopeIdKeysAndValuesExtractorImpl() {
                    var _this = _super !== null && _super.apply(this, arguments) || this;
                    _this.keys = [];
                    _this.values = [];
                    _this.pairs = [];
                    return _this;
                }
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitAnd = function (expr) {
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== 0 /* Equal */) {
                        this.visitDefault(expr);
                        return;
                    }
                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');
                    this.pairs.push(expr);
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitColumnRef = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitGroupRef = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitHierarchyLevel = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitConstant = function (expr) {
                    this.values.push(expr);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitArithmetic = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdKeysAndValuesExtractorImpl.prototype.visitDefault = function (expr) {
                    this.malformed = true;
                };
                return ScopeIdKeysAndValuesExtractorImpl;
            }(data.DefaultSQExprVisitor));
            /** Extracts the SQCompareExpr objects of a given DataViewScopeIdentity's expr by a given set of identity field expressions. */
            var ScopeIdSubsetExtractorImpl = /** @class */ (function (_super) {
                __extends(ScopeIdSubsetExtractorImpl, _super);
                function ScopeIdSubsetExtractorImpl(identityFieldExprs) {
                    var _this = _super.call(this) || this;
                    debug.assertNonEmpty(identityFieldExprs, 'identityFieldExprs');
                    _this.identityFieldExprs = identityFieldExprs;
                    _this.identityComparisonExprs = [];
                    _this.identityComparisonExprCount = 0;
                    return _this;
                }
                ScopeIdSubsetExtractorImpl.prototype.getResult = function () {
                    debug.assert(this.identityComparisonExprCount === _.filter(this.identityComparisonExprs, (function (expr) { return !!expr; })).length, 'invariant: this.identityComparisonExprCount should equal to the number of defined elements in this.identityComparisonExprs array');
                    if (this.malformed ||
                        this.identityComparisonExprCount !== this.identityFieldExprs.length) {
                        return;
                    }
                    var result;
                    for (var _i = 0, _a = this.identityComparisonExprs; _i < _a.length; _i++) {
                        var identityComparisonExpr = _a[_i];
                        result = result ?
                            data.SQExprBuilder.and(result, identityComparisonExpr) :
                            identityComparisonExpr;
                    }
                    return result;
                };
                ScopeIdSubsetExtractorImpl.prototype.visitAnd = function (expr) {
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                ScopeIdSubsetExtractorImpl.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== 0 /* Equal */) {
                        this.visitDefault(expr);
                        return;
                    }
                    var matchingFieldExprIndex = _.findIndex(this.identityFieldExprs, (function (fieldExpr) { return data.SQExpr.equals(expr.left, fieldExpr); }));
                    if (matchingFieldExprIndex >= 0 && !this.identityComparisonExprs[matchingFieldExprIndex]) {
                        this.identityComparisonExprs[matchingFieldExprIndex] = expr;
                        this.identityComparisonExprCount++;
                    }
                };
                ScopeIdSubsetExtractorImpl.prototype.visitDefault = function (expr) {
                    this.malformed = true;
                };
                return ScopeIdSubsetExtractorImpl;
            }(data.DefaultSQExprVisitor));
        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var TopNFilterPattern;
        (function (TopNFilterPattern) {
            function extractParametersFromFilter(filter, from) {
                if (!filter)
                    return;
                if (filter instanceof data.SemanticFilter) {
                    var conditions = filter.conditions();
                    debug.assertValue(conditions, 'conditions');
                    debug.assert(conditions.length === 1, 'should be exactly one filter condition for a TopN filter');
                    return extractParametersFromCondition(filter.from(), conditions[0]);
                }
                else {
                    return extractParametersFromCondition(from, filter.condition);
                }
            }
            TopNFilterPattern.extractParametersFromFilter = extractParametersFromFilter;
            /** Build the semantic filter for the given Top N parameters */
            function buildFilterFromParameters(parameters) {
                var subquery = buildSubquery(parameters);
                var subquerySource = new data.SQFromSubquerySource(subquery);
                var from = new data.SQFrom();
                var addSubquerySourceResult = from.ensureSource(subquerySource, "subquery");
                var condition = data.SQExprBuilder.inTable([parameters.fieldBeingFiltered], data.SQExprBuilder.subqueryRef(addSubquerySourceResult.name));
                return data.SemanticFilter.fromSQFromAndSQExpr(from, condition);
            }
            TopNFilterPattern.buildFilterFromParameters = buildFilterFromParameters;
            function extractParametersFromCondition(from, condition) {
                debug.assertValue(from, 'from');
                debug.assertValue(condition, 'condition');
                var conditionVisitor = new TopNFilterConditionVisitor();
                if (!conditionVisitor.visitCondition(condition))
                    return;
                var sources = from.sources();
                var source = sources && sources[conditionVisitor.subqueryName];
                if (source && data.isSQFromSubquerySource(source)) {
                    var orderBy = source.subquery.orderBy();
                    if (!orderBy || orderBy.length !== 1)
                        return;
                    var sortDefinition = orderBy[0];
                    var orderByExpr = TopNOrderByExtractor.run(sortDefinition);
                    if (!orderByExpr)
                        return;
                    return {
                        fieldBeingFiltered: conditionVisitor.fieldBeingFiltered,
                        isTop: sortDefinition.direction === 2 /* Descending */,
                        itemCount: source.subquery.top(),
                        orderByField: orderByExpr,
                    };
                }
            }
            TopNFilterPattern.extractParametersFromCondition = extractParametersFromCondition;
            function buildSubquery(parameters) {
                var from = new data.SQFrom();
                var fieldBeingFiltered = data.SQExprRewriterWithSourceRenames.rewrite(parameters.fieldBeingFiltered, 
                /*sourceFrom*/ null, from);
                var orderByExpr = data.SQExprRewriterWithSourceRenames.rewrite(parameters.orderByField, 
                /*sourceFrom*/ null, from);
                var direction = parameters.isTop ? 2 /* Descending */ : 1 /* Ascending */;
                var query = data.SemanticQuery.createWith({
                    from: from,
                    orderBy: [{ expr: orderByExpr, direction: direction }],
                    select: [{ name: "field", expr: fieldBeingFiltered }],
                    top: parameters.itemCount
                });
                return query;
            }
        })(TopNFilterPattern = data.TopNFilterPattern || (data.TopNFilterPattern = {}));
        var TopNFilterConditionVisitor = /** @class */ (function (_super) {
            __extends(TopNFilterConditionVisitor, _super);
            function TopNFilterConditionVisitor() {
                var _this = _super.call(this) || this;
                _this.fieldBeingFiltered = null;
                _this.subqueryName = null;
                return _this;
            }
            TopNFilterConditionVisitor.prototype.visitCondition = function (condition) {
                return condition.accept(this, 0 /* Root */);
            };
            TopNFilterConditionVisitor.prototype.visitIn = function (expr, position) {
                if (position !== 0 /* Root */)
                    return false;
                if (!expr.args ||
                    expr.args.length !== 1 ||
                    !expr.args[0].accept(this, 1 /* LeftOfIn */))
                    return false;
                if (!expr.table ||
                    !expr.table.accept(this, 2 /* RightOfIn */))
                    return false;
                return true;
            };
            TopNFilterConditionVisitor.prototype.visitColumnRef = function (expr, position) {
                if (position !== 1 /* LeftOfIn */)
                    return false;
                this.fieldBeingFiltered = expr;
                return true;
            };
            TopNFilterConditionVisitor.prototype.visitHierarchyLevel = function (expr, position) {
                if (position !== 1 /* LeftOfIn */)
                    return false;
                this.fieldBeingFiltered = expr;
                return true;
            };
            TopNFilterConditionVisitor.prototype.visitGroupRef = function (expr, position) {
                if (position !== 1 /* LeftOfIn */)
                    return false;
                this.fieldBeingFiltered = expr;
                return true;
            };
            TopNFilterConditionVisitor.prototype.visitSubqueryRef = function (expr, position) {
                if (position !== 2 /* RightOfIn */)
                    return false;
                this.subqueryName = expr.variable;
                return true;
            };
            return TopNFilterConditionVisitor;
        }(data.DefaultSQExprVisitorWithArg));
        var TopNOrderByExtractor;
        (function (TopNOrderByExtractor) {
            function run(sortDefinition) {
                var visitor = new TopNSubqueryOrderByVisitor();
                if (!visitor.visitOrderBy(sortDefinition.expr))
                    return;
                return visitor.orderByField;
            }
            TopNOrderByExtractor.run = run;
            var TopNSubqueryOrderByVisitor = /** @class */ (function (_super) {
                __extends(TopNSubqueryOrderByVisitor, _super);
                function TopNSubqueryOrderByVisitor() {
                    var _this = _super.call(this) || this;
                    _this.orderByField = null;
                    return _this;
                }
                TopNSubqueryOrderByVisitor.prototype.visitOrderBy = function (orderBy) {
                    return orderBy.accept(this, 0 /* Root */);
                };
                TopNSubqueryOrderByVisitor.prototype.visitAggr = function (expr, position) {
                    if (position !== 0 /* Root */)
                        return false;
                    debug.assertValue(data.SQExprConverter.asFieldPattern(expr), 'expected field pattern');
                    this.orderByField = expr;
                    return true;
                };
                TopNSubqueryOrderByVisitor.prototype.visitMeasureRef = function (expr, position) {
                    if (position !== 0 /* Root */)
                        return false;
                    this.orderByField = expr;
                    return true;
                };
                return TopNSubqueryOrderByVisitor;
            }(data.DefaultSQExprVisitorWithArg));
        })(TopNOrderByExtractor || (TopNOrderByExtractor = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var TopNFilterPruner;
        (function (TopNFilterPruner) {
            /**
             * Remove any TOPN filters that are made unnecessary because the given selector filter is a strict
             * subset of the TOPN filter.
             *
             * Note: It is assumed that the selector resulted from selecting a data point on a visual that had the TOPN
             * filter applied.  So, we're really checking for TOPN filters which filter on a field contained in the
             * selector filter.
             */
            function removeUnnecessaryTopNFilters(filterPossiblyWithTopN, selectorFilter) {
                if (!selectorFilter || !filterPossiblyWithTopN)
                    return filterPossiblyWithTopN;
                var conditions = selectorFilter.conditions();
                if (!conditions || conditions.length !== 1)
                    return filterPossiblyWithTopN;
                var selectorConditionVisitor = new SelectorConditionVisitor();
                if (!selectorConditionVisitor.visitCondition(conditions[0]))
                    return filterPossiblyWithTopN;
                var selectedFields = selectorConditionVisitor.fieldsBeingFiltered, topNFromClause = filterPossiblyWithTopN.from(), topNWhereClause = filterPossiblyWithTopN.where(), prunedWhereClause;
                var _loop_8 = function (i, count) {
                    var potentialTopNFilter = topNWhereClause[i];
                    var parameters = data.TopNFilterPattern.extractParametersFromFilter(potentialTopNFilter, topNFromClause);
                    if (parameters && _.find(selectedFields, (function (field) { return data.SQExpr.equals(parameters.fieldBeingFiltered, field); }))) {
                        if (!prunedWhereClause) {
                            prunedWhereClause = _.take(topNWhereClause, i);
                        }
                    }
                    else if (prunedWhereClause) {
                        prunedWhereClause.push(potentialTopNFilter);
                    }
                };
                for (var i = 0, count = topNWhereClause.length; i < count; i++) {
                    _loop_8(i, count);
                }
                if (!prunedWhereClause)
                    return filterPossiblyWithTopN;
                return data.SemanticFilter.fromSQFromAndSQFilters(topNFromClause, prunedWhereClause);
            }
            TopNFilterPruner.removeUnnecessaryTopNFilters = removeUnnecessaryTopNFilters;
        })(TopNFilterPruner = data.TopNFilterPruner || (data.TopNFilterPruner = {}));
        var SelectorConditionVisitor = /** @class */ (function (_super) {
            __extends(SelectorConditionVisitor, _super);
            function SelectorConditionVisitor() {
                var _this = _super.call(this) || this;
                _this.fieldsBeingFiltered = [];
                return _this;
            }
            SelectorConditionVisitor.prototype.visitCondition = function (condition) {
                return condition.accept(this, 0 /* Root */);
            };
            SelectorConditionVisitor.prototype.visitIn = function (expr, position) {
                if (position !== 0 /* Root */)
                    return false;
                if (!expr.args)
                    return false;
                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    if (!arg.accept(this, 1 /* LeftOfIn */))
                        return false;
                }
                if (!expr.values)
                    return false;
                if (expr.table)
                    return false;
                return true;
            };
            SelectorConditionVisitor.prototype.visitColumnRef = function (expr, position) {
                if (position !== 1 /* LeftOfIn */)
                    return false;
                this.fieldsBeingFiltered.push(expr);
                return true;
            };
            return SelectorConditionVisitor;
        }(data.DefaultSQExprVisitorWithArg));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SubqueryRewriter;
        (function (SubqueryRewriter) {
            /**
             * Make the subqueries within the given SemanticQuery to be lower precedence than the column filters
             * within the same SemanticQuery.
             */
            function makeSubqueriesLowerPrecedenceThanColumnFilters(semanticFilter) {
                var columnFilters = _.filter(semanticFilter.where(), (function (filter) { return data.FilterKindDetector.run(filter.condition) === 0 /* Column */; }));
                if (_.isEmpty(columnFilters))
                    return semanticFilter;
                var origFrom = semanticFilter.from(), rewrittenFrom = EnsureFiltersInSubqueryRewriter.ensureFiltersInSubqueries(origFrom, columnFilters, origFrom);
                if (origFrom === rewrittenFrom)
                    return semanticFilter;
                return data.SemanticFilter.fromSQFromAndSQFilters(rewrittenFrom, semanticFilter.where());
            }
            SubqueryRewriter.makeSubqueriesLowerPrecedenceThanColumnFilters = makeSubqueriesLowerPrecedenceThanColumnFilters;
            /**
             *  Make the subqueries within lowerPrecedenceFilter be lower precedence than *all* the
             *  filter conditions within higherPrecedenceFilter.  The conditions within higherPrecedenceFilter
             *  can be either column filters or other TOPN filters.
             *
             *  Return the modified lowerPrecedenceFilter.
             */
            function makeSubqueriesLowerPrecedenceThanSpecificFilters(lowerPrecedenceFilter, higherPrecedenceFilters) {
                var lowerPrecedenceFrom = lowerPrecedenceFilter.from(), rewrittenLowerPrecedenceFrom = lowerPrecedenceFrom;
                for (var _i = 0, higherPrecedenceFilters_1 = higherPrecedenceFilters; _i < higherPrecedenceFilters_1.length; _i++) {
                    var higherPrecedenceFilter = higherPrecedenceFilters_1[_i];
                    rewrittenLowerPrecedenceFrom = EnsureFiltersInSubqueryRewriter.ensureFiltersInSubqueries(rewrittenLowerPrecedenceFrom, higherPrecedenceFilter.where(), higherPrecedenceFilter.from());
                }
                if (lowerPrecedenceFrom === rewrittenLowerPrecedenceFrom)
                    return lowerPrecedenceFilter;
                return data.SemanticFilter.fromSQFromAndSQFilters(rewrittenLowerPrecedenceFrom, lowerPrecedenceFilter.where());
            }
            SubqueryRewriter.makeSubqueriesLowerPrecedenceThanSpecificFilters = makeSubqueriesLowerPrecedenceThanSpecificFilters;
            /**
             * Rewrite the subqueries in the given filter to take into account that the filter was created in the given
             * visual query.
             *
             * In particular, update the handling of default members in any subqueries in the given filter to match the default
             * member handling of the containing visual.
             *
             * Some background:  You can specify a default member for a dimension in an MD model, such as State = Washington.
             * Normally, this means that whenever you evaluate a measure, it will be evaluated in a filter context with the
             * default member applied.  So, for example, if you evaluate Sum([Sales]), we will return the sum of sales in Washington.
             *
             * The DataShape Engine has some logic to override the default member behavior.  If you group on a dimension which has
             * a default member, the DSE will implicitly remove that default member.  For example, if you have a column chart showing
             * Sales by State, it would be a pretty boring chart if it only showed State = Washington.  Instead of that, the default
             * member is implicitly removed, and the chart shows sales by state for all states.
             *
             * If you then add a TOPN filter to your Sales by State chart, selecting, for example, the top 5 Products by Sales, most
             * likely you would expect to filter to the top 5 Products by Sales in all the states, not just in Washington.  However,
             * the subquery that the TOPN filter uses is defined to be completely independent of the query in which it is contained.
             * So, just because the chart (and therefore the outer query) groups on State and has the default member for State removed
             * doesn't mean that the default member will automatically be removed for the subquery used by the TOPN filter.  Instead,
             * that subquery is evaluated independently, and so it is evaluated with the default member still applied, and so it will
             * pick the top 5 Products by Sales in Washington.
             *
             * In order to get the behavior we want, the client must explicitly indicate in the subquery the behavior we want with
             * regard to default members.  We want to mimic the behavior of the visual the filter is created in.  That behavior removes
             * the default member for all projections.  So, for each projection in that visual's query, we must create a filter in the
             * TOPN's subquery which removes the default member.  (Note that this filter is a no-op if there is actually no default
             * member for the projection.)
             *
             * The filters we create are slightly different from the Any filters the user can create through the UI.  The difference
             * relates to how the Any filter combines with a Default filter.  The flag DefaultValueOverridesAncestors is responsible
             * for this difference.  If you want to know exactly what this flag does, consult with AComan.  But a reasonable way to
             * think about it is that it instructs the DSE to remove the default member on the field in exactly the same way it would
             * do so if the query were grouping on that field.
             */
            function rewriteSubqueriesForContainingQuery(semanticFilter, visualSemanticQuery) {
                var eligibleProjections = _.filter(_.map(visualSemanticQuery.select(), (function (select) { return select.expr; })), (function (expr) { return !data.SQExprUtils.isMeasure(expr); }));
                if (_.isEmpty(eligibleProjections))
                    return semanticFilter;
                var filters = _.map(eligibleProjections, (function (projection) {
                    return {
                        condition: data.SQExprBuilder.equal(projection, data.SQExprBuilder.anyValue(/*defaultValueOverridesAncestors*/ true))
                    };
                }));
                var origFrom = semanticFilter.from(), rewrittenFrom = EnsureFiltersInSubqueryRewriter.ensureFiltersInSubqueries(origFrom, filters, origFrom);
                if (origFrom === rewrittenFrom)
                    return semanticFilter;
                return data.SemanticFilter.fromSQFromAndSQFilters(rewrittenFrom, semanticFilter.where());
            }
            SubqueryRewriter.rewriteSubqueriesForContainingQuery = rewriteSubqueriesForContainingQuery;
        })(SubqueryRewriter = data.SubqueryRewriter || (data.SubqueryRewriter = {}));
        /** Ensures that the given set of filters exist in each subquery in the given From clause */
        var EnsureFiltersInSubqueryRewriter = /** @class */ (function () {
            function EnsureFiltersInSubqueryRewriter(filtersToEnsure, filtersToEnsureFrom) {
                this.filtersToEnsure = filtersToEnsure;
                this.filtersToEnsureFrom = filtersToEnsureFrom;
                this.modifiedSubquery = false;
                debug.assertNonEmpty(filtersToEnsure, 'expected filters to ensure exist in each subquery');
            }
            EnsureFiltersInSubqueryRewriter.ensureFiltersInSubqueries = function (from, filtersToEnsure, filtersToEnsureFrom) {
                var rewriter = new EnsureFiltersInSubqueryRewriter(filtersToEnsure, filtersToEnsureFrom);
                var rewrittenFrom = data.SemanticQueryRewriter.rewriteFrom(from, rewriter);
                debug.assert((rewrittenFrom !== from) === rewriter.modifiedSubquery, 'expected to rewrite the from clause if and only if we modified a subquery');
                return rewrittenFrom;
            };
            EnsureFiltersInSubqueryRewriter.prototype.visitEntity = function (source, key) {
                return source;
            };
            EnsureFiltersInSubqueryRewriter.prototype.visitSubquery = function (currentSubquery, key) {
                // Check if the filters are already there
                var currentWhere = currentSubquery.subquery.where();
                var filtersToAdd = [];
                var _loop_9 = function (filterToEnsure) {
                    if (!_.find(currentWhere, (function (existingFilter) { return data.SQFilter.equals(filterToEnsure, existingFilter); }))) {
                        filtersToAdd.push(filterToEnsure);
                    }
                };
                for (var _i = 0, _a = this.filtersToEnsure; _i < _a.length; _i++) {
                    var filterToEnsure = _a[_i];
                    _loop_9(filterToEnsure);
                }
                if (filtersToAdd.length === 0)
                    return currentSubquery;
                this.modifiedSubquery = true;
                return new data.SQFromSubquerySource(currentSubquery.subquery.addWhere(filtersToAdd, this.filtersToEnsureFrom));
            };
            EnsureFiltersInSubqueryRewriter.prototype.visitExpr = function (source, key) {
                return source;
            };
            return EnsureFiltersInSubqueryRewriter;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var PrimitiveValueEncoding;
        (function (PrimitiveValueEncoding) {
            var SingleQuoteRegex = /'/g;
            function decimal(value) {
                debug.assertValue(value, 'value');
                return value + 'M';
            }
            PrimitiveValueEncoding.decimal = decimal;
            function double(value) {
                debug.assertValue(value, 'value');
                return value + 'D';
            }
            PrimitiveValueEncoding.double = double;
            function integer(value) {
                debug.assertValue(value, 'value');
                return value + 'L';
            }
            PrimitiveValueEncoding.integer = integer;
            function dateTime(value) {
                debug.assertValue(value, 'value');
                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.
                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.
                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.
                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));
                var dateTimeString = date.toISOString();
                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so
                // we will drop it.
                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.
                if (_.endsWith(dateTimeString, 'Z'))
                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);
                return "datetime'" + dateTimeString + "'";
            }
            PrimitiveValueEncoding.dateTime = dateTime;
            function text(value) {
                debug.assertValue(value, 'value');
                return "'" + value.replace(SingleQuoteRegex, "''") + "'";
            }
            PrimitiveValueEncoding.text = text;
            function nullEncoding() {
                return 'null';
            }
            PrimitiveValueEncoding.nullEncoding = nullEncoding;
            function boolean(value) {
                return value ? 'true' : 'false';
            }
            PrimitiveValueEncoding.boolean = boolean;
        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createSQAggregationOperations() {
            return new SQAggregationOperations();
        }
        data.createSQAggregationOperations = createSQAggregationOperations;
        var SQAggregationOperations = /** @class */ (function () {
            function SQAggregationOperations() {
            }
            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                debug.assertAnyValue(targetTypes, 'targetTypes');
                var metadata = getMetadataForUnderlyingType(expr, schema);
                // don't use expr.validate as validate will be using this function and we end up in a recursive loop
                if (!metadata)
                    return [];
                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;
                if (!valueType)
                    return [];
                // Cannot aggregate on model measures
                if (fieldKind === 1 /* Measure */)
                    return [];
                if (valueType.numeric || valueType.integer) {
                    var aggregates_1 = [0 /* Sum */, 1 /* Avg */, 3 /* Min */, 4 /* Max */, 2 /* Count */, 5 /* CountNonNull */, 7 /* StandardDeviation */, 8 /* Variance */];
                    if (capabilities(expr, schema).supportsMedian)
                        aggregates_1.push(6 /* Median */);
                    return aggregates_1;
                }
                var aggregates = [];
                // Min/Max of DateTime|String
                if (((valueType.dateTime) ||
                    (valueType.text && capabilities(expr, schema).supportsStringMinMax)) &&
                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {
                    aggregates.push(3 /* Min */);
                    aggregates.push(4 /* Max */);
                }
                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)
                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)
                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === 2 /* Count */;
                if (!(isPropertyIdentity && !distinctCountAggExists))
                    aggregates.push(2 /* Count */);
                aggregates.push(5 /* CountNonNull */);
                return aggregates;
            };
            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);
                return _.contains(supportedAggregates, aggregate);
            };
            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var aggregate;
                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {
                    aggregate = preferredAggregate;
                }
                else {
                    aggregate = this.defaultAggregate(expr, schema, aggregateNonNumericFields, targetTypes);
                }
                if (aggregate !== undefined)
                    expr = data.SQExprBuilder.aggregate(expr, aggregate);
                return expr;
            };
            SQAggregationOperations.prototype.defaultAggregate = function (expr, schema, forceAggregation, targetTypes) {
                if (forceAggregation === void 0) { forceAggregation = false; }
                debug.assertValue(schema, 'schema');
                var property = expr.getConceptualProperty(schema, /*translateHierarchy*/ true);
                if (!property)
                    return;
                var aggregate;
                if (property && property.kind === 0 /* Column */) {
                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;
                    var type = property.type;
                    if ((type.integer || type.numeric) &&
                        propertyDefaultAggregate !== 1 /* None */) {
                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);
                        if (aggregate === undefined)
                            aggregate = 0 /* Sum */;
                    }
                    else if (forceAggregation &&
                        (type.dateTime ||
                            (type.text && capabilities(expr, schema).supportsStringMinMax)) &&
                        (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(type, targetTypes))) {
                        return 3 /* Min */;
                    }
                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, 
                    // aggregate on CountNonNull.
                    if (aggregate === undefined && forceAggregation) {
                        aggregate = 5 /* CountNonNull */;
                    }
                }
                return aggregate;
            };
            return SQAggregationOperations;
        }());
        function getMetadataForUnderlyingType(expr, schema) {
            // Unwrap the aggregate (if the expr has one), and look at the underlying type.
            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);
            if (!metadata)
                metadata = expr.getMetadata(schema);
            return metadata;
        }
        function capabilities(expr, schema) {
            var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
            var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
            var currentSchema = schema.schema(fieldExprItem.schema);
            return currentSchema.capabilities;
        }
        /** Note: Exported for testability */
        function defaultAggregateToQueryAggregateFunction(aggregate) {
            switch (aggregate) {
                case 6 /* Average */:
                    return 1 /* Avg */;
                case 3 /* Count */:
                    return 5 /* CountNonNull */;
                case 7 /* DistinctCount */:
                    return 2 /* Count */;
                case 5 /* Max */:
                    return 4 /* Max */;
                case 4 /* Min */:
                    return 3 /* Min */;
                case 2 /* Sum */:
                    return 0 /* Sum */;
            }
        }
        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQHierarchyExprUtils;
        (function (SQHierarchyExprUtils) {
            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {
                var hierarchyLevel = getHierarchyLevel(fieldExpr);
                if (hierarchyLevel)
                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.name, hierarchyLevel.level);
            }
            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;
            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {
                var schema = conceptualSchema.schema(schemaName);
                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);
                if (conceptualHierarchy) {
                    return conceptualHierarchy.levels.withName(hierarchyLevel);
                }
            }
            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;
            function getConceptualHierarchy(sqExpr, federatedSchema) {
                if (sqExpr instanceof data.SQHierarchyExpr) {
                    var hierarchy = sqExpr;
                    if (sqExpr.arg instanceof data.SQEntityExpr) {
                        var entityExpr = sqExpr.arg;
                        return federatedSchema
                            .schema(entityExpr.schema)
                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);
                    }
                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {
                        var variationExpr = sqExpr.arg;
                        var sourceEntityExpr = variationExpr.arg;
                        return federatedSchema
                            .schema(sourceEntityExpr.schema)
                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);
                    }
                }
            }
            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;
            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {
                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||
                    SQExprVariationConverter.expand(expr, schema) ||
                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels
                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||
                    expr;
            }
            SQHierarchyExprUtils.expandExpr = expandExpr;
            function isHierarchyOrVariation(schema, expr) {
                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)
                    return true;
                var conceptualProperty = expr.getConceptualProperty(schema);
                if (conceptualProperty) {
                    var column = conceptualProperty.column;
                    if (column && column.variations && column.variations.length > 0)
                        return true;
                }
                return false;
            }
            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;
            // Return column reference expression for hierarchy level expression.
            function getSourceVariationExpr(hierarchyLevelExpr) {
                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);
                if (fieldExprPattern.columnHierarchyLevelVariation) {
                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);
                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);
                }
            }
            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;
            // Return hierarchy expression for hierarchy level expression.
            function getSourceHierarchy(hierarchyLevelExpr) {
                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);
                var hierarchyLevel = fieldExprPattern.hierarchyLevel;
                if (hierarchyLevel) {
                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);
                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);
                }
            }
            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;
            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {
                // Make sure the hierarchy level source is a hierarchy
                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))
                    return;
                // Check if the hierarchy source if a variation
                var hierarchyRef = hierarchyLevelExpr.arg;
                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)
                    return hierarchyRef.arg;
            }
            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;
            /**
            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.
            */
            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {
                // Validate that both items hierarchy levels
                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))
                    return false;
                var firstLevel = firstExpr;
                var secondLevel = secondExpr;
                // Validate that both items belong to the same hierarchy
                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))
                    return false;
                // Determine the order
                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);
                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);
                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;
            }
            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;
            /**
             * Given an ordered set of levels and an ordered subset of those levels, returns the index where
             * expr should be inserted into the subset to maintain the correct order.
             */
            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {
                var insertIndex = 0;
                // Loop through the supplied levels until the insertion would no longer be in the correct order
                while (insertIndex < orderedSubsetOfLevels.length &&
                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {
                    insertIndex++;
                }
                return insertIndex;
            }
            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;
            function getHierarchyLevel(fieldExpr) {
                return fieldExpr.hierarchyLevel ||
                    fieldExpr.hierarchyLevelAggr ||
                    (fieldExpr.columnHierarchyLevelVariation && fieldExpr.columnHierarchyLevelVariation.level);
            }
        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));
        var SQExprHierarchyToHierarchyLevelConverter;
        (function (SQExprHierarchyToHierarchyLevelConverter) {
            function convert(sqExpr, federatedSchema) {
                debug.assertValue(sqExpr, 'sqExpr');
                debug.assertValue(federatedSchema, 'federatedSchema');
                if (sqExpr instanceof data.SQHierarchyExpr) {
                    var hierarchyExpr = sqExpr;
                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);
                    if (conceptualHierarchy)
                        return _.map(conceptualHierarchy.levels, (function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); }));
                }
            }
            SQExprHierarchyToHierarchyLevelConverter.convert = convert;
        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));
        var SQExprHierarchyLevelConverter;
        (function (SQExprHierarchyLevelConverter) {
            function expand(expr, schema) {
                debug.assertValue(expr, 'sqExpr');
                debug.assertValue(schema, 'federatedSchema');
                var exprs = [];
                if (expr instanceof data.SQHierarchyLevelExpr) {
                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                    if (fieldExpr.hierarchyLevel) {
                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                        var hierarchy = schema
                            .schema(fieldExprItem.schema)
                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);
                        if (hierarchy) {
                            var hierarchyLevels = hierarchy.levels;
                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {
                                var hierarchyLevel = hierarchyLevels_2[_i];
                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {
                                    exprs.push(expr);
                                    break;
                                }
                                else
                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));
                            }
                        }
                    }
                }
                if (!_.isEmpty(exprs))
                    return exprs;
            }
            SQExprHierarchyLevelConverter.expand = expand;
        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));
        var SQExprVariationConverter;
        (function (SQExprVariationConverter) {
            function expand(expr, schema) {
                debug.assertValue(expr, 'sqExpr');
                debug.assertValue(schema, 'federatedSchema');
                var exprs;
                var conceptualProperty = expr.getConceptualProperty(schema);
                if (conceptualProperty) {
                    var column = conceptualProperty.column;
                    if (column && column.variations && column.variations.length > 0) {
                        var variations = column.variations;
                        // for SU11, we support only one variation
                        debug.assert(variations.length === 1, "variations.length");
                        var variation = variations[0];
                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                        exprs = [];
                        if (variation.defaultHierarchy) {
                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);
                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {
                                var level = _a[_i];
                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));
                            }
                        }
                    }
                }
                return exprs;
            }
            SQExprVariationConverter.expand = expand;
        })(SQExprVariationConverter || (SQExprVariationConverter = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExprGroupUtils;
        (function (SQExprGroupUtils) {
            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */
            function groupExprs(schema, exprs) {
                var groups = [];
                for (var i = 0, len = exprs.length; i < len; i++) {
                    var expr = exprs[i];
                    debug.assertValue(expr, "Expression not found");
                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {
                        groups.push({ expr: expr, children: null, selectQueryIndex: i });
                    }
                    else {
                        addChildToGroup(schema, groups, expr, i);
                    }
                }
                return groups;
            }
            SQExprGroupUtils.groupExprs = groupExprs;
            function addChildToGroup(schema, groups, expr, selectQueryIndex) {
                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to 
                // a new Group or to the last Group
                var shouldAddExpressionToNewGroup = true;
                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);
                var lastGroup = _.last(groups);
                // The relevant group is always the last added. If it has the same source hierarchy,
                // and is properly ordered within that hierarchy, we will need to add to this group.
                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {
                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);
                    if (expandedExpr instanceof Array) {
                        var allHierarchyLevels = expandedExpr;
                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);
                    }
                }
                if (shouldAddExpressionToNewGroup)
                    // Use the Sourcevariation as the expression for the group.
                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });
                else {
                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');
                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');
                    lastGroup.children.push(expr);
                }
            }
        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var StringExtensions = jsCommon.StringExtensions;
        /** Represents an immutable expression within a SemanticQuery. */
        var SQExpr = /** @class */ (function () {
            function SQExpr(kind) {
                debug.assertValue(kind, 'kind');
                this._kind = kind;
            }
            SQExpr.equals = function (x, y, ignoreCase, ignoreVariables) {
                return SQExprEqualityVisitor.run(x, y, ignoreCase, ignoreVariables);
            };
            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {
                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);
                this.accept(validator);
                return validator.errors;
            };
            SQExpr.prototype.accept = function (visitor, arg) {
                debug.assertFail('abstract method');
                return;
            };
            Object.defineProperty(SQExpr.prototype, "kind", {
                get: function () {
                    return this._kind;
                },
                enumerable: true,
                configurable: true
            });
            SQExpr.isArithmetic = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 23 /* Arithmetic */;
            };
            SQExpr.isFloor = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 34 /* Floor */;
            };
            SQExpr.isColumn = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 2 /* ColumnRef */;
            };
            SQExpr.isConstant = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 17 /* Constant */;
            };
            SQExpr.isConstantNumeric = function (expr) {
                debug.assertValue(expr, 'expr');
                return SQExpr.isConstant(expr) && expr.type.numeric;
            };
            SQExpr.isConstantText = function (expr) {
                debug.assertValue(expr, 'expr');
                return SQExpr.isConstant(expr) && expr.type.text;
            };
            SQExpr.isEntity = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 0 /* Entity */;
            };
            SQExpr.isHierarchy = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 6 /* Hierarchy */;
            };
            SQExpr.isHierarchyLevel = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 7 /* HierarchyLevel */;
            };
            SQExpr.isIn = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 10 /* In */;
            };
            SQExpr.isAggregation = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 4 /* Aggregation */;
            };
            SQExpr.isMinAggregation = function (expr) {
                debug.assertValue(expr, 'expr');
                return SQExpr.isAggregation(expr) && expr.func === 3 /* Min */;
            };
            SQExpr.isMaxAggregation = function (expr) {
                debug.assertValue(expr, 'expr');
                return SQExpr.isAggregation(expr) && expr.func === 4 /* Max */;
            };
            SQExpr.isAvgAggregation = function (expr) {
                debug.assertValue(expr, 'expr');
                return SQExpr.isAggregation(expr) && expr.func === 1 /* Avg */;
            };
            SQExpr.isMedianAggregation = function (expr) {
                debug.assertValue(expr, 'expr');
                return SQExpr.isAggregation(expr) && expr.func === 6 /* Median */;
            };
            SQExpr.isMeasure = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 3 /* MeasureRef */;
            };
            SQExpr.isPercentile = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 28 /* Percentile */;
            };
            SQExpr.isPropertyVariationSource = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 5 /* PropertyVariationSource */;
            };
            SQExpr.isSelectRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 29 /* SelectRef */;
            };
            SQExpr.isScopedEval = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 26 /* ScopedEval */;
            };
            SQExpr.isFilteredEval = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 39 /* FilteredEval */;
            };
            SQExpr.isSubqueryRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 1 /* SubqueryRef */;
            };
            SQExpr.isWithRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 27 /* WithRef */;
            };
            SQExpr.isTransformTableRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 30 /* TransformTableRef */;
            };
            SQExpr.isTransformOutputRoleRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 31 /* TransformOutputRoleRef */;
            };
            SQExpr.isResourcePackageItem = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 25 /* ResourcePackageItem */;
            };
            SQExpr.isCompareRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 13 /* Compare */;
            };
            SQExpr.isGroupRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 33 /* GroupRef */;
            };
            SQExpr.isRoleRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 35 /* RoleRef */;
            };
            SQExpr.isNamedQueryRef = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 37 /* NamedQueryRef */;
            };
            SQExpr.isBetween = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 9 /* Between */;
            };
            SQExpr.isAnd = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 8 /* And */;
            };
            SQExpr.isOr = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 11 /* Or */;
            };
            SQExpr.isCompare = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 13 /* Compare */;
            };
            SQExpr.isConditional = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 40 /* Conditional */;
            };
            SQExpr.isContains = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 12 /* Contains */;
            };
            SQExpr.isDateSpan = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 18 /* DateSpan */;
            };
            SQExpr.isDateAdd = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 19 /* DateAdd */;
            };
            SQExpr.isExists = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 15 /* Exists */;
            };
            SQExpr.isNot = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 16 /* Not */;
            };
            SQExpr.isNow = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 20 /* Now */;
            };
            SQExpr.isDefaultValue = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 22 /* DefaultValue */;
            };
            SQExpr.isAnyValue = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 21 /* AnyValue */;
            };
            SQExpr.isStartsWith = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 14 /* StartsWith */;
            };
            SQExpr.isFillRule = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 24 /* FillRule */;
            };
            SQExpr.isThemeColor = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 32 /* ThemeColor */;
            };
            SQExpr.isDiscretize = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 36 /* Discretize */;
            };
            SQExpr.isMember = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 38 /* Member */;
            };
            SQExpr.prototype.getMetadata = function (federatedSchema) {
                debug.assertValue(federatedSchema, 'federatedSchema');
                var field = data.SQExprConverter.asFieldPattern(this);
                if (!field)
                    return;
                if (field.column || field.columnAggr || field.groupingColumn || field.groupingColumnAggr || field.measure)
                    return this.getMetadataForProperty(field, federatedSchema);
                if (field.hierarchyLevel || field.hierarchyLevelAggr)
                    return this.getMetadataForHierarchyLevel(field, federatedSchema);
                if (field.columnHierarchyLevelVariation)
                    return this.getMetadataForVariation(field, federatedSchema);
                return SQExpr.getMetadataForEntity(field, federatedSchema);
            };
            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/
            SQExpr.prototype.getKeyColumns = function (schema) {
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);
                if (!columnRefExpr)
                    return;
                var keySQExprs = [];
                var keys = this.getPropertyKeys(schema);
                if (keys && keys.length > 0) {
                    for (var i = 0, len = keys.length; i < len; i++) {
                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));
                    }
                }
                else
                    keySQExprs.push(columnRefExpr);
                return keySQExprs;
            };
            /** Returns a value indicating whether the expression would group on keys other than itself.*/
            SQExpr.prototype.hasGroupOnKeys = function (schema) {
                var columnRefExpr = this.getTargetColumnRef(schema);
                if (!columnRefExpr)
                    return;
                var keys = this.getPropertyKeys(schema);
                if (!keys || keys.length < 1)
                    return false;
                if (keys.length > 1)
                    return true;
                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);
                return !SQExpr.equals(keySqExpr, this);
            };
            SQExpr.prototype.getPropertyKeys = function (schema) {
                var property = this.getConceptualProperty(schema, /*translateHierarchy*/ true);
                if (!property)
                    return;
                return property.column ? property.column.keys : undefined;
            };
            /** Return the SQExpr[] of orderBy columns if there are any.*/
            SQExpr.prototype.getOrderByColumns = function (schema) {
                var columnRefExpr = this.getTargetColumnRef(schema);
                if (!columnRefExpr)
                    return;
                var property = columnRefExpr.getConceptualProperty(schema, /*translateHierarchy*/ true);
                var orderBy = property && property.column && property.column.orderBy;
                if (_.isEmpty(orderBy))
                    return [];
                var expressions = new Array(orderBy.length);
                for (var i = 0, len = orderBy.length; i < len; i++)
                    expressions[i] = SQExprBuilder.columnRef(columnRefExpr.source, orderBy[i].name);
                return expressions;
            };
            SQExpr.prototype.getConceptualProperty = function (federatedSchema, translateHierarchy) {
                var field = data.SQExprConverter.asFieldPattern(this);
                if (!field)
                    return;
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var propertyName = data.FieldExprPattern.getPropertyName(field);
                if (propertyName) {
                    return federatedSchema
                        .schema(fieldExprItem.schema)
                        .findProperty(fieldExprItem.entity, propertyName);
                }
                if (translateHierarchy) {
                    var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;
                    if (fieldExprHierachyLevel) {
                        var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                        var hierarchy = federatedSchema
                            .schema(fieldExprEntity.schema)
                            .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);
                        if (hierarchy) {
                            var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);
                            if (hierarchyLevel)
                                return hierarchyLevel.column;
                        }
                    }
                }
            };
            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {
                var property = this.getConceptualProperty(federatedSchema);
                if (property && property.column && !_.isEmpty(property.column.variations)) {
                    var variations = property.column.variations;
                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {
                        var variation = variations_2[_i];
                        if (variation.name === variationName)
                            return variation.navigationProperty.targetEntity.name;
                    }
                }
            };
            SQExpr.prototype.getTargetEntity = function () {
                return TargetEntityFinder.getEntityExpr(this);
            };
            SQExpr.prototype.getTargetColumnRef = function (schema) {
                debug.assertValue(schema, 'schema');
                return SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);
            };
            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var sourceProperty = federatedSchema
                    .schema(fieldExprItem.schema)
                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);
                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {
                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {
                        var variation = _a[_i];
                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {
                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {
                                var level = _c[_b];
                                if (level.name === columnHierarchyLevelVariation.level.level) {
                                    var property = level.column;
                                    return {
                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,
                                        type: property.type,
                                        format: property.format,
                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,
                                        defaultAggregate: property.column ? property.column.defaultAggregate : null
                                    };
                                }
                            }
                        }
                    }
                }
            };
            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var property = this.getConceptualProperty(federatedSchema, /*translateHierarchy*/ true);
                if (!property)
                    return;
                return this.getPropertyMetadata(field, property);
            };
            SQExpr.prototype.getPropertyMetadata = function (field, property) {
                var format = property.format;
                var type = property.type;
                var columnAggregate = field.columnAggr || field.groupingColumnAggr || field.hierarchyLevelAggr;
                if (columnAggregate) {
                    switch (columnAggregate.aggregate) {
                        case 2 /* Count */:
                        case 5 /* CountNonNull */:
                            type = powerbi.ValueType.fromExtendedType(260 /* Integer */);
                            format = undefined;
                            break;
                        case 1 /* Avg */:
                        case 7 /* StandardDeviation */:
                        case 8 /* Variance */:
                            if (type.integer) {
                                type = powerbi.ValueType.fromExtendedType(259 /* Double */);
                                format = powerbi.NumberFormat.getFormatForWholeNumberAverage(format);
                            }
                            break;
                    }
                }
                return {
                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,
                    type: type,
                    format: format,
                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,
                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,
                    defaultAggregate: property.column ? property.column.defaultAggregate : null
                };
            };
            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var property = this.getConceptualProperty(federatedSchema);
                if (!property)
                    return;
                return this.getPropertyMetadata(field, property);
            };
            SQExpr.getMetadataForEntity = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var entity = federatedSchema
                    .schema(fieldExprItem.schema)
                    .entities
                    .withName(fieldExprItem.entity);
                if (!entity)
                    return;
                // We only support count and countnonnull for entity.
                if (field.entityAggr) {
                    switch (field.entityAggr.aggregate) {
                        case 2 /* Count */:
                        case 5 /* CountNonNull */:
                            return {
                                kind: 1 /* Measure */,
                                type: powerbi.ValueType.fromExtendedType(260 /* Integer */),
                                format: undefined,
                                idOnEntityKey: false,
                                aggregate: field.entityAggr.aggregate
                            };
                    }
                }
            };
            return SQExpr;
        }());
        data.SQExpr = SQExpr;
        var SQEntityExpr = /** @class */ (function (_super) {
            __extends(SQEntityExpr, _super);
            function SQEntityExpr(schema, entity, variable) {
                var _this = this;
                debug.assertValue(entity, 'entity');
                _this = _super.call(this, 0 /* Entity */) || this;
                _this.schema = schema;
                _this.entity = entity;
                if (variable)
                    _this.variable = variable;
                return _this;
            }
            SQEntityExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitEntity(this, arg);
            };
            SQEntityExpr.prototype.as = function (variable) {
                return new SQEntityExpr(this.schema, this.entity, variable);
            };
            return SQEntityExpr;
        }(SQExpr));
        data.SQEntityExpr = SQEntityExpr;
        var SQSubqueryRefExpr = /** @class */ (function (_super) {
            __extends(SQSubqueryRefExpr, _super);
            function SQSubqueryRefExpr(variable) {
                var _this = this;
                debug.assertValue(variable, 'variable');
                _this = _super.call(this, 1 /* SubqueryRef */) || this;
                _this.variable = variable;
                return _this;
            }
            SQSubqueryRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitSubqueryRef(this, arg);
            };
            SQSubqueryRefExpr.prototype.as = function (variable) {
                return new SQSubqueryRefExpr(variable);
            };
            return SQSubqueryRefExpr;
        }(SQExpr));
        data.SQSubqueryRefExpr = SQSubqueryRefExpr;
        var SQNamedQueryRefExpr = /** @class */ (function (_super) {
            __extends(SQNamedQueryRefExpr, _super);
            function SQNamedQueryRefExpr(queryName, variable) {
                var _this = this;
                debug.assertValue(queryName, 'source');
                _this = _super.call(this, 37 /* NamedQueryRef */) || this;
                _this.queryName = queryName;
                if (variable)
                    _this.variable = variable;
                return _this;
            }
            SQNamedQueryRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitNamedQueryRef(this, arg);
            };
            SQNamedQueryRefExpr.prototype.as = function (variable) {
                return new SQNamedQueryRefExpr(this.queryName, variable);
            };
            return SQNamedQueryRefExpr;
        }(SQExpr));
        data.SQNamedQueryRefExpr = SQNamedQueryRefExpr;
        var SQArithmeticExpr = /** @class */ (function (_super) {
            __extends(SQArithmeticExpr, _super);
            function SQArithmeticExpr(left, right, operator) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                debug.assertValue(operator, 'operator');
                _this = _super.call(this, 23 /* Arithmetic */) || this;
                _this.left = left;
                _this.right = right;
                _this.operator = operator;
                return _this;
            }
            SQArithmeticExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitArithmetic(this, arg);
            };
            SQArithmeticExpr.prototype.getMetadata = function (federatedSchema) {
                var metadata = this.left.getMetadata(federatedSchema);
                if (metadata && this.operator === 3 /* Divide */) {
                    metadata.format = '#,##0.00%';
                    metadata.type = powerbi.ValueType.fromExtendedType(259 /* Double */);
                }
                return metadata;
            };
            return SQArithmeticExpr;
        }(SQExpr));
        data.SQArithmeticExpr = SQArithmeticExpr;
        var SQFloorExpr = /** @class */ (function (_super) {
            __extends(SQFloorExpr, _super);
            function SQFloorExpr(arg, size, timeUnit) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(size, 'size');
                _this = _super.call(this, 34 /* Floor */) || this;
                _this.arg = arg;
                _this.size = size;
                if (timeUnit != null)
                    _this.timeUnit = timeUnit;
                return _this;
            }
            SQFloorExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitFloor(this, arg);
            };
            return SQFloorExpr;
        }(SQExpr));
        data.SQFloorExpr = SQFloorExpr;
        var SQScopedEvalExpr = /** @class */ (function (_super) {
            __extends(SQScopedEvalExpr, _super);
            function SQScopedEvalExpr(expression, scope) {
                var _this = this;
                debug.assertValue(expression, 'expression');
                debug.assertValue(scope, 'scope');
                _this = _super.call(this, 26 /* ScopedEval */) || this;
                _this.expression = expression;
                _this.scope = scope;
                return _this;
            }
            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitScopedEval(this, arg);
            };
            SQScopedEvalExpr.prototype.getMetadata = function (federatedSchema) {
                return this.expression.getMetadata(federatedSchema);
            };
            return SQScopedEvalExpr;
        }(SQExpr));
        data.SQScopedEvalExpr = SQScopedEvalExpr;
        var SQFilteredEvalExpr = /** @class */ (function (_super) {
            __extends(SQFilteredEvalExpr, _super);
            function SQFilteredEvalExpr(expression, filters) {
                var _this = this;
                debug.assertValue(expression, 'expression');
                debug.assertValue(filters, 'filters');
                _this = _super.call(this, 39 /* FilteredEval */) || this;
                _this.expression = expression;
                _this.filters = filters;
                return _this;
            }
            SQFilteredEvalExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitFilteredEval(this, arg);
            };
            SQFilteredEvalExpr.prototype.getMetadata = function (federatedSchema) {
                return this.expression.getMetadata(federatedSchema);
            };
            return SQFilteredEvalExpr;
        }(SQExpr));
        data.SQFilteredEvalExpr = SQFilteredEvalExpr;
        var SQWithRefExpr = /** @class */ (function (_super) {
            __extends(SQWithRefExpr, _super);
            function SQWithRefExpr(expressionName) {
                var _this = this;
                debug.assertValue(expressionName, 'expressionName');
                _this = _super.call(this, 27 /* WithRef */) || this;
                _this.expressionName = expressionName;
                return _this;
            }
            SQWithRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitWithRef(this, arg);
            };
            return SQWithRefExpr;
        }(SQExpr));
        data.SQWithRefExpr = SQWithRefExpr;
        var SQPropRefExpr = /** @class */ (function (_super) {
            __extends(SQPropRefExpr, _super);
            function SQPropRefExpr(kind, source, ref) {
                var _this = this;
                debug.assertValue(kind, 'kind');
                debug.assertValue(source, 'source');
                debug.assertValue(ref, 'ref');
                _this = _super.call(this, kind) || this;
                _this.source = source;
                _this.ref = ref;
                return _this;
            }
            return SQPropRefExpr;
        }(SQExpr));
        data.SQPropRefExpr = SQPropRefExpr;
        var SQColumnRefExpr = /** @class */ (function (_super) {
            __extends(SQColumnRefExpr, _super);
            function SQColumnRefExpr(source, ref, kind) {
                return _super.call(this, kind || 2 /* ColumnRef */, source, ref) || this;
            }
            SQColumnRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitColumnRef(this, arg);
            };
            return SQColumnRefExpr;
        }(SQPropRefExpr));
        data.SQColumnRefExpr = SQColumnRefExpr;
        var SQMeasureRefExpr = /** @class */ (function (_super) {
            __extends(SQMeasureRefExpr, _super);
            function SQMeasureRefExpr(source, ref) {
                return _super.call(this, 3 /* MeasureRef */, source, ref) || this;
            }
            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitMeasureRef(this, arg);
            };
            return SQMeasureRefExpr;
        }(SQPropRefExpr));
        data.SQMeasureRefExpr = SQMeasureRefExpr;
        var SQAggregationExpr = /** @class */ (function (_super) {
            __extends(SQAggregationExpr, _super);
            function SQAggregationExpr(arg, func) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(func, 'func');
                _this = _super.call(this, 4 /* Aggregation */) || this;
                _this.arg = arg;
                _this.func = func;
                return _this;
            }
            SQAggregationExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitAggr(this, arg);
            };
            return SQAggregationExpr;
        }(SQExpr));
        data.SQAggregationExpr = SQAggregationExpr;
        var SQPercentileExpr = /** @class */ (function (_super) {
            __extends(SQPercentileExpr, _super);
            function SQPercentileExpr(arg, k, exclusive) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(k, 'k');
                debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');
                debug.assertValue(exclusive, 'exclusive');
                _this = _super.call(this, 28 /* Percentile */) || this;
                _this.arg = arg;
                _this.k = k;
                _this.exclusive = exclusive;
                return _this;
            }
            SQPercentileExpr.prototype.getMetadata = function (federatedSchema) {
                debug.assertValue(federatedSchema, 'federatedSchema');
                var argMetadata = this.arg.getMetadata(federatedSchema);
                if (argMetadata) {
                    return {
                        kind: 1 /* Measure */,
                        type: argMetadata.type,
                    };
                }
            };
            SQPercentileExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitPercentile(this, arg);
            };
            return SQPercentileExpr;
        }(SQExpr));
        data.SQPercentileExpr = SQPercentileExpr;
        var SQPropertyVariationSourceExpr = /** @class */ (function (_super) {
            __extends(SQPropertyVariationSourceExpr, _super);
            function SQPropertyVariationSourceExpr(arg, name, property) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(name, 'name');
                debug.assertValue(property, 'property');
                _this = _super.call(this, 5 /* PropertyVariationSource */) || this;
                _this.arg = arg;
                _this.name = name;
                _this.property = property;
                return _this;
            }
            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitPropertyVariationSource(this, arg);
            };
            return SQPropertyVariationSourceExpr;
        }(SQExpr));
        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;
        var SQGroupRefExpr = /** @class */ (function (_super) {
            __extends(SQGroupRefExpr, _super);
            function SQGroupRefExpr(name, source, groupedExprs) {
                var _this = this;
                debug.assertValue(name, 'name');
                debug.assertValue(groupedExprs, 'groupedExprs');
                debug.assert(groupedExprs.length > 0, 'groupedExprs.length > 0');
                _this = _super.call(this, source, name, 33 /* GroupRef */) || this;
                _this.groupedExprs = groupedExprs;
                return _this;
            }
            SQGroupRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitGroupRef(this, arg);
            };
            return SQGroupRefExpr;
        }(SQColumnRefExpr));
        data.SQGroupRefExpr = SQGroupRefExpr;
        var SQHierarchyExpr = /** @class */ (function (_super) {
            __extends(SQHierarchyExpr, _super);
            function SQHierarchyExpr(arg, hierarchy) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(hierarchy, 'hierarchy');
                _this = _super.call(this, 6 /* Hierarchy */) || this;
                _this.arg = arg;
                _this.hierarchy = hierarchy;
                return _this;
            }
            SQHierarchyExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitHierarchy(this, arg);
            };
            return SQHierarchyExpr;
        }(SQExpr));
        data.SQHierarchyExpr = SQHierarchyExpr;
        var SQHierarchyLevelExpr = /** @class */ (function (_super) {
            __extends(SQHierarchyLevelExpr, _super);
            function SQHierarchyLevelExpr(arg, level) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(level, 'level');
                _this = _super.call(this, 7 /* HierarchyLevel */) || this;
                _this.arg = arg;
                _this.level = level;
                return _this;
            }
            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitHierarchyLevel(this, arg);
            };
            return SQHierarchyLevelExpr;
        }(SQExpr));
        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;
        var SQSelectRefExpr = /** @class */ (function (_super) {
            __extends(SQSelectRefExpr, _super);
            function SQSelectRefExpr(expressionName, attributeKind) {
                var _this = this;
                debug.assertValue(expressionName, 'arg');
                _this = _super.call(this, 29 /* SelectRef */) || this;
                _this.expressionName = expressionName;
                _this.attributeKind = attributeKind;
                return _this;
            }
            SQSelectRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitSelectRef(this, arg);
            };
            return SQSelectRefExpr;
        }(SQExpr));
        data.SQSelectRefExpr = SQSelectRefExpr;
        var SQAndExpr = /** @class */ (function (_super) {
            __extends(SQAndExpr, _super);
            function SQAndExpr(left, right) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _this = _super.call(this, 8 /* And */) || this;
                _this.left = left;
                _this.right = right;
                return _this;
            }
            SQAndExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitAnd(this, arg);
            };
            return SQAndExpr;
        }(SQExpr));
        data.SQAndExpr = SQAndExpr;
        var SQBetweenExpr = /** @class */ (function (_super) {
            __extends(SQBetweenExpr, _super);
            function SQBetweenExpr(arg, lower, upper) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                debug.assertValue(lower, 'lower');
                debug.assertValue(upper, 'upper');
                _this = _super.call(this, 9 /* Between */) || this;
                _this.arg = arg;
                _this.lower = lower;
                _this.upper = upper;
                return _this;
            }
            SQBetweenExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitBetween(this, arg);
            };
            return SQBetweenExpr;
        }(SQExpr));
        data.SQBetweenExpr = SQBetweenExpr;
        var SQInExpr = /** @class */ (function (_super) {
            __extends(SQInExpr, _super);
            function SQInExpr(args, values, table) {
                var _this = this;
                debug.assertValue(args, 'args');
                debug.assert((values == null) !== (table == null), 'values or table');
                _this = _super.call(this, 10 /* In */) || this;
                _this.args = args;
                if (values)
                    _this.values = values;
                if (table)
                    _this.table = table;
                return _this;
            }
            SQInExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitIn(this, arg);
            };
            return SQInExpr;
        }(SQExpr));
        data.SQInExpr = SQInExpr;
        var SQOrExpr = /** @class */ (function (_super) {
            __extends(SQOrExpr, _super);
            function SQOrExpr(left, right) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _this = _super.call(this, 11 /* Or */) || this;
                _this.left = left;
                _this.right = right;
                return _this;
            }
            SQOrExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitOr(this, arg);
            };
            return SQOrExpr;
        }(SQExpr));
        data.SQOrExpr = SQOrExpr;
        var SQCompareExpr = /** @class */ (function (_super) {
            __extends(SQCompareExpr, _super);
            function SQCompareExpr(comparison, left, right) {
                var _this = this;
                debug.assertValue(comparison, 'kind');
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _this = _super.call(this, 13 /* Compare */) || this;
                _this.comparison = comparison;
                _this.left = left;
                _this.right = right;
                return _this;
            }
            SQCompareExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitCompare(this, arg);
            };
            return SQCompareExpr;
        }(SQExpr));
        data.SQCompareExpr = SQCompareExpr;
        /**
         * (Client-Only) Represents an Expression with several cases and an optional default case that evaluates to a single PrimitiveValue
         * When evaluating the expression, the cases are evaluated in order, once a match is found, its value is returned
         * If no match is found, the default value is returned, if any
         */
        var SQConditionalExpr = /** @class */ (function (_super) {
            __extends(SQConditionalExpr, _super);
            function SQConditionalExpr(cases, defaultValue) {
                var _this = this;
                debug.assertNonEmpty(cases, 'cases');
                debug.assertAnyValue(defaultValue, 'defaultValue');
                _this = _super.call(this, 40 /* Conditional */) || this;
                _this.cases = cases;
                _this.defaultValue = defaultValue;
                return _this;
            }
            SQConditionalExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitConditional(this, arg);
            };
            return SQConditionalExpr;
        }(SQExpr));
        data.SQConditionalExpr = SQConditionalExpr;
        var SQContainsExpr = /** @class */ (function (_super) {
            __extends(SQContainsExpr, _super);
            function SQContainsExpr(left, right) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _this = _super.call(this, 12 /* Contains */) || this;
                _this.left = left;
                _this.right = right;
                return _this;
            }
            SQContainsExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitContains(this, arg);
            };
            return SQContainsExpr;
        }(SQExpr));
        data.SQContainsExpr = SQContainsExpr;
        var SQStartsWithExpr = /** @class */ (function (_super) {
            __extends(SQStartsWithExpr, _super);
            function SQStartsWithExpr(left, right) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _this = _super.call(this, 14 /* StartsWith */) || this;
                _this.left = left;
                _this.right = right;
                return _this;
            }
            SQStartsWithExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitStartsWith(this, arg);
            };
            return SQStartsWithExpr;
        }(SQExpr));
        data.SQStartsWithExpr = SQStartsWithExpr;
        var SQExistsExpr = /** @class */ (function (_super) {
            __extends(SQExistsExpr, _super);
            function SQExistsExpr(arg) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                _this = _super.call(this, 15 /* Exists */) || this;
                _this.arg = arg;
                return _this;
            }
            SQExistsExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitExists(this, arg);
            };
            return SQExistsExpr;
        }(SQExpr));
        data.SQExistsExpr = SQExistsExpr;
        var SQNotExpr = /** @class */ (function (_super) {
            __extends(SQNotExpr, _super);
            function SQNotExpr(arg) {
                var _this = this;
                debug.assertValue(arg, 'arg');
                _this = _super.call(this, 16 /* Not */) || this;
                _this.arg = arg;
                return _this;
            }
            SQNotExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitNot(this, arg);
            };
            return SQNotExpr;
        }(SQExpr));
        data.SQNotExpr = SQNotExpr;
        var SQConstantExpr = /** @class */ (function (_super) {
            __extends(SQConstantExpr, _super);
            function SQConstantExpr(type, value, valueEncoded) {
                var _this = this;
                debug.assertValue(type, 'type');
                _this = _super.call(this, 17 /* Constant */) || this;
                _this.type = type;
                _this.value = value;
                if (valueEncoded)
                    _this.encoded = valueEncoded;
                return _this;
            }
            Object.defineProperty(SQConstantExpr.prototype, "valueEncoded", {
                /** The string encoded, lossless representation of the value. */
                get: function () {
                    if (this.encoded !== undefined)
                        return this.encoded;
                    else {
                        // TODO: Create encoded value based on type
                        debug.assertFail('not implemented yet');
                    }
                },
                enumerable: true,
                configurable: true
            });
            SQConstantExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitConstant(this, arg);
            };
            SQConstantExpr.prototype.getMetadata = function () {
                return {
                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.
                    // A getType or similiar function in the future would be more appropriate.
                    kind: 1 /* Measure */,
                    type: this.type,
                };
            };
            SQConstantExpr.getNumericValue = function (expr) {
                if (SQExpr.isConstantNumeric(expr) && _.isNumber(expr.value))
                    return expr.value;
                debug.assertFail('SQConstantExpr.getNumericValue - Unexpected SQExpr kind/value');
            };
            SQConstantExpr.getTextValue = function (sqExpr) {
                if (SQExpr.isConstantText(sqExpr) && _.isString(sqExpr.value))
                    return sqExpr.value;
                debug.assertFail('SQConstantExpr.getTextValue - Unexpected SQExpr kind/value');
            };
            return SQConstantExpr;
        }(SQExpr));
        data.SQConstantExpr = SQConstantExpr;
        var SQDateSpanExpr = /** @class */ (function (_super) {
            __extends(SQDateSpanExpr, _super);
            function SQDateSpanExpr(unit, arg) {
                var _this = this;
                debug.assertValue(unit, 'unit');
                debug.assertValue(arg, 'arg');
                _this = _super.call(this, 18 /* DateSpan */) || this;
                _this.unit = unit;
                _this.arg = arg;
                return _this;
            }
            SQDateSpanExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDateSpan(this, arg);
            };
            return SQDateSpanExpr;
        }(SQExpr));
        data.SQDateSpanExpr = SQDateSpanExpr;
        var SQDateAddExpr = /** @class */ (function (_super) {
            __extends(SQDateAddExpr, _super);
            function SQDateAddExpr(unit, amount, arg) {
                var _this = this;
                debug.assertValue(unit, 'unit');
                debug.assertValue(amount, 'amount');
                debug.assertValue(arg, 'arg');
                _this = _super.call(this, 19 /* DateAdd */) || this;
                _this.unit = unit;
                _this.arg = arg;
                _this.amount = amount;
                return _this;
            }
            SQDateAddExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDateAdd(this, arg);
            };
            SQDateAddExpr.prototype.getMetadata = function (federatedSchema) {
                // NOTE: the DateAdd argument should be a temporal type.
                return this.arg.getMetadata(federatedSchema);
            };
            return SQDateAddExpr;
        }(SQExpr));
        data.SQDateAddExpr = SQDateAddExpr;
        var SQNowExpr = /** @class */ (function (_super) {
            __extends(SQNowExpr, _super);
            function SQNowExpr() {
                return _super.call(this, 20 /* Now */) || this;
            }
            SQNowExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitNow(this, arg);
            };
            SQNowExpr.prototype.getMetadata = function () {
                return {
                    // Returning Measure as the kind for a SQNowExpr is slightly ambiguous allowing the return object to conform to SQExprMetadata.
                    // A getType or similiar function in the future would be more appropriate.
                    kind: 1 /* Measure */,
                    type: powerbi.ValueType.fromExtendedType(519 /* DateTime */),
                };
            };
            return SQNowExpr;
        }(SQExpr));
        data.SQNowExpr = SQNowExpr;
        var SQDefaultValueExpr = /** @class */ (function (_super) {
            __extends(SQDefaultValueExpr, _super);
            function SQDefaultValueExpr() {
                return _super.call(this, 22 /* DefaultValue */) || this;
            }
            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDefaultValue(this, arg);
            };
            return SQDefaultValueExpr;
        }(SQExpr));
        data.SQDefaultValueExpr = SQDefaultValueExpr;
        var SQAnyValueExpr = /** @class */ (function (_super) {
            __extends(SQAnyValueExpr, _super);
            function SQAnyValueExpr(defaultValueOverridesAncestors) {
                var _this = this;
                debug.assertAnyValue(defaultValueOverridesAncestors, 'defaultValueOverridesAncestors');
                _this = _super.call(this, 21 /* AnyValue */) || this;
                _this.defaultValueOverridesAncestors = defaultValueOverridesAncestors;
                return _this;
            }
            SQAnyValueExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitAnyValue(this, arg);
            };
            return SQAnyValueExpr;
        }(SQExpr));
        data.SQAnyValueExpr = SQAnyValueExpr;
        var SQFillRuleExpr = /** @class */ (function (_super) {
            __extends(SQFillRuleExpr, _super);
            function SQFillRuleExpr(input, fillRule) {
                var _this = this;
                debug.assertValue(input, 'input');
                debug.assertValue(fillRule, 'fillRule');
                _this = _super.call(this, 24 /* FillRule */) || this;
                _this.input = input;
                _this.rule = fillRule;
                return _this;
            }
            SQFillRuleExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitFillRule(this, arg);
            };
            return SQFillRuleExpr;
        }(SQExpr));
        data.SQFillRuleExpr = SQFillRuleExpr;
        var SQThemeColorExpr = /** @class */ (function (_super) {
            __extends(SQThemeColorExpr, _super);
            function SQThemeColorExpr(color, percent) {
                var _this = this;
                debug.assertValue(color, 'SQThemeColorExpr - color');
                debug.assertValue(percent, 'SQThemeColorExpr - percent');
                debug.assertValue(-1 <= percent && percent <= 1, 'percent');
                _this = _super.call(this, 32 /* ThemeColor */) || this;
                _this.color = color;
                _this.percent = percent;
                return _this;
            }
            SQThemeColorExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitThemeColor(this, arg);
            };
            return SQThemeColorExpr;
        }(SQExpr));
        data.SQThemeColorExpr = SQThemeColorExpr;
        var SQResourcePackageItemExpr = /** @class */ (function (_super) {
            __extends(SQResourcePackageItemExpr, _super);
            function SQResourcePackageItemExpr(packageName, packageType, itemName) {
                var _this = this;
                debug.assertValue(packageName, 'packageName');
                debug.assertValue(itemName, 'itemName');
                _this = _super.call(this, 25 /* ResourcePackageItem */) || this;
                _this.packageName = packageName;
                _this.packageType = packageType;
                _this.itemName = itemName;
                return _this;
            }
            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitResourcePackageItem(this, arg);
            };
            return SQResourcePackageItemExpr;
        }(SQExpr));
        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;
        var SQTransformTableRefExpr = /** @class */ (function (_super) {
            __extends(SQTransformTableRefExpr, _super);
            function SQTransformTableRefExpr(source) {
                var _this = this;
                debug.assertValue(source, 'source');
                _this = _super.call(this, 30 /* TransformTableRef */) || this;
                _this.source = source;
                return _this;
            }
            SQTransformTableRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitTransformTableRef(this, arg);
            };
            return SQTransformTableRefExpr;
        }(SQExpr));
        data.SQTransformTableRefExpr = SQTransformTableRefExpr;
        var SQTransformOutputRoleRefExpr = /** @class */ (function (_super) {
            __extends(SQTransformOutputRoleRefExpr, _super);
            function SQTransformOutputRoleRefExpr(role, transform) {
                var _this = this;
                debug.assertValue(role, 'role');
                _this = _super.call(this, 31 /* TransformOutputRoleRef */) || this;
                _this.role = role;
                if (transform)
                    _this.transform = transform;
                return _this;
            }
            SQTransformOutputRoleRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitTransformOutputRoleRef(this, arg);
            };
            SQTransformOutputRoleRefExpr.prototype.getMetadata = function (federatedSchema) {
                // These are fabricated columns created by the transform algorithms on the service and hence don't have metadata
                return;
            };
            return SQTransformOutputRoleRefExpr;
        }(SQExpr));
        data.SQTransformOutputRoleRefExpr = SQTransformOutputRoleRefExpr;
        var SQRoleRefExpr = /** @class */ (function (_super) {
            __extends(SQRoleRefExpr, _super);
            function SQRoleRefExpr(role) {
                var _this = this;
                debug.assertValue(role, 'role');
                _this = _super.call(this, 35 /* RoleRef */) || this;
                _this.role = role;
                return _this;
            }
            SQRoleRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitRoleRef(this, arg);
            };
            return SQRoleRefExpr;
        }(SQExpr));
        data.SQRoleRefExpr = SQRoleRefExpr;
        var SQDiscretizeExpr = /** @class */ (function (_super) {
            __extends(SQDiscretizeExpr, _super);
            function SQDiscretizeExpr(source, count) {
                var _this = this;
                debug.assertValue(source, 'source');
                _this = _super.call(this, 36 /* Discretize */) || this;
                _this.source = source;
                _this.count = count;
                return _this;
            }
            SQDiscretizeExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDiscretize(this, arg);
            };
            return SQDiscretizeExpr;
        }(SQExpr));
        data.SQDiscretizeExpr = SQDiscretizeExpr;
        var SQMemberExpr = /** @class */ (function (_super) {
            __extends(SQMemberExpr, _super);
            function SQMemberExpr(source, member) {
                var _this = this;
                debug.assertValue(source, 'source');
                debug.assertValue(member, 'member');
                _this = _super.call(this, 38 /* Member */) || this;
                _this.source = source;
                _this.member = member;
                return _this;
            }
            SQMemberExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitMember(this, arg);
            };
            return SQMemberExpr;
        }(SQExpr));
        data.SQMemberExpr = SQMemberExpr;
        /** Provides utilities for creating & manipulating expressions. */
        var SQExprBuilder;
        (function (SQExprBuilder) {
            function entity(schema, entity, variable) {
                return new SQEntityExpr(schema, entity, variable);
            }
            SQExprBuilder.entity = entity;
            function subqueryRef(variable) {
                return new SQSubqueryRefExpr(variable);
            }
            SQExprBuilder.subqueryRef = subqueryRef;
            function namedQueryRef(queryName, variable) {
                return new SQNamedQueryRefExpr(queryName, variable);
            }
            SQExprBuilder.namedQueryRef = namedQueryRef;
            function columnRef(source, prop) {
                return new SQColumnRefExpr(source, prop);
            }
            SQExprBuilder.columnRef = columnRef;
            function measureRef(source, prop) {
                return new SQMeasureRefExpr(source, prop);
            }
            SQExprBuilder.measureRef = measureRef;
            function aggregate(source, aggregate) {
                return new SQAggregationExpr(source, aggregate);
            }
            SQExprBuilder.aggregate = aggregate;
            function selectRef(expressionName, attributeType) {
                return new SQSelectRefExpr(expressionName, attributeType);
            }
            SQExprBuilder.selectRef = selectRef;
            function percentile(source, k, exclusive) {
                return new SQPercentileExpr(source, k, exclusive);
            }
            SQExprBuilder.percentile = percentile;
            function arithmetic(left, right, operator) {
                return new SQArithmeticExpr(left, right, operator);
            }
            SQExprBuilder.arithmetic = arithmetic;
            function floor(arg, size, timeUnit) {
                return new SQFloorExpr(arg, size, timeUnit);
            }
            SQExprBuilder.floor = floor;
            function scopedEval(expression, scope) {
                return new SQScopedEvalExpr(expression, scope);
            }
            SQExprBuilder.scopedEval = scopedEval;
            function filteredEval(expression, filters) {
                return new SQFilteredEvalExpr(expression, filters);
            }
            SQExprBuilder.filteredEval = filteredEval;
            function withRef(expressionName) {
                return new SQWithRefExpr(expressionName);
            }
            SQExprBuilder.withRef = withRef;
            function groupRef(name, source, groupedColumns) {
                return new SQGroupRefExpr(name, source, groupedColumns);
            }
            SQExprBuilder.groupRef = groupRef;
            function hierarchy(source, hierarchy) {
                return new SQHierarchyExpr(source, hierarchy);
            }
            SQExprBuilder.hierarchy = hierarchy;
            function propertyVariationSource(source, name, property) {
                return new SQPropertyVariationSourceExpr(source, name, property);
            }
            SQExprBuilder.propertyVariationSource = propertyVariationSource;
            function hierarchyLevel(source, level) {
                return new SQHierarchyLevelExpr(source, level);
            }
            SQExprBuilder.hierarchyLevel = hierarchyLevel;
            function transformTableRef(source) {
                return new SQTransformTableRefExpr(source);
            }
            SQExprBuilder.transformTableRef = transformTableRef;
            function transformOutputRoleRef(role, transform) {
                return new SQTransformOutputRoleRefExpr(role, transform);
            }
            SQExprBuilder.transformOutputRoleRef = transformOutputRoleRef;
            function roleRef(role) {
                return new SQRoleRefExpr(role);
            }
            SQExprBuilder.roleRef = roleRef;
            function and(left, right) {
                if (!left)
                    return right;
                if (!right)
                    return left;
                return new SQAndExpr(left, right);
            }
            SQExprBuilder.and = and;
            function between(arg, lower, upper) {
                return new SQBetweenExpr(arg, lower, upper);
            }
            SQExprBuilder.between = between;
            function inValues(args, values) {
                return new SQInExpr(args, values, /*table*/ null);
            }
            SQExprBuilder.inValues = inValues;
            function inTable(args, table) {
                return new SQInExpr(args, /*values*/ null, table);
            }
            SQExprBuilder.inTable = inTable;
            function or(left, right) {
                if (!left)
                    return right;
                if (!right)
                    return left;
                if (SQExpr.isIn(left) && SQExpr.isIn(right)) {
                    var inExpr = tryUseInExprs(left, right);
                    if (inExpr)
                        return inExpr;
                }
                return new SQOrExpr(left, right);
            }
            SQExprBuilder.or = or;
            function tryUseInExprs(left, right) {
                if (!left.args || !right.args || !left.values || !right.values)
                    return;
                var leftArgLen = left.args.length;
                var rightArgLen = right.args.length;
                if (leftArgLen !== rightArgLen)
                    return;
                for (var i = 0; i < leftArgLen; ++i) {
                    if (!SQExpr.equals(left.args[i], right.args[i]))
                        return;
                }
                var combinedValues = left.values.concat(right.values);
                return SQExprBuilder.inValues(left.args, combinedValues);
            }
            function compare(kind, left, right) {
                return new SQCompareExpr(kind, left, right);
            }
            SQExprBuilder.compare = compare;
            function conditional(cases, defaultValue) {
                return new SQConditionalExpr(cases, defaultValue);
            }
            SQExprBuilder.conditional = conditional;
            function contains(left, right) {
                return new SQContainsExpr(left, right);
            }
            SQExprBuilder.contains = contains;
            function exists(arg) {
                return new SQExistsExpr(arg);
            }
            SQExprBuilder.exists = exists;
            function equal(left, right) {
                return compare(0 /* Equal */, left, right);
            }
            SQExprBuilder.equal = equal;
            function not(arg) {
                return new SQNotExpr(arg);
            }
            SQExprBuilder.not = not;
            function startsWith(left, right) {
                return new SQStartsWithExpr(left, right);
            }
            SQExprBuilder.startsWith = startsWith;
            /** Given an SQExpr is immutable, create a const instance for null SQExpr for perf */
            var nullConstantInstance = new SQConstantExpr(powerbi.ValueType.fromExtendedType(0 /* Null */), null, data.PrimitiveValueEncoding.nullEncoding());
            function nullConstant() {
                return nullConstantInstance;
            }
            SQExprBuilder.nullConstant = nullConstant;
            function now() {
                return new SQNowExpr();
            }
            SQExprBuilder.now = now;
            function defaultValue() {
                return new SQDefaultValueExpr();
            }
            SQExprBuilder.defaultValue = defaultValue;
            function anyValue(defaultValueOverridesAncestors) {
                return new SQAnyValueExpr(defaultValueOverridesAncestors);
            }
            SQExprBuilder.anyValue = anyValue;
            function boolean(value) {
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(5 /* Boolean */), value, data.PrimitiveValueEncoding.boolean(value));
            }
            SQExprBuilder.boolean = boolean;
            function dateAdd(unit, amount, arg) {
                return new SQDateAddExpr(unit, amount, arg);
            }
            SQExprBuilder.dateAdd = dateAdd;
            function dateTime(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(519 /* DateTime */), value, valueEncoded);
            }
            SQExprBuilder.dateTime = dateTime;
            function dateSpan(unit, arg) {
                return new SQDateSpanExpr(unit, arg);
            }
            SQExprBuilder.dateSpan = dateSpan;
            function decimal(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(258 /* Decimal */), value, valueEncoded);
            }
            SQExprBuilder.decimal = decimal;
            function double(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.double(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(259 /* Double */), value, valueEncoded);
            }
            SQExprBuilder.double = double;
            function integer(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.integer(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(260 /* Integer */), value, valueEncoded);
            }
            SQExprBuilder.integer = integer;
            function text(value, valueEncoded) {
                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(1 /* Text */), value, valueEncoded || data.PrimitiveValueEncoding.text(value));
            }
            SQExprBuilder.text = text;
            /** Returns an SQExpr that evaluates to the constant value. */
            function typedConstant(value, type) {
                if (value == null)
                    return nullConstant();
                if (_.isBoolean(value)) {
                    return boolean(value);
                }
                if (_.isString(value)) {
                    return text(value);
                }
                if (_.isNumber(value)) {
                    if (type.integer && powerbi.Double.isInteger(value))
                        return integer(value);
                    return double(value);
                }
                if (value instanceof Date) {
                    return dateTime(value);
                }
            }
            SQExprBuilder.typedConstant = typedConstant;
            function setAggregate(expr, aggregate) {
                return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);
            }
            SQExprBuilder.setAggregate = setAggregate;
            function removeAggregate(expr) {
                return FieldExprRemoveAggregateRewriter.rewrite(expr);
            }
            SQExprBuilder.removeAggregate = removeAggregate;
            function setPercentOfGrandTotal(expr) {
                return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);
            }
            SQExprBuilder.setPercentOfGrandTotal = setPercentOfGrandTotal;
            function removePercentOfGrandTotal(expr) {
                return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);
            }
            SQExprBuilder.removePercentOfGrandTotal = removePercentOfGrandTotal;
            function setPercentOfRoleTotal(expr, roles) {
                return SQExprSetPercentOfRoleTotalRewriter.rewrite(expr, roles);
            }
            SQExprBuilder.setPercentOfRoleTotal = setPercentOfRoleTotal;
            function removePercentOfRoleTotal(expr) {
                return SQExprRemovePercentOfRoleTotalRewriter.rewrite(expr);
            }
            SQExprBuilder.removePercentOfRoleTotal = removePercentOfRoleTotal;
            function removeEntityVariables(expr) {
                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);
            }
            SQExprBuilder.removeEntityVariables = removeEntityVariables;
            function fillRule(expr, rule) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(rule, 'rule');
                return new SQFillRuleExpr(expr, rule);
            }
            SQExprBuilder.fillRule = fillRule;
            function themeColor(color, percent) {
                debug.assertValue(color, 'themeColor - color');
                debug.assertValue(percent, 'themeColor - percent');
                return new SQThemeColorExpr(color, percent);
            }
            SQExprBuilder.themeColor = themeColor;
            function resourcePackageItem(packageName, packageType, itemName) {
                return new SQResourcePackageItemExpr(packageName, packageType, itemName);
            }
            SQExprBuilder.resourcePackageItem = resourcePackageItem;
            function discretize(source, count) {
                return new SQDiscretizeExpr(source, count);
            }
            SQExprBuilder.discretize = discretize;
            function member(source, member) {
                return new SQMemberExpr(source, member);
            }
            SQExprBuilder.member = member;
        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));
        /** Provides utilities for obtaining information about expressions. */
        var SQExprInfo;
        (function (SQExprInfo) {
            function getAggregate(expr) {
                return SQExprAggregateInfoVisitor.getAggregate(expr);
            }
            SQExprInfo.getAggregate = getAggregate;
        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));
        // ToDo: Split this into a separate file
        var SQExprEqualityVisitor = /** @class */ (function () {
            function SQExprEqualityVisitor(ignoreCase, ignoreVariables) {
                this.ignoreCase = ignoreCase;
                this.ignoreVariables = ignoreVariables;
            }
            SQExprEqualityVisitor.run = function (x, y, ignoreCase, ignoreVariables) {
                // Normalize falsy to null
                x = x || null;
                y = y || null;
                if (x === y)
                    return true;
                if (!x !== !y)
                    return false;
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                if (ignoreVariables) {
                    if (ignoreCase)
                        return x.accept(SQExprEqualityVisitor.ignoreVariablesAndCaseInstance, y);
                    return x.accept(SQExprEqualityVisitor.ignoreVariablesInstance, y);
                }
                if (ignoreCase)
                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);
                return x.accept(SQExprEqualityVisitor.instance, y);
            };
            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {
                if (SQExpr.isColumn(comparand) || SQExpr.isGroupRef(comparand)) {
                    return expr.ref === comparand.ref
                        && this.equals(expr.source, comparand.source);
                }
            };
            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {
                return SQExpr.isMeasure(comparand) &&
                    expr.ref === comparand.ref &&
                    this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {
                return SQExpr.isAggregation(comparand) &&
                    expr.func === comparand.func &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitPercentile = function (expr, comparand) {
                return SQExpr.isPercentile(comparand) &&
                    expr.exclusive === comparand.exclusive &&
                    expr.k === comparand.k &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitGroupRef = function (expr, comparand) {
                var baseColumnEqual = false;
                if (SQExpr.isGroupRef(comparand) || SQExpr.isColumn(comparand)) {
                    baseColumnEqual = expr.ref === comparand.ref
                        && this.equals(expr.source, comparand.source);
                }
                if (SQExpr.isGroupRef(comparand))
                    baseColumnEqual = baseColumnEqual && this.equalsAll(expr.groupedExprs, comparand.groupedExprs);
                return baseColumnEqual;
            };
            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {
                return SQExpr.isHierarchy(comparand) &&
                    expr.hierarchy === comparand.hierarchy &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {
                return SQExpr.isHierarchyLevel(comparand) &&
                    expr.level === comparand.level &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {
                return SQExpr.isPropertyVariationSource(comparand) &&
                    expr.name === comparand.name &&
                    expr.property === comparand.property &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitSelectRef = function (expr, comparand) {
                return SQExpr.isSelectRef(comparand) &&
                    expr.expressionName === comparand.expressionName &&
                    (expr.attributeKind === comparand.attributeKind ||
                        this.isNullOrUndefined(expr.attributeKind) === this.isNullOrUndefined(comparand.attributeKind));
            };
            SQExprEqualityVisitor.prototype.isNullOrUndefined = function (value) {
                if (value === null || value === undefined) {
                    return true;
                }
                return false;
            };
            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {
                return SQExpr.isBetween(comparand) &&
                    this.equals(expr.arg, comparand.arg) &&
                    this.equals(expr.lower, comparand.lower) &&
                    this.equals(expr.upper, comparand.upper);
            };
            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {
                if (!SQExpr.isIn(comparand) || !this.equalsAll(expr.args, comparand.args))
                    return false;
                var typedComparand = comparand, values = expr.values;
                if (values) {
                    var compareValues = typedComparand.values;
                    if (!compareValues)
                        return false;
                    if (values.length !== compareValues.length)
                        return false;
                    for (var i = 0, len = values.length; i < len; i++) {
                        if (!this.equalsAll(values[i], compareValues[i]))
                            return false;
                    }
                }
                else {
                    debug.assert(!!expr.table, 'either values or table must be non-null for an In operator');
                    if (!typedComparand.table)
                        return false;
                    if (!this.equals(expr.table, typedComparand.table))
                        return false;
                }
                return true;
            };
            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {
                return SQExpr.isEntity(comparand) &&
                    expr.schema === comparand.schema &&
                    expr.entity === comparand.entity &&
                    (this.ignoreVariables || this.optionalEqual(expr.variable, comparand.variable));
            };
            SQExprEqualityVisitor.prototype.visitSubqueryRef = function (expr, comparand) {
                return SQExpr.isSubqueryRef(comparand) &&
                    expr.variable === comparand.variable;
            };
            SQExprEqualityVisitor.prototype.visitNamedQueryRef = function (expr, comparand) {
                return SQExpr.isNamedQueryRef(comparand) &&
                    expr.queryName === comparand.queryName &&
                    (this.ignoreVariables || this.optionalEqual(expr.variable, comparand.variable));
            };
            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {
                return SQExpr.isAnd(comparand) &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {
                return SQExpr.isOr(comparand) &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {
                return SQExpr.isCompare(comparand) &&
                    expr.comparison === comparand.comparison &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitConditional = function (expr, comparand) {
                var _this = this;
                return SQExpr.isConditional(comparand) &&
                    ArrayExtensions.sequenceEqual(expr.cases, comparand.cases, (function (x, y) { return _this.visitCase(x, y); })) &&
                    this.equalsNullableObject(expr.defaultValue, comparand.defaultValue, (function (x, y) { return _this.equals(x, y); }));
            };
            SQExprEqualityVisitor.prototype.visitCase = function (case1, case2) {
                return this.equals(case1.condition, case2.condition) &&
                    this.equals(case1.value, case2.value);
            };
            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {
                return SQExpr.isContains(comparand) &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {
                return SQExpr.isDateSpan(comparand) &&
                    expr.unit === comparand.unit &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {
                return SQExpr.isDateAdd(comparand) &&
                    expr.unit === comparand.unit &&
                    expr.amount === comparand.amount &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {
                return SQExpr.isExists(comparand) &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {
                return SQExpr.isNot(comparand) &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {
                return SQExpr.isNow(comparand);
            };
            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {
                return SQExpr.isDefaultValue(comparand);
            };
            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {
                return SQExpr.isAnyValue(comparand);
            };
            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {
                return SQExpr.isResourcePackageItem(comparand) &&
                    expr.packageName === comparand.packageName &&
                    expr.packageType === comparand.packageType &&
                    expr.itemName === comparand.itemName;
            };
            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {
                return SQExpr.isStartsWith(comparand) &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {
                if (SQExpr.isConstant(comparand) && expr.type === comparand.type)
                    return expr.type.text && this.ignoreCase ?
                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :
                        expr.valueEncoded === comparand.valueEncoded;
                return false;
            };
            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {
                var _this = this;
                if (!SQExpr.isFillRule(comparand) || !this.equals(expr.input, comparand.input))
                    return false;
                var left = expr.rule;
                var right = comparand.rule;
                if (left === right)
                    return true;
                return this.equalsNullableObject(left.linearGradient2, right.linearGradient2, (function (x, y) { return _this.visitLinearGradient2(x, y); }))
                    && this.equalsNullableObject(left.linearGradient3, right.linearGradient3, (function (x, y) { return _this.visitLinearGradient3(x, y); }));
            };
            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left, right) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                return this.equalsFillRuleStop(left.min, right.min) &&
                    this.equalsFillRuleStop(left.max, right.max) &&
                    this.equalsNullableObject(left.nullColoringStrategy, right.nullColoringStrategy, (function (x, y) { return _this.equalsNullStrategy(x, y); }));
            };
            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left, right) {
                var _this = this;
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                return this.equalsFillRuleStop(left.min, right.min) &&
                    this.equalsFillRuleStop(left.mid, right.mid) &&
                    this.equalsFillRuleStop(left.max, right.max) &&
                    this.equalsNullableObject(left.nullColoringStrategy, right.nullColoringStrategy, (function (x, y) { return _this.equalsNullStrategy(x, y); }));
            };
            SQExprEqualityVisitor.prototype.visitThemeColor = function (expr, comparand) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(comparand, 'comparand');
                return SQExpr.isThemeColor(comparand) &&
                    expr.color === comparand.color &&
                    expr.percent === comparand.percent;
            };
            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {
                debug.assertValue(stop1, 'stop1');
                debug.assertValue(stop2, 'stop2');
                return this.equals(stop1.color, stop2.color)
                    && this.equalsNullable(stop1.value, stop2.value);
            };
            SQExprEqualityVisitor.prototype.equalsNullStrategy = function (left, right) {
                debug.assertValue(left, 'equalsNullStrategy - left');
                debug.assertValue(right, 'equalsNullStrategy - right');
                return this.equals(left.strategy, right.strategy)
                    && this.equalsNullable(left.color, right.color);
            };
            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {
                return SQExpr.isArithmetic(comparand) &&
                    expr.operator === comparand.operator &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitFloor = function (expr, comparand) {
                return SQExpr.isFloor(comparand) &&
                    expr.timeUnit === comparand.timeUnit &&
                    expr.size === comparand.size &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {
                return SQExpr.isScopedEval(comparand) &&
                    this.equals(expr.expression, comparand.expression) &&
                    this.equalsAll(expr.scope, comparand.scope);
            };
            SQExprEqualityVisitor.prototype.visitFilteredEval = function (expr, comparand) {
                return SQExpr.isFilteredEval(comparand) &&
                    this.equals(expr.expression, comparand.expression) &&
                    expr.filters.length === comparand.filters.length &&
                    _.all(expr.filters, (function (filter, index) { return data.SQFilter.equals(filter, comparand.filters[index]); }));
            };
            SQExprEqualityVisitor.prototype.visitWithRef = function (expr, comparand) {
                return SQExpr.isWithRef(comparand) &&
                    expr.expressionName === comparand.expressionName;
            };
            SQExprEqualityVisitor.prototype.visitTransformTableRef = function (expr, comparand) {
                return SQExpr.isTransformTableRef(comparand) &&
                    expr.source === comparand.source;
            };
            SQExprEqualityVisitor.prototype.visitTransformOutputRoleRef = function (expr, comparand) {
                return SQExpr.isTransformOutputRoleRef(comparand) &&
                    expr.role === comparand.role &&
                    expr.transform === comparand.transform;
            };
            SQExprEqualityVisitor.prototype.visitRoleRef = function (expr, comparand) {
                return SQExpr.isRoleRef(comparand) &&
                    expr.role === comparand.role;
            };
            SQExprEqualityVisitor.prototype.visitDiscretize = function (expr, comparand) {
                return SQExpr.isDiscretize(comparand) &&
                    expr.count === comparand.count &&
                    this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.visitMember = function (expr, comparand) {
                return SQExpr.isMember(comparand) &&
                    expr.member === comparand.member &&
                    this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {
                // Only check equality if both values are specified.
                if (x && y)
                    return x === y;
                return true;
            };
            SQExprEqualityVisitor.prototype.equals = function (x, y) {
                return x.accept(this, y);
            };
            SQExprEqualityVisitor.prototype.equalsNullable = function (left, right) {
                var _this = this;
                return this.equalsNullableObject(left, right, (function (x, y) { return _this.equals(x, y); }));
            };
            /**
             * Checks if 2 objects are equal, or are both undefiend
             */
            SQExprEqualityVisitor.prototype.equalsNullableObject = function (left, right, comparer) {
                if (left == null && right == null)
                    return true;
                if (left != null && right != null)
                    return comparer(left, right);
                return false;
            };
            SQExprEqualityVisitor.prototype.equalsAll = function (left, right) {
                var _this = this;
                return ArrayExtensions.sequenceEqual(left, right, (function (x, y) { return _this.equals(x, y); }));
            };
            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/*ignoreCase*/ false, /*ignoreVariables*/ false);
            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(/*ignoreCase*/ true, /*ignoreVariables*/ false);
            SQExprEqualityVisitor.ignoreVariablesInstance = new SQExprEqualityVisitor(/*ignoreCase*/ false, /*ignoreVariables*/ true);
            SQExprEqualityVisitor.ignoreVariablesAndCaseInstance = new SQExprEqualityVisitor(/*ignoreCase*/ true, /*ignoreVariables*/ true);
            return SQExprEqualityVisitor;
        }());
        /** Rewrites a root-level expression. */
        var SQExprRootRewriter = /** @class */ (function (_super) {
            __extends(SQExprRootRewriter, _super);
            function SQExprRootRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprRootRewriter.prototype.visitDefault = function (expr) {
                return expr;
            };
            return SQExprRootRewriter;
        }(data.DefaultSQExprVisitor));
        var SQExprRootRewriterWithArg = /** @class */ (function (_super) {
            __extends(SQExprRootRewriterWithArg, _super);
            function SQExprRootRewriterWithArg() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprRootRewriterWithArg.prototype.visitDefault = function (expr, arg) {
                return expr;
            };
            return SQExprRootRewriterWithArg;
        }(data.DefaultSQExprVisitorWithArg));
        var SQExprValidationVisitor = /** @class */ (function (_super) {
            __extends(SQExprValidationVisitor, _super);
            function SQExprValidationVisitor(schema, aggrUtils, errors) {
                var _this = this;
                debug.assertValue(schema, 'schema');
                debug.assertValue(aggrUtils, 'aggrUtils');
                _this = _super.call(this) || this;
                _this.schema = schema;
                _this.aggrUtils = aggrUtils;
                if (errors)
                    _this.errors = errors;
                return _this;
            }
            SQExprValidationVisitor.prototype.visitIn = function (expr) {
                var inExpr = _super.prototype.visitIn.call(this, expr);
                var args = inExpr.args;
                var values = inExpr.values;
                if (values) {
                    debug.assert(!inExpr.table, "values and table cannot both be specified for the In operator");
                    for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
                        var valueTuple = values_2[_i];
                        debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');
                        for (var i = 0, len = valueTuple.length; i < len; ++i)
                            this.validateCompatibleType(args[i], valueTuple[i]);
                    }
                }
                else {
                    var table = inExpr.table;
                    debug.assert(!!table, 'either values or table must be non-null for an In operator');
                    this.validateIsTableRef(table);
                }
                return inExpr;
            };
            SQExprValidationVisitor.prototype.visitCompare = function (expr) {
                var compareExpr = _super.prototype.visitCompare.call(this, expr);
                this.validateCompatibleType(compareExpr.left, compareExpr.right);
                return compareExpr;
            };
            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    this.validateColumnExpr(fieldExpr);
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);
                    if (entity) {
                        var prop = entity.properties.withName(fieldExpr.measure.name);
                        if (!prop ||
                            prop.kind !== 1 /* Measure */ ||
                            !this.isQueryable(fieldExpr))
                            this.register(5 /* invalidMeasureReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitAggr = function (expr) {
                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);
                if (columnRefExpr) {
                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))
                        this.register(0 /* invalidAggregateFunction */);
                }
                return aggregateExpr;
            };
            SQExprValidationVisitor.prototype.visitGroupRef = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);
                    if (entity) {
                        var prop = entity.properties.withName(fieldExpr.groupingColumn.name);
                        if (!prop ||
                            prop.kind !== 0 /* Column */ ||
                            !this.validateExprSequence(expr.groupedExprs) ||
                            !prop.column.groupingMetadata ||
                            !this.isQueryable(fieldExpr))
                            this.register(4 /* invalidGroupingColumnReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var fieldExprItem = fieldExpr.hierarchy;
                    if (fieldExprItem) {
                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);
                    }
                    else {
                        this.register(6 /* invalidHierarchyReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;
                    var hierarchyLevelVariationFieldExprItem = fieldExpr.columnHierarchyLevelVariation;
                    if (hierarchyLevelFieldExprItem) {
                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);
                    }
                    else if (hierarchyLevelVariationFieldExprItem) {
                        this.validateHierarchyLevelVariation(hierarchyLevelVariationFieldExprItem);
                    }
                    else {
                        this.register(7 /* invalidHierarchyLevelReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitPercentile = function (expr) {
                expr.arg.accept(this);
                if (_.isEmpty(this.errors)) {
                    var argMetadata = expr.arg.getMetadata(this.schema);
                    if (!argMetadata ||
                        argMetadata.kind !== 0 /* Column */ ||
                        !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {
                        this.register(12 /* invalidPercentileArgument */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitDiscretize = function (expr) {
                expr.source.accept(this);
                if (expr.count <= 0) {
                    this.register(15 /* invalidDiscretizeCount */);
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitEntity = function (expr) {
                this.validateEntity(expr.schema, expr.entity);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitSubqueryRef = function (expr) {
                return expr;
            };
            SQExprValidationVisitor.prototype.visitNamedQueryRef = function (expr) {
                return expr;
            };
            SQExprValidationVisitor.prototype.visitContains = function (expr) {
                this.validateStartOrContainsArgs(expr.left, expr.right);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {
                this.validateStartOrContainsArgs(expr.left, expr.right);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {
                this.validateArithmeticTypes(expr.operator, expr.left, expr.right);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {
                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {
                    var scopeRef = _a[_i];
                    if (!(SQExpr.isWithRef(scopeRef) || SQExpr.isColumn(scopeRef))) {
                        this.register(13 /* invalidScopeArgument */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitFilteredEval = function (expr) {
                expr.expression.accept(this);
                if (_.size(expr.filters) === 0)
                    this.register(16 /* invalidFiltersForFilteredEval */);
                for (var _i = 0, _a = expr.filters; _i < _a.length; _i++) {
                    var filter = _a[_i];
                    if (!_.isEmpty(filter.target)) {
                        for (var _b = 0, _c = filter.target; _b < _c.length; _b++) {
                            var target = _c[_b];
                            target.accept(this);
                        }
                    }
                    filter.condition.accept(this);
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitWithRef = function (expr) {
                return expr;
            };
            SQExprValidationVisitor.prototype.visitTransformTableRef = function (expr) {
                return expr;
            };
            SQExprValidationVisitor.prototype.visitTransformOutputRoleRef = function (expr) {
                return expr;
            };
            SQExprValidationVisitor.prototype.visitRoleRef = function (expr) {
                return expr;
            };
            SQExprValidationVisitor.prototype.validateExprSequence = function (exprs) {
                var _this = this;
                return _.reduce(exprs, (function (result, expr) { return result = result && _.isEmpty(expr.validate(_this.schema, _this.aggrUtils, _this.errors)); }), true);
            };
            SQExprValidationVisitor.prototype.validateStartOrContainsArgs = function (left, right) {
                left.accept(this);
                right.accept(this);
                if (_.isEmpty(this.errors)) {
                    if (!(SQExpr.isConstant(right)) || !right.type.text)
                        this.register(10 /* invalidRightOperandType */);
                    else
                        this.validateCompatibleType(left, right, /*strictTypeCheck*/ true);
                }
            };
            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (operator, left, right) {
                if (!data.SQExprUtils.supportsArithmetic(operator, left, this.schema))
                    this.register(9 /* invalidLeftOperandType */);
                if (!data.SQExprUtils.supportsArithmetic(operator, right, this.schema))
                    this.register(10 /* invalidRightOperandType */);
            };
            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right, strictTypeCheck) {
                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;
                var isInvalid;
                if (strictTypeCheck) {
                    isInvalid = !leftType || !rightType || !leftType.isCompatibleFrom(rightType);
                }
                else {
                    isInvalid = leftType && rightType && !leftType.isCompatibleFrom(rightType);
                }
                if (isInvalid)
                    this.register(11 /* invalidValueType */);
            };
            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {
                var schema = this.schema.schema(schemaName);
                if (schema) {
                    var entity = schema.entities.withName(entityName);
                    if (entity)
                        return entity;
                    this.register(2 /* invalidEntityReference */);
                }
                else {
                    this.register(1 /* invalidSchemaReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateIsTableRef = function (expr) {
                if (expr.kind !== 1 /* SubqueryRef */ && expr.kind !== 0 /* Entity */) {
                    this.register(14 /* invalidTableReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {
                var entity = this.validateEntity(schemaName, entityName);
                if (entity) {
                    var hierarchy = entity.hierarchies.withName(hierarchyName);
                    if (hierarchy)
                        return hierarchy;
                    this.register(6 /* invalidHierarchyReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {
                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);
                if (hierarchy) {
                    var hierarchyLevel = hierarchy.levels.withName(levelName);
                    if (hierarchyLevel)
                        return hierarchyLevel;
                    this.register(7 /* invalidHierarchyLevelReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateHierarchyLevelVariation = function (fieldExpr) {
                var variationSourceFieldExpr = fieldExpr.source;
                var schema = this.schema.schema(variationSourceFieldExpr.schema);
                var sourceProperty = schema.findProperty(variationSourceFieldExpr.entity, variationSourceFieldExpr.name);
                this.validateColumnExpr({ column: fieldExpr.source });
                var sourceColumn = sourceProperty && sourceProperty.column;
                if (sourceColumn) {
                    var variation = sourceProperty.column.variations.withName(fieldExpr.variationName);
                    if (variation) {
                        var variationHierarchy = schema.findHierarchyByVariation(variationSourceFieldExpr.entity, variationSourceFieldExpr.name, fieldExpr.variationName, fieldExpr.level.name);
                        if (variationHierarchy) {
                            var level = variationHierarchy.levels.withName(fieldExpr.level.level);
                            if (level)
                                return variation;
                        }
                    }
                    this.register(8 /* invalidVariationReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateColumnExpr = function (fieldExpr) {
                var columnExpr = fieldExpr.column;
                var entity = this.validateEntity(columnExpr.schema, columnExpr.entity);
                if (entity) {
                    var prop = entity.properties.withName(columnExpr.name);
                    if (!prop ||
                        prop.kind !== 0 /* Column */ ||
                        !this.isQueryable(fieldExpr))
                        this.register(3 /* invalidColumnReference */);
                    else
                        return prop;
                }
            };
            SQExprValidationVisitor.prototype.register = function (error) {
                if (!this.errors)
                    this.errors = [];
                this.errors.push(error);
            };
            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {
                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);
                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;
                }
                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;
            };
            return SQExprValidationVisitor;
        }(data.SQExprRewriter));
        data.SQExprValidationVisitor = SQExprValidationVisitor;
        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */
        var SQExprAggregateInfoVisitor = /** @class */ (function (_super) {
            __extends(SQExprAggregateInfoVisitor, _super);
            function SQExprAggregateInfoVisitor() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {
                return expr.func;
            };
            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {
                return;
            };
            SQExprAggregateInfoVisitor.getAggregate = function (expr) {
                var visitor = new SQExprAggregateInfoVisitor();
                return expr.accept(visitor);
            };
            return SQExprAggregateInfoVisitor;
        }(data.DefaultSQExprVisitor));
        /** Returns a SQExprColumnRef expression or undefined.*/
        var SQExprColumnRefInfoVisitor = /** @class */ (function (_super) {
            __extends(SQExprColumnRefInfoVisitor, _super);
            function SQExprColumnRefInfoVisitor(schema) {
                var _this = _super.call(this) || this;
                _this.schema = schema;
                return _this;
            }
            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {
                return expr;
            };
            SQExprColumnRefInfoVisitor.prototype.visitGroupRef = function (expr) {
                return expr;
            };
            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {
                var ref = expr.level;
                var hierarchy = (expr.arg);
                var sourceExpr = hierarchy.accept(this);
                if (hierarchy && SQExpr.isPropertyVariationSource(hierarchy.arg)) {
                    var propertyVariationSource = hierarchy.arg;
                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);
                    if (sourceExpr && targetEntity) {
                        var schemaName = (sourceExpr.source).schema;
                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);
                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);
                        if (schemaHierarchy) {
                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {
                                var level = _a[_i];
                                if (level.name === ref)
                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);
                            }
                        }
                    }
                }
                else {
                    var entityExpr = (hierarchy.arg);
                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);
                    if (hierarchyLevelRef)
                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);
                }
            };
            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {
                return expr.arg.accept(this);
            };
            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {
                var propertyName = expr.property;
                return new SQColumnRefExpr(expr.arg, propertyName);
            };
            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {
                return expr.arg.accept(this);
            };
            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {
                return;
            };
            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {
                var visitor = new SQExprColumnRefInfoVisitor(schema);
                return expr.accept(visitor);
            };
            return SQExprColumnRefInfoVisitor;
        }(data.DefaultSQExprVisitor));
        /** Returns a SQEntityExpr expression or undefined.*/
        var TargetEntityFinder = /** @class */ (function (_super) {
            __extends(TargetEntityFinder, _super);
            function TargetEntityFinder() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            TargetEntityFinder.prototype.visitEntity = function (expr) {
                var currentExpr = this.result;
                if (currentExpr === undefined || SQExpr.equals(currentExpr, expr))
                    this.result = expr;
                else
                    this.result = null;
            };
            TargetEntityFinder.prototype.visitFilteredEval = function (expr) {
                expr.expression.accept(this);
            };
            TargetEntityFinder.getEntityExpr = function (expr) {
                var visitor = new TargetEntityFinder();
                expr.accept(visitor);
                return visitor.result || undefined;
            };
            return TargetEntityFinder;
        }(data.DefaultSQExprVisitorWithTraversal));
        var SQExprChangeAggregateRewriter = /** @class */ (function (_super) {
            __extends(SQExprChangeAggregateRewriter, _super);
            function SQExprChangeAggregateRewriter(func) {
                var _this = this;
                debug.assertValue(func, 'func');
                _this = _super.call(this) || this;
                _this.func = func;
                return _this;
            }
            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {
                if (expr.func === this.func)
                    return expr;
                return new SQAggregationExpr(expr.arg, this.func);
            };
            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {
                return new SQAggregationExpr(expr, this.func);
            };
            SQExprChangeAggregateRewriter.prototype.visitGroupRef = function (expr) {
                return new SQAggregationExpr(expr, this.func);
            };
            SQExprChangeAggregateRewriter.prototype.visitHierarchyLevel = function (expr) {
                return new SQAggregationExpr(expr, this.func);
            };
            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(func, 'func');
                var rewriter = new SQExprChangeAggregateRewriter(func);
                return expr.accept(rewriter);
            };
            return SQExprChangeAggregateRewriter;
        }(SQExprRootRewriter));
        var FieldExprChangeAggregateRewriter = /** @class */ (function () {
            function FieldExprChangeAggregateRewriter(sqExpr, aggregate) {
                this.sqExpr = sqExpr;
                this.aggregate = aggregate;
            }
            FieldExprChangeAggregateRewriter.rewrite = function (sqExpr, aggregate) {
                return data.FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));
            };
            FieldExprChangeAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {
                pattern.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr), this.aggregate));
                return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });
            };
            FieldExprChangeAggregateRewriter.prototype.visitPercentOfRoleTotal = function (pattern) {
                pattern.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr), this.aggregate));
                return SQExprBuilder.fieldExpr({ percentOfRoleTotal: pattern });
            };
            FieldExprChangeAggregateRewriter.prototype.visitFilteredEval = function (filteredEval) {
                filteredEval.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(filteredEval.baseExpr), this.aggregate));
                return SQExprBuilder.fieldExpr({ filteredEval: filteredEval });
            };
            FieldExprChangeAggregateRewriter.prototype.visitColumn = function (column) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitGroupingColumn = function (column) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitGroupingColumnAggr = function (columnAggr) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitSelectRef = function (selectRef) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitEntity = function (entity) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitMeasure = function (measure) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitPercentile = function (percentile) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                return this.defaultRewrite();
            };
            FieldExprChangeAggregateRewriter.prototype.defaultRewrite = function () {
                return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);
            };
            return FieldExprChangeAggregateRewriter;
        }());
        var FieldExprRemoveAggregateRewriter = /** @class */ (function () {
            function FieldExprRemoveAggregateRewriter(sqExpr) {
                this.sqExpr = sqExpr;
            }
            FieldExprRemoveAggregateRewriter.rewrite = function (sqExpr) {
                return data.FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));
            };
            FieldExprRemoveAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {
                return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));
            };
            FieldExprRemoveAggregateRewriter.prototype.visitPercentOfRoleTotal = function (pattern) {
                return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));
            };
            FieldExprRemoveAggregateRewriter.prototype.visitFilteredEval = function (filteredEval) {
                return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(filteredEval.baseExpr));
            };
            FieldExprRemoveAggregateRewriter.prototype.visitColumn = function (column) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitGroupingColumn = function (column) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitGroupingColumnAggr = function (columnAggr) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitSelectRef = function (selectRef) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitEntity = function (entity) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitMeasure = function (measure) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitPercentile = function (percentile) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.visitTransformOutputRoleRef = function (transformOutputRoleRef) {
                return this.defaultRewrite();
            };
            FieldExprRemoveAggregateRewriter.prototype.defaultRewrite = function () {
                return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);
            };
            return FieldExprRemoveAggregateRewriter;
        }());
        var SQExprRemoveAggregateRewriter = /** @class */ (function (_super) {
            __extends(SQExprRemoveAggregateRewriter, _super);
            function SQExprRemoveAggregateRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {
                return expr.arg;
            };
            SQExprRemoveAggregateRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprRemoveAggregateRewriter.instance);
            };
            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();
            return SQExprRemoveAggregateRewriter;
        }(SQExprRootRewriter));
        var SQExprRemoveEntityVariablesRewriter = /** @class */ (function (_super) {
            __extends(SQExprRemoveEntityVariablesRewriter, _super);
            function SQExprRemoveEntityVariablesRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {
                if (expr.variable)
                    return SQExprBuilder.entity(expr.schema, expr.entity);
                return expr;
            };
            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);
            };
            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();
            return SQExprRemoveEntityVariablesRewriter;
        }(data.SQExprRewriter));
        var SQExprRemovePercentOfGrandTotalRewriter = /** @class */ (function (_super) {
            __extends(SQExprRemovePercentOfGrandTotalRewriter, _super);
            function SQExprRemovePercentOfGrandTotalRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprRemovePercentOfGrandTotalRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);
            };
            SQExprRemovePercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr && fieldExpr.percentOfGrandTotal)
                    expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);
                return expr;
            };
            SQExprRemovePercentOfGrandTotalRewriter.instance = new SQExprRemovePercentOfGrandTotalRewriter();
            return SQExprRemovePercentOfGrandTotalRewriter;
        }(SQExprRootRewriter));
        var SQExprSetPercentOfGrandTotalRewriter = /** @class */ (function (_super) {
            __extends(SQExprSetPercentOfGrandTotalRewriter, _super);
            function SQExprSetPercentOfGrandTotalRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprSetPercentOfGrandTotalRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);
            };
            SQExprSetPercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr && !fieldExpr.percentOfGrandTotal)
                    expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: fieldExpr } });
                return expr;
            };
            SQExprSetPercentOfGrandTotalRewriter.instance = new SQExprSetPercentOfGrandTotalRewriter();
            return SQExprSetPercentOfGrandTotalRewriter;
        }(SQExprRootRewriter));
        var SQExprRemovePercentOfRoleTotalRewriter = /** @class */ (function (_super) {
            __extends(SQExprRemovePercentOfRoleTotalRewriter, _super);
            function SQExprRemovePercentOfRoleTotalRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprRemovePercentOfRoleTotalRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprRemovePercentOfRoleTotalRewriter.instance);
            };
            SQExprRemovePercentOfRoleTotalRewriter.prototype.visitDefault = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr && fieldExpr.percentOfRoleTotal)
                    expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfRoleTotal.baseExpr);
                return expr;
            };
            SQExprRemovePercentOfRoleTotalRewriter.instance = new SQExprRemovePercentOfRoleTotalRewriter();
            return SQExprRemovePercentOfRoleTotalRewriter;
        }(SQExprRootRewriter));
        var SQExprSetPercentOfRoleTotalRewriter = /** @class */ (function (_super) {
            __extends(SQExprSetPercentOfRoleTotalRewriter, _super);
            function SQExprSetPercentOfRoleTotalRewriter() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            SQExprSetPercentOfRoleTotalRewriter.rewrite = function (expr, roles) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprSetPercentOfRoleTotalRewriter.instance, roles);
            };
            SQExprSetPercentOfRoleTotalRewriter.prototype.visitDefault = function (expr, roles) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr && !fieldExpr.percentOfRoleTotal)
                    expr = SQExprBuilder.fieldExpr({
                        percentOfRoleTotal: {
                            baseExpr: fieldExpr,
                            roles: roles
                        }
                    });
                return expr;
            };
            SQExprSetPercentOfRoleTotalRewriter.instance = new SQExprSetPercentOfRoleTotalRewriter();
            return SQExprSetPercentOfRoleTotalRewriter;
        }(SQExprRootRewriterWithArg));
        /**
         * Visitor for getting information about a hierarchy
         */
        var HierarchyVisitor = /** @class */ (function (_super) {
            __extends(HierarchyVisitor, _super);
            function HierarchyVisitor() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            HierarchyVisitor.prototype.visitHierarchyLevel = function (expr) {
                return expr.arg.accept(this);
            };
            HierarchyVisitor.prototype.visitHierarchy = function (expr) {
                return expr.arg.accept(this);
            };
            HierarchyVisitor.prototype.visitPropertyVariationSource = function (expr) {
                return expr.property;
            };
            HierarchyVisitor.getProperty = function (expr) {
                var visitor = new HierarchyVisitor();
                return expr.accept(visitor);
            };
            return HierarchyVisitor;
        }(data.DefaultSQExprVisitor));
        data.HierarchyVisitor = HierarchyVisitor;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var StringExtensions = jsCommon.StringExtensions;
        var SQExprUtils;
        (function (SQExprUtils) {
            function supportsArithmetic(operator, expr, schema) {
                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;
                if (!metadata || !type) {
                    return false;
                }
                if (operator === 2 /* Multiply */ || operator === 3 /* Divide */) {
                    return type.numeric;
                }
                return type.numeric || type.dateTime || type.duration;
            }
            SQExprUtils.supportsArithmetic = supportsArithmetic;
            function indexOfExpr(items, searchElement) {
                debug.assertValue(items, 'items');
                debug.assertValue(searchElement, 'searchElement');
                for (var i = 0, len = items.length; i < len; i++) {
                    if (data.SQExpr.equals(items[i], searchElement))
                        return i;
                }
                return -1;
            }
            SQExprUtils.indexOfExpr = indexOfExpr;
            function indexOfNamedExpr(items, searchElement) {
                debug.assertValue(items, 'items');
                debug.assertValue(searchElement, 'searchElement');
                for (var i = 0, len = items.length; i < len; i++) {
                    var item = items[i];
                    if (item && data.SQExpr.equals(item.expr, searchElement))
                        return i;
                }
                return -1;
            }
            SQExprUtils.indexOfNamedExpr = indexOfNamedExpr;
            function sequenceEqual(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                var len = x.length;
                if (len !== y.length)
                    return false;
                for (var i = 0; i < len; i++) {
                    if (!data.SQExpr.equals(x[i], y[i]))
                        return false;
                }
                return true;
            }
            SQExprUtils.sequenceEqual = sequenceEqual;
            function uniqueName(namedItems, expr, exprDefaultName) {
                debug.assertValue(namedItems, 'namedItems');
                // Determine all names
                var names = {};
                for (var i = 0, len = namedItems.length; i < len; i++)
                    names[namedItems[i].name] = true;
                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));
            }
            SQExprUtils.uniqueName = uniqueName;
            /** Generates a default expression name  */
            function defaultName(expr, fallback) {
                if (fallback === void 0) { fallback = 'select'; }
                if (!expr)
                    return fallback;
                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);
            }
            SQExprUtils.defaultName = defaultName;
            /** Gets a value indicating whether the expr is a model measure or an aggregate. */
            function isMeasure(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(IsMeasureVisitor.instance);
            }
            SQExprUtils.isMeasure = isMeasure;
            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/
            function isAnyValue(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(IsAnyValueVisitor.instance);
            }
            SQExprUtils.isAnyValue = isAnyValue;
            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/
            function isDefaultValue(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(IsDefaultValueVisitor.instance);
            }
            SQExprUtils.isDefaultValue = isDefaultValue;
            function discourageAggregation(expr, schema) {
                var capabilities = getSchemaCapabilities(expr, schema);
                return capabilities && capabilities.discourageQueryAggregateUsage;
            }
            SQExprUtils.discourageAggregation = discourageAggregation;
            function getAggregateBehavior(expr, schema) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var column = getConceptualColumn(expr, schema);
                if (column)
                    return column.aggregateBehavior;
            }
            SQExprUtils.getAggregateBehavior = getAggregateBehavior;
            function getSchemaCapabilities(expr, schema) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var field = data.SQExprConverter.asFieldPattern(expr);
                if (!field)
                    return;
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var conceptualSchema = schema.schema(fieldExprItem.schema);
                if (conceptualSchema)
                    return conceptualSchema.capabilities;
            }
            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;
            function getKpiMetadata(expr, schema) {
                var kpiStatusProperty = getKpiStatusProperty(expr, schema);
                if (kpiStatusProperty)
                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;
                var kpiTrendProperty = getKpiTrendProperty(expr, schema);
                if (kpiTrendProperty)
                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;
            }
            SQExprUtils.getKpiMetadata = getKpiMetadata;
            function getParameterMetadata(expr, schema) {
                var property = expr.getConceptualProperty(schema);
                return property && property.column && property.column.parameterMetadata;
            }
            SQExprUtils.getParameterMetadata = getParameterMetadata;
            function getConceptualEntity(entityExpr, schema) {
                debug.assertValue(entityExpr, 'entityExpr');
                var conceptualEntity = schema
                    .schema(entityExpr.schema)
                    .entities
                    .withName(entityExpr.entity);
                return conceptualEntity;
            }
            SQExprUtils.getConceptualEntity = getConceptualEntity;
            /**
             * Returns a list of expressions for the columns whose collection of keys contain the given one (and on the same entity as said key).
             * */
            function getColumnnsWithKey(keyExpr, schema) {
                debug.assertValue(keyExpr, 'keyExpr');
                debug.assertValue(schema, 'schema');
                var keyColumnExpr = keyExpr.getTargetColumnRef(schema);
                if (!keyColumnExpr)
                    return;
                var keyColumn = keyColumnExpr.getConceptualProperty(schema);
                if (!keyColumn || !keyColumn.column)
                    return;
                var entityExpr = keyColumnExpr.getTargetEntity();
                if (!entityExpr)
                    return;
                var entity = getConceptualEntity(entityExpr, schema);
                if (!entity)
                    return;
                var displayProperties = [];
                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {
                    var property = _a[_i];
                    if (property.column && property.column.keys && _.contains(property.column.keys, keyColumn)) {
                        displayProperties.push(data.SQExprBuilder.columnRef(entityExpr, property.name));
                    }
                }
                return displayProperties;
            }
            SQExprUtils.getColumnnsWithKey = getColumnnsWithKey;
            function tryGetExprFromFilter(filter) {
                if (data.SQExpr.isIn(filter.condition) && _.size(filter.condition.args) === 1) {
                    return filter.condition.args[0];
                }
                else if (data.SQExpr.isCompare(filter.condition)) {
                    // This only supports compare exprs of type expr <op> value or value <op> expr, but not
                    // exprs of the form like expr <op> expr or expr <op> datespan
                    if (data.SQExpr.isConstant(filter.condition.left))
                        return filter.condition.right;
                    else if (data.SQExpr.isConstant(filter.condition.right))
                        return filter.condition.left;
                }
            }
            SQExprUtils.tryGetExprFromFilter = tryGetExprFromFilter;
            function getKpiStatusProperty(expr, schema) {
                var property = expr.getConceptualProperty(schema);
                if (!property)
                    return;
                var kpiValue = property.kpiValue;
                if (kpiValue && kpiValue.measure.kpi.status === property)
                    return property;
            }
            function getKpiTrendProperty(expr, schema) {
                var property = expr.getConceptualProperty(schema);
                if (!property)
                    return;
                var kpiValue = property.kpiValue;
                if (kpiValue && kpiValue.measure.kpi.trend === property)
                    return property;
            }
            function getDefaultValue(fieldSQExpr, schema) {
                var column = getConceptualColumn(fieldSQExpr, schema);
                if (column)
                    return column.defaultValue;
            }
            SQExprUtils.getDefaultValue = getDefaultValue;
            function getConceptualColumn(fieldSQExpr, schema) {
                if (!fieldSQExpr || !schema)
                    return;
                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);
                if (!sqField)
                    return;
                var column = sqField.column || sqField.groupingColumn;
                if (column) {
                    if (schema.schema(column.schema) && column.name) {
                        var property = schema.schema(column.schema).findProperty(column.entity, column.name);
                        if (property)
                            return property.column;
                    }
                }
                else {
                    var hierarchyLevelField = sqField.hierarchyLevel;
                    if (hierarchyLevelField) {
                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);
                        var schemaName = fieldExprItem.schema;
                        if (schema.schema(schemaName)) {
                            var hierarchy = schema.schema(schemaName)
                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);
                            if (hierarchy) {
                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);
                                if (hierarchyLevel && hierarchyLevel.column)
                                    return hierarchyLevel.column.column;
                            }
                        }
                    }
                }
            }
            function getDefaultValues(fieldSQExprs, schema) {
                if (_.isEmpty(fieldSQExprs) || !schema)
                    return;
                var result = [];
                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {
                    var sqExpr = fieldSQExprs_2[_i];
                    var defaultValue = getDefaultValue(sqExpr, schema);
                    if (defaultValue)
                        result.push(defaultValue);
                }
                return result;
            }
            SQExprUtils.getDefaultValues = getDefaultValues;
            /** Return compare or and expression for key value pairs. */
            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {
                debug.assert(fieldsExpr.length === values.length, "fileds and values need to be the same size");
                var compareExprs = [];
                for (var i = 0; i < fieldsExpr.length; i++) {
                    compareExprs.push(data.SQExprBuilder.compare(0 /* Equal */, fieldsExpr[i], values[i]));
                }
                if (_.isEmpty(compareExprs))
                    return;
                var resultExpr;
                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {
                    var compareExpr = compareExprs_1[_i];
                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);
                }
                return resultExpr;
            }
            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;
            function getActiveTablesNames(queryDefn) {
                var tables = [];
                var entitiesVisitor = new data.SQFromEntitiesVisitor();
                if (queryDefn) {
                    var selectedItems = queryDefn.from();
                    if (selectedItems !== undefined) {
                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {
                            var key = _a[_i];
                            selectedItems.source(key).accept(entitiesVisitor, /*arg*/ null);
                        }
                    }
                }
                tables = _.map(entitiesVisitor.entities, (function (value) { return value.entity; }));
                return tables;
            }
            SQExprUtils.getActiveTablesNames = getActiveTablesNames;
            function isRelatedToMany(schema, sourceExpr, targetExpr) {
                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||
                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);
            }
            SQExprUtils.isRelatedToMany = isRelatedToMany;
            function isRelatedToOne(schema, sourceExpr, targetExpr) {
                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||
                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);
            }
            SQExprUtils.isRelatedToOne = isRelatedToOne;
            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {
                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);
                debug.assertValue(source, "could not resolve conceptual entity form sourceExpr.");
                if (_.isEmpty(source.navigationProperties))
                    return false;
                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);
                debug.assertValue(target, "could not resolve conceptual entity form targetExpr.");
                var queue = [];
                queue.push(source);
                // walk the relationship path from source.
                while (!_.isEmpty(queue)) {
                    var current = queue.shift();
                    var navProperties = current.navigationProperties;
                    if (_.isEmpty(navProperties))
                        continue;
                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {
                        var navProperty = navProperties_1[_i];
                        if (!navProperty.isActive)
                            continue;
                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {
                            if (navProperty.targetEntity === target)
                                return true;
                            queue.push(navProperty.targetEntity);
                        }
                    }
                }
                return false;
            }
            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {
                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);
                debug.assertValue(source, "could not resolve conceptual entity form sourceExpr.");
                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);
                debug.assertValue(target, "could not resolve conceptual entity form targetExpr.");
                var sourceNavigations = source.navigationProperties;
                var targetNavigations = target.navigationProperties;
                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))
                    return false;
                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);
            }
            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;
            function hasOneToOneNavigation(navigationProperties, targetEntity) {
                if (_.isEmpty(navigationProperties))
                    return false;
                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {
                    var navigationProperty = navigationProperties_1[_i];
                    if (!navigationProperty.isActive)
                        continue;
                    if (navigationProperty.targetEntity !== targetEntity)
                        continue;
                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&
                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {
                        return true;
                    }
                }
                return false;
            }
            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,
                and returns a new array. When available, we should use _.unionWith from lodash. */
            function concatUnique(leftExprs, rightExprs) {
                debug.assertValue(leftExprs, 'leftExprs');
                debug.assertValue(rightExprs, 'rightExprs');
                var concatExprs = ArrayExtensions.copy(leftExprs);
                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {
                    var expr = rightExprs_1[_i];
                    if (indexOfExpr(concatExprs, expr) === -1) {
                        concatExprs.push(expr);
                    }
                }
                return concatExprs;
            }
            SQExprUtils.concatUnique = concatUnique;
            function detectTransformExpr(expr) {
                debug.assertValue(expr, "expr");
                var detector = new TransformExprDetectionVisitor();
                expr.accept(detector);
                return detector.sawTransformOutputRoleRef;
            }
            SQExprUtils.detectTransformExpr = detectTransformExpr;
            function isExprValidForSorting(expr) {
                debug.assertValue(expr, 'expr');
                return !data.SQExpr.isFilteredEval(expr);
            }
            SQExprUtils.isExprValidForSorting = isExprValidForSorting;
            function isExprValidForFiltering(expr) {
                debug.assertValue(expr, 'expr');
                return !(data.SQExpr.isFilteredEval(expr) || data.SQExpr.isTransformOutputRoleRef(expr));
            }
            SQExprUtils.isExprValidForFiltering = isExprValidForFiltering;
            function isExprValidForClustering(expr) {
                debug.assertValue(expr, 'expr');
                return !(data.SQExpr.isFilteredEval(expr) || data.SQExpr.isHierarchy(expr) || data.SQExpr.isHierarchyLevel(expr));
            }
            SQExprUtils.isExprValidForClustering = isExprValidForClustering;
            function isExprValidForForecasting(expr) {
                debug.assertValue(expr, 'expr');
                return !data.SQExpr.isFilteredEval(expr);
            }
            SQExprUtils.isExprValidForForecasting = isExprValidForForecasting;
            var SQExprDefaultNameGenerator = /** @class */ (function (_super) {
                __extends(SQExprDefaultNameGenerator, _super);
                function SQExprDefaultNameGenerator() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {
                    return expr.entity;
                };
                SQExprDefaultNameGenerator.prototype.visitNamedQueryRef = function (expr) {
                    return "QueryRef(" + expr.queryName + ")";
                };
                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {
                    return expr.source.accept(this) + '.' + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitGroupRef = function (expr) {
                    return expr.source.accept(this) + '.' + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr) {
                    return expr.source.accept(this) + '.' + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitHierarchy = function (expr) {
                    return expr.arg.accept(this) + '.' + expr.hierarchy;
                };
                SQExprDefaultNameGenerator.prototype.visitHierarchyLevel = function (expr) {
                    return expr.arg.accept(this) + '.' + expr.level;
                };
                SQExprDefaultNameGenerator.prototype.visitPropertyVariationSource = function (expr) {
                    return expr.arg.accept(this) + '.' + expr.property + '.' + expr.name;
                };
                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr) {
                    return data.aggregateFunctionName(expr.func) + '(' + expr.arg.accept(this) + ')';
                };
                SQExprDefaultNameGenerator.prototype.visitPercentile = function (expr) {
                    var func = expr.exclusive
                        ? 'Percentile.Exc('
                        : 'Percentile.Inc(';
                    return func + expr.arg.accept(this) + ', ' + expr.k + ')';
                };
                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr) {
                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';
                };
                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {
                    return 'const';
                };
                SQExprDefaultNameGenerator.prototype.visitTransformOutputRoleRef = function (expr) {
                    var name = expr.role;
                    if (expr.transform)
                        name += '.' + expr.transform;
                    return name;
                };
                SQExprDefaultNameGenerator.prototype.visitScopedEval = function (expr) {
                    var _this = this;
                    return 'ScopedEval(' + expr.expression.accept(this) + ', [' + _.map(expr.scope, (function (expr) { return expr.accept(_this); })).join(', ') + '])';
                };
                SQExprDefaultNameGenerator.prototype.visitFilteredEval = function (expr) {
                    var _this = this;
                    var filterNameGenerator = function (filter) {
                        var filterString = '{';
                        if (!_.isEmpty(filter.target))
                            filterString += "Target(" + _.map(filter.target, (function (target) { return target.accept(_this); })).join(', ') + "), ";
                        filterString += "Condition(" + filter.condition.accept(_this) + ")}";
                        return filterString;
                    };
                    return "FilteredEval(" + expr.expression.accept(this) + ", [" + _.map(expr.filters, (function (filter) { return filterNameGenerator(filter); })).join(', ') + "])";
                };
                SQExprDefaultNameGenerator.prototype.visitRoleRef = function (expr) {
                    return 'Role.' + expr.role;
                };
                SQExprDefaultNameGenerator.prototype.visitDiscretize = function (expr) {
                    return "Discretize(" + expr.source.accept(this) + ", " + expr.count + ")";
                };
                SQExprDefaultNameGenerator.prototype.visitMember = function (expr) {
                    return "Member(" + expr.source.accept(this) + ", " + expr.member + ")";
                };
                SQExprDefaultNameGenerator.prototype.visitCompare = function (expr) {
                    var left = expr.left.accept(this);
                    var right = expr.right.accept(this);
                    var operator = '';
                    switch (expr.comparison) {
                        case 0 /* Equal */:
                            operator = '=';
                            break;
                        case 1 /* GreaterThan */:
                            operator = '>';
                            break;
                        case 2 /* GreaterThanOrEqual */:
                            operator = '>=';
                            break;
                        case 3 /* LessThan */:
                            operator = '<';
                            break;
                        case 4 /* LessThanOrEqual */:
                            operator = '<=';
                            break;
                    }
                    return "" + left + operator + right;
                };
                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {
                    return fallback || 'expr';
                };
                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();
                return SQExprDefaultNameGenerator;
            }(data.DefaultSQExprVisitorWithArg));
            var IsMeasureVisitor = /** @class */ (function (_super) {
                __extends(IsMeasureVisitor, _super);
                function IsMeasureVisitor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {
                    return true;
                };
                IsMeasureVisitor.prototype.visitAggr = function (expr) {
                    return true;
                };
                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {
                    return true;
                };
                IsMeasureVisitor.prototype.visitDefault = function (expr) {
                    return false;
                };
                IsMeasureVisitor.instance = new IsMeasureVisitor();
                return IsMeasureVisitor;
            }(data.DefaultSQExprVisitor));
            var IsDefaultValueVisitor = /** @class */ (function (_super) {
                __extends(IsDefaultValueVisitor, _super);
                function IsDefaultValueVisitor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== 0 /* Equal */)
                        return false;
                    return expr.right.accept(this);
                };
                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {
                    return expr.left.accept(this) && expr.right.accept(this);
                };
                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {
                    return true;
                };
                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {
                    return false;
                };
                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();
                return IsDefaultValueVisitor;
            }(data.DefaultSQExprVisitor));
            var IsAnyValueVisitor = /** @class */ (function (_super) {
                __extends(IsAnyValueVisitor, _super);
                function IsAnyValueVisitor() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                IsAnyValueVisitor.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== 0 /* Equal */)
                        return false;
                    return expr.right.accept(this);
                };
                IsAnyValueVisitor.prototype.visitAnd = function (expr) {
                    return expr.left.accept(this) && expr.right.accept(this);
                };
                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {
                    return true;
                };
                IsAnyValueVisitor.prototype.visitDefault = function (expr) {
                    return false;
                };
                IsAnyValueVisitor.instance = new IsAnyValueVisitor();
                return IsAnyValueVisitor;
            }(data.DefaultSQExprVisitor));
            var TransformExprDetectionVisitor = /** @class */ (function (_super) {
                __extends(TransformExprDetectionVisitor, _super);
                function TransformExprDetectionVisitor() {
                    var _this = _super.call(this) || this;
                    _this.sawTransformOutputRoleRef = false;
                    return _this;
                }
                TransformExprDetectionVisitor.prototype.visitTransformOutputRoleRef = function (expr) {
                    this.sawTransformOutputRoleRef = true;
                };
                return TransformExprDetectionVisitor;
            }(data.DefaultSQExprVisitorWithTraversal));
        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SemanticQueryRewriter = /** @class */ (function () {
            function SemanticQueryRewriter(exprRewriter) {
                this.exprRewriter = exprRewriter;
            }
            SemanticQueryRewriter.rewriteFrom = function (fromValue, sourceRewriter) {
                var updatedFromContents;
                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();
                for (var i = 0, len = originalFromKeys.length; i < len; i++) {
                    var keyName = originalFromKeys[i];
                    var orig = originalFrom.source(keyName), rewritten = orig.accept(sourceRewriter, keyName);
                    if (orig !== rewritten || updatedFromContents) {
                        if (!updatedFromContents) {
                            updatedFromContents = _.pick(originalFrom.sources(), originalFromKeys.slice(0, i));
                        }
                        updatedFromContents[keyName] = rewritten;
                    }
                }
                if (!updatedFromContents)
                    return originalFrom;
                return new data.SQFrom(updatedFromContents);
            };
            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {
                return SemanticQueryRewriter.rewriteFrom(fromValue, new data.SQFromSourceRewriter(this.exprRewriter));
            };
            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {
                debug.assertValue(selectItems, 'selectItems');
                debug.assertValue(from, 'from');
                return this.rewriteNamedSQExpressions(selectItems, from);
            };
            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {
                debug.assertAnyValue(groupByitems, 'groupByitems');
                debug.assertValue(from, 'from');
                if (_.isEmpty(groupByitems))
                    return;
                return this.rewriteNamedSQExpressions(groupByitems, from);
            };
            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {
                var _this = this;
                debug.assertValue(expressions, 'expressions');
                return _.map(expressions, (function (item) {
                    return {
                        name: item.name,
                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from, from)
                    };
                }));
            };
            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {
                debug.assertAnyValue(orderByItems, 'orderByItems');
                debug.assertValue(from, 'from');
                if (_.isEmpty(orderByItems))
                    return;
                var orderBy = [];
                for (var i = 0, len = orderByItems.length; i < len; i++) {
                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from, from);
                    orderBy.push({
                        direction: item.direction,
                        expr: updatedExpr,
                    });
                }
                return orderBy;
            };
            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {
                var _this = this;
                debug.assertAnyValue(whereItems, 'whereItems');
                debug.assertValue(from, 'from');
                if (_.isEmpty(whereItems))
                    return;
                var where = [];
                for (var i = 0, len = whereItems.length; i < len; i++) {
                    var originalWhere = whereItems[i];
                    var updatedWhere = {
                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from, from),
                    };
                    if (originalWhere.target)
                        updatedWhere.target = _.map(originalWhere.target, (function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from, from); }));
                    where.push(updatedWhere);
                }
                return where;
            };
            SemanticQueryRewriter.prototype.rewriteTransform = function (transformItems, from) {
                var _this = this;
                debug.assertAnyValue(transformItems, 'transformItems');
                debug.assertAnyValue(from, 'from');
                if (_.isEmpty(transformItems))
                    return;
                var transforms = [];
                for (var _i = 0, transformItems_1 = transformItems; _i < transformItems_1.length; _i++) {
                    var transformItem = transformItems_1[_i];
                    var inputColumns = void 0;
                    if (transformItem.input.table && !_.isEmpty(transformItem.input.table.columns)) {
                        inputColumns = _.map(transformItem.input.table.columns, (function (c) {
                            return {
                                role: c.role,
                                expression: {
                                    name: c.expression.name,
                                    expr: data.SQExprRewriterWithSourceRenames.rewrite(c.expression.expr.accept(_this.exprRewriter), from, from)
                                }
                            };
                        }));
                    }
                    var newTransform = {
                        name: transformItem.name,
                        algorithm: transformItem.algorithm,
                        input: {
                            parameters: transformItem.input.parameters,
                        },
                        output: transformItem.output
                    };
                    if (transformItem.input.table) {
                        newTransform.input.table = {
                            name: transformItem.input.table.name,
                            columns: inputColumns
                        };
                    }
                    transforms.push(newTransform);
                }
                return transforms;
            };
            return SemanticQueryRewriter;
        }());
        data.SemanticQueryRewriter = SemanticQueryRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var StringExtensions = jsCommon.StringExtensions;
        /** Represents an entity reference in SemanticQuery from. */
        var SQFromEntitySource = /** @class */ (function () {
            function SQFromEntitySource(schema, entity) {
                this.schema = schema;
                this.entity = entity;
            }
            SQFromEntitySource.prototype.accept = function (visitor, arg) {
                return visitor.visitEntity(this, arg);
            };
            SQFromEntitySource.prototype.equals = function (source) {
                return source && this.entity === source.entity && this.schema === source.schema;
            };
            return SQFromEntitySource;
        }());
        data.SQFromEntitySource = SQFromEntitySource;
        /** Represents a subquery reference in SemanticQuery from.
            for subquery use SQExpr instead of SemanticQuery when we have one for QuerySubqueryExpression
         */
        var SQFromSubquerySource = /** @class */ (function () {
            function SQFromSubquerySource(subquery) {
                this.subquery = subquery;
            }
            SQFromSubquerySource.prototype.accept = function (visitor, arg) {
                return visitor.visitSubquery(this, arg);
            };
            SQFromSubquerySource.prototype.equals = function (source) {
                return source && data.SemanticQuery.equals(this.subquery, source.subquery);
            };
            return SQFromSubquerySource;
        }());
        data.SQFromSubquerySource = SQFromSubquerySource;
        var SQFromExprSource = /** @class */ (function () {
            function SQFromExprSource(expr) {
                this.expr = expr;
            }
            SQFromExprSource.prototype.accept = function (visitor, arg) {
                return visitor.visitExpr(this, arg);
            };
            SQFromExprSource.prototype.equals = function (source) {
                return source && data.SQExpr.equals(this.expr, source.expr);
            };
            return SQFromExprSource;
        }());
        data.SQFromExprSource = SQFromExprSource;
        /** Represents a SemanticQuery/SemanticFilter from clause. */
        var SQFrom = /** @class */ (function () {
            function SQFrom(items) {
                this.items = items || {};
            }
            SQFrom.prototype.keys = function () {
                return Object.keys(this.items);
            };
            SQFrom.prototype.source = function (key) {
                return this.items[key];
            };
            SQFrom.prototype.sources = function () {
                return this.items;
            };
            SQFrom.prototype.ensureSource = function (source, desiredVariableName) {
                debug.assertValue(source, 'source');
                // 1) Reuse a reference to the entity among the already referenced
                var key = this.getSourceKeyFromItems(source);
                if (key)
                    return { name: key };
                // 2) Add a reference to the entity
                var uniqueName = this.addSource(source, desiredVariableName);
                return { name: uniqueName, new: true };
            };
            SQFrom.prototype.remove = function (key) {
                delete this.items[key];
            };
            SQFrom.prototype.getSourceKeyFromItems = function (source) {
                var keys = this.keys();
                for (var i in keys) {
                    var key = keys[i], item = this.items[key];
                    if (equals(item, source))
                        return key;
                }
            };
            SQFrom.prototype.addSource = function (source, desiredVariableName) {
                var candidateName = desiredVariableName || source.accept(new SQFromSourceCandidateNameVisitor(), /*arg*/ null), uniqueName = candidateName, usedNames = {};
                for (var _i = 0, _a = this.keys(); _i < _a.length; _i++) {
                    var key = _a[_i];
                    usedNames[key] = true;
                }
                uniqueName = StringExtensions.findUniqueName(usedNames, uniqueName);
                this.items[uniqueName] = source;
                return uniqueName;
            };
            SQFrom.prototype.clone = function () {
                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).
                var cloned = new SQFrom();
                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.            
                $.extend(cloned.items, this.items);
                return cloned;
            };
            SQFrom.prototype.equals = function (comparand) {
                var _this = this;
                if (!comparand)
                    return false;
                var localKeys = this.keys(), comparandKeys = comparand.keys();
                if (localKeys.length !== comparandKeys.length)
                    return false;
                return ArrayExtensions.sequenceEqual(localKeys, comparandKeys, (function (localKey, comparandKey) { return equals(_this.source(localKey), comparand.source(comparandKey)); }));
            };
            SQFrom.prototype.renameSources = function (usedNames) {
                var items = this.items, rewrittenItems, keys = Object.keys(items);
                for (var i = 0, count = keys.length; i < count; i++) {
                    var originalKey = keys[i], rewrittenKey = originalKey;
                    if (usedNames[originalKey]) {
                        // Key is already used.  Must choose a new key.
                        rewrittenKey = StringExtensions.findUniqueName(usedNames, originalKey);
                        // Copy over all previous items, if they weren't already copied over
                        if (!rewrittenItems) {
                            rewrittenItems = {};
                            for (var j = 0; j < i; j++) {
                                var keyToCopy = keys[j];
                                rewrittenItems[keyToCopy] = items[keyToCopy];
                            }
                        }
                    }
                    usedNames[rewrittenKey] = true;
                    if (rewrittenItems)
                        rewrittenItems[rewrittenKey] = items[originalKey];
                }
                if (!rewrittenItems)
                    return this;
                return new SQFrom(rewrittenItems);
            };
            return SQFrom;
        }());
        data.SQFrom = SQFrom;
        function equals(left, right) {
            if (left === right)
                return true;
            if (left && right) {
                if (isSQFromEntitySource(left) && isSQFromEntitySource(right))
                    return left.equals(right);
                else if (isSQFromSubquerySource(left) && isSQFromSubquerySource(right))
                    return left.equals(right);
                else if (isSQFromExprSource(left) && isSQFromExprSource(right))
                    return left.equals(right);
            }
            return false;
        }
        data.equals = equals;
        function isSQFromEntitySource(source) {
            debug.assertValue(source, 'source');
            return source.entity != null;
        }
        data.isSQFromEntitySource = isSQFromEntitySource;
        function isSQFromSubquerySource(source) {
            debug.assertValue(source, 'source');
            return source.subquery != null;
        }
        data.isSQFromSubquerySource = isSQFromSubquerySource;
        function isSQFromExprSource(source) {
            debug.assertValue(source, 'source');
            return source.expr != null;
        }
        data.isSQFromExprSource = isSQFromExprSource;
        var SQFromSourceCandidateNameVisitor = /** @class */ (function () {
            function SQFromSourceCandidateNameVisitor() {
            }
            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */
            SQFromSourceCandidateNameVisitor.prototype.visitEntity = function (source) {
                var ref = source.entity, idx = ref.lastIndexOf('.');
                if (idx >= 0 && (idx !== ref.length - 1))
                    ref = ref.substr(idx + 1);
                return ref.substring(0, 1).toLowerCase();
            };
            SQFromSourceCandidateNameVisitor.prototype.visitSubquery = function (source) {
                return 'q';
            };
            SQFromSourceCandidateNameVisitor.prototype.visitExpr = function (source) {
                return 'x';
            };
            return SQFromSourceCandidateNameVisitor;
        }());
        data.SQFromSourceCandidateNameVisitor = SQFromSourceCandidateNameVisitor;
        var SQFromEntitiesVisitor = /** @class */ (function () {
            function SQFromEntitiesVisitor() {
                this.entities = [];
            }
            SQFromEntitiesVisitor.prototype.visitEntity = function (source, key) {
                this.entities.push(new data.SQEntityExpr(source.schema, source.entity, key));
            };
            SQFromEntitiesVisitor.prototype.visitSubquery = function (source, key) {
                // does nothing
            };
            SQFromEntitiesVisitor.prototype.visitExpr = function (source, key) {
                // does nothing
            };
            return SQFromEntitiesVisitor;
        }());
        data.SQFromEntitiesVisitor = SQFromEntitiesVisitor;
        var SQFromSourceRewriter = /** @class */ (function () {
            function SQFromSourceRewriter(exprRewriter) {
                this.exprRewriter = exprRewriter;
            }
            SQFromSourceRewriter.prototype.visitEntity = function (source, key) {
                var originalEntityExpr = data.SQExprBuilder.entity(source.schema, source.entity, key), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);
                return new SQFromEntitySource(updatedEntityExpr.schema, updatedEntityExpr.entity);
            };
            SQFromSourceRewriter.prototype.visitSubquery = function (source, key) {
                var originalSubquery = source.subquery, updatedSubquery = originalSubquery.rewrite(this.exprRewriter);
                return new SQFromSubquerySource(updatedSubquery);
            };
            SQFromSourceRewriter.prototype.visitExpr = function (source, key) {
                var originalExpr = source.expr, updatedExpr = originalExpr.accept(this.exprRewriter);
                return new SQFromExprSource(updatedExpr);
            };
            return SQFromSourceRewriter;
        }());
        data.SQFromSourceRewriter = SQFromSourceRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /**
         * Represents a semantic query that is:
         * 1) Round-trippable with a JSON QueryDefinition.
         * 2) Immutable
         * 3) Long-lived and does not have strong references to a conceptual model (only names).
         */
        var SemanticQuery = /** @class */ (function () {
            function SemanticQuery(from, where, orderBy, select, groupBy, transforms, top) {
                debug.assertValue(from, 'from');
                debug.assertValue(select, 'select');
                this.fromValue = from;
                this.whereItems = where;
                this.orderByItems = orderBy;
                this.selectItems = select;
                this.groupByItems = groupBy;
                this.transformItems = transforms;
                if (top != null)
                    this.topValue = top;
            }
            SemanticQuery.create = function () {
                if (!SemanticQuery.empty)
                    SemanticQuery.empty = new SemanticQuery(new data.SQFrom(), null, null, [], null, null, null);
                return SemanticQuery.empty;
            };
            /**
             * Create a SemanticQuery from the given set of clauses.
             *
             * Contract: Neither the passed in SemanticQueryClauses class nor the contents of its member collections will be modified.
             */
            SemanticQuery.createWith = function (clauses, suppressNormalization) {
                debug.assertValue(clauses, 'clauses');
                if (!suppressNormalization)
                    clauses = SemanticQuery.normalize(clauses);
                return new SemanticQuery(clauses.from, clauses.where, clauses.orderBy, clauses.select, clauses.groupBy, clauses.transforms, clauses.top);
            };
            /**
             * Create a new SemanticQuery which is a clone of this SemanticQuery with the exception of the given modified clauses.
             *
             * Contract: The original SemanticQuery remains completely unmodified at all levels of depth.
             */
            SemanticQuery.prototype.createModified = function (modifiedClauses) {
                return SemanticQuery.createWith({
                    from: modifiedClauses.from !== undefined ? modifiedClauses.from : this.fromValue,
                    where: modifiedClauses.where !== undefined ? modifiedClauses.where : this.whereItems,
                    transforms: modifiedClauses.transforms !== undefined ? modifiedClauses.transforms : this.transformItems,
                    orderBy: modifiedClauses.orderBy !== undefined ? modifiedClauses.orderBy : this.orderByItems,
                    select: modifiedClauses.select !== undefined ? modifiedClauses.select : this.selectItems,
                    groupBy: modifiedClauses.groupBy !== undefined ? modifiedClauses.groupBy : this.groupByItems,
                    top: modifiedClauses.top !== undefined ? modifiedClauses.top : this.topValue
                });
            };
            /**
             * Make the given semantic query under construction internally consistent.
             *
             * In addition, rename any sources whose names conflict with the given set of already used names.
             * (This is only used when normalizing a subquery, to ensure that the subquery's source names don't
             * conflict with the outer query's source names.)  Return an updated set of used source names that
             * includes the source names from the normalized query.
             *
             * Contract: Neither the passed in SemanticQueryClauses class nor the contents of its member collections will be modified.
             */
            SemanticQuery.normalize = function (clauses) {
                var semanticQueryUnderConstruction = {
                    clauses: {
                        from: clauses.from,
                        where: clauses.where,
                        orderBy: clauses.orderBy,
                        select: clauses.select,
                        groupBy: clauses.groupBy,
                        transforms: clauses.transforms,
                        top: clauses.top
                    },
                    usedSourceNames: {}
                };
                // Trim the from clause to remove unreferenced sources
                SemanticQuery.removeUnreferencedKeys(semanticQueryUnderConstruction);
                // Rename sources whose names conflict with already existing source names
                SemanticQuery.renameSources(semanticQueryUnderConstruction);
                // Rename sources in subqueries whose names conflict with already existing source names
                SemanticQuery.renameSourcesInSubqueries(semanticQueryUnderConstruction);
                return semanticQueryUnderConstruction.clauses;
            };
            /**
             * Modify the from clause to remove all sources which are not referenced by any expression.
             */
            SemanticQuery.removeUnreferencedKeys = function (semanticQueryUnderConstruction) {
                var clauses = semanticQueryUnderConstruction.clauses;
                var from = clauses.from;
                var where = clauses.where;
                var orderBy = clauses.orderBy;
                var select = clauses.select;
                var groupBy = clauses.groupBy;
                var transform = clauses.transforms;
                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());
                // Where
                if (where) {
                    for (var i = 0, len = where.length; i < len; i++) {
                        var filter = where[i];
                        filter.condition.accept(unreferencedKeyFinder);
                        var filterTarget = filter.target;
                        if (filterTarget) {
                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)
                                if (filterTarget[j])
                                    filterTarget[j].accept(unreferencedKeyFinder);
                        }
                    }
                }
                // Transform
                if (transform) {
                    for (var i = 0, len = transform.length; i < len; i++) {
                        var table = transform[i].input.table;
                        if (!table || _.isEmpty(table.columns))
                            continue;
                        for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            column.expression.expr.accept(unreferencedKeyFinder);
                        }
                    }
                }
                // OrderBy
                if (orderBy) {
                    for (var i = 0, len = orderBy.length; i < len; i++)
                        orderBy[i].expr.accept(unreferencedKeyFinder);
                }
                // Select
                for (var i = 0, len = select.length; i < len; i++)
                    select[i].expr.accept(unreferencedKeyFinder);
                // GroupBy
                if (groupBy) {
                    for (var i = 0, len = groupBy.length; i < len; i++)
                        groupBy[i].expr.accept(unreferencedKeyFinder);
                }
                var unreferencedKeys = unreferencedKeyFinder.result();
                if (!unreferencedKeys)
                    return;
                var trimmedFrom = from.clone();
                for (var _b = 0, unreferencedKeys_1 = unreferencedKeys; _b < unreferencedKeys_1.length; _b++) {
                    var unreferencedKey = unreferencedKeys_1[_b];
                    trimmedFrom.remove(unreferencedKey);
                }
                semanticQueryUnderConstruction.clauses.from = trimmedFrom;
            };
            /**
             * Rename sources in order to not conflict with the given set of used source names.
             */
            SemanticQuery.renameSources = function (semanticQueryUnderConstruction) {
                var originalFrom = semanticQueryUnderConstruction.clauses.from, rewrittenFrom = originalFrom.renameSources(semanticQueryUnderConstruction.usedSourceNames);
                if (rewrittenFrom !== originalFrom) {
                    semanticQueryUnderConstruction.clauses.from = rewrittenFrom;
                    // Rewrite all expressions to reflect the new names
                    SemanticQuery.rewriteClauses(semanticQueryUnderConstruction.clauses, new SQExprRewriterWithSourceRenames(originalFrom, rewrittenFrom));
                }
            };
            /**
             * Rename sources in all subqueries in order to not conflict with the given set of used source names.
             */
            SemanticQuery.renameSourcesInSubqueries = function (semanticQueryUnderConstruction) {
                semanticQueryUnderConstruction.clauses.from = SubquerySourceRenamer.renameSources(SemanticQuery.renameSourcesInQuery, semanticQueryUnderConstruction.clauses.from, semanticQueryUnderConstruction.usedSourceNames);
            };
            /**
             * Rename sources in an already existing SemanticQuery in order to not conflict with the given set of used source names.
             * Produce a new SemanticQuery with the renamed sources
             */
            SemanticQuery.renameSourcesInQuery = function (semanticQuery, usedSourceNames) {
                var semanticQueryUnderConstruction = {
                    clauses: semanticQuery.getClauses(),
                    usedSourceNames: usedSourceNames
                }, originalFrom = semanticQueryUnderConstruction.clauses.from;
                SemanticQuery.renameSources(semanticQueryUnderConstruction);
                SemanticQuery.renameSourcesInSubqueries(semanticQueryUnderConstruction);
                if (semanticQueryUnderConstruction.clauses.from === originalFrom)
                    return semanticQuery;
                return SemanticQuery.createWith(semanticQueryUnderConstruction.clauses);
            };
            SemanticQuery.prototype.from = function (value) {
                if (!value)
                    return this.fromValue.clone();
                return this.createModified({ from: value });
            };
            SemanticQuery.prototype.select = function (values) {
                if (_.isEmpty(arguments))
                    return this.getSelect();
                return this.setSelect(values);
            };
            SemanticQuery.prototype.getSelect = function () {
                return SemanticQuery.createNamedExpressionArray(this.selectItems);
            };
            SemanticQuery.createNamedExpressionArray = function (items) {
                return ArrayExtensions.extendWithName(_.map(items, (function (s) {
                    return {
                        name: s.name,
                        expr: s.expr,
                    };
                })));
            };
            SemanticQuery.prototype.setSelect = function (values) {
                var from = this.fromValue.clone();
                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);
                return this.createModified({ from: from, select: selectItems });
            };
            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {
                var items = [];
                for (var i = 0, len = values.length; i < len; i++) {
                    var value = values[i];
                    items.push({
                        name: value.name,
                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, /*sourceFrom*/ null, from)
                    });
                }
                return items;
            };
            /** Removes the given expression from the select. */
            SemanticQuery.prototype.removeSelect = function (expr) {
                debug.assertValue(expr, 'expr');
                var originalItems = this.selectItems, selectItems = [];
                for (var i = 0, len = originalItems.length; i < len; i++) {
                    var originalExpr = originalItems[i];
                    if (data.SQExpr.equals(originalExpr.expr, expr))
                        continue;
                    selectItems.push(originalExpr);
                }
                return this.createModified({ select: selectItems });
            };
            /** Removes the given expression from order by. */
            SemanticQuery.prototype.removeOrderBy = function (expr) {
                var sorts = this.orderBy();
                for (var i = sorts.length - 1; i >= 0; i--) {
                    if (data.SQExpr.equals(sorts[i].expr, expr))
                        sorts.splice(i, 1);
                }
                return this.createModified({ orderBy: sorts });
            };
            /** Removes the given expression from transforms. */
            SemanticQuery.prototype.removeTransform = function (transform) {
                var transforms = this.transforms();
                for (var i = 0, len = transforms.length; i < len; i++) {
                    if (transforms[i].name === transform.name) {
                        transforms.splice(i, 1);
                        break;
                    }
                }
                return this.createModified({ transforms: transforms });
            };
            SemanticQuery.prototype.selectNameOf = function (expr) {
                var index = data.SQExprUtils.indexOfNamedExpr(this.selectItems, expr);
                if (index >= 0)
                    return this.selectItems[index].name;
            };
            SemanticQuery.prototype.setSelectAt = function (index, expr) {
                debug.assertValue(expr, 'expr');
                if (index >= this.selectItems.length)
                    return;
                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;
                select[index] = {
                    name: originalName,
                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, /*sourceFrom*/ null, from)
                };
                return this.createModified({ from: from, select: select });
            };
            /** Adds a the expression to the select clause. */
            SemanticQuery.prototype.addSelect = function (expr, exprName) {
                debug.assertValue(expr, 'expr');
                var selectItems = this.select(), from = this.fromValue.clone();
                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));
                return this.createModified({ from: from, select: selectItems });
            };
            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {
                return {
                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),
                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, /*sourceFrom*/ null, from)
                };
            };
            SemanticQuery.prototype.groupBy = function (values) {
                if (_.isEmpty(arguments))
                    return this.getGroupBy();
                return this.setGroupBy(values);
            };
            SemanticQuery.prototype.getGroupBy = function () {
                return SemanticQuery.createNamedExpressionArray(this.groupByItems);
            };
            SemanticQuery.prototype.setGroupBy = function (values) {
                var from = this.fromValue.clone();
                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);
                return this.createModified({ from: from, groupBy: groupByItems });
            };
            SemanticQuery.prototype.addGroupBy = function (expr) {
                debug.assertValue(expr, 'expr');
                var groupByItems = this.groupBy(), from = this.fromValue.clone();
                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));
                return this.createModified({ from: from, groupBy: groupByItems });
            };
            SemanticQuery.prototype.orderBy = function (values) {
                if (_.isEmpty(arguments))
                    return this.getOrderBy();
                return this.setOrderBy(values);
            };
            SemanticQuery.prototype.getOrderBy = function () {
                var result = [];
                var orderBy = this.orderByItems;
                if (orderBy) {
                    for (var i = 0, len = orderBy.length; i < len; i++) {
                        var clause = orderBy[i];
                        result.push({
                            expr: clause.expr,
                            direction: clause.direction,
                        });
                    }
                }
                return result;
            };
            SemanticQuery.prototype.setOrderBy = function (values) {
                debug.assertValue(values, 'values');
                var updatedOrderBy = [], from = this.fromValue.clone();
                for (var i = 0, len = values.length; i < len; i++) {
                    var clause = values[i];
                    updatedOrderBy.push({
                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, /*sourceFrom*/ null, from),
                        direction: clause.direction,
                    });
                }
                return this.createModified({ from: from, orderBy: updatedOrderBy });
            };
            SemanticQuery.prototype.where = function (filters, sourceFrom) {
                if (_.isEmpty(arguments))
                    return this.getWhere();
                return this.setWhere([], filters, sourceFrom);
            };
            SemanticQuery.prototype.getWhere = function () {
                var result = [];
                var whereItems = this.whereItems;
                if (whereItems) {
                    for (var i = 0, len = whereItems.length; i < len; i++)
                        result.push(whereItems[i]);
                }
                return result;
            };
            SemanticQuery.prototype.setWhere = function (existingFilters, newFilters, newFiltersFrom) {
                debug.assertValue(existingFilters, 'existingFilters');
                debug.assertValue(newFilters, 'newFilters');
                var updatedWhere = _.clone(existingFilters), updatedFrom = this.fromValue.clone();
                for (var _i = 0, newFilters_1 = newFilters; _i < newFilters_1.length; _i++) {
                    var newFilter = newFilters_1[_i];
                    var updatedFilter = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(newFilter.condition, newFiltersFrom, updatedFrom)
                    };
                    if (newFilter.target)
                        updatedFilter.target = _.map(newFilter.target, (function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, newFiltersFrom, updatedFrom); }));
                    updatedWhere.push(updatedFilter);
                }
                return this.createModified({ from: updatedFrom, where: updatedWhere });
            };
            SemanticQuery.prototype.addWhere = function (newFilters, newFiltersFrom) {
                return this.setWhere(this.where(), newFilters, newFiltersFrom);
            };
            SemanticQuery.prototype.addSemanticFilter = function (filter) {
                debug.assertValue(filter, 'filter');
                return this.setWhere(this.where(), filter.where(), filter.from());
            };
            SemanticQuery.prototype.transforms = function (transforms) {
                if (_.isEmpty(arguments))
                    return this.getTransforms();
                return this.setTransforms(transforms);
            };
            SemanticQuery.prototype.getTransforms = function () {
                var transforms = [];
                if (!_.isEmpty(this.transformItems)) {
                    for (var _i = 0, _a = this.transformItems; _i < _a.length; _i++) {
                        var transform = _a[_i];
                        transforms.push(transform);
                    }
                }
                return transforms;
            };
            SemanticQuery.prototype.setTransforms = function (transforms) {
                var _this = this;
                var from = this.fromValue.clone();
                var transformItems = [];
                for (var _i = 0, transforms_1 = transforms; _i < transforms_1.length; _i++) {
                    var transform = transforms_1[_i];
                    var inputColumns = void 0;
                    if (transform.input.table && !_.isEmpty(transform.input.table.columns)) {
                        inputColumns = _.map(transform.input.table.columns, (function (c) {
                            return {
                                role: c.role,
                                expression: _this.createNamedExpr(ArrayExtensions.extendWithName([]), from, c.expression.expr, c.expression.name)
                            };
                        }));
                    }
                    var newTransform = {
                        name: transform.name,
                        algorithm: transform.algorithm,
                        input: {
                            parameters: transform.input.parameters,
                        },
                        output: transform.output
                    };
                    if (transform.input.table) {
                        newTransform.input.table = {
                            name: transform.input.table.name,
                            columns: inputColumns
                        };
                    }
                    transformItems.push(newTransform);
                }
                return this.createModified({ from: from, transforms: transforms });
            };
            SemanticQuery.prototype.top = function (value) {
                if (_.isEmpty(arguments))
                    return this.topValue;
                return this.setTop(value);
            };
            SemanticQuery.prototype.setTop = function (top) {
                debug.assert(top == null || top > 0, 'if top is specified, it must be positive');
                return this.createModified({ top: top });
            };
            SemanticQuery.prototype.rewrite = function (exprRewriter) {
                var clauses = this.getClauses();
                SemanticQuery.rewriteClauses(clauses, exprRewriter);
                return this.createModified(clauses);
            };
            SemanticQuery.prototype.getClauses = function () {
                return {
                    from: this.fromValue,
                    where: this.whereItems,
                    orderBy: this.orderByItems,
                    select: this.selectItems,
                    groupBy: this.groupByItems,
                    transforms: this.transformItems,
                    top: this.topValue
                };
            };
            /**
             * Use the given expression rewriter to rewrite all the semantic query clauses which contain expressions.
             *
             * Contract: The passed in SemanticQueryClauses will be modified.  However, none of the collections within
             * it will be modified.  Instead, they will be replaced by new collections, if necessary.
             */
            SemanticQuery.rewriteClauses = function (clauses, exprRewriter) {
                var rewriter = new data.SemanticQueryRewriter(exprRewriter);
                clauses.from = rewriter.rewriteFrom(clauses.from);
                clauses.where = rewriter.rewriteWhere(clauses.where, clauses.from);
                clauses.orderBy = rewriter.rewriteOrderBy(clauses.orderBy, clauses.from);
                clauses.select = rewriter.rewriteSelect(clauses.select, clauses.from);
                clauses.groupBy = rewriter.rewriteGroupBy(clauses.groupBy, clauses.from);
                clauses.transforms = rewriter.rewriteTransform(clauses.transforms, clauses.from);
            };
            SemanticQuery.equals = function (x, y) {
                debug.assertValue(x, 'x SemanticQuery');
                debug.assertValue(y, 'y SemanticQuery');
                return x.from().equals(y.from())
                    && ArrayExtensions.sequenceEqual(x.where(), y.where(), data.SQFilter.equals)
                    && ArrayExtensions.sequenceEqual(x.orderBy(), y.orderBy(), data.SQUtils.sqSortDefinitionEquals)
                    && ArrayExtensions.sequenceEqual(x.select(), y.select(), data.SQUtils.namedSQExprEquals)
                    && ArrayExtensions.sequenceEqual(x.groupBy(), y.groupBy(), data.SQUtils.namedSQExprEquals)
                    && ArrayExtensions.sequenceEqual(x.transforms(), y.transforms(), data.SQUtils.sqTransformEquals)
                    && x.top() === y.top();
            };
            return SemanticQuery;
        }());
        data.SemanticQuery = SemanticQuery;
        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */
        var SemanticFilter = /** @class */ (function () {
            function SemanticFilter(from, where) {
                debug.assertValue(from, 'from');
                debug.assertValue(where, 'where');
                this.fromValue = from;
                this.whereItems = where;
            }
            SemanticFilter.fromSQExpr = function (condition) {
                return SemanticFilter.fromSQFromAndSQExpr(new data.SQFrom(), condition);
            };
            SemanticFilter.fromSQFromAndSQExpr = function (from, condition) {
                debug.assertValue(from, 'from');
                debug.assertValue(condition, 'condition');
                // Note:  Any subqueries referenced by condition must already be contained in from
                var rewrittenCondition = SQExprRewriterWithSourceRenames.rewrite(condition, from, from);
                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.
                //         Thus not setting a target here.
                var where = [{
                        condition: rewrittenCondition
                    }];
                return new SemanticFilter(from, where);
            };
            SemanticFilter.fromSQFromAndSQFilters = function (from, where) {
                return new SemanticFilter(from, where);
            };
            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {
                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());
            };
            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {
                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());
            };
            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {
                debug.assertValue(fieldSQExprs, 'fieldSQExprs');
                debug.assertValue(value, 'value');
                if (fieldSQExprs instanceof Array) {
                    var values = Array.apply(null, Array(fieldSQExprs.length)).map((function () { return value; }));
                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));
                }
                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));
            };
            SemanticFilter.prototype.from = function () {
                return this.fromValue.clone();
            };
            SemanticFilter.prototype.conditions = function () {
                var expressions = [];
                var where = this.whereItems;
                for (var i = 0, len = where.length; i < len; i++) {
                    var filter = where[i];
                    expressions.push(filter.condition);
                }
                return expressions;
            };
            SemanticFilter.prototype.where = function () {
                var result = [];
                var whereItems = this.whereItems;
                for (var i = 0, len = whereItems.length; i < len; i++)
                    result.push(whereItems[i]);
                return result;
            };
            SemanticFilter.prototype.rewrite = function (exprRewriter) {
                var rewriter = new data.SemanticQueryRewriter(exprRewriter);
                var from = rewriter.rewriteFrom(this.fromValue);
                var where = rewriter.rewriteWhere(this.whereItems, from);
                return new SemanticFilter(from, where);
            };
            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {
                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);
                this.rewrite(validator);
                return validator.errors;
            };
            /** Merges a list of SemanticFilters into one. */
            SemanticFilter.merge = function (filters) {
                if (_.isEmpty(filters))
                    return null;
                if (filters.length === 1)
                    return filters[0];
                var firstFilter = filters[0];
                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);
                for (var i = 1, len = filters.length; i < len; i++)
                    SemanticFilter.applyFilter(filters[i], from, where);
                return new SemanticFilter(from, where);
            };
            SemanticFilter.isDefaultFilter = function (filter) {
                if (!filter || filter.where().length !== 1)
                    return false;
                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);
            };
            SemanticFilter.isAnyFilter = function (filter) {
                if (!filter || filter.where().length !== 1)
                    return false;
                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);
            };
            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {
                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {
                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))
                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));
                }
                return false;
            };
            SemanticFilter.applyFilter = function (filter, from, where) {
                debug.assertValue(filter, 'filter');
                debug.assertValue(from, 'from');
                debug.assertValue(where, 'where');
                // Where
                var filterWhereItems = filter.whereItems;
                for (var _i = 0, filterWhereItems_1 = filterWhereItems; _i < filterWhereItems_1.length; _i++) {
                    var filterWhereItem = filterWhereItems_1[_i];
                    var updatedWhereItem = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, filter.fromValue, from),
                    };
                    if (filterWhereItem.target)
                        updatedWhereItem.target = _.map(filterWhereItem.target, (function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, filter.fromValue, from); }));
                    where.push(updatedWhereItem);
                }
            };
            return SemanticFilter;
        }());
        data.SemanticFilter = SemanticFilter;
        var SQExprRewriterWithSourceRenames = /** @class */ (function (_super) {
            __extends(SQExprRewriterWithSourceRenames, _super);
            function SQExprRewriterWithSourceRenames(sourceFrom, destinationFrom) {
                var _this = this;
                debug.assertValue(destinationFrom, 'destinationFrom');
                _this = _super.call(this) || this;
                _this.sourceFrom = sourceFrom;
                _this.destinationFrom = destinationFrom;
                return _this;
            }
            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {
                var existingDestinationSource = this.destinationFrom.source(expr.variable);
                if (existingDestinationSource &&
                    data.isSQFromEntitySource(existingDestinationSource) &&
                    existingDestinationSource.schema === expr.schema &&
                    existingDestinationSource.entity === expr.entity)
                    return expr;
                var resultOfEnsure = this.destinationFrom.ensureSource(new data.SQFromEntitySource(expr.schema, expr.entity), expr.variable);
                if (resultOfEnsure.name !== expr.variable)
                    return new data.SQEntityExpr(expr.schema, expr.entity, resultOfEnsure.name);
                return expr;
            };
            SQExprRewriterWithSourceRenames.prototype.visitSubqueryRef = function (expr) {
                if (!this.sourceFrom) {
                    // If this assert fires, it means that a subquery reference is being used in a code path that does not currently
                    // support subqueries.  In particular, many code paths currently take SQExprs to be added to a SemanticQuery, with
                    // the assumption that the SemanticQuery's From clause will automatically be updated to include any sources
                    // referenced by the SQExpr.  This works for entity sources, since the SQEntityExpr contains the full description
                    // of the entity source.  However, SQSubqueryRefExprs contain only references to SQFromSubquerySources; they
                    // do not contain the full subquery.  Therefore, we cannot automatically update the From clause for subqueries.
                    //
                    // In order to support subqueries, a code path must take both an SQExpr and a source From clause in which any
                    // referenced subquery can be looked up.  Once we have this, then the destination SemanticQuery's From clause
                    // can be updated appropriately.
                    debug.assertFail('A source From clause must be provided to rewrite an expression containing a subquery reference.');
                    return expr;
                }
                var sourceSource = this.sourceFrom.source(expr.variable);
                var existingDestinationSource = this.destinationFrom.source(expr.variable);
                if (existingDestinationSource &&
                    data.isSQFromSubquerySource(existingDestinationSource) &&
                    SemanticQuery.equals(sourceSource.subquery, existingDestinationSource.subquery))
                    return expr;
                var resultOfEnsure = this.destinationFrom.ensureSource(new data.SQFromSubquerySource(sourceSource.subquery), expr.variable);
                if (resultOfEnsure.name !== expr.variable)
                    return new data.SQSubqueryRefExpr(resultOfEnsure.name);
                return expr;
            };
            SQExprRewriterWithSourceRenames.prototype.visitNamedQueryRef = function (expr) {
                var existingDestinationSource = this.destinationFrom.source(expr.variable);
                if (existingDestinationSource && data.isSQFromExprSource(existingDestinationSource)) {
                    var sourceExpr = existingDestinationSource.expr;
                    if (data.SQExpr.equals(sourceExpr, expr))
                        return expr;
                }
                var resultOfEnsure = this.destinationFrom.ensureSource(new data.SQFromExprSource(expr), expr.variable);
                if (resultOfEnsure.name !== expr.variable)
                    return new data.SQNamedQueryRefExpr(expr.queryName, resultOfEnsure.name);
            };
            /** Searches through an expression for source references.  Ensures that those source
             * references exist in the destination From clause, and if necessary, renames them to
             * avoid collision with existing entries in the destination From clause.
             *
             * @param expr - Expression in which to search for source references
             * @param sourceFrom - From clause that expr is originally associated with
             * @param destinationFrom - From clause that expr will be associated with after renames
             */
            SQExprRewriterWithSourceRenames.rewrite = function (expr, sourceFrom, destinationFrom) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(destinationFrom, 'destinationFrom');
                var rewriter = new SQExprRewriterWithSourceRenames(sourceFrom, destinationFrom);
                return expr.accept(rewriter);
            };
            return SQExprRewriterWithSourceRenames;
        }(data.SQExprRewriter));
        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;
        /** Visitor for finding unreferenced sources. */
        var UnreferencedKeyFinder = /** @class */ (function (_super) {
            __extends(UnreferencedKeyFinder, _super);
            function UnreferencedKeyFinder(keys) {
                var _this = this;
                debug.assertValue(keys, 'keys');
                _this = _super.call(this) || this;
                _this.keys = keys;
                return _this;
            }
            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {
                this.removeKey(expr.variable);
            };
            UnreferencedKeyFinder.prototype.visitSubqueryRef = function (expr) {
                this.removeKey(expr.variable);
            };
            UnreferencedKeyFinder.prototype.visitNamedQueryRef = function (expr) {
                this.removeKey(expr.variable);
            };
            UnreferencedKeyFinder.prototype.removeKey = function (key) {
                var index = this.keys.indexOf(key);
                if (index >= 0)
                    this.keys.splice(index, 1);
            };
            UnreferencedKeyFinder.prototype.result = function () {
                return this.keys;
            };
            return UnreferencedKeyFinder;
        }(data.DefaultSQExprVisitorWithTraversal));
        /**
         * Renames sources within all subqueries, if necessary, to avoid conflicts with the given set of already used source names.
         *
         * Returns a rewritten from clause with normalized subqueries, and also updates the collection of used names to include those
         * used in subqueries.
         */
        var SubquerySourceRenamer = /** @class */ (function () {
            function SubquerySourceRenamer(renameSources, from, usedSourceNames) {
                this.renameSources = renameSources;
                this.from = from;
                this.usedSourceNames = usedSourceNames;
                debug.assertValue(renameSources, 'renameSources');
                debug.assertValue(from, 'from');
                debug.assertValue(usedSourceNames, 'usedSourceNames');
            }
            SubquerySourceRenamer.renameSources = function (renameSources, from, usedSourceNames) {
                var renamer = new SubquerySourceRenamer(renameSources, from, usedSourceNames);
                return data.SemanticQueryRewriter.rewriteFrom(from, renamer);
            };
            SubquerySourceRenamer.prototype.visitEntity = function (source, key) {
                return source;
            };
            SubquerySourceRenamer.prototype.visitSubquery = function (source, key) {
                var originalSubquery = source.subquery, rewrittenSubquery = this.renameSources(originalSubquery, this.usedSourceNames);
                if (rewrittenSubquery === originalSubquery)
                    return source;
                return new data.SQFromSubquerySource(rewrittenSubquery);
            };
            SubquerySourceRenamer.prototype.visitExpr = function (source, key) {
                return source;
            };
            return SubquerySourceRenamer;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var SQFilter;
        (function (SQFilter) {
            /**
             * Returns true if leftFilter and rightFilter have the same target and condition.
             */
            function equals(leftFilter, rightFilter) {
                debug.assertAnyValue(leftFilter, 'leftFilter');
                debug.assertAnyValue(rightFilter, 'rightFilter');
                // Normalize falsy to null
                if (!leftFilter) {
                    leftFilter = null;
                }
                if (!rightFilter) {
                    rightFilter = null;
                }
                if (leftFilter === rightFilter) {
                    return true;
                }
                if (!!leftFilter !== !!rightFilter) {
                    return false;
                }
                if (!targetsEqual(leftFilter, rightFilter)) {
                    return false;
                }
                return data.SQExpr.equals(leftFilter.condition, rightFilter.condition);
            }
            SQFilter.equals = equals;
            /**
             * Returns true if leftFilter and rightFilter have the same target.
             */
            function targetsEqual(leftFilter, rightFilter) {
                debug.assertValue(leftFilter, 'leftFilter');
                debug.assertValue(rightFilter, 'rightFilter');
                return ArrayExtensions.sequenceEqual(leftFilter.target, rightFilter.target, data.SQExpr.equals);
            }
            SQFilter.targetsEqual = targetsEqual;
            function contains(filters, searchTarget) {
                debug.assertAnyValue(filters, 'filters');
                debug.assertValue(searchTarget, 'searchTarget');
                return !_.isEmpty(filters) &&
                    _.any(filters, (function (filter) { return equals(filter, searchTarget); }));
            }
            SQFilter.contains = contains;
        })(SQFilter = data.SQFilter || (data.SQFilter = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 31*  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var SQUtils;
        (function (SQUtils) {
            function sqSortDefinitionEquals(left, right) {
                if (!left && !right)
                    return true;
                if (left && right) {
                    return left.direction === right.direction && data.SQExpr.equals(left.expr, right.expr);
                }
                return false;
            }
            SQUtils.sqSortDefinitionEquals = sqSortDefinitionEquals;
            function namedSQExprEquals(left, right) {
                if (!left && !right)
                    return true;
                // ignores name of NamedSQExpr
                if (left && right) {
                    return data.SQExpr.equals(left.expr, right.expr);
                }
                return false;
            }
            SQUtils.namedSQExprEquals = namedSQExprEquals;
            function sqTransformTableColumnsEquals(left, right) {
                if (!left && !right)
                    return true;
                if (left && right) {
                    return left.role === right.role && namedSQExprEquals(left.expression, right.expression);
                }
                return false;
            }
            SQUtils.sqTransformTableColumnsEquals = sqTransformTableColumnsEquals;
            function sqTransformTableEquals(left, right) {
                if (!left && !right)
                    return true;
                if (left && right) {
                    return ArrayExtensions.sequenceEqual(left.columns, right.columns, (function (left, right) { return sqTransformTableColumnsEquals(left, right); }));
                }
                return false;
            }
            SQUtils.sqTransformTableEquals = sqTransformTableEquals;
            function sqTransformInputEquals(left, right) {
                if (!left && !right)
                    return true;
                if (left && right) {
                    return ArrayExtensions.sequenceEqual(left.parameters, right.parameters, (function (left, right) { return namedSQExprEquals(left, right); }))
                        && sqTransformTableEquals(left.table, right.table);
                }
                return false;
            }
            SQUtils.sqTransformInputEquals = sqTransformInputEquals;
            function sqTransformOutputEquals(left, right) {
                if (!left && !right)
                    return true;
                if (left && right) {
                    return sqTransformTableEquals(left.table, right.table);
                }
                return false;
            }
            SQUtils.sqTransformOutputEquals = sqTransformOutputEquals;
            function sqTransformEquals(left, right) {
                if (!left && !right)
                    return true;
                if (left && right) {
                    return left.algorithm === right.algorithm &&
                        sqTransformInputEquals(left.input, right.input) &&
                        sqTransformOutputEquals(left.output, right.output);
                }
                return false;
            }
            SQUtils.sqTransformEquals = sqTransformEquals;
        })(SQUtils = data.SQUtils || (data.SQUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewTransform = powerbi.data.DataViewTransform;
        var SQExprBuilder = powerbi.data.SQExprBuilder;
        function createCategoricalDataViewBuilder() {
            return new CategoricalDataViewBuilder();
        }
        data.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;
        var CategoricalDataViewBuilder = /** @class */ (function () {
            function CategoricalDataViewBuilder() {
                this.categories = [];
                this.staticMeasureColumns = [];
                this.dynamicMeasureColumns = [];
                this.columnIndex = 0;
            }
            CategoricalDataViewBuilder.prototype.withCategory = function (options) {
                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;
                var categoryColumn = {
                    source: options.source,
                    identityFields: options.identityFrom.fields,
                    identity: options.identityFrom.identities || [],
                    values: categoryValues,
                };
                if (!options.identityFrom.identities) {
                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {
                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));
                    }
                }
                if (!this.categories)
                    this.categories = [];
                this.categories.push(categoryColumn);
                return this;
            };
            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {
                if (_.isEmpty(this.categories))
                    this.categories = categories;
                else
                    Array.prototype.push.apply(this.categories, categories);
                return this;
            };
            /**
             * Adds static series columns.
             *
             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in
             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.
             */
            CategoricalDataViewBuilder.prototype.withValues = function (options) {
                debug.assertValue(options, 'options');
                var columns = options.columns;
                debug.assertValue(columns, 'columns');
                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {
                    var column = columns_8[_i];
                    this.staticMeasureColumns.push(column.source);
                }
                this.staticSeriesValues = columns;
                return this;
            };
            /**
             * Adds dynamic series columns.
             *
             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in
             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.
             */
            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {
                debug.assertValue(options, 'options');
                var groupColumn = options.groupColumn;
                debug.assertValue(groupColumn, 'groupColumn');
                this.dynamicSeriesMetadata = {
                    column: groupColumn.source,
                    identityFrom: groupColumn.identityFrom,
                    values: groupColumn.values,
                };
                var valueColumns = options.valueColumns;
                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {
                    var valueColumn = valueColumns_1[_i];
                    this.dynamicMeasureColumns.push(valueColumn.source);
                }
                this.dynamicSeriesValues = options.data;
                return this;
            };
            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues) {
                var categoryColumn = _.first(this.categories);
                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 0;
                if (this.hasDynamicSeries()) {
                    for (var seriesIndex = 0, seriesLength = this.dynamicSeriesMetadata.values.length; seriesIndex < seriesLength; seriesIndex++) {
                        var seriesMeasures = this.dynamicSeriesValues[seriesIndex];
                        debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');
                        for (var measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {
                            var groupIndex = seriesIndex * measuresLen + measureIndex;
                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);
                        }
                    }
                }
                if (this.hasStaticSeries()) {
                    // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.
                    var staticColumnsStartingIndex = this.hasDynamicSeries() ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;
                    for (var measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {
                        applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);
                    }
                }
            };
            /**
             * Returns the DataView with metadata and DataViewCategorical.
             * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.
             */
            CategoricalDataViewBuilder.prototype.build = function () {
                var metadataColumns = [];
                var categorical = {};
                var categoryMetadata = this.categories;
                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;
                // --- Build metadata columns and value groups ---
                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {
                    var columnMetadata = categoryMetadata_1[_i];
                    pushIfNotExists(metadataColumns, columnMetadata.source);
                }
                if (this.hasDynamicSeries()) {
                    // Dynamic series, or Dyanmic & Static series.
                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);
                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);
                    // For each series value we will make one column per measure
                    var seriesValues = dynamicSeriesMetadata.values;
                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {
                        var seriesValue = seriesValues[seriesIndex];
                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);
                        for (var _a = 0, _b = this.dynamicMeasureColumns; _a < _b.length; _a++) {
                            var measure = _b[_a];
                            // Note related to VSTS 7705322: It is possible that the 'measure' object is part of visual DataView with prototypal inheritance,
                            // in which case _.clone() would not copy any inherited properties. Meanwhile, this builder class can also be used for building
                            // query DataView, hence this code should not produce an inherited object from 'measure'.
                            var column = _.toPlainObject(measure);
                            column.groupName = seriesValue;
                            pushIfNotExists(metadataColumns, column);
                            categorical.values.push({
                                source: column,
                                values: [],
                                identity: seriesIdentity,
                            });
                        }
                    }
                    // If there is no data we should add a column that contains a pointer to the dynamic measure columns, for consistency with the dsrReader
                    if (seriesValues.length === 0) {
                        for (var _c = 0, _d = this.dynamicMeasureColumns; _c < _d.length; _c++) {
                            var measure = _d[_c];
                            // Note related to VSTS 7705322: Read previous note
                            var column = _.toPlainObject(measure);
                            pushIfNotExists(metadataColumns, column);
                            categorical.values.push({ source: column, values: [] });
                        }
                    }
                    if (this.hasStaticSeries()) {
                        // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of production code that creates query DataView objects.
                        // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.
                        // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.
                        var dynamicSeriesGroups_1 = categorical.values.grouped();
                        categorical.values.grouped = function () { return dynamicSeriesGroups_1; };
                        this.appendStaticMeasureColumns(metadataColumns, categorical.values);
                    }
                }
                else {
                    // Static series only / no series
                    categorical.values = DataViewTransform.createValueColumns();
                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);
                }
                var categories = this.categories;
                if (!_.isEmpty(categories))
                    categorical.categories = categories;
                // --- Fill in data point values ---
                this.fillData(categorical.values);
                var dataView = {
                    metadata: {
                        columns: metadataColumns,
                    },
                    categorical: categorical,
                };
                if (this.isLegalDataView(dataView)) {
                    return dataView;
                }
            };
            CategoricalDataViewBuilder.prototype.appendStaticMeasureColumns = function (metadataColumns, valueColumns) {
                debug.assertValue(metadataColumns, 'metadataColumns');
                debug.assertValue(valueColumns, 'valueColumns');
                if (!_.isEmpty(this.staticMeasureColumns)) {
                    for (var _i = 0, _a = this.staticMeasureColumns; _i < _a.length; _i++) {
                        var column = _a[_i];
                        pushIfNotExists(metadataColumns, column);
                        valueColumns.push({
                            source: column,
                            values: [],
                        });
                    }
                }
            };
            CategoricalDataViewBuilder.prototype.isLegalDataView = function (dataView) {
                if (this.hasDynamicSeries() && this.hasStaticSeries() && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {
                    // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,
                    // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).
                    return false;
                }
                return true;
            };
            /**
             * This function infers that if any metadata column has 'queryName',
             * then the user of this builder is building a visual DataView (as opposed to query DataView).
             *
             * @param metadataColumns The complete collection of metadata columns in the categorical.
             */
            CategoricalDataViewBuilder.isVisualDataView = function (metadataColumns) {
                return !_.isEmpty(metadataColumns) &&
                    _.any(metadataColumns, (function (metadataColumn) { return !!metadataColumn.queryName; }));
            };
            CategoricalDataViewBuilder.prototype.hasDynamicSeries = function () {
                return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns
            };
            CategoricalDataViewBuilder.prototype.hasStaticSeries = function () {
                return !!this.staticSeriesValues;
            };
            return CategoricalDataViewBuilder;
        }());
        function getScopeIdentity(source, index, value, valueType) {
            var identities = source.identities;
            if (identities) {
                return identities[index];
            }
            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');
            return data.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));
        }
        function pushIfNotExists(items, itemToAdd) {
            if (_.contains(items, itemToAdd))
                return;
            items.push(itemToAdd);
        }
        function applySeriesData(target, source, categoryLength) {
            debug.assertValue(target, 'target');
            debug.assertValue(source, 'source');
            debug.assertValue(categoryLength, 'categoryLength');
            var values = source.values;
            debug.assert(categoryLength === values.length || categoryLength === 0, 'categoryLength === values.length || categoryLength === 0');
            target.values = values;
            var highlights = source.highlights;
            if (highlights) {
                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');
                target.highlights = highlights;
            }
            var aggregates;
            if (source.minLocal !== undefined) {
                if (!aggregates)
                    aggregates = {};
                aggregates.minLocal = source.minLocal;
            }
            if (source.maxLocal !== undefined) {
                if (!aggregates)
                    aggregates = {};
                aggregates.maxLocal = source.maxLocal;
            }
            if (aggregates) {
                target.source.aggregates = aggregates;
                _.extend(target, aggregates);
            }
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExpr = powerbi.data.SQExpr;
        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms, themeColors) {
            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), themeColors, dataView || { metadata: { columns: [] } }, selectTransforms);
        }
        data.createStaticEvalContext = createStaticEvalContext;
        /**
         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects
         * are supported.
         */
        var StaticEvalContext = /** @class */ (function () {
            function StaticEvalContext(colorAllocatorCache, themeColors, dataView, selectTransforms) {
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                debug.assertAnyValue(themeColors, 'themeColors'); // TODO: should be mandatory
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                this.colorAllocatorCache = colorAllocatorCache;
                this.dataView = dataView;
                this.selectTransforms = selectTransforms;
                this.themeColors = themeColors;
            }
            StaticEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorCache.get(expr);
            };
            StaticEvalContext.prototype.getThemeColor = function (colorIdx) {
                var themeColors = this.themeColors;
                if (themeColors)
                    return themeColors.get(colorIdx);
            };
            StaticEvalContext.prototype.getExprValue = function (expr) {
                var dataView = this.dataView, selectTransforms = this.selectTransforms;
                if (!dataView || !selectTransforms)
                    return;
                if (SQExpr.isAggregation(expr) || SQExpr.isPercentile(expr) || SQExpr.isMeasure(expr)) {
                    var columnAggregate = findAggregateValue(expr, selectTransforms, dataView.metadata.columns);
                    if (columnAggregate !== undefined) {
                        return columnAggregate;
                    }
                }
                if (dataView.table && !_.isEmpty(dataView.table.columns) && !_.isEmpty(dataView.table.rows))
                    return getExprValueFromTable(expr, selectTransforms, dataView.table.columns, dataView.table.rows[0]);
            };
            StaticEvalContext.prototype.getRoleValues = function (roleName) {
                return;
            };
            return StaticEvalContext;
        }());
        function getExprValueFromTable(expr, selectTransforms, tableColumns, tableRow) {
            debug.assertValue(expr, 'expr');
            debug.assertValue(selectTransforms, 'selectTransforms');
            debug.assertNonEmpty(tableColumns, 'tableColumns');
            debug.assertValue(tableRow, 'tableRow');
            debug.assert(tableColumns.length === tableRow.length, 'Columns do not match Row cells');
            var selectIdx = data.DataViewSelectTransform.findExprSelectIndex(expr, selectTransforms);
            if (selectIdx < 0)
                return;
            var columnIdx = _.findIndex(tableColumns, (function (column) { return column.index === selectIdx; }));
            if (columnIdx < 0)
                return;
            if (SQExpr.isSelectRef(expr) && expr.attributeKind === 0 /* FormatString */) {
                // Get the format string column index
                var column = tableColumns[columnIdx];
                var formatStringColumn = column.formatSource && column.formatSource.formatString;
                columnIdx = tableColumns.indexOf(formatStringColumn);
                if (columnIdx < 0)
                    return;
            }
            return tableRow[columnIdx];
        }
        data.getExprValueFromTable = getExprValueFromTable;
        function findAggregateValue(expr, selectTransforms, columns) {
            debug.assertValue(expr, 'expr');
            debug.assertValue(selectTransforms, 'selectTransforms');
            debug.assertValue(columns, 'columns');
            var isSelfAggregate;
            var selectIdx = data.DataViewSelectTransform.findExprSelectIndex(expr, selectTransforms);
            if (selectIdx < 0 && !SQExpr.isMeasure(expr)) {
                selectIdx = data.DataViewSelectTransform.findExprSelectIndex(expr.arg, selectTransforms);
                if (selectIdx < 0) {
                    return;
                }
            }
            else {
                isSelfAggregate = true;
            }
            var column = _.find(columns, (function (column) { return column.index === selectIdx && column.aggregates; }));
            if (!column)
                return;
            var columnAggr = column.aggregates;
            var aggregateValue = isSelfAggregate ? columnAggr.single : findAggregates(columnAggr, expr);
            if (aggregateValue !== undefined)
                return aggregateValue;
        }
        function findAggregates(aggregates, expr) {
            debug.assertValue(aggregates, 'aggregates');
            debug.assertValue(expr, 'expr');
            if (SQExpr.isPercentile(expr)) {
                var percentile = _.find(aggregates.percentiles, (function (percentile) {
                    if (percentile.k === expr.k) {
                        var isExclusive = !!percentile.exclusive;
                        return expr.exclusive === isExclusive;
                    }
                }));
                if (percentile)
                    return percentile.value;
            }
            else if (SQExpr.isAggregation(expr)) {
                debug.assertValue(expr.func, 'func');
                switch (expr.func) {
                    case 3 /* Min */:
                        return getOptional(aggregates.min, aggregates.minLocal);
                    case 4 /* Max */:
                        return getOptional(aggregates.max, aggregates.maxLocal);
                    case 6 /* Median */:
                        return aggregates.median;
                    case 1 /* Avg */:
                        return aggregates.average;
                }
            }
        }
        function getOptional(value1, value2) {
            debug.assertAnyValue(value1, 'value1');
            debug.assertAnyValue(value2, 'value2');
            if (value1 !== undefined)
                return value1;
            return value2;
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExpr = powerbi.data.SQExpr;
        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {
            return new MatrixEvalContext(colorAllocatorProvider, dataViewMatrix);
        }
        data.createMatrixEvalContext = createMatrixEvalContext;
        var MatrixEvalContext = /** @class */ (function () {
            function MatrixEvalContext(colorAllocatorProvider, dataView) {
                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');
                debug.assertValue(dataView, 'dataView');
                this.colorAllocatorProvider = colorAllocatorProvider;
                this.dataView = dataView;
                if (dataView)
                    this.valueSourcesQueryNames = _.map(dataView.valueSources, (function (source) { return source.queryName; }));
            }
            MatrixEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorProvider.get(expr);
            };
            MatrixEvalContext.prototype.getExprValue = function (expr) {
                debug.assertValue(expr, "matrixEvalContext - Undefined expr");
                // Currently we only support expr which references the value node itself
                // But the current context has the columnNode and rowNode
                if (!SQExpr.isSelectRef(expr)) {
                    debug.assertFail("matrixEvalContext - Only Select Ref exprs are supported");
                    return;
                }
                else {
                    if (this.valueNode) {
                        return this.evaluateValue(expr);
                    }
                    else {
                        if (this.rowPath) {
                            return this.evaluateRowHeader(expr);
                        }
                        else if (this.columnPath) {
                            return this.evaluateColumnHeader(expr);
                        }
                    }
                }
                debug.assertFail("getExprValue - context is empty");
            };
            MatrixEvalContext.prototype.evaluateValue = function (expr) {
                debug.assertValue(this.rowPath, "matrixEvalContext.evaluateValue - Undefined this.rowNode");
                debug.assertValue(this.columnPath, "matrixEvalContext.evaluateValue - Undefined this.columnNode");
                var valueSources = this.dataView.valueSources;
                var currentValueColumnIndex = this.valueNode.valueSourceIndex || 0;
                var exprValueSourceIndex;
                exprValueSourceIndex = _.findIndex(valueSources, (function (source) { return source.queryName === expr.expressionName; }));
                if (exprValueSourceIndex < 0)
                    return;
                var exprColumn = valueSources[exprValueSourceIndex];
                if (expr.attributeKind === 0 /* FormatString */ &&
                    exprColumn.formatSource &&
                    exprColumn.formatSource.formatString) {
                    exprValueSourceIndex = _.findIndex(valueSources, (function (source) { return source === exprColumn.formatSource.formatString; }));
                }
                if (exprValueSourceIndex === currentValueColumnIndex) {
                    return this.valueNode.value;
                }
                else {
                    // Expr refers to another ValueSource, move within siblings by the difference in valueSourceIndex
                    var exprColumnLeafIndex = (exprValueSourceIndex - currentValueColumnIndex) + this.columnLeafIndex;
                    var exprValueNode = _.last(this.rowPath).values[exprColumnLeafIndex];
                    return exprValueNode ? exprValueNode.value : undefined;
                }
            };
            MatrixEvalContext.prototype.evaluateRowHeader = function (expr) {
                debug.assert(!this.columnPath, "matrixEvalContext.evaluateRowHeader - context has columnNode");
                debug.assert(!this.valueNode, "matrixEvalContext.evaluateRowHeader - context has value");
                // Properly handle evaluating an Expr
                debug.assertFail("matrixEvalContext.evaluateRowHeader - only constant exprs are supported");
                return;
            };
            MatrixEvalContext.prototype.evaluateColumnHeader = function (expr) {
                debug.assert(!this.rowPath, "matrixEvalContext.evaluateColumnHeader - context has rowNode");
                debug.assert(!this.valueNode, "matrixEvalContext.evaluateColumnHeader - context has value");
                // Properly handle evaluating an Expr
                debug.assertFail("matrixEvalContext.evaluateColumnHeader - only constant exprs are supported");
                return;
            };
            MatrixEvalContext.prototype.getRoleValues = function (roleName) {
                debug.assert(!this.columnPath || !this.valueNode, 'getRoleValues returns values for row groupings only');
                // To return the right values for column groupings/sub totals, this method could take in a Selector to narrow down the target values
                var rowNode = _.last(this.rowPath);
                if (!rowNode || rowNode.isSubtotal)
                    return;
                var valueSources = this.dataView.valueSources;
                var roleValues = [];
                for (var index = 0, len = valueSources.length; index < len; index++) {
                    if (data.DataRoleHelper.hasRole(valueSources[index], roleName))
                        roleValues.push(rowNode.values[index].value);
                }
                if (roleValues.length > 0)
                    return roleValues;
            };
            MatrixEvalContext.prototype.setCurrentContext = function (valueNode, rowPath, columnPath, columnLeafIndex) {
                this.valueNode = valueNode;
                this.columnPath = columnPath;
                this.columnLeafIndex = columnLeafIndex;
                this.rowPath = rowPath;
                if (this.valueNode)
                    debug.assert(this.columnLeafIndex != null && this.columnLeafIndex >= 0, 'MatrixEvalContext.setCurrentContext - invalid columnLeafIndex');
            };
            MatrixEvalContext.prototype.getDataView = function () {
                return this.dataView;
            };
            MatrixEvalContext.prototype.getValueSourcesQueryNames = function () {
                return this.valueSourcesQueryNames;
            };
            MatrixEvalContext.prototype.getRowPath = function () {
                return this.rowPath;
            };
            MatrixEvalContext.prototype.getColumnPath = function () {
                return this.columnPath;
            };
            MatrixEvalContext.prototype.getIntersection = function () {
                return this.valueNode;
            };
            return MatrixEvalContext;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi_1) {
    var StringExtensions = jsCommon.StringExtensions;
    var Formatting = jsCommon.Formatting;
    var RegExpExtensions = jsCommon.RegExpExtensions;
    /** Formatting Encoder */
    var FormattingEncoder;
    (function (FormattingEncoder) {
        // quoted and escaped literal patterns
        // NOTE: the final three cases match .NET behavior
        var literalPatterns = [
            "'[^']*'",
            '"[^"]*"',
            "\\\\.",
            "'[^']*$",
            '"[^"]*$',
            "\\\\$",
        ];
        var literalMatcher = new RegExp(literalPatterns.join("|"), "g");
        // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences
        function removeLiterals(format) {
            literalMatcher.lastIndex = 0;
            // just in case consecutive non-literals have some meaning
            return format.replace(literalMatcher, "\uE100");
        }
        FormattingEncoder.removeLiterals = removeLiterals;
        function preserveLiterals(format, literals) {
            literalMatcher.lastIndex = 0;
            for (;;) {
                var match = literalMatcher.exec(format);
                if (!match)
                    break;
                var literal = match[0];
                var literalOffset = literalMatcher.lastIndex - literal.length;
                var token = String.fromCharCode(0xE100 + literals.length);
                literals.push(literal);
                format = format.substr(0, literalOffset) + token + format.substr(literalMatcher.lastIndex);
                // back to avoid skipping due to removed literal substring
                literalMatcher.lastIndex = literalOffset + 1;
            }
            return format;
        }
        FormattingEncoder.preserveLiterals = preserveLiterals;
        function restoreLiterals(format, literals, quoted) {
            if (quoted === void 0) { quoted = true; }
            var count = literals.length;
            for (var i = 0; i < count; i++) {
                var token = String.fromCharCode(0xE100 + i);
                var literal = literals[i];
                if (!quoted) {
                    // caller wants literals to be re-inserted without escaping
                    var firstChar = literal[0];
                    if (firstChar === "\\" || literal.length === 1 || literal[literal.length - 1] !== firstChar) {
                        // either escaped literal OR quoted literal that's missing the trailing quote
                        // in either case we only remove the leading character
                        literal = literal.substring(1);
                    }
                    else {
                        // so must be a quoted literal with both starting and ending quote
                        literal = literal.substring(1, literal.length - 1);
                    }
                }
                format = format.replace(token, literal);
            }
            return format;
        }
        FormattingEncoder.restoreLiterals = restoreLiterals;
    })(FormattingEncoder || (FormattingEncoder = {}));
    var IndexedTokensRegex = /({{)|(}})|{(\d+[^}]*)}/g;
    var ZeroPlaceholder = '0';
    var DigitPlaceholder = '#';
    var ExponentialFormatChar = 'E';
    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];
    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');
    /** Formatting Service */
    var FormattingService = /** @class */ (function () {
        function FormattingService() {
        }
        FormattingService.prototype.formatValue = function (value, format, culture) {
            // Handle special cases
            if (value === undefined || value === null) {
                return '';
            }
            var gculture = this.getCulture(culture);
            if (DateTimeFormat.canFormat(value)) {
                // Dates
                return DateTimeFormat.format(value, format, gculture);
            }
            else if (NumberFormat.canFormat(value)) {
                // Numbers
                return NumberFormat.format(value, format, gculture);
            }
            else {
                // Other data types - return as string
                return value.toString();
            }
        };
        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {
            var _this = this;
            if (!formatWithIndexedTokens) {
                return "";
            }
            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, (function (match, left, right, argToken) {
                if (left) {
                    return "{";
                }
                else if (right) {
                    return "}";
                }
                else {
                    var parts = argToken.split(":");
                    var argIndex = parseInt(parts[0], 10);
                    var argFormat = parts[1];
                    return _this.formatValue(args[argIndex], argFormat, culture);
                }
            }));
            return result;
        };
        FormattingService.prototype.isStandardNumberFormat = function (format) {
            return NumberFormat.isStandardFormat(format);
        };
        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {
            var gculture = this.getCulture(culture);
            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);
        };
        FormattingService.prototype.dateFormatString = function (unit) {
            if (!this._dateTimeScaleFormatInfo)
                this.initialize();
            return this._dateTimeScaleFormatInfo.getFormatString(unit);
        };
        /**
         * Sets the current localization culture
         * @param cultureSelector - name of a culture: "en", "en-UK", "fr-FR" etc. (See National Language Support (NLS) for full lists. Use "default" for invariant culture).
         */
        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {
            if (this._currentCultureSelector !== cultureSelector) {
                this._currentCulture = this.getCulture(cultureSelector);
                this._currentCultureSelector = cultureSelector;
                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);
            }
        };
        /**
         * Gets the culture assotiated with the specified cultureSelector ("en", "en-US", "fr-FR" etc).
         * @param cultureSelector - name of a culture: "en", "en-UK", "fr-FR" etc. (See National Language Support (NLS) for full lists. Use "default" for invariant culture).
         * Exposing this function for testability of unsupported cultures
         */
        FormattingService.prototype.getCulture = function (cultureSelector) {
            if (cultureSelector == null) {
                if (this._currentCulture == null) {
                    this.initialize();
                }
                return this._currentCulture;
            }
            else {
                var culture = Globalize.findClosestCulture(cultureSelector);
                if (!culture)
                    culture = Globalize.culture("en-US");
                return culture;
            }
        };
        FormattingService.prototype.parseFloat = function (value) {
            return Globalize.parseFloat(value, this.getCulture());
        };
        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */
        FormattingService.prototype.initialize = function () {
            var cultureName = this.getCurrentCulture();
            this.setCurrentCulture(cultureName);
            var calendarName = this.getUrlParam("calendar");
            if (calendarName) {
                var culture = this._currentCulture;
                var c = culture.calendars[calendarName];
                if (c) {
                    culture.calendar = c;
                }
            }
        };
        /**
         *  Exposing this function for testability
         */
        FormattingService.prototype.getCurrentCulture = function () {
            var formattingLocale = window.navigator["userLanguage"] || window.navigator["language"] || Globalize.culture().name;
            if (powerbi.common) {
                formattingLocale = powerbi.common.formattingLocale || powerbi.common.cultureInfo || formattingLocale;
            }
            formattingLocale = this.getUrlParam("formatLocale") || this.getUrlParam("language") || formattingLocale;
            return formattingLocale;
        };
        /**
         *  Exposing this function for testability
         *  @param name: queryString name
         */
        FormattingService.prototype.getUrlParam = function (name) {
            var param = window.location.search.match(RegExp("[?&]" + name + "=([^&]*)"));
            return param ? param[1] : undefined;
        };
        return FormattingService;
    }());
    /**
     * DateTimeFormat module contains the static methods for formatting the DateTimes.
     * It extends the JQuery.Globalize functionality to support complete set of .NET
     * formatting expressions for dates.
     */
    var DateTimeFormat;
    (function (DateTimeFormat) {
        var _currentCachedFormat;
        var _currentCachedProcessedFormat;
        /** Evaluates if the value can be formatted using the NumberFormat */
        function canFormat(value) {
            var result = value instanceof Date;
            return result;
        }
        DateTimeFormat.canFormat = canFormat;
        /** Formats the date using provided format and culture */
        function format(value, format, culture) {
            format = format || "G";
            var isStandard = format.length === 1;
            try {
                if (isStandard) {
                    return formatDateStandard(value, format, culture);
                }
                else {
                    return formatDateCustom(value, format, culture);
                }
            }
            catch (e) {
                return formatDateStandard(value, "G", culture);
            }
        }
        DateTimeFormat.format = format;
        /** Formats the date using standard format expression */
        function formatDateStandard(value, format, culture) {
            // In order to provide parity with .NET we have to support additional set of DateTime patterns.
            var patterns = culture.calendar.patterns;
            // Extend supported set of patterns
            ensurePatterns(culture.calendar);
            // Handle extended set of formats
            var output = Formatting.findDateFormat(value, format, culture.name);
            if (output.format.length === 1)
                format = patterns[output.format];
            else
                format = output.format;
            //need to revisit when globalization is enabled
            culture = Globalize.culture("en-US");
            return Globalize.format(output.value, format, culture);
        }
        /** Formats the date using custom format expression */
        function formatDateCustom(value, format, culture) {
            var result;
            var literals = [];
            format = FormattingEncoder.preserveLiterals(format, literals);
            if (format.indexOf("F") > -1) {
                // F is not supported so we need to replace the F with f based on the milliseconds
                // Replace all sequences of F longer than 3 with "FFF"
                format = StringExtensions.replaceAll(format, "FFFF", "FFF");
                // Based on milliseconds update the format to use fff
                var milliseconds = value.getMilliseconds();
                if (milliseconds % 10 >= 1) {
                    format = StringExtensions.replaceAll(format, "FFF", "fff");
                }
                format = StringExtensions.replaceAll(format, "FFF", "FF");
                if ((milliseconds % 100) / 10 >= 1) {
                    format = StringExtensions.replaceAll(format, "FF", "ff");
                }
                format = StringExtensions.replaceAll(format, "FF", "F");
                if ((milliseconds % 1000) / 100 >= 1) {
                    format = StringExtensions.replaceAll(format, "F", "f");
                }
                format = StringExtensions.replaceAll(format, "F", "");
                if (format === "" || format === "%")
                    return "";
            }
            format = processCustomDateTimeFormat(format);
            result = Globalize.format(value, format, culture);
            result = localize(result, culture.calendar);
            result = FormattingEncoder.restoreLiterals(result, literals, false);
            return result;
        }
        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */
        function processCustomDateTimeFormat(format) {
            if (format === _currentCachedFormat) {
                return _currentCachedProcessedFormat;
            }
            _currentCachedFormat = format;
            format = Formatting.fixDateTimeFormat(format);
            _currentCachedProcessedFormat = format;
            return format;
        }
        /** Localizes the time separator symbol */
        function localize(value, dictionary) {
            var timeSeparator = dictionary[":"];
            if (timeSeparator === ":") {
                return value;
            }
            var result = "";
            var count = value.length;
            for (var i = 0; i < count; i++) {
                var char = value.charAt(i);
                switch (char) {
                    case ":":
                        result += timeSeparator;
                        break;
                    default:
                        result += char;
                        break;
                }
            }
            return result;
        }
        function ensurePatterns(calendar) {
            var patterns = calendar.patterns;
            if (patterns["g"] === undefined) {
                patterns["g"] = patterns["f"].replace(patterns["D"], patterns["d"]); // Generic: Short date, short time
                patterns["G"] = patterns["F"].replace(patterns["D"], patterns["d"]); // Generic: Short date, long time
            }
        }
    })(DateTimeFormat || (DateTimeFormat = {}));
    /**
     * NumberFormat module contains the static methods for formatting the numbers.
     * It extends the JQuery.Globalize functionality to support complete set of .NET
     * formatting expressions for numeric types including custom formats.
     */
    var NumberFormat;
    (function (NumberFormat) {
        var NonScientificFormatRegex = /^\{.+\}.*/;
        var NumericalPlaceHolderRegex = /\{.+\}/;
        var ScientificFormatRegex = /e[+-]*[0#]+/i;
        var StandardFormatRegex = /^[a-z]\d{0,2}$/i; // a letter + up to 2 digits for precision specifier
        var TrailingZerosRegex = /0+$/;
        var DecimalFormatRegex = /\.([0#]*)/g;
        var NumericFormatRegex = /[0#,\.]+[0,#]*/g;
        // (?=...) is a positive lookahead assertion. The RE is asking for the last digit placeholder, [0#],
        // which is followed by non-digit placeholders and the end of string, [^0#]*$. But it only matches
        // the last digit placeholder, not anything that follows because the positive lookahead isn't included
        // in the match - it is only a condition.
        var LastNumericPlaceholderRegex = /([0#])(?=[^0#]*$)/;
        var DecimalFormatCharacter = '.';
        NumberFormat.NumberFormatComponentsDelimeter = ';';
        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {
            if (!numericFormat || baseFormat === undefined)
                return baseFormat;
            var newFormat = "{0:" + numericFormat + "}";
            return baseFormat.replace("{0}", newFormat);
        }
        function getNumericFormat(value, baseFormat) {
            if (baseFormat == null)
                return baseFormat;
            if (hasFormatComponents(baseFormat)) {
                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;
                if (value > 0)
                    return getNumericFormatFromComponent(value, positive);
                else if (value === 0)
                    return getNumericFormatFromComponent(value, zero);
                return getNumericFormatFromComponent(value, negative);
            }
            return getNumericFormatFromComponent(value, baseFormat);
        }
        NumberFormat.getNumericFormat = getNumericFormat;
        function getNumericFormatFromComponent(value, format) {
            var match = RegExpExtensions.run(NumericFormatRegex, format);
            if (match)
                return match[0];
            return format;
        }
        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {
            if (decimals == null)
                return baseFormat;
            // Default format string
            if (baseFormat == null)
                baseFormat = ZeroPlaceholder;
            if (hasFormatComponents(baseFormat)) {
                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;
                var formats = [positive, negative, zero];
                for (var i = 0; i < formats.length; i++) {
                    // Update format in formats array
                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);
                }
                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);
            }
            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);
        }
        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;
        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {
            decimals = Math.abs(decimals);
            if (decimals >= 0) {
                var literals = [];
                format = FormattingEncoder.preserveLiterals(format, literals);
                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;
                var decimalPlaceholders = _.repeat(placeholder, Math.abs(decimals));
                var match = RegExpExtensions.run(DecimalFormatRegex, format);
                if (match) {
                    var beforeDecimal = format.substr(0, match.index);
                    var formatDecimal = format.substr(match.index + 1, match[1].length);
                    var afterDecimal = format.substr(match.index + match[0].length);
                    if (trailingZeros)
                        // Use explicit decimals argument as placeholders
                        formatDecimal = decimalPlaceholders;
                    else {
                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;
                        if (decimalChange > 0)
                            // Append decimalPlaceholders to existing decimal portion of format string
                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);
                        else if (decimalChange < 0)
                            // Remove decimals from formatDecimal
                            formatDecimal = formatDecimal.slice(0, decimalChange);
                    }
                    if (formatDecimal.length > 0)
                        formatDecimal = DecimalFormatCharacter + formatDecimal;
                    format = beforeDecimal + formatDecimal + afterDecimal;
                }
                else if (decimalPlaceholders.length > 0) {
                    // Replace last numeric placeholder with decimal portion
                    format = format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);
                }
                if (literals.length !== 0)
                    format = FormattingEncoder.restoreLiterals(format, literals);
            }
            return format;
        }
        function hasFormatComponents(format) {
            return FormattingEncoder.removeLiterals(format).indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;
        }
        NumberFormat.hasFormatComponents = hasFormatComponents;
        function getComponents(format) {
            var signFormat = {
                hasNegative: false,
                positive: format,
                negative: format,
                zero: format,
            };
            // escape literals so semi-colon in a literal isn't interpreted as a delimiter
            // NOTE: OK to use the literals extracted here for all three components before since the literals are indexed.
            // For example, "'pos-lit';'neg-lit'" will get preserved as "\uE000;\uE001" and the literal array will be
            // ['pos-lit', 'neg-lit']. When the negative components is restored, its \uE001 will select the second
            // literal.
            var literals = [];
            format = FormattingEncoder.preserveLiterals(format, literals);
            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);
            var formatCount = signSpecificFormats.length;
            if (formatCount > 1) {
                if (literals.length !== 0)
                    signSpecificFormats = _.map(signSpecificFormats, (function (signSpecificFormat) { return FormattingEncoder.restoreLiterals(signSpecificFormat, literals); }));
                signFormat.hasNegative = true;
                signFormat.positive = signFormat.zero = signSpecificFormats[0];
                signFormat.negative = signSpecificFormats[1];
                if (formatCount > 2)
                    signFormat.zero = signSpecificFormats[2];
            }
            return signFormat;
        }
        NumberFormat.getComponents = getComponents;
        var _lastCustomFormatMeta;
        /** Evaluates if the value can be formatted using the NumberFormat */
        function canFormat(value) {
            var result = typeof (value) === "number";
            return result;
        }
        NumberFormat.canFormat = canFormat;
        function isStandardFormat(format) {
            debug.assertValue(format, 'format');
            return StandardFormatRegex.test(format);
        }
        NumberFormat.isStandardFormat = isStandardFormat;
        /**
         * If user is displaying average/stddev/variance of a whole number column and has not changed
         * the column format from the default "0" then that format is a bad choice for the aggregate.
         * Instead we should add a little more precision.
         * @param columnFormat
         */
        function getFormatForWholeNumberAverage(columnFormat) {
            if (columnFormat) {
                // can't add precision to standard formats
                if (!isStandardFormat(columnFormat)) {
                    // has user given explicit precision?
                    var metadata = getCustomFormatMetadata(columnFormat);
                    if (!metadata.hasDots) {
                        return addDecimalsToFormat(columnFormat, 2, true);
                    }
                }
            }
            return columnFormat;
        }
        NumberFormat.getFormatForWholeNumberAverage = getFormatForWholeNumberAverage;
        /** Formats the number using specified format expression and culture */
        function format(value, format, culture) {
            format = format || "G";
            try {
                if (isStandardFormat(format))
                    return formatNumberStandard(value, format, culture);
                return formatNumberCustom(value, format, culture);
            }
            catch (e) {
                return Globalize.format(value, undefined, culture);
            }
        }
        NumberFormat.format = format;
        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */
        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {
            debug.assertValue(value, 'value');
            debug.assert(typeof (value) === "number", "value must be a number");
            debug.assertValue(format, 'format');
            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');
            debug.assertValue(culture, 'culture');
            debug.assert(!isStandardFormat(format), 'Standard format');
            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);
        }
        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;
        /** Formats the number using standard format expression */
        function formatNumberStandard(value, format, culture) {
            var result;
            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);
            var numberFormatInfo = culture.numberFormat;
            var formatChar = format.charAt(0);
            switch (formatChar) {
                case "e":
                case "E":
                    if (precision === undefined) {
                        precision = 6;
                    }
                    var mantissaDecimalDigits = _.repeat("0", precision);
                    format = "0." + mantissaDecimalDigits + formatChar + "+000";
                    result = formatNumberCustom(value, format, culture);
                    break;
                case "f":
                case "F":
                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);
                    result = localize(result, numberFormatInfo);
                    break;
                case "g":
                case "G":
                    var abs = Math.abs(value);
                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {
                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form
                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();
                    }
                    else {
                        // Otherwise use exponential
                        // Assert that value is a number and fall back on returning value if it is not
                        debug.assert(typeof (value) === "number", "value must be a number");
                        if (typeof (value) !== "number")
                            return String(value);
                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();
                        result = result.replace("e", "E");
                    }
                    result = localize(result, numberFormatInfo);
                    break;
                case "r":
                case "R":
                    result = value.toString();
                    result = localize(result, numberFormatInfo);
                    break;
                case "x":
                case "X":
                    result = value.toString(16);
                    if (formatChar === "X") {
                        result = result.toUpperCase();
                    }
                    if (precision !== undefined) {
                        var actualPrecision = result.length;
                        var isNegative = value < 0;
                        if (isNegative) {
                            actualPrecision--;
                        }
                        var paddingZerosCount = precision - actualPrecision;
                        var paddingZeros = void 0;
                        if (paddingZerosCount > 0) {
                            paddingZeros = _.repeat("0", paddingZerosCount);
                        }
                        if (isNegative) {
                            result = "-" + paddingZeros + result.substr(1);
                        }
                        else {
                            result = paddingZeros + result;
                        }
                    }
                    result = localize(result, numberFormatInfo);
                    break;
                default:
                    result = Globalize.format(value, format, culture);
            }
            return result;
        }
        /** Formats the number using custom format expression */
        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {
            var result;
            var numberFormatInfo = culture.numberFormat;
            if (isFinite(value)) {
                // Split format by positive[;negative;zero] pattern
                var formatComponents = getComponents(format);
                // Pick a format based on the sign of value
                if (value > 0) {
                    format = formatComponents.positive;
                }
                else if (value === 0) {
                    format = formatComponents.zero;
                }
                else {
                    format = formatComponents.negative;
                }
                // Normalize value if we have an explicit negative format
                if (formatComponents.hasNegative)
                    value = Math.abs(value);
                // Get format metadata
                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);
                // Preserve literals and escaped chars
                var literals = [];
                if (formatMeta.hasLiterals) {
                    format = FormattingEncoder.preserveLiterals(format, literals);
                }
                // Scientific format
                if (formatMeta.hasE && !nonScientificOverrideFormat) {
                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);
                    if (scientificMatch) {
                        // Case 2.1. Scientific custom format
                        var formatM = format.substr(0, scientificMatch.index);
                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)
                        var precision = getAndSaveCustomFormatPrecision(formatM, formatMeta);
                        var scale = getCustomFormatScale(formatM, formatMeta);
                        if (scale !== 1) {
                            value = value * scale;
                        }
                        // Assert that value is a number and fall back on returning value if it is not
                        debug.assert(typeof (value) === "number", "value must be a number");
                        if (typeof (value) !== "number")
                            return String(value);
                        var s = value.toExponential(precision);
                        var indexOfE = s.indexOf("e");
                        var mantissa = s.substr(0, indexOfE);
                        var exp = s.substr(indexOfE + 1);
                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);
                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);
                        if (resultE.charAt(0) === "+" && scientificMatch[0].charAt(1) !== "+") {
                            resultE = resultE.substr(1);
                        }
                        var e = scientificMatch[0].charAt(0);
                        result = resultM + e + resultE;
                    }
                }
                // Non scientific format
                if (result === undefined) {
                    var valueFormatted = void 0;
                    var isValueGlobalized = false;
                    var precision = getAndSaveCustomFormatPrecision(format, formatMeta);
                    var scale = getCustomFormatScale(format, formatMeta);
                    if (scale !== 1)
                        value = value * scale;
                    // Rounding
                    value = parseFloat(toNonScientific(value, precision));
                    if (!isFinite(value)) {
                        // very large and small finite values can become infinite by parseFloat(toNonScientific())
                        return Globalize.format(value, undefined);
                    }
                    if (nonScientificOverrideFormat) {
                        // Get numeric format from format string
                        var numericFormat = NumberFormat.getNumericFormat(value, format);
                        // Add separators and decimalFormat to nonScientificFormat
                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);
                        // Format the value
                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);
                        isValueGlobalized = true;
                    }
                    else {
                        valueFormatted = toNonScientific(value, precision);
                        valueFormatted = removeExtraneousPrecision(value, valueFormatted, precision, getAndSaveCustomFormatOptionalPrecision(format, formatMeta));
                    }
                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);
                }
                if (formatMeta.hasLiterals) {
                    result = FormattingEncoder.restoreLiterals(result, literals, false);
                }
                _lastCustomFormatMeta = formatMeta;
            }
            else {
                return Globalize.format(value, undefined);
            }
            return result;
        }
        // Auto decimals is implemented by 15 optional digit placeholders. For exmaple, Currency General has this format
        //      \$#,0.###############;(\$#,0.###############);\$#,0.###############
        // The precision is implemented by toFixed(N) where N is the total available precision - 15 in this case. But some
        // numbers' closest 15 place decimal representation add spurious precision. For example,
        //      (34.99).toFixed(15)     =>      34.990000000000002
        //      (349.9).toFixed(15)     =>      349.899999999999977
        // This function sees if some of the optional decimal places can be eliminated while still representing the value.
        // A number of decimal places M represents the value if
        //      value === parseFloat(value.toFixed(M))
        // For example M=1 does not represent 34.99 because
        //      parseFloat((34.99).toFixed(1)) === 35 !== 34.99
        // but M=2 does
        //      parseFloat((34.99).toFixed(2)) === 34.99
        function removeExtraneousPrecision(value, valueFormatted, decimals, optionalDecimals) {
            if (optionalDecimals === 0)
                return valueFormatted;
            // where does the fractional part start?
            var decimalPoint = valueFormatted.indexOf('.');
            if (decimalPoint === -1)
                return valueFormatted;
            var fractionStart = decimalPoint + 1;
            var optionalStart = fractionStart + (decimals - optionalDecimals);
            // in optional decimals look for zero or nine which might begin extraneous precision
            for (var i = optionalStart; i < valueFormatted.length; ++i) {
                var d = valueFormatted[i];
                if (d === '0' || d === '9') {
                    var shorterFormattedValue = toNonScientific(value, i - fractionStart);
                    if (parseFloat(shorterFormattedValue) === value)
                        return shorterFormattedValue;
                }
            }
            return valueFormatted;
        }
        /** Returns string with the fixed point respresentation of the number */
        function toNonScientific(value, precision) {
            var result = "";
            var precisionZeros = 0;
            // Double precision numbers support actual 15-16 decimal digits of precision.
            if (precision > 16) {
                precisionZeros = precision - 16;
                precision = 16;
            }
            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));
            if (digitsBeforeDecimalPoint < 16) {
                if (digitsBeforeDecimalPoint > 0) {
                    var maxPrecision = 16 - digitsBeforeDecimalPoint;
                    if (precision > maxPrecision) {
                        precisionZeros += precision - maxPrecision;
                        precision = maxPrecision;
                    }
                }
                result = toFixedAwayFromZero(value, precision);
            }
            else if (digitsBeforeDecimalPoint === 16) {
                result = value.toFixed(0);
                precisionZeros += precision;
                if (precisionZeros > 0) {
                    result += ".";
                }
            }
            else {
                // Different browsers have different implementations of the toFixed().
                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.
                // So we need to check for range and convert the to exponential with the max precision.
                // Then we convert exponential string to fixed by removing the dot and padding with "power" zeros.
                // Assert that value is a number and fall back on returning value if it is not
                debug.assert(typeof (value) === "number", "value must be a number");
                if (typeof (value) !== "number")
                    return String(value);
                result = value.toExponential(15);
                var indexOfE = result.indexOf("e");
                if (indexOfE > 0) {
                    var indexOfDot = result.indexOf(".");
                    var mantissa = result.substr(0, indexOfE);
                    var exp = result.substr(indexOfE + 1);
                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);
                    result = mantissa.replace(".", "") + _.repeat("0", powerZeros);
                    if (precision > 0) {
                        result = result + "." + _.repeat("0", precision);
                    }
                }
            }
            if (precisionZeros > 0) {
                result = result + _.repeat("0", precisionZeros);
            }
            return result;
        }
        // toFixed but round away from zero taking machine precision into account.
        // 
        // (3.465).toFixed(2) gives "3.46" but we want to round away from zero to give "3.47"
        // The reason we get "3.46" is that 3.465 has no precise representation as a floating
        // point number. Rather it is approximated by a binary floating point number whose value
        // is very close to by ever so slightly less than 3.465 (think 3.46499999999...). As this
        // approximate value is closer to 3.46 that 3.47, toFixed(2) returns "3.46."
        //
        // The basic idea therefore is to help toFixed get the desired result by rounding the
        // value to the number of decimal places like this
        //      let d = Math.pow(10, n);
        //      v = Math.round(v * d) / d;
        // But Math.round is subject to the machine precision issue also. For example,
        //      0.145 * 100 => 14.499999999999998
        // so
        //      Math.round(0.145 * 100) / 100 => 0.14
        // instead of the desired 0.15.
        //
        // Therefore we explictly account for machine imprecision in the value. The machine epsilon
        // (the difference between v and the next greater representable number) around the value is
        //      Math.pow(2, Math.floor(Math.log2(v)) - 52).
        // If the v*d rounds to it's floor but (v+e)*d rounds to its ceiling, we'll use the latter.
        // This will only be wrong when v is a precise representation which just happens to be
        // infinitesimally less than the halfway cutoff in the desired place value. Fer example, the
        // user really did mean 0.14499999999999998 rather than 0.145. This is very, very unlikely.
        function toFixedAwayFromZero(v, n) {
            if (!v || isFinite(v)) {
                var negative = v < 0;
                if (negative)
                    v = -v;
                var e = Math.pow(2, Math.floor(Math.log(v) / Math.LN2) - 52);
                var d = Math.pow(10, n);
                // is it safe to perturb the value? not if the decimal precision being requested
                // is very fine. i.e. on the order of the machine epsilon.
                if (1 / d > 10 * e) {
                    var vd = (v + e) * d;
                    var vr = Math.round(vd);
                    v = vr / d;
                }
                if (negative)
                    v = -v;
            }
            return v.toFixed(n);
        }
        /**
         * Returns the formatMetadata of the format
         * When calculating precision and scale, if format string of
         * positive[;negative;zero] => positive format will be used
         * @param (required) format - format string
         * @param (optional) calculatePrecision - calculate precision of positive format
         * @param (optional) calculateScale - calculate scale of positive format
         */
        function getCustomFormatMetadata(format, calculatePrecision, calculateScale, calculatePartsPerScale) {
            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {
                return _lastCustomFormatMeta;
            }
            var literals = [];
            var escaped = FormattingEncoder.preserveLiterals(format, literals);
            var result = {
                format: format,
                hasLiterals: literals.length !== 0,
                hasE: false,
                hasCommas: false,
                hasDots: false,
                hasPercent: false,
                hasPermile: false,
                precision: undefined,
                optionalPrecision: undefined,
                scale: undefined,
                partsPerScale: undefined,
            };
            for (var i = 0, length_1 = escaped.length; i < length_1; i++) {
                var c = escaped.charAt(i);
                switch (c) {
                    case "e":
                    case "E":
                        result.hasE = true;
                        break;
                    case ",":
                        result.hasCommas = true;
                        break;
                    case ".":
                        result.hasDots = true;
                        break;
                    case "%":
                        result.hasPercent = true;
                        break;
                    case "\u2030":// 
                        result.hasPermile = true;
                        break;
                }
            }
            // Use positive format for calculating these values
            var formatComponents = getComponents(format);
            if (calculatePrecision)
                result.precision = getAndSaveCustomFormatPrecision(formatComponents.positive, result);
            if (calculatePartsPerScale)
                result.partsPerScale = getCustomFormatPartsPerScale(formatComponents.positive, result);
            if (calculateScale)
                result.scale = getCustomFormatScale(formatComponents.positive, result);
            return result;
        }
        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;
        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point
          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */
        function getAndSaveCustomFormatPrecision(format, formatMeta) {
            ensureCustomFormatPrecision(format, formatMeta);
            return formatMeta.precision;
        }
        function getAndSaveCustomFormatOptionalPrecision(format, formatMeta) {
            ensureCustomFormatPrecision(format, formatMeta);
            return formatMeta.optionalPrecision;
        }
        function ensureCustomFormatPrecision(format, formatMeta) {
            if (formatMeta.precision > -1) {
                return;
            }
            var precision = 0;
            var optional = 0;
            if (formatMeta.hasDots) {
                if (formatMeta.hasLiterals) {
                    format = FormattingEncoder.removeLiterals(format);
                }
                var dotIndex = format.indexOf(".");
                if (dotIndex > -1) {
                    var count = format.length;
                    for (var i = dotIndex; i < count; i++) {
                        var char = format.charAt(i);
                        if (char.match(NumericPlaceholderRegex))
                            ++precision;
                        if (char === DigitPlaceholder)
                            ++optional;
                        else
                            optional = 0;
                        // 0.00E+0 :: Break before counting 0 in
                        // exponential portion of format string
                        if (char === ExponentialFormatChar)
                            break;
                    }
                    // limit decimal places to 19. if limit is applied, optional decimal places must also
                    // decrease by the same amount (but can't be less than zero)
                    if (precision > 19) {
                        var precisionReduction = precision - 19;
                        optional = Math.max(0, optional - precisionReduction);
                        precision = 19;
                    }
                }
            }
            formatMeta.precision = precision;
            formatMeta.optionalPrecision = optional;
        }
        function getCustomFormatPartsPerScale(format, formatMeta) {
            if (formatMeta.partsPerScale != null)
                return formatMeta.partsPerScale;
            var result = 1;
            if (formatMeta.hasPercent && format.indexOf("%") > -1) {
                result = result * 100;
            }
            if (formatMeta.hasPermile && format.indexOf(/*  */ "\u2030") > -1) {
                result = result * 1000;
            }
            formatMeta.partsPerScale = result;
            return result;
        }
        /** Returns the scale factor of the format based on the "%" and scaling "," chars in the format */
        function getCustomFormatScale(format, formatMeta) {
            if (formatMeta.scale > -1) {
                return formatMeta.scale;
            }
            var result = getCustomFormatPartsPerScale(format, formatMeta);
            if (formatMeta.hasCommas) {
                var dotIndex = format.indexOf(".");
                if (dotIndex === -1) {
                    dotIndex = format.length;
                }
                for (var i = dotIndex - 1; i > -1; i--) {
                    var char = format.charAt(i);
                    if (char === ",") {
                        result = result / 1000;
                    }
                    else {
                        break;
                    }
                }
            }
            formatMeta.scale = result;
            return result;
        }
        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {
            var suppressModifyValue = !!nonScientificOverrideFormat;
            var formatParts = format.split(".", 2);
            if (formatParts.length === 2) {
                var wholeFormat = formatParts[0];
                var fractionFormat = formatParts[1];
                var displayUnit = "";
                // Remove display unit from value before splitting on "." as localized display units sometimes end with "."
                if (nonScientificOverrideFormat) {
                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), "Number should always precede the display unit");
                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, "");
                    value = value.replace(displayUnit, "");
                }
                var globalizedDecimalSeparator = numberFormatInfo["."];
                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : ".";
                var valueParts = value.split(decimalSeparator, 2);
                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];
                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : "";
                fractionValue = fractionValue.replace(TrailingZerosRegex, "");
                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);
                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);
                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === "")
                    return wholeFormattedValue + fractionFormattedValue.value;
                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;
            }
            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);
        }
        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {
            var groupSymbolIndex = format.indexOf(",");
            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf("0"), format.lastIndexOf("#")) && numberFormatInfo[","];
            var groupDigitCount = 0;
            var groupIndex = 0;
            var groupSizes = numberFormatInfo.groupSizes || [3];
            var groupSize = groupSizes[0];
            var groupSeparator = numberFormatInfo[","];
            var sign = "";
            var firstChar = value.charAt(0);
            if (firstChar === "+" || firstChar === "-") {
                sign = numberFormatInfo[firstChar];
                value = value.substr(1);
            }
            var isZero = value === "0";
            var result = "";
            var leftBuffer = "";
            var vi = value.length - 1;
            var fmtOnly = true;
            // Iterate through format chars and replace 0 and # with the digits from the value string
            for (var fi = format.length - 1; fi > -1; fi--) {
                var formatChar = format.charAt(fi);
                switch (formatChar) {
                    case ZeroPlaceholder:
                    case DigitPlaceholder:
                        fmtOnly = false;
                        if (leftBuffer !== "") {
                            result = leftBuffer + result;
                            leftBuffer = "";
                        }
                        if (!suppressModifyValue) {
                            if (vi > -1 || formatChar === ZeroPlaceholder) {
                                if (enableGroups) {
                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,
                                    if (groupDigitCount === groupSize) {
                                        result = groupSeparator + result;
                                        groupIndex++;
                                        if (groupIndex < groupSizes.length) {
                                            groupSize = groupSizes[groupIndex];
                                        }
                                        groupDigitCount = 1;
                                    }
                                    else {
                                        groupDigitCount++;
                                    }
                                }
                            }
                            if (vi > -1) {
                                if (isZero && formatChar === DigitPlaceholder) {
                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)
                                }
                                else {
                                    result = value.charAt(vi) + result;
                                }
                                vi--;
                            }
                            else if (formatChar !== DigitPlaceholder) {
                                result = formatChar + result;
                            }
                        }
                        break;
                    case ",":
                        // We should skip all the , chars
                        break;
                    default:
                        leftBuffer = formatChar + leftBuffer;
                        break;
                }
            }
            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result
            if (!suppressModifyValue) {
                if (vi > -1 && result !== "") {
                    if (enableGroups) {
                        while (vi > -1) {
                            if (groupDigitCount === groupSize) {
                                result = groupSeparator + result;
                                groupIndex++;
                                if (groupIndex < groupSizes.length) {
                                    groupSize = groupSizes[groupIndex];
                                }
                                groupDigitCount = 1;
                            }
                            else {
                                groupDigitCount++;
                            }
                            result = value.charAt(vi) + result;
                            vi--;
                        }
                    }
                    else {
                        result = value.substr(0, vi + 1) + result;
                    }
                }
                // Insert sign in front of the leftBuffer and result
                return sign + leftBuffer + result;
            }
            if (fmtOnly)
                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.
                return sign + leftBuffer + result;
            return sign + leftBuffer + value + result;
        }
        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {
            var vi = 0;
            var fCount = format.length;
            var vCount = value.length;
            if (suppressModifyValue) {
                debug.assert(fCount > 0, "Empty formatting string");
                var lastChar = format.charAt(fCount - 1);
                if (!lastChar.match(NumericPlaceholderRegex))
                    return {
                        value: value + lastChar,
                        fmtOnly: value === "",
                    };
                return {
                    value: value,
                    fmtOnly: value === "",
                };
            }
            var result = "", fmtOnly = true;
            for (var fi = 0; fi < fCount; fi++) {
                var formatChar = format.charAt(fi);
                if (vi < vCount) {
                    switch (formatChar) {
                        case ZeroPlaceholder:
                        case DigitPlaceholder:
                            result += value[vi++];
                            fmtOnly = false;
                            break;
                        default:
                            result += formatChar;
                    }
                }
                else {
                    if (formatChar !== DigitPlaceholder) {
                        result += formatChar;
                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);
                    }
                }
            }
            return {
                value: result,
                fmtOnly: fmtOnly,
            };
        }
        function localize(value, dictionary) {
            var plus = dictionary["+"];
            var minus = dictionary["-"];
            var dot = dictionary["."];
            var comma = dictionary[","];
            if (plus === "+" && minus === "-" && dot === "." && comma === ",") {
                return value;
            }
            var count = value.length;
            var result = "";
            for (var i = 0; i < count; i++) {
                var char = value.charAt(i);
                switch (char) {
                    case "+":
                        result = result + plus;
                        break;
                    case "-":
                        result = result + minus;
                        break;
                    case ".":
                        result = result + dot;
                        break;
                    case ",":
                        result = result + comma;
                        break;
                    default:
                        result = result + char;
                        break;
                }
            }
            return result;
        }
    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));
    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */
    var DateTimeScaleFormatInfo = /** @class */ (function () {
        // Constructor
        /**
         * Creates new instance of the DateTimeScaleFormatInfo class.
         * @param culture - culture which calendar info is going to be used to derive the formats.
         */
        function DateTimeScaleFormatInfo(culture) {
            var calendar = culture.calendar;
            var patterns = calendar.patterns;
            var monthAbbreviations = calendar["months"]["namesAbbr"];
            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];
            var yearMonthPattern = patterns["Y"];
            var monthDayPattern = patterns["M"];
            var fullPattern = patterns["f"];
            var longTimePattern = patterns["T"];
            var shortTimePattern = patterns["t"];
            var separator = fullPattern.indexOf(",") > -1 ? ", " : " ";
            var hasYearSymbol = yearMonthPattern.indexOf("yyyy'") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\'';
            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : "yyyy";
            var yearPos = fullPattern.indexOf("yy");
            var monthPos = fullPattern.indexOf("MMMM");
            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? "MMM yyyy" : "yyyy MMM") : yearMonthPattern;
            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace("MMMM", "MMM") : monthDayPattern;
            var minutePos = fullPattern.indexOf("mm");
            var pmPos = fullPattern.indexOf("tt");
            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(":mm ", "") : shortTimePattern;
            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;
            this.MinutePattern = shortTimePattern;
            this.SecondPattern = longTimePattern;
            this.MillisecondPattern = longTimePattern.replace("ss", "ss.fff");
            // Special cases
            switch (culture.name) {
                case "fi-FI":
                    this.DayPattern = this.DayPattern.replace("'ta'", ""); // Fix for finish 'ta' suffix for month names.
                    this.HourPattern = this.HourPattern.replace("'ta'", "");
                    break;
            }
        }
        // Methods
        /**
         * Returns the format string of the provided DateTimeUnit.
         * @param unit - date or time unit
         */
        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {
            switch (unit) {
                case powerbi_1.DateTimeUnit.Year:
                    return this.YearPattern;
                case powerbi_1.DateTimeUnit.Month:
                    return this.MonthPattern;
                case powerbi_1.DateTimeUnit.Week:
                case powerbi_1.DateTimeUnit.Day:
                    return this.DayPattern;
                case powerbi_1.DateTimeUnit.Hour:
                    return this.HourPattern;
                case powerbi_1.DateTimeUnit.Minute:
                    return this.MinutePattern;
                case powerbi_1.DateTimeUnit.Second:
                    return this.SecondPattern;
                case powerbi_1.DateTimeUnit.Millisecond:
                    return this.MillisecondPattern;
            }
            debug.assertFail('Unexpected unit: ' + unit);
        };
        return DateTimeScaleFormatInfo;
    }());
    powerbi_1.formattingService = new FormattingService();
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */
        var SQExprShortSerializer;
        (function (SQExprShortSerializer) {
            function serialize(expr) {
                return JSON.stringify(expr.accept(SQExprSerializer.instance));
            }
            SQExprShortSerializer.serialize = serialize;
            function serializeArray(exprs) {
                var str = '[';
                for (var i = 0, len = exprs.length; i < len; i++) {
                    if (i > 0)
                        str += ',';
                    str += SQExprShortSerializer.serialize(exprs[i]);
                }
                return str + ']';
            }
            SQExprShortSerializer.serializeArray = serializeArray;
            /** Responsible for serializing an SQExpr into a comparable string. */
            var SQExprSerializer = /** @class */ (function (_super) {
                __extends(SQExprSerializer, _super);
                function SQExprSerializer() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                SQExprSerializer.prototype.visitColumnRef = function (expr) {
                    return {
                        col: {
                            s: expr.source.accept(this),
                            r: expr.ref,
                        }
                    };
                };
                SQExprSerializer.prototype.visitMeasureRef = function (expr) {
                    return {
                        measure: {
                            s: expr.source.accept(this),
                            r: expr.ref,
                        }
                    };
                };
                SQExprSerializer.prototype.visitAggr = function (expr) {
                    return {
                        agg: {
                            a: expr.arg.accept(this),
                            f: expr.func,
                        }
                    };
                };
                SQExprSerializer.prototype.visitEntity = function (expr) {
                    debug.assertValue(expr, 'expr');
                    debug.assertValue(expr.entity, 'expr.entity');
                    return {
                        e: expr.entity
                    };
                };
                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {
                    return {
                        h: expr.arg.accept(this),
                        l: expr.level,
                    };
                };
                SQExprSerializer.prototype.visitHierarchy = function (expr) {
                    return {
                        e: expr.arg.accept(this),
                        h: expr.hierarchy,
                    };
                };
                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {
                    return {
                        e: expr.arg.accept(this),
                        n: expr.name,
                        p: expr.property,
                    };
                };
                SQExprSerializer.prototype.visitAnd = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        and: {
                            l: expr.left.accept(this),
                            r: expr.right.accept(this),
                        }
                    };
                };
                SQExprSerializer.prototype.visitCompare = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        comp: {
                            k: expr.comparison,
                            l: expr.left.accept(this),
                            r: expr.right.accept(this),
                        }
                    };
                };
                SQExprSerializer.prototype.visitConstant = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        const: {
                            t: expr.type.primitiveType,
                            v: expr.value,
                        }
                    };
                };
                SQExprSerializer.prototype.visitArithmetic = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        arithmetic: {
                            o: expr.operator,
                            l: expr.left.accept(this),
                            r: expr.right.accept(this)
                        }
                    };
                };
                SQExprSerializer.prototype.visitScopedEval = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        scopedEval: {
                            e: expr.expression.accept(this),
                            s: serializeArray(expr.scope)
                        }
                    };
                };
                SQExprSerializer.prototype.visitFilteredEval = function (expr) {
                    var _this = this;
                    debug.assertValue(expr, 'expr');
                    var filterShortSerializer = function (filter) {
                        var filterObject = {};
                        if (!_.isEmpty(filter.target))
                            filterObject['t'] = _.map(filter.target, (function (target) { return target.accept(_this); }));
                        filterObject['c'] = filter.condition.accept(_this);
                        return filterObject;
                    };
                    return {
                        filteredEval: {
                            e: expr.expression.accept(this),
                            f: "[" + _.map(expr.filters, (function (filter) { return JSON.stringify(filterShortSerializer(filter)); })).join(', ') + "]",
                        }
                    };
                };
                SQExprSerializer.prototype.visitWithRef = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        withRef: {
                            e: expr.expressionName
                        }
                    };
                };
                SQExprSerializer.prototype.visitTransformTableRef = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        transformTableRef: {
                            source: expr.source,
                        }
                    };
                };
                SQExprSerializer.prototype.visitTransformOutputRoleRef = function (expr) {
                    debug.assertValue(expr, 'expr');
                    var ref = {
                        transformOutputRoleRef: {
                            role: expr.role
                        }
                    };
                    if (expr.transform)
                        ref.transformOutputRoleRef['transform'] = expr.transform;
                    return ref;
                };
                SQExprSerializer.prototype.visitFloor = function (expr) {
                    debug.assertValue(expr, 'expr');
                    var ref = {
                        floor: {
                            a: expr.arg.accept(this),
                            s: expr.size
                        }
                    };
                    if (expr.timeUnit != null)
                        ref.floor['timeunit'] = expr.timeUnit;
                    return ref;
                };
                SQExprSerializer.prototype.visitRoleRef = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        roleRef: {
                            role: expr.role
                        }
                    };
                };
                SQExprSerializer.prototype.visitNot = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        not: expr.arg.accept(this)
                    };
                };
                SQExprSerializer.prototype.visitIn = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        in: {
                            c: serializeArray(expr.args),
                            v: _.map(expr.values, (function (v) { return serializeArray(v); }))
                        }
                    };
                };
                SQExprSerializer.prototype.visitDefault = function (expr) {
                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');
                    return;
                };
                SQExprSerializer.instance = new SQExprSerializer();
                return SQExprSerializer;
            }(data.DefaultSQExprVisitor));
        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Selector = powerbi.data.Selector;
        /**
         * A combination of identifiers used to uniquely identify
         * data points and their bound geometry.
         */
        var SelectionId = /** @class */ (function () {
            function SelectionId(selector, highlight, selectorsByColumn) {
                this.selector = selector;
                this.highlight = highlight;
                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });
                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });
                this.selectorsByColumn = selectorsByColumn;
            }
            SelectionId.fromSelectorsByColumn = function (selectorsByColumn) {
                var selector = Selector.convertSelectorsByColumnToSelector(selectorsByColumn);
                return new SelectionId(selector, false, selectorsByColumn);
            };
            SelectionId.prototype.equals = function (other) {
                if (!this.selector || !other.selector) {
                    return (!this.selector === !other.selector) && this.highlight === other.highlight;
                }
                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);
            };
            SelectionId.isEqual = function (one, other) {
                if (one === other)
                    return true;
                if (one == null || other == null)
                    return false;
                return one.equals(other);
            };
            /**
             * Checks equality against other for all identifiers existing in this.
             */
            SelectionId.prototype.includes = function (other, ignoreHighlight) {
                if (ignoreHighlight === void 0) { ignoreHighlight = false; }
                var thisSelector = this.selector;
                var otherSelector = other.selector;
                if (!thisSelector || !otherSelector) {
                    return false;
                }
                var thisData = thisSelector.data;
                var otherData = otherSelector.data;
                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))
                    return false;
                if (!ignoreHighlight && this.highlight !== other.highlight)
                    return false;
                if (thisData) {
                    if (!otherData)
                        return false;
                    if (thisData.length > 0) {
                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {
                            var thisValue = thisData[i];
                            if (!otherData.some((function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); })))
                                return false;
                        }
                    }
                }
                return true;
            };
            SelectionId.prototype.getKey = function () {
                return this.key;
            };
            SelectionId.prototype.getKeyWithoutHighlight = function () {
                return this.keyWithoutHighlight;
            };
            SelectionId.prototype.hasIdentity = function () {
                return (this.selector && !!this.selector.data);
            };
            SelectionId.prototype.getSelector = function () {
                return this.selector;
            };
            SelectionId.prototype.getSelectorsByColumn = function () {
                return this.selectorsByColumn;
            };
            SelectionId.createNull = function (highlight) {
                if (highlight === void 0) { highlight = false; }
                return new SelectionId(null, highlight);
            };
            SelectionId.createWithId = function (id, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = null;
                if (id) {
                    selector = {
                        data: [id]
                    };
                }
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithMeasure = function (measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                debug.assertValue(measureId, 'measureId');
                var selector = {
                    metadata: measureId
                };
                var selectionId = new SelectionId(selector, highlight);
                selectionId.selectorsByColumn = { metadata: [measureId] };
                return selectionId;
            };
            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                if (id) {
                    selector.data = [id];
                }
                if (measureId)
                    selector.metadata = measureId;
                if (!id && !measureId)
                    selector = null;
                var selectionId = new SelectionId(selector, highlight);
                return selectionId;
            };
            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);
                if (selectionId.selector) {
                    selectionId.selectorsByColumn = {};
                    if (id && queryName) {
                        selectionId.selectorsByColumn.dataMap = {};
                        selectionId.selectorsByColumn.dataMap[queryName] = [id];
                    }
                    if (measureId)
                        selectionId.selectorsByColumn.metadata = [measureId];
                }
                return selectionId;
            };
            SelectionId.createWithIds = function (id1, id2, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = null;
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData)
                    selector = { data: selectorData };
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData)
                    selector.data = selectorData;
                if (measureId)
                    selector.metadata = measureId;
                if (!id1 && !id2 && !measureId)
                    selector = null;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selectorsByColumn = {};
                if (!_.isEmpty(dataMap))
                    selectorsByColumn.dataMap = dataMap;
                if (measureId)
                    selectorsByColumn.metadata = [measureId];
                if (!dataMap && !measureId)
                    selectorsByColumn = null;
                var selector = Selector.convertSelectorsByColumnToSelector(selectorsByColumn);
                return new SelectionId(selector, highlight, selectorsByColumn);
            };
            SelectionId.createWithSelectorForColumnAndMeasures = function (dataMap, measureIds, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selectorsByColumn = {};
                if (!_.isEmpty(dataMap))
                    selectorsByColumn.dataMap = dataMap;
                if (!_.isEmpty(measureIds))
                    selectorsByColumn.metadata = measureIds;
                if (!dataMap && _.isEmpty(measureIds))
                    selectorsByColumn = null;
                var selector = Selector.convertSelectorsByColumnToSelector(selectorsByColumn);
                return new SelectionId(selector, highlight, selectorsByColumn);
            };
            SelectionId.createWithHighlight = function (original) {
                debug.assertValue(original, 'original');
                debug.assert(!original.highlight, '!original.highlight');
                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);
                newId.selectorsByColumn = original.selectorsByColumn;
                return newId;
            };
            SelectionId.idArray = function (id1, id2) {
                if (id1 || id2) {
                    var data_5 = [];
                    if (id1)
                        data_5.push(id1);
                    if (id2 && id2 !== id1)
                        data_5.push(id2);
                    return data_5;
                }
            };
            return SelectionId;
        }());
        visuals.SelectionId = SelectionId;
        /**
         * This class is designed to simplify the creation of SelectionId objects
         * It allows chaining to build up an object before calling 'create' to build a SelectionId
         */
        var SelectionIdBuilder = /** @class */ (function () {
            function SelectionIdBuilder() {
            }
            SelectionIdBuilder.builder = function () {
                return new SelectionIdBuilder();
            };
            SelectionIdBuilder.prototype.withColumnIdentity = function (identity, queryName) {
                this.addItemToDataMap(queryName, identity);
                return this;
            };
            SelectionIdBuilder.prototype.withCategoryIdentity = function (categoryColumn, identity) {
                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName)
                    this.addItemToDataMap(categoryColumn.source.queryName, identity);
                return this;
            };
            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {
                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)
                    this.addItemToDataMap(categoryColumn.source.queryName, categoryColumn.identity[index]);
                return this;
            };
            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {
                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)
                    this.addItemToDataMap(seriesColumn.source.queryName, valueColumn.identity);
                return this;
            };
            SelectionIdBuilder.prototype.withMeasure = function (measureId) {
                this.ensureMeasures();
                if (measureId != null) {
                    this.measures.push(measureId);
                }
                return this;
            };
            SelectionIdBuilder.prototype.withMeasures = function (measureIds) {
                this.ensureMeasures();
                for (var _i = 0, measureIds_1 = measureIds; _i < measureIds_1.length; _i++) {
                    var measureId = measureIds_1[_i];
                    this.measures.push(measureId);
                }
                return this;
            };
            SelectionIdBuilder.prototype.createSelectionId = function () {
                return SelectionId.createWithSelectorForColumnAndMeasures(this.dataMap, this.measures);
            };
            SelectionIdBuilder.prototype.ensureMeasures = function () {
                if (this.measures === undefined)
                    this.measures = [];
            };
            SelectionIdBuilder.prototype.addItemToDataMap = function (queryName, id) {
                if (!id)
                    return;
                if (!this.dataMap)
                    this.dataMap = {};
                var dataMap = this.dataMap;
                var currentItem = dataMap[queryName];
                if (currentItem == null) {
                    dataMap[queryName] = [id];
                    return;
                }
                currentItem.push(id);
            };
            return SelectionIdBuilder;
        }());
        visuals.SelectionIdBuilder = SelectionIdBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var VisualStylePresetHelpers;
    (function (VisualStylePresetHelpers) {
        /**
         * Get a visual style preset by name.
         * If stylePresets is undefined, returns undefined
         * If the name doesn't match one or name is undefined, the default preset should be returned, can be undefined
         * @param {string} name name of the Style Preset
         */
        function getStylePreset(stylePresets, name) {
            debug.assertValue(stylePresets, "getStylePreset called with undefined stylePresets");
            if (!stylePresets)
                return;
            if (_.isEmpty(name))
                name = stylePresets.defaultPresetName;
            var preset = stylePresets.presets[name];
            // If no preset matches name, return default one
            // This can happen when format painting between different visuals
            if (!preset)
                preset = stylePresets.presets[stylePresets.defaultPresetName];
            debug.assertValue(preset, "VisualStylePreset not found and no valid default exists");
            return preset;
        }
        VisualStylePresetHelpers.getStylePreset = getStylePreset;
        function getStylePresetsEnum(stylePresets) {
            var members = [];
            if (stylePresets) {
                var presets = stylePresets.presets;
                if (presets) {
                    for (var name_2 in presets) {
                        var stylePreset = presets[name_2];
                        members.push({ value: stylePreset.name, displayName: stylePreset.displayName });
                    }
                }
            }
            return powerbi.createEnumType(members);
        }
        VisualStylePresetHelpers.getStylePresetsEnum = getStylePresetsEnum;
    })(VisualStylePresetHelpers = powerbi.VisualStylePresetHelpers || (powerbi.VisualStylePresetHelpers = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataColorPalette = /** @class */ (function () {
            /**
             * Creates a DataColorPalette using the given theme, or the default theme.
             */
            function DataColorPalette(colors, sentimentcolors) {
                // Hardcoded values for Color Picker.
                this.basePickerColors = [
                    { value: '#FFFFFF' },
                    { value: '#000000' },
                ];
                this.colors = colors || DefaultColorManager.getDefaultColors();
                this.sentimentColors = sentimentcolors || DefaultColorManager.defaultSentimentColors;
                this.scales = {};
                (_a = this.basePickerColors).push.apply(_a, _.take(this.colors, 8));
                var _a;
            }
            DataColorPalette.prototype.getColorScaleByKey = function (key) {
                var scale = this.scales[key];
                if (scale === undefined) {
                    scale = this.createScale();
                    this.scales[key] = scale;
                }
                return scale;
            };
            DataColorPalette.prototype.getNewColorScale = function () {
                return this.createScale();
            };
            DataColorPalette.prototype.getColorByIndex = function (index) {
                debug.assert(index >= 0 && index < this.colors.length, 'index is out of bounds');
                return this.colors[index];
            };
            DataColorPalette.prototype.getSentimentColors = function () {
                return this.sentimentColors;
            };
            DataColorPalette.prototype.getBasePickerColors = function () {
                return this.basePickerColors;
            };
            DataColorPalette.prototype.getAllColors = function () {
                return this.colors;
            };
            DataColorPalette.prototype.createScale = function () {
                return D3ColorScale.createFromColors(this.colors);
            };
            return DataColorPalette;
        }());
        visuals.DataColorPalette = DataColorPalette;
        var D3ColorScale = /** @class */ (function () {
            function D3ColorScale(scale) {
                this.scale = scale;
            }
            D3ColorScale.prototype.getColor = function (key) {
                return this.scale(key);
            };
            D3ColorScale.prototype.clearAndRotateScale = function () {
                var offset = this.scale.domain().length;
                var rotatedColors = ArrayExtensions.rotate(this.scale.range(), offset);
                this.scale = d3.scale.ordinal().range(rotatedColors);
            };
            D3ColorScale.prototype.clone = function () {
                return new D3ColorScale(this.scale.copy());
            };
            D3ColorScale.prototype.getDomain = function () {
                return this.scale.domain();
            };
            D3ColorScale.createFromColors = function (colors) {
                return new D3ColorScale(d3.scale.ordinal().range(colors));
            };
            return D3ColorScale;
        }());
        visuals.D3ColorScale = D3ColorScale;
        var DefaultColorManager = /** @class */ (function () {
            function DefaultColorManager() {
            }
            DefaultColorManager.getDefaultColors = function () {
                if (!DefaultColorManager.defaultColors) {
                    // Extend the list of available colors by cycling the base colors
                    DefaultColorManager.defaultColors = [];
                    var baseColors = DefaultColorManager.defaultBaseColors;
                    for (var i = 0; i < DefaultColorManager.colorSectorCount; ++i) {
                        for (var j = 0, jlen = baseColors.length; j < jlen; ++j) {
                            DefaultColorManager.defaultColors.push({
                                value: jsCommon.Color.rotate(baseColors[j].value, i / DefaultColorManager.colorSectorCount)
                            });
                        }
                    }
                }
                return DefaultColorManager.defaultColors;
            };
            DefaultColorManager.colorSectorCount = 12;
            // declare the Theme code as a private implementation detail inside the DataColorPalette so that the code stays hidden
            // until it's ready for wider use.
            DefaultColorManager.defaultBaseColors = [
                // First loop
                { value: '#01B8AA' },
                { value: '#374649' },
                { value: '#FD625E' },
                { value: '#F2C80F' },
                { value: '#5F6B6D' },
                { value: '#8AD4EB' },
                { value: '#FE9666' },
                { value: '#A66999' },
                { value: '#3599B8' },
                { value: '#DFBFBF' },
                // Second loop
                { value: '#4AC5BB' },
                { value: '#5F6B6D' },
                { value: '#FB8281' },
                { value: '#F4D25A' },
                { value: '#7F898A' },
                { value: '#A4DDEE' },
                { value: '#FDAB89' },
                { value: '#B687AC' },
                { value: '#28738A' },
                { value: '#A78F8F' },
                // Third loop
                { value: '#168980' },
                { value: '#293537' },
                { value: '#BB4A4A' },
                { value: '#B59525' },
                { value: '#475052' },
                { value: '#6A9FB0' },
                { value: '#BD7150' },
                { value: '#7B4F71' },
                { value: '#1B4D5C' },
                { value: '#706060' },
                // Fourth loop
                { value: '#0F5C55' },
                { value: '#1C2325' },
                { value: '#7D3231' },
                { value: '#796419' },
                { value: '#303637' },
                { value: '#476A75' },
                { value: '#7E4B36' },
                { value: '#52354C' },
                { value: '#0D262E' },
                { value: '#544848' },
            ];
            DefaultColorManager.defaultSentimentColors = [
                { value: '#C0433A' },
                { value: '#E8D62E' },
                { value: '#79C75B' },
            ];
            return DefaultColorManager;
        }());
        visuals.DefaultColorManager = DefaultColorManager;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        function createColorAllocatorFactory() {
            return new ColorAllocatorFactory();
        }
        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
        var ColorAllocatorFactory = /** @class */ (function () {
            function ColorAllocatorFactory() {
            }
            ColorAllocatorFactory.prototype.linearGradient2 = function (options) {
                return new LinearGradient2Allocator(options);
            };
            ColorAllocatorFactory.prototype.linearGradient3 = function (options, splitScales) {
                if (splitScales)
                    return new LinearGradient3AllocatorWithSplittedScales(options);
                return new LinearGradient3Allocator(options);
            };
            return ColorAllocatorFactory;
        }());
        function isColorAsZero(nullColoringStrategy) {
            return nullColoringStrategy.strategy === powerbi.NullStrategy.asZero;
        }
        function getColorFromNullStrategy(nullColoringStrategy) {
            switch (nullColoringStrategy.strategy) {
                case powerbi.NullStrategy.noColor:
                    return undefined;
                case powerbi.NullStrategy.specificColor:
                    return nullColoringStrategy.color;
                case powerbi.NullStrategy.asZero:
                    debug.assertFail("getColorFromNullStrategy - called with asZero");
                    break;
                default:
                    debug.assertFail("getColorFromNullStrategy - Unexpected null strategy: " + nullColoringStrategy.strategy);
                    break;
            }
        }
        var LinearGradient2Allocator = /** @class */ (function () {
            function LinearGradient2Allocator(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, max = options.max;
                this.scale = Color.createLinearColorScale([min.value, max.value], [min.color, max.color], true);
            }
            LinearGradient2Allocator.prototype.color = function (value) {
                var nullColoringStrategy = this.options.nullColoringStrategy;
                if (value === null && nullColoringStrategy) {
                    if (isColorAsZero(nullColoringStrategy))
                        value = 0;
                    else
                        return getColorFromNullStrategy(nullColoringStrategy);
                }
                return this.scale(value);
            };
            return LinearGradient2Allocator;
        }());
        var LinearGradient3Allocator = /** @class */ (function () {
            function LinearGradient3Allocator(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                this.scale = Color.createLinearColorScale([min.value, mid.value, max.value], [min.color, mid.color, max.color], true);
            }
            LinearGradient3Allocator.prototype.color = function (value) {
                var nullColoringStrategy = this.options.nullColoringStrategy;
                if (value === null && nullColoringStrategy) {
                    if (isColorAsZero(nullColoringStrategy))
                        value = 0;
                    else
                        return getColorFromNullStrategy(nullColoringStrategy);
                }
                return this.scale(value);
            };
            return LinearGradient3Allocator;
        }());
        var LinearGradient3AllocatorWithSplittedScales = /** @class */ (function () {
            function LinearGradient3AllocatorWithSplittedScales(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                /*
                If the center value is overridden, but the max and min remain automatic,
                colors are then assigned on a scale between the overridden center value and the max/min values in the data.
                Each side of the center value is assigned separately, independent of the relative scales.
                */
                this.scale1 = Color.createLinearColorScale([min.value, mid.value], [min.color, mid.color], true);
                this.scale2 = Color.createLinearColorScale([mid.value, max.value], [mid.color, max.color], true);
            }
            LinearGradient3AllocatorWithSplittedScales.prototype.color = function (value) {
                var nullColoringStrategy = this.options.nullColoringStrategy;
                if (value === null && nullColoringStrategy) {
                    if (isColorAsZero(nullColoringStrategy))
                        value = 0;
                    else
                        return getColorFromNullStrategy(nullColoringStrategy);
                }
                if (value <= this.options.mid.value)
                    return this.scale1(value);
                return this.scale2(value);
            };
            return LinearGradient3AllocatorWithSplittedScales;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
;// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

/// <disable>JS2025.InsertSpaceBeforeCommentText,JS2027.PunctuateCommentsCorrectly,JS2076.IdentifierIsMiscased,JS3085.VariableDeclaredMultipleTimes, JS3116.PreviousDeclarationWasHere, JS2074.IdentifierNameIsMisspelled, JS2030.FollowKeywordsWithSpace, JS2023.UseDoubleQuotesForStringLiterals, JS2028.UseCPlusPlusStyleComments, JS2026.CapitalizeComments, JS2008.DoNotUseCookies, JS2005.UseShortFormInitializations, JS2064.SpecifyNewWhenCallingConstructor, JS2024.DoNotQuoteObjectLiteralPropertyNames, JS2043.RemoveDebugCode, JS3045.MissingInputFile</disable>
/// <dictionary target='comment'>args,aspx,autocompletion,enqueue,Firefox,Hardcoded,interdependant,Kinda,Moderncop,Nav,param,params,powerview, secweb, serializer, sharepoint, silverlight, src, stylesheet, theming, untokenized, Xmla </dictionary>

// ModernCop Rules and Settings - Disabling some non critical warnings that we currently have per:
// http://secweb01/MSEC/Tools/Lists/MSEC%20Tool%20Errors%20and%20Warnings/AllItems.aspx?FilterField1=Tool&FilterValue1=Moderncop

/// <disable>JS2085.EnableStrictMode</disable>
// Justification: The violation is that strict mode is enabled for global scope, which could lead
// to unexpected behavior if the target JS file of this project is concatenated with other JS files.
// The target JS file of this project is not concatenated with other files.
"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
        var ColorHelper = /** @class */ (function () {
            function ColorHelper(colors, fillProp, defaultDataPointColor, defaultCategoryColor) {
                this.colors = colors;
                this.fillProp = fillProp;
                this.defaultDataPointColor = defaultDataPointColor;
                this.defaultCategoryColor = defaultCategoryColor;
                this.defaultColorScale = colors.getNewColorScale();
            }
            /**
             * Gets the color for the given series value.
             * If no explicit color or default color has been set then the color is
             * allocated from the color scale for this series.
             */
            ColorHelper.prototype.getColorForSeriesValue = function (objects, fieldIds, value) {
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultDataPointColor
                    || this.getColorScaleForSeries(fieldIds).getColor(value).value;
            };
            /**
             * Gets the color scale for the given series.
             */
            ColorHelper.prototype.getColorScaleForSeries = function (fieldIds) {
                return this.colors.getColorScaleByKey(SQExprShortSerializer.serializeArray(fieldIds || []));
            };
            ColorHelper.prototype.getColorForStaticSeries = function (objects, measureKey) {
                var scaleColor = this.defaultColorScale.getColor(measureKey).value;
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultDataPointColor
                    || scaleColor;
            };
            /**
             * Gets the color for the given measure.
             */
            ColorHelper.prototype.getColorForMeasure = function (objects, measureKey) {
                // Note, this allocates the color from the scale regardless of if we use it or not which helps keep colors stable.
                var scaleColor = this.defaultColorScale.getColor(measureKey).value;
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultCategoryColor
                    || this.defaultDataPointColor
                    || scaleColor;
            };
            ColorHelper.normalizeSelector = function (selector, isSingleSeries) {
                debug.assertAnyValue(selector, 'selector');
                // For dynamic series charts, colors are set per category.  So, exclude any measure (metadata repetition) from the selector.
                if (selector && (isSingleSeries || selector.data))
                    return { data: selector.data };
                return selector;
            };
            return ColorHelper;
        }());
        visuals.ColorHelper = ColorHelper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var dataviewReaders;
        (function (dataviewReaders) {
            var categorical;
            (function (categorical) {
                var ColorHelper = powerbi.visuals.ColorHelper;
                /**
                 * This function shouldn't be called directly except by the parent reader.
                 * Use createIDataViewCategoricalReader() to create a DataView reader.
                 */
                function createColorReader(columnReader, objectReader, dataReader, options) {
                    return new ColorReader(columnReader, objectReader, dataReader, options);
                }
                categorical.createColorReader = createColorReader;
                var ColorReader = /** @class */ (function () {
                    function ColorReader(columnReader, objectReader, dataReader, options) {
                        this.columnReader = columnReader;
                        this.objectReader = objectReader;
                        this.dataReader = dataReader;
                        if (options && options.colorOptions) {
                            this.colorPalette = options.colorOptions.visualStyle.colorPalette.dataColors;
                            this.valueRole = options.colorOptions.valueRole;
                            var defaultColor = powerbi.DataViewObjects.getFillColor(this.objectReader.getStaticObjects(), ColorReader.defaultColorProp);
                            var defaultCategoryColor = powerbi.DataViewObjects.getFillColor(this.objectReader.getStaticObjects(), ColorReader.defaultCategoryColorProp);
                            this.colorHelper = new ColorHelper(this.colorPalette, ColorReader.fillProp, options.colorOptions.ignoreDefaultColor ? undefined : defaultColor, options.colorOptions.ignoreDefaultCategoryColor ? undefined : defaultCategoryColor);
                            this.colorReaderIsValid = true;
                        }
                        else {
                            this.colorReaderIsValid = false;
                        }
                    }
                    ColorReader.prototype.createByCategory = function (categoryIndex) {
                        if (!this.colorReaderIsValid) {
                            debug.assertFail('You must create the DataViewCategoricalReader with color options to use color functions.');
                            return;
                        }
                        return this.colorHelper.getColorForSeriesValue(this.objectReader.getCategoryDataObjects(categoryIndex), this.columnReader.getCategoryColumnIdentityFields(), this.getCategoryValueForColor(categoryIndex));
                    };
                    ColorReader.prototype.createBySeries = function (seriesIndex, categoryIndex) {
                        if (!this.colorReaderIsValid) {
                            debug.assertFail('You must create the DataViewCategoricalReader with color options to use color functions.');
                            return;
                        }
                        var valueQueryName = '';
                        if (this.valueRole) {
                            valueQueryName = this.columnReader.getValueQueryName(this.valueRole, seriesIndex) || '';
                        }
                        // Color comes from the dynamic series
                        if (this.columnReader.hasDynamicSeries()) {
                            return this.colorHelper.getColorForSeriesValue(this.objectReader.getSeriesDataObjects(seriesIndex), this.columnReader.getDynamicSeriesColumnIdentityFields(), this.dataReader.getSeriesName(seriesIndex));
                        }
                        else if (this.columnReader.hasStaticSeries()) {
                            return this.colorHelper.getColorForStaticSeries(this.objectReader.getSeriesDataObjects(seriesIndex), valueQueryName);
                        }
                        else if (this.columnReader.hasCategories() && categoryIndex != null) {
                            return this.colorHelper.getColorForMeasure(this.objectReader.getCategoryDataObjects(categoryIndex), valueQueryName);
                        }
                        else {
                            return this.colorHelper.getColorForMeasure(this.objectReader.getValueMetadataObjects(this.valueRole, seriesIndex), valueQueryName);
                        }
                    };
                    ColorReader.prototype.createByValue = function (seriesIndex) {
                        if (!this.colorReaderIsValid) {
                            debug.assertFail('You must create the DataViewCategoricalReader with color options to use color functions.');
                            return;
                        }
                        if (this.valueRole == null) {
                            debug.assertFail("You cannot use colors.createByValue if you do not initialize the reader with a valueRole in colorOptions.");
                            return;
                        }
                        // Always use the first value query name to use an actual query name, but to stick to one default color across series
                        var queryName = this.columnReader.getValueQueryName(this.valueRole, 0) || '';
                        return this.colorHelper.getColorForMeasure(this.objectReader.getValueMetadataObjects(this.valueRole, seriesIndex), queryName);
                    };
                    ColorReader.prototype.getCategoryValueForColor = function (categoryIndex) {
                        var categoryColumns = this.columnReader.getAllCategoryColumns();
                        if (categoryColumns) {
                            return _.first(categoryColumns).values[categoryIndex];
                        }
                    };
                    ColorReader.defaultColorProp = { objectName: 'dataPoint', propertyName: 'defaultColor' };
                    ColorReader.defaultCategoryColorProp = { objectName: 'dataPoint', propertyName: 'defaultCategoryColor' };
                    ColorReader.fillProp = { objectName: 'dataPoint', propertyName: 'fill' };
                    return ColorReader;
                }());
            })(categorical = dataviewReaders.categorical || (dataviewReaders.categorical = {}));
        })(dataviewReaders = data.dataviewReaders || (data.dataviewReaders = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var dataviewReaders;
        (function (dataviewReaders) {
            var categorical;
            (function (categorical_1) {
                var DataRoleHelper = powerbi.data.DataRoleHelper;
                /**
                 * This function shouldn't be called directly except by the parent reader.
                 * Use createIDataViewCategoricalReader() to create a DataView reader.
                 */
                function createColumnReader(dataView, options) {
                    return new ColumnReader(dataView, options);
                }
                categorical_1.createColumnReader = createColumnReader;
                var ColumnReader = /** @class */ (function () {
                    function ColumnReader(dataView, options) {
                        debug.assertValue(dataView, 'dataView');
                        this.dataView = dataView;
                        // Validate categories
                        var categorical;
                        if (dataView)
                            categorical = dataView.categorical;
                        var categories;
                        if (categorical)
                            categories = this.categories = categorical.categories;
                        this.hasValidCategories = !_.isEmpty(categories);
                        if (options) {
                            this.staticSeriesRole = options.staticSeriesRole;
                        }
                        // Validate values
                        var values;
                        if (categorical)
                            values = categorical.values;
                        // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff
                        // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something
                        this.dataHasAnyValidValues = false;
                        if (values != null) {
                            var grouped = dataView.categorical.values.grouped();
                            if (grouped.length > 0) {
                                this.grouped = grouped;
                                // Iterate through the first group's values to populate the valueRoleIndexMapping
                                var valueRoleIndexMapping = {};
                                var firstGroupValues = grouped[0].values;
                                // There are cases where we don't have any valid values due to filtering, but we still get a blank value column with a source
                                //   In this case, we want to set dataHasAnyValidValues to false.
                                this.dataHasAnyValidValues = !!grouped[0].identity || (!_.isEmpty(firstGroupValues) && !_.isEmpty(firstGroupValues[0].values));
                                for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {
                                    var valueRoles = firstGroupValues[valueIndex].source.roles;
                                    for (var role in valueRoles) {
                                        if (valueRoles[role]) {
                                            if (!valueRoleIndexMapping[role])
                                                valueRoleIndexMapping[role] = [];
                                            valueRoleIndexMapping[role].push(valueIndex);
                                        }
                                    }
                                }
                                this.valueRoleIndexMapping = valueRoleIndexMapping;
                            }
                            this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;
                        }
                        this.dataHasStaticSeries = !this.dataHasDynamicSeries && this.getValueColumnCount(this.staticSeriesRole) > 1;
                    }
                    // Category methods
                    ColumnReader.prototype.hasCategories = function () {
                        return this.hasValidCategories;
                    };
                    ColumnReader.prototype.hasCategoryWithRole = function (roleName) {
                        return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;
                    };
                    ColumnReader.prototype.getCategoryCount = function () {
                        if (this.hasValidCategories)
                            return _.last(this.categories).values.length;
                        return 0;
                    };
                    ColumnReader.prototype.hasCompositeCategories = function () {
                        if (this.hasValidCategories)
                            return this.categories.length > 1;
                        return false;
                    };
                    ColumnReader.prototype.getCategoryColumn = function (roleName) {
                        if (this.hasValidCategories) {
                            var categories = this.categories;
                            var index = roleName ? DataRoleHelper.getCategoryIndexOfRole(categories, roleName) : 0;
                            return categories[index];
                        }
                    };
                    ColumnReader.prototype.getCategoryMetadataColumn = function (roleName) {
                        var categoryColumn = this.getCategoryColumn(roleName);
                        if (categoryColumn)
                            return categoryColumn.source;
                    };
                    ColumnReader.prototype.getCategoryColumnIdentityFields = function (roleName) {
                        var categoryColumn = this.getCategoryColumn(roleName);
                        return categoryColumn ? categoryColumn.identityFields : undefined;
                    };
                    ColumnReader.prototype.getAllCategoryColumns = function (roleName) {
                        if (roleName == null)
                            return this.categories;
                        if (this.hasValidCategories) {
                            var categories_1 = this.categories;
                            var indexes = roleName ? DataRoleHelper.getCategoryIndexesOfRole(categories_1, roleName) : [0];
                            return _.map(indexes, (function (index) { return categories_1[index]; }));
                        }
                        return [];
                    };
                    // Value Methods
                    ColumnReader.prototype.hasValues = function (roleName) {
                        return !!this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);
                    };
                    ColumnReader.prototype.hasAnyValidValues = function () {
                        return this.dataHasAnyValidValues;
                    };
                    ColumnReader.prototype.getValueColumnCount = function (roleName) {
                        if (this.hasValues(roleName)) {
                            return this.valueRoleIndexMapping[roleName].length;
                        }
                        return 0;
                    };
                    ColumnReader.prototype.hasHighlights = function () {
                        if (this.grouped && this.grouped[0] && this.grouped[0].values[0]) {
                            return !_.isEmpty(this.grouped[0].values[0].highlights);
                        }
                        return false;
                    };
                    ColumnReader.prototype.getValueColumn = function (roleName, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        if (!this.hasValues(roleName)) {
                            return;
                        }
                        // If we have a dynamic series, seriesIndex is the groupIndex and valueColumnInRole is 0;
                        //   otherwise, it is reversed.
                        if (this.dataHasDynamicSeries) {
                            return this.getValueColumnInternal(roleName, seriesIndex, 0);
                        }
                        else {
                            return this.getValueColumnInternal(roleName, 0, seriesIndex);
                        }
                    };
                    ColumnReader.prototype.getAllValueColumnsForRole = function (roleName, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        if (!this.hasValues(roleName)) {
                            return;
                        }
                        var roleIndices = this.valueRoleIndexMapping[roleName];
                        var valueColumnForRoleCount = roleIndices.length;
                        var valueColumns = [];
                        for (var valueColumnIndexForRole = 0; valueColumnIndexForRole < valueColumnForRoleCount; valueColumnIndexForRole++) {
                            valueColumns.push(this.getValueColumnInternal(roleName, seriesIndex, valueColumnIndexForRole));
                        }
                        return valueColumns;
                    };
                    /**
                     * Obtains the value column.
                     *
                     * Grouped:             [0] [1] [2] [3] (seriesIndex)
                     *                         /   \
                     * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)
                     *
                     *--------------------------------|
                     *                      |Category |
                     * Series|Value Columns |A B C D E|
                     *--------------------------------|
                     *      0|col0 (tooltip)|         |
                     *       |col1 (value)  |         |
                     *       |col2 (value)  |         |
                     *       |col3 (tooltip)|         |
                     *       |col4 (value)  |         |
                     *--------------------------------|
                     *      1|col0 (tooltip)|         |
                     *       |col1 (value)  |0 1 2 3 4|
                     *       |col2 (value)  |5 6 7 8 9|
                     *       |col3 (tooltip)|         |
                     *       |col4 (value)  |         |
                     *--------------------------------|
                     *      2|col0 (tooltip)|...      |
                     *
                     * valueColumnIndexInRole is for indexing into the values for a single role
                     * valueColumnIndex is for indexing into the entire value array including
                     * all roles
                     *
                     * The valueRoleIndexMapping converts valueColumnIndexInRole and role into
                     * valueColumnIndex
                     *
                     * Example: getValueColumn('value', 1, 1) returns the column containing the
                     * values [5,6,7,8,9]: The second group, the second value column with role
                     * "value" (which is the third in the value array).
                     */
                    ColumnReader.prototype.getValueColumnInternal = function (roleName, groupIndex, valueColumnIndexInRole) {
                        if (this.hasValues(roleName)) {
                            var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];
                            return this.grouped[groupIndex].values[valueColumnIndex];
                        }
                    };
                    ColumnReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        // Get the metadata column from the first value column in this role
                        var valueColumn = this.getValueColumn(roleName, seriesIndex);
                        if (valueColumn) {
                            return valueColumn.source;
                        }
                    };
                    ColumnReader.prototype.getAllValueMetadataColumnsForRole = function (roleName, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        if (this.hasValues(roleName)) {
                            return _.map(this.getAllValueColumnsForRole(roleName, seriesIndex), (function (valueColumn) { return valueColumn.source; }));
                        }
                    };
                    ColumnReader.prototype.getValueQueryName = function (roleName, seriesIndex) {
                        var metadataColumn = this.getValueMetadataColumn(roleName, seriesIndex);
                        if (metadataColumn) {
                            return metadataColumn.queryName;
                        }
                    };
                    ColumnReader.prototype.getAllValueQueryNames = function (roleName, seriesIndex) {
                        var metadataColumns = this.getAllValueMetadataColumnsForRole(roleName, seriesIndex);
                        if (!_.isEmpty(metadataColumns)) {
                            return _.map(metadataColumns, (function (column) { return column.queryName; }));
                        }
                    };
                    ColumnReader.prototype.getAllValueRoles = function () {
                        var roles = _.keys(this.valueRoleIndexMapping);
                        if (!_.isEmpty(roles)) {
                            return roles;
                        }
                    };
                    // Series methods
                    ColumnReader.prototype.hasDynamicSeries = function () {
                        return this.dataHasDynamicSeries;
                    };
                    ColumnReader.prototype.hasStaticSeries = function () {
                        return this.dataHasStaticSeries;
                    };
                    ColumnReader.prototype.getSeriesCount = function () {
                        // No values; there shouldn't be any looping over "series"
                        if (!this.dataHasAnyValidValues)
                            return 0;
                        if (this.dataHasDynamicSeries) {
                            return this.grouped.length;
                        }
                        if (this.dataHasStaticSeries) {
                            var roleIndexMap = this.valueRoleIndexMapping[this.staticSeriesRole];
                            if (roleIndexMap)
                                return roleIndexMap.length;
                        }
                        // No series, but callers typically should loop over one "series" to get the values
                        return 1;
                    };
                    ColumnReader.prototype.getSeriesValueColumns = function () {
                        var hasDynamicSeries = this.dataHasDynamicSeries;
                        debug.assert(hasDynamicSeries, 'getSeriesValueColumns should not be called when there is no dynamic series');
                        if (hasDynamicSeries)
                            return this.dataView.categorical.values;
                    };
                    ColumnReader.prototype.getSeriesMetadataColumn = function () {
                        var seriesColumns = this.getSeriesValueColumns();
                        if (seriesColumns)
                            return seriesColumns.source;
                    };
                    ColumnReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {
                        var hasDynamicSeries = this.dataHasDynamicSeries;
                        debug.assert(hasDynamicSeries, 'getSeriesValueColumnGroup should not be called when there is no dynamic series');
                        if (this.dataHasAnyValidValues && hasDynamicSeries)
                            return this.grouped[seriesIndex];
                    };
                    ColumnReader.prototype.getDynamicSeriesColumnIdentityFields = function () {
                        var seriesColumns = this.getSeriesValueColumns();
                        return seriesColumns ? seriesColumns.identityFields : undefined;
                    };
                    // Other methods
                    ColumnReader.prototype.getStaticObjects = function () {
                        if (this.dataView && this.dataView.metadata && this.dataView.metadata.objects) {
                            return this.dataView.metadata.objects;
                        }
                    };
                    ColumnReader.prototype.getMetadataColumns = function (role) {
                        var result = [];
                        if (this.dataView && this.dataView.metadata && this.dataView.metadata.columns) {
                            result = _.filter(this.dataView.metadata.columns, (function (column) {
                                return column.roles != null && column.roles[role] === true;
                            }));
                        }
                        return !_.isEmpty(result) ? result : undefined;
                    };
                    return ColumnReader;
                }());
            })(categorical = dataviewReaders.categorical || (dataviewReaders.categorical = {}));
        })(dataviewReaders = data.dataviewReaders || (data.dataviewReaders = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var dataviewReaders;
        (function (dataviewReaders) {
            var categorical;
            (function (categorical) {
                /**
                 * This function shouldn't be called directly except by the parent reader.
                 * Use createIDataViewCategoricalReader() to create a DataView reader.
                 */
                function createDataReader(columnReader, options) {
                    return new DataReader(columnReader, options);
                }
                categorical.createDataReader = createDataReader;
                var DataReader = /** @class */ (function () {
                    function DataReader(columnReader, options) {
                        this.columnReader = columnReader;
                        this.dataHasDynamicSeries = columnReader.hasDynamicSeries();
                        this.dataHasStaticSeries = columnReader.hasStaticSeries();
                        this.hasAnyValidValues = columnReader.hasAnyValidValues();
                        if (options) {
                            this.staticSeriesRole = options.staticSeriesRole;
                        }
                    }
                    // Category methods
                    DataReader.prototype.hasCategories = function () {
                        return this.columnReader.hasCategories();
                    };
                    DataReader.prototype.hasCategoryWithRole = function (roleName) {
                        return this.columnReader.hasCategoryWithRole(roleName);
                    };
                    DataReader.prototype.hasCompositeCategories = function () {
                        return this.columnReader.hasCompositeCategories();
                    };
                    DataReader.prototype.getCategoryCount = function () {
                        return this.columnReader.getCategoryCount();
                    };
                    DataReader.prototype.getCategoryValue = function (roleName, categoryIndex) {
                        var categoryColumn = this.columnReader.getCategoryColumn(roleName);
                        return categoryColumn ? categoryColumn.values[categoryIndex] : undefined;
                    };
                    DataReader.prototype.getAllCategoryValuesForRole = function (roleName, categoryIndex) {
                        var categoryColumns = this.columnReader.getAllCategoryColumns(roleName);
                        return categoryColumns ? _.map(categoryColumns, (function (categoryColumn) { return categoryColumn.values[categoryIndex]; })) : undefined;
                    };
                    DataReader.prototype.getCategoryMetadataColumn = function (roleName) {
                        var categoryColumn = this.columnReader.getCategoryColumn(roleName);
                        return categoryColumn ? categoryColumn.source : undefined;
                    };
                    DataReader.prototype.getCategoryDisplayName = function (roleName) {
                        var targetColumn = this.columnReader.getCategoryColumn(roleName);
                        if (targetColumn && targetColumn.source) {
                            return targetColumn.source.displayName;
                        }
                    };
                    DataReader.prototype.getAllCategoryDisplayNamesForRole = function (roleName) {
                        var targetColumns = this.columnReader.getAllCategoryColumns(roleName);
                        if (targetColumns) {
                            return _.map(targetColumns, (function (targetColumn) { return targetColumn.source && targetColumn.source.displayName; }));
                        }
                    };
                    DataReader.prototype.getCategoryType = function (roleName) {
                        var targetMetadataColumn = this.columnReader.getCategoryMetadataColumn(roleName);
                        if (targetMetadataColumn) {
                            return targetMetadataColumn.type;
                        }
                    };
                    // Value and measure methods
                    DataReader.prototype.hasValues = function (roleName) {
                        return this.columnReader.hasValues(roleName);
                    };
                    DataReader.prototype.hasHighlights = function () {
                        return this.columnReader.hasHighlights();
                    };
                    DataReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        if (this.hasValues(roleName)) {
                            var valueColumn = this.columnReader.getValueColumn(roleName, seriesIndex);
                            if (valueColumn) {
                                return valueColumn.values[categoryIndex];
                            }
                        }
                    };
                    DataReader.prototype.getHighlight = function (roleName, categoryIndex, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        debug.assert(this.hasHighlights(), 'getHighlight should not be called when there are no highlight values.');
                        if (this.hasValues(roleName) && this.hasHighlights()) {
                            var valueColumn = this.columnReader.getValueColumn(roleName, seriesIndex);
                            if (valueColumn) {
                                return valueColumn.highlights[categoryIndex];
                            }
                        }
                    };
                    DataReader.prototype.getValueType = function (roleName, seriesIndex) {
                        var targetMetadataColumn = this.columnReader.getValueMetadataColumn(roleName, seriesIndex);
                        if (targetMetadataColumn) {
                            return targetMetadataColumn.type;
                        }
                    };
                    DataReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        debug.assert(roleName !== this.staticSeriesRole, "getAllValuesForRole should not be called with the static series role.  Use getValue and a seriesIndex.");
                        if (this.hasValues(roleName)) {
                            // If we do not have a dynamic series, zero out the series index, as static
                            //   series are irrelevant to this function.
                            if (!this.dataHasDynamicSeries)
                                seriesIndex = 0;
                            var valueColumns = this.columnReader.getAllValueColumnsForRole(roleName, seriesIndex);
                            return _.map(valueColumns, (function (valueColumn) { return valueColumn.values[categoryIndex]; }));
                        }
                    };
                    DataReader.prototype.getAllHighlightsForRole = function (roleName, categoryIndex, seriesIndex) {
                        if (seriesIndex === void 0) { seriesIndex = 0; }
                        debug.assert(this.hasHighlights(), 'getAllHighlightsForRole should not be called when there are no highlight values.');
                        debug.assert(roleName !== this.staticSeriesRole, "getAllHighlightsForRole should not be called with the static series role.  Use getHighlight and a seriesIndex.");
                        if (this.hasValues(roleName) && this.hasHighlights()) {
                            // If we do not have a dynamic series, zero out the series index, as static
                            //   series are irrelevant to this function.
                            if (!this.dataHasDynamicSeries)
                                seriesIndex = 0;
                            var valueColumns = this.columnReader.getAllValueColumnsForRole(roleName, seriesIndex);
                            return _.map(valueColumns, (function (valueColumn) { return valueColumn.highlights[categoryIndex]; }));
                        }
                    };
                    DataReader.prototype.getAllValueTypesForRole = function (roleName, seriesIndex) {
                        var targetMetadataColumns = this.columnReader.getAllValueMetadataColumnsForRole(roleName, seriesIndex);
                        if (targetMetadataColumns) {
                            return _.map(targetMetadataColumns, (function (targetMetadataColumn) { return targetMetadataColumn.type; }));
                        }
                    };
                    DataReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {
                        if (this.hasValues(roleName)) {
                            var seriesCount = this.getSeriesCount();
                            if (!this.dataHasDynamicSeries) {
                                debug.assert(!this.dataHasStaticSeries, "getFirstNonNullValueForCategory shouldn't be called if you have a static series");
                                return this.getValue(roleName, categoryIndex);
                            }
                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var value = this.getValue(roleName, categoryIndex, seriesIndex);
                                if (value != null) {
                                    return value;
                                }
                            }
                        }
                    };
                    DataReader.prototype.getValueDisplayName = function (roleName) {
                        debug.assert(roleName !== this.staticSeriesRole || !this.columnReader.hasStaticSeries(), "getValueDisplayName shouldn't be called on the static series role if there is a static series.  Use getSeriesName.");
                        if (this.hasValues(roleName)) {
                            var metadataColumn = this.columnReader.getValueMetadataColumn(roleName);
                            if (metadataColumn) {
                                return metadataColumn.displayName;
                            }
                        }
                    };
                    DataReader.prototype.getAllValueDisplayNamesForRole = function (roleName) {
                        debug.assert(roleName !== this.staticSeriesRole, "getAllValueDisplayNamesForRole shouldn't be called on the static series role if you have a static series. Use getSeriesName.");
                        if (this.hasValues(roleName)) {
                            var metadataColumns = this.columnReader.getAllValueMetadataColumnsForRole(roleName);
                            if (!_.isEmpty(metadataColumns)) {
                                return _.map(metadataColumns, (function (metadataColumn) { return metadataColumn.displayName; }));
                            }
                        }
                    };
                    DataReader.prototype.getValueQueryName = function (roleName, seriesIndex) {
                        return this.columnReader.getValueQueryName(roleName, seriesIndex);
                    };
                    // Series methods
                    DataReader.prototype.hasSeries = function () {
                        return this.dataHasDynamicSeries || this.dataHasStaticSeries;
                    };
                    DataReader.prototype.getSeriesCount = function () {
                        return this.columnReader.getSeriesCount();
                    };
                    DataReader.prototype.getSeriesName = function (seriesIndex) {
                        debug.assert(this.hasSeries(), "getSeriesName should not be called when there is no series");
                        if (!this.hasSeries())
                            return;
                        if (this.dataHasDynamicSeries) {
                            var seriesValueColumnGroup = this.columnReader.getSeriesValueColumnGroup(seriesIndex);
                            if (seriesValueColumnGroup)
                                return seriesValueColumnGroup.name;
                        }
                        else if (this.dataHasStaticSeries && this.hasValues(this.staticSeriesRole)) {
                            var metadataColumn = this.columnReader.getValueMetadataColumn(this.staticSeriesRole, seriesIndex);
                            if (metadataColumn) {
                                return metadataColumn.displayName;
                            }
                        }
                    };
                    DataReader.prototype.getSeriesDisplayName = function () {
                        debug.assert(this.hasSeries(), "getSeriesDisplayName should not be called when there is no series");
                        if (this.dataHasDynamicSeries) {
                            return this.columnReader.getSeriesValueColumns().source.displayName;
                        }
                    };
                    DataReader.prototype.getSeriesType = function () {
                        var targetMetadataColumn = this.columnReader.getSeriesMetadataColumn();
                        if (targetMetadataColumn) {
                            return targetMetadataColumn.type;
                        }
                    };
                    return DataReader;
                }());
            })(categorical = dataviewReaders.categorical || (dataviewReaders.categorical = {}));
        })(dataviewReaders = data.dataviewReaders || (data.dataviewReaders = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /**
         * Creates a collection of useful readers used to read information
         * from a categorical DataView.  It's strongly recommended to use this
         * reader, as these abstractions are built to ease the process of
         * reading the correct thing from DataViews.
         */
        function createDataViewCategoricalReader(dataView, options) {
            var columnReader = data.dataviewReaders.categorical.createColumnReader(dataView, options);
            var dataReader = data.dataviewReaders.categorical.createDataReader(columnReader, options);
            var objectReader = data.dataviewReaders.categorical.createObjectReader(columnReader, options);
            return {
                data: dataReader,
                identities: data.dataviewReaders.categorical.createIdentityReader(columnReader, options),
                objects: objectReader,
                colors: data.dataviewReaders.categorical.createColorReader(columnReader, objectReader, dataReader, options),
            };
        }
        data.createDataViewCategoricalReader = createDataViewCategoricalReader;
        /**
         * Creates a collection of all the readers IDataViewCategoricalReader has,
         * but also includes a column reader for accessing the DataView columns
         * directly.  Use of this reader is not recommended except for advanced
         * users, but is still preferable to accessing a DataView directly.
         *
         * In most cases, if the normal reader doesn't provide something, it
         * should be upgraded to provide that information instead of using this.
         *
         * The advanced reader is being used by many core visuals temporarily to
         * reduce code churn while this new interface is being introduced.
         */
        function createDataViewCategoricalReaderAdvanced(dataView, options) {
            var columnReader = data.dataviewReaders.categorical.createColumnReader(dataView, options);
            var dataReader = data.dataviewReaders.categorical.createDataReader(columnReader, options);
            var objectReader = data.dataviewReaders.categorical.createObjectReader(columnReader, options);
            return {
                data: dataReader,
                identities: data.dataviewReaders.categorical.createIdentityReader(columnReader, options),
                objects: objectReader,
                colors: data.dataviewReaders.categorical.createColorReader(columnReader, objectReader, dataReader, options),
                columns: columnReader,
            };
        }
        data.createDataViewCategoricalReaderAdvanced = createDataViewCategoricalReaderAdvanced;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var dataviewReaders;
        (function (dataviewReaders) {
            var categorical;
            (function (categorical) {
                /**
                 * This function shouldn't be called directly except by the parent reader.
                 * Use createIDataViewCategoricalReader() to create a DataView reader.
                 */
                function createIdentityReader(columnReader, options) {
                    return new IdentityReader(columnReader, options);
                }
                categorical.createIdentityReader = createIdentityReader;
                var IdentityReader = /** @class */ (function () {
                    function IdentityReader(columnReader, options) {
                        this.columnReader = columnReader;
                        this.dataHasDynamicSeries = columnReader.hasDynamicSeries();
                        this.dataHasStaticSeries = columnReader.hasStaticSeries();
                        this.hasAnyValidValues = columnReader.hasAnyValidValues();
                        this.valueRoles = columnReader.getAllValueRoles();
                        if (options) {
                            this.staticSeriesRole = options.staticSeriesRole;
                        }
                    }
                    IdentityReader.prototype.createForCategory = function (categoryIndex, valueRoleNames) {
                        return new powerbi.visuals.SelectionIdBuilder()
                            .withCategory(this.columnReader.getCategoryColumn(), categoryIndex)
                            .withMeasures(this.mapRolesToValueMetadata(valueRoleNames))
                            .createSelectionId();
                    };
                    IdentityReader.prototype.createForDataPoint = function (categoryIndex, seriesIndex, valueRoleNames) {
                        if (this.dataHasDynamicSeries || this.dataHasStaticSeries) {
                            debug.assert(seriesIndex != null, "A seriesIndex is required if you have a series");
                        }
                        var builder = new powerbi.visuals.SelectionIdBuilder()
                            .withCategory(this.columnReader.getCategoryColumn(), categoryIndex);
                        if (seriesIndex != null && this.dataHasDynamicSeries) {
                            builder.withSeries(this.columnReader.getSeriesValueColumns(), this.columnReader.getSeriesValueColumnGroup(seriesIndex));
                        }
                        builder.withMeasures(this.mapRolesToValueMetadata(valueRoleNames, seriesIndex));
                        return builder.createSelectionId();
                    };
                    IdentityReader.prototype.createForSeries = function (seriesIndex, valueRoleNames) {
                        var builder = new powerbi.visuals.SelectionIdBuilder();
                        if (this.dataHasDynamicSeries) {
                            builder.withSeries(this.columnReader.getSeriesValueColumns(), this.columnReader.getSeriesValueColumnGroup(seriesIndex));
                        }
                        builder.withMeasures(this.mapRolesToValueMetadata(valueRoleNames, seriesIndex));
                        return builder.createSelectionId();
                    };
                    IdentityReader.prototype.createForValue = function (seriesIndex, valueRoleNames) {
                        return new powerbi.visuals.SelectionIdBuilder()
                            .withMeasures(this.mapRolesToValueMetadata(valueRoleNames, seriesIndex))
                            .createSelectionId();
                    };
                    IdentityReader.prototype.mapRolesToValueMetadata = function (valueRoles, seriesIndex) {
                        var valueMetadata = [];
                        var roleIndex = 0;
                        var staticSeriesRole = this.staticSeriesRole;
                        var hasStaticSeries = this.columnReader.hasStaticSeries();
                        if (valueRoles == null) {
                            valueRoles = this.columnReader.getAllValueRoles() || [];
                        }
                        // If we have a static series, only include the query name for the series we want.
                        if (hasStaticSeries) {
                            valueMetadata.push(this.columnReader.getValueQueryName(staticSeriesRole, seriesIndex));
                        }
                        for (var roleCount = valueRoles.length; roleIndex < roleCount; roleIndex++) {
                            var valueRole = valueRoles[roleIndex];
                            // Skip the static series role if we have a static series, as we only want to add that once based on series index in that case
                            if (valueRole !== staticSeriesRole || !hasStaticSeries) {
                                valueMetadata.push.apply(valueMetadata, this.columnReader.getAllValueQueryNames(valueRole));
                            }
                        }
                        return valueMetadata;
                    };
                    return IdentityReader;
                }());
            })(categorical = dataviewReaders.categorical || (dataviewReaders.categorical = {}));
        })(dataviewReaders = data.dataviewReaders || (data.dataviewReaders = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var dataviewReaders;
        (function (dataviewReaders) {
            var categorical;
            (function (categorical) {
                /**
                 * This function shouldn't be called directly except by the parent reader.
                 * Use createIDataViewCategoricalReader() to create a DataView reader.
                 */
                function createObjectReader(columnReader, options) {
                    return new ObjectReader(columnReader, options);
                }
                categorical.createObjectReader = createObjectReader;
                var ObjectReader = /** @class */ (function () {
                    function ObjectReader(columnReader, options) {
                        this.columnReader = columnReader;
                        this.staticObjects = columnReader.getStaticObjects();
                        if (options) {
                            this.staticSeriesRole = options.staticSeriesRole;
                            if (options.colorOptions) {
                                this.dataColors = options.colorOptions.visualStyle.colorPalette.dataColors;
                            }
                        }
                    }
                    ObjectReader.prototype.getStaticObjects = function () {
                        return this.staticObjects;
                    };
                    ObjectReader.prototype.getCategoryMetadataObjects = function (roleName) {
                        var categoryColumn = this.columnReader.getCategoryColumn(roleName);
                        if (categoryColumn) {
                            return categoryColumn.source.objects;
                        }
                    };
                    ObjectReader.prototype.getAllCategoryMetadataObjectsForRole = function (roleName) {
                        var categoryColumns = this.columnReader.getAllCategoryColumns(roleName);
                        if (categoryColumns) {
                            return _.map(categoryColumns, (function (categoryColumn) { return categoryColumn.source.objects; }));
                        }
                    };
                    ObjectReader.prototype.getCategoryDataObjects = function (categoryIndex) {
                        var categoryColumn = this.columnReader.getCategoryColumn();
                        if (categoryColumn && categoryColumn.objects) {
                            return categoryColumn.objects[categoryIndex];
                        }
                    };
                    ObjectReader.prototype.getValueMetadataObjects = function (roleName, seriesIndex) {
                        debug.assert(!(this.columnReader.hasStaticSeries && roleName === this.staticSeriesRole && seriesIndex == null), "getValueMetadataObjects requires a seriesIndex when called on the static series role");
                        var valueColumn = this.columnReader.getValueMetadataColumn(roleName, seriesIndex);
                        if (valueColumn) {
                            return valueColumn.objects;
                        }
                    };
                    ObjectReader.prototype.getAllValueMetadataObjectsForRole = function (roleName) {
                        debug.assert(roleName !== this.staticSeriesRole, "getAllValueMetadataObjectsForRole should not be called with the static series role.  Use getValueMetadataObjects with a seriesIndex.");
                        var metadataColumns = this.columnReader.getAllValueMetadataColumnsForRole(roleName);
                        return _.map(metadataColumns, (function (column) { return column.objects; }));
                    };
                    ObjectReader.prototype.getSeriesMetadataObjects = function () {
                        debug.assert(this.columnReader.hasDynamicSeries() || this.columnReader.hasStaticSeries(), 'getSeriesDataObjects should not be called if there is no series.');
                        if (!this.columnReader.hasDynamicSeries())
                            return;
                        var seriesColumn = this.columnReader.getSeriesMetadataColumn();
                        if (seriesColumn) {
                            return seriesColumn.objects;
                        }
                    };
                    ObjectReader.prototype.getSeriesDataObjects = function (seriesIndex) {
                        debug.assert(this.columnReader.hasDynamicSeries() || this.columnReader.hasStaticSeries(), 'getSeriesDataObjects should not be called if there is no series.');
                        var seriesColumn;
                        if (this.columnReader.hasDynamicSeries()) {
                            seriesColumn = this.columnReader.getSeriesValueColumnGroup(seriesIndex);
                        }
                        else {
                            seriesColumn = this.columnReader.getValueMetadataColumn(this.staticSeriesRole, seriesIndex);
                        }
                        if (seriesColumn) {
                            return seriesColumn.objects;
                        }
                    };
                    ObjectReader.prototype.getCategoryFormatString = function (roleName) {
                        return powerbi.DataViewObjects.getValue(this.getCategoryMetadataObjects(roleName), ObjectReader.StandardFormatStringProp);
                    };
                    ObjectReader.prototype.getAllCategoryFormatStringsForRole = function (roleName) {
                        return _.map(this.getAllCategoryMetadataObjectsForRole(roleName), (function (objects) { return powerbi.DataViewObjects.getValue(objects, ObjectReader.StandardFormatStringProp); }));
                    };
                    ObjectReader.prototype.getValueFormatString = function (roleName, seriesIndex) {
                        if (this.columnReader.hasStaticSeries && roleName === this.staticSeriesRole && seriesIndex == null) {
                            debug.assertFail("getValueFormatString requires a seriesIndex when called on the static series role");
                            return undefined;
                        }
                        return powerbi.DataViewObjects.getValue(this.getValueMetadataObjects(roleName, seriesIndex), ObjectReader.StandardFormatStringProp);
                    };
                    ObjectReader.prototype.getAllValueFormatStringsForRole = function (roleName) {
                        debug.assert(roleName !== this.staticSeriesRole, "getAllValueFormatStringsForRole should not be called with the static series role.  Use getValueFormatString and a seriesIndex.");
                        var objects = this.getAllValueMetadataObjectsForRole(roleName);
                        return _.map(objects, (function (object) { return powerbi.DataViewObjects.getValue(object, ObjectReader.StandardFormatStringProp); }));
                    };
                    ObjectReader.prototype.getSeriesFormatString = function (seriesIndex) {
                        if (this.columnReader.hasStaticSeries()) {
                            return;
                        }
                        if (this.columnReader.hasDynamicSeries()) {
                            return powerbi.DataViewObjects.getValue(this.getSeriesMetadataObjects(), ObjectReader.StandardFormatStringProp);
                        }
                        debug.assertFail('getSeriesFormatString should not be called if you have no series.');
                    };
                    ObjectReader.StandardFormatStringProp = { objectName: 'general', propertyName: 'formatString' };
                    return ObjectReader;
                }());
            })(categorical = dataviewReaders.categorical || (dataviewReaders.categorical = {}));
        })(dataviewReaders = data.dataviewReaders || (data.dataviewReaders = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Font;
        (function (Font) {
            Font.FamilyQuote = "\"";
            Font.FamilyDelimiter = ", ";
            var FamilyInfo = /** @class */ (function () {
                function FamilyInfo(families) {
                    this.families = families;
                }
                Object.defineProperty(FamilyInfo.prototype, "family", {
                    /**
                     * Gets the font-families joined by FamilyDelimiter.
                     */
                    get: function () {
                        return this.getFamily();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                * Gets the font-families joined by FamilyDelimiter.
                */
                FamilyInfo.prototype.getFamily = function () {
                    return this.families.join(Font.FamilyDelimiter);
                };
                Object.defineProperty(FamilyInfo.prototype, "css", {
                    /**
                     * Gets the CSS string for the "font-family" CSS attribute.
                     */
                    get: function () {
                        return this.getCSS();
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Gets the CSS string for the "font-family" CSS attribute.
                 */
                FamilyInfo.prototype.getCSS = function () {
                    return this.families ? this.families.map((function (font) { return font.indexOf(' ') > -1 ? "'" + font + "'" : font; })).join(', ') : null;
                };
                return FamilyInfo;
            }());
            Font.FamilyInfo = FamilyInfo;
            // These should map to the fonts in src\clients\externals\StyleLibrary\less\fontFaces.less
            Font.Family = {
                light: new FamilyInfo(['Segoe UI Light', 'wf_segoe-ui_light', 'helvetica', 'arial', 'sans-serif']),
                semilight: new FamilyInfo(['Segoe UI Semilight', 'wf_segoe-ui_semilight', 'helvetica', 'arial', 'sans-serif']),
                regular: new FamilyInfo(['Segoe UI', 'wf_segoe-ui_normal', 'helvetica', 'arial', 'sans-serif']),
                semibold: new FamilyInfo(['Segoe UI Semibold', 'wf_segoe-ui_semibold', 'helvetica', 'arial', 'sans-serif']),
                bold: new FamilyInfo(['Segoe UI Bold', 'wf_segoe-ui_bold', 'helvetica', 'arial', 'sans-serif']),
                lightSecondary: new FamilyInfo(['wf_standard-font_light', 'helvetica', 'arial', 'sans-serif']),
                regularSecondary: new FamilyInfo(['wf_standard-font', 'helvetica', 'arial', 'sans-serif']),
                boldSecondary: new FamilyInfo(['wf_standard-font_bold', 'helvetica', 'arial', 'sans-serif']),
                glyphs: new FamilyInfo(['PowerVisuals']),
            };
            function normalizeFamily(family, quoteFontsWithWhitespace) {
                if (quoteFontsWithWhitespace === void 0) { quoteFontsWithWhitespace = true; }
                if (_.isEmpty(family)) {
                    return family;
                }
                if (family.indexOf(',') === -1) {
                    return family.indexOf(' ') === -1 ? family :
                        (quoteFontsWithWhitespace ? quoteFontFamily(family) : unQuoteFamily(family));
                }
                var families = family.split(',');
                return families.map((function (currentFamily) { return normalizeFamily(currentFamily.trim(), quoteFontsWithWhitespace); }))
                    .join(Font.FamilyDelimiter);
            }
            Font.normalizeFamily = normalizeFamily;
            function unQuoteFamily(family) {
                if (!family) {
                    return;
                }
                return family.replace(/['"]+/g, '');
            }
            Font.unQuoteFamily = unQuoteFamily;
            /**
             * Adds quotes around font families. Strips an existing quotes.
             */
            function quoteFontFamily(family) {
                if (!family) {
                    return;
                }
                return Font.FamilyQuote + family.replace(/['"]+/g, '') + Font.FamilyQuote;
            }
            Font.quoteFontFamily = quoteFontFamily;
        })(Font = visuals.Font || (visuals.Font = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var Units;
        (function (Units) {
            var FontSize = /** @class */ (function () {
                function FontSize(pt, px) {
                    this.pt = pt;
                    this.px = px;
                }
                FontSize.createFromPt = function (pt) {
                    debug.assert(_.isFinite(pt), 'pt is not a number');
                    return new FontSize(pt, PixelConverter.fromPointToPixel(pt));
                };
                FontSize.createFromPx = function (px) {
                    debug.assert(_.isFinite(px), 'px is not a number');
                    return new FontSize(PixelConverter.toPoint(px), px);
                };
                return FontSize;
            }());
            Units.FontSize = FontSize;
        })(Units = visuals.Units || (visuals.Units = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ClampValue = jsCommon.Utility.clampValue;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var FontSize = visuals.Units.FontSize;
        var PixelConverter = jsCommon.PixelConverter;
        var LegendIcon;
        (function (LegendIcon) {
            LegendIcon[LegendIcon["Box"] = 0] = "Box";
            LegendIcon[LegendIcon["Circle"] = 1] = "Circle";
            LegendIcon[LegendIcon["Line"] = 2] = "Line";
        })(LegendIcon = visuals.LegendIcon || (visuals.LegendIcon = {}));
        var LegendPosition;
        (function (LegendPosition) {
            LegendPosition[LegendPosition["Top"] = 0] = "Top";
            LegendPosition[LegendPosition["Bottom"] = 1] = "Bottom";
            LegendPosition[LegendPosition["Right"] = 2] = "Right";
            LegendPosition[LegendPosition["Left"] = 3] = "Left";
            // Try to avoid using None enum type in the code. This type is not exist in the LegendPosition.ts
            LegendPosition[LegendPosition["None"] = 4] = "None";
            LegendPosition[LegendPosition["TopCenter"] = 5] = "TopCenter";
            LegendPosition[LegendPosition["BottomCenter"] = 6] = "BottomCenter";
            LegendPosition[LegendPosition["RightCenter"] = 7] = "RightCenter";
            LegendPosition[LegendPosition["LeftCenter"] = 8] = "LeftCenter";
        })(LegendPosition = visuals.LegendPosition || (visuals.LegendPosition = {}));
        visuals.legendProps = {
            show: 'show',
            position: 'position',
            titleText: 'titleText',
            showTitle: 'showTitle',
            labelColor: 'labelColor',
            fontSize: 'fontSize',
        };
        visuals.legendPropIdentifiers = {
            show: { objectName: 'legend', propertyName: 'show' },
            position: { objectName: 'legend', propertyName: 'position' },
            showTitle: { objectName: 'legend', propertyName: 'showTitle' },
            titleText: { objectName: 'legend', propertyName: 'titleText' },
            labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            fontSize: { objectName: 'legend', propertyName: 'fontSize' },
            fontFamily: { objectName: 'legend', propertyName: 'fontFamily' },
        };
        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition, legendSmallViewPortProperties) {
            if (isScrollable === void 0) { isScrollable = false; }
            if (legendPosition === void 0) { legendPosition = LegendPosition.Top; }
            if (interactive)
                return new CartesianChartInteractiveLegend(legendParentElement);
            else
                return new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable, legendSmallViewPortProperties);
        }
        visuals.createLegend = createLegend;
        var Legend;
        (function (Legend) {
            function isLeft(orientation) {
                switch (orientation) {
                    case LegendPosition.Left:
                    case LegendPosition.LeftCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isLeft = isLeft;
            function isTop(orientation) {
                switch (orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isTop = isTop;
            function isBottom(orientation) {
                switch (orientation) {
                    case LegendPosition.Bottom:
                    case LegendPosition.BottomCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isBottom = isBottom;
            function isRight(orientation) {
                switch (orientation) {
                    case LegendPosition.Right:
                    case LegendPosition.RightCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isRight = isRight;
            function isCentered(orientation) {
                switch (orientation) {
                    case LegendPosition.BottomCenter:
                    case LegendPosition.LeftCenter:
                    case LegendPosition.RightCenter:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isCentered = isCentered;
            function isTopOrBottom(orientation) {
                return (Legend.isTop(orientation) || Legend.isBottom(orientation));
            }
            Legend.isTopOrBottom = isTopOrBottom;
            function isLeftOrRight(orientation) {
                return (Legend.isLeft(orientation) || Legend.isRight(orientation));
            }
            Legend.isLeftOrRight = isLeftOrRight;
            function positionChartArea(chartArea, legend) {
                var legendMargins = legend.getMargins();
                var legendOrientation = legend.getOrientation();
                chartArea.style({
                    'margin-left': Legend.isLeft(legendOrientation) ? legendMargins.width + 'px' : null,
                    'margin-top': Legend.isTop(legendOrientation) ? legendMargins.height + 'px' : null,
                });
            }
            Legend.positionChartArea = positionChartArea;
            Legend.DefaultFontFamily = visuals.Font.Family.regular.css;
            Legend.DefaultFontSize = FontSize.createFromPt(8);
            Legend.DefaultLabelColor = '#666666';
            Legend.DefaultPositionKey = 'Top';
            function getDefaultFontProperties() {
                return {
                    family: Legend.DefaultFontFamily,
                    size: Legend.DefaultFontSize,
                    color: Legend.DefaultLabelColor
                };
            }
            Legend.getDefaultFontProperties = getDefaultFontProperties;
            function getDefaultLegendData() {
                return {
                    show: true,
                    title: '',
                    dataPoints: [],
                    fontProperties: powerbi.Prototype.inherit(Legend.getDefaultFontProperties()),
                    grouped: false,
                    showTitle: true,
                    position: LegendPosition.Top,
                };
            }
            Legend.getDefaultLegendData = getDefaultLegendData;
            function buildSeriesLegendData(options) {
                var reader = powerbi.data.createDataViewCategoricalReaderAdvanced(options.dataView, {
                    staticSeriesRole: options.staticSeriesRole,
                    colorOptions: {
                        valueRole: options.staticSeriesRole,
                        visualStyle: options.style,
                        ignoreDefaultColor: options.ignoreDefaultColor,
                        ignoreDefaultCategoryColor: options.ignoreDefaultCategoryColor
                    }
                });
                if (!reader.data.hasSeries()) {
                    return options.allowLegendWithNoSeries ?
                        Legend.buildSeriesLegendDataForWithNoSeries(reader, options) :
                        Legend.getDefaultLegendData();
                }
                var staticObjects = reader.objects.getStaticObjects();
                var legendDataPoints = [];
                var hasDynamicSeries = reader.columns.hasDynamicSeries();
                // Using just a marker shape instead of the full line and marker options
                var simpleMarkerProp = options.simpleMarkerProp;
                var staticSimpleMarkerShape = simpleMarkerProp ? powerbi.DataViewObjects.getValue(staticObjects, simpleMarkerProp, visuals.markerShape.circle) : visuals.markerShape.circle;
                // Using the full line and marker options
                var lineAndMarkerOptions = options.lineAndMarkerOptions;
                var legendMarkerRenderingOption = lineAndMarkerOptions && lineAndMarkerOptions.legendMarkerRendering;
                var staticMarkerProperties = lineAndMarkerOptions && lineAndMarkerOptions.renderMarkers ? visuals.MarkerProperties.readFromStaticObjects(staticObjects) : undefined;
                var readSeriesMarkerOptions = lineAndMarkerOptions && lineAndMarkerOptions.renderMarkers && powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.showSeries, false);
                var staticLineStyle = powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.lineStyle, visuals.lineStyle.solid);
                for (var seriesIndex = 0, seriesCount = reader.data.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                    var seriesKey = reader.data.getSeriesName(seriesIndex);
                    var seriesLabel = visuals.valueFormatter.format(seriesKey, reader.objects.getSeriesFormatString(seriesIndex));
                    var seriesMarkerProperties = readSeriesMarkerOptions ? visuals.MarkerProperties.readFromSeries(reader, staticMarkerProperties, seriesIndex) : staticMarkerProperties;
                    var seriesColor = reader.colors.createBySeries(seriesIndex);
                    var identity = reader.identities.createForSeries(seriesIndex);
                    var shape = void 0;
                    if (simpleMarkerProp) {
                        shape = powerbi.DataViewObjects.getValue(reader.objects.getSeriesDataObjects(seriesIndex), simpleMarkerProp, staticSimpleMarkerShape);
                    }
                    else {
                        shape = visuals.Markers.resolveMarkerShape(seriesMarkerProperties, legendMarkerRenderingOption, lineAndMarkerOptions && lineAndMarkerOptions.defaultMarkerShape);
                    }
                    var renderLineStyle = lineAndMarkerOptions && lineAndMarkerOptions.renderLineStyle && (legendMarkerRenderingOption !== visuals.legendMarkerRendering.markerOnly);
                    legendDataPoints.push({
                        color: visuals.Markers.resolveMarkerColor(seriesMarkerProperties, seriesColor, legendMarkerRenderingOption, lineAndMarkerOptions && lineAndMarkerOptions.matchSeriesColor),
                        label: seriesLabel,
                        icon: LegendIcon.Circle,
                        identity: identity,
                        selected: false,
                        markerShape: shape,
                        lineStyle: renderLineStyle ? powerbi.DataViewObjects.getValue(reader.objects.getSeriesDataObjects(seriesIndex), visuals.lineChartProps.lineStyles.lineStyle, staticLineStyle) : undefined,
                        lineColor: seriesColor,
                    });
                }
                var legendData = LegendData.create(reader.objects.getStaticObjects(), legendDataPoints, options.showByDefault, reader.data.getSeriesDisplayName() || '', hasDynamicSeries);
                return legendData;
            }
            Legend.buildSeriesLegendData = buildSeriesLegendData;
            /**
             * Builds a legendData based on the series for data sets that lack a dynamic series
             * and have either no static series role or only a single value in that role.  This
             * is used typically for series legends that merge from multiple sets of data.
             *
             * Typically, it is best to simply call buildSeriesLegendData with the appropriate
             * flag.
             */
            function buildSeriesLegendDataForWithNoSeries(reader, options) {
                var lineAndMarkerOptions = options.lineAndMarkerOptions;
                var key = reader.data.getValueDisplayName(options.staticSeriesRole);
                var label = visuals.valueFormatter.format(key, reader.objects.getValueFormatString(options.staticSeriesRole, 0));
                var color = reader.colors.createByValue(0);
                var identity = reader.identities.createForValue(0);
                var staticObjects = reader.objects.getStaticObjects();
                var staticMarkerProperties = visuals.MarkerProperties.readFromStaticObjects(staticObjects);
                var staticLineStyle = powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.lineStyle);
                var markerProperties = lineAndMarkerOptions && lineAndMarkerOptions.renderMarkers ? visuals.MarkerProperties.readFromSeries(reader, staticMarkerProperties, 0) : undefined;
                var legendDataPoints = [{
                        color: color,
                        label: label,
                        icon: LegendIcon.Circle,
                        identity: identity,
                        selected: false,
                        markerShape: markerProperties && markerProperties.showMarker ? markerProperties.shape : visuals.markerShape.circle,
                        lineStyle: lineAndMarkerOptions && lineAndMarkerOptions.renderLineStyle ? powerbi.DataViewObjects.getValue(reader.objects.getValueMetadataObjects(options.staticSeriesRole, 0), visuals.lineChartProps.lineStyles.lineStyle, staticLineStyle) : undefined,
                    }];
                var legendData = LegendData.create(staticObjects, legendDataPoints, options.showByDefault, '');
                return legendData;
            }
            Legend.buildSeriesLegendDataForWithNoSeries = buildSeriesLegendDataForWithNoSeries;
            function buildCategoryLegendData(options) {
                var reader = powerbi.data.createDataViewCategoricalReader(options.dataView, { colorOptions: { valueRole: options.valueRole, visualStyle: options.style } });
                var legendDataPoints = [];
                var legendTitle;
                var categoryRole = options.categoryRole;
                var staticObjects = reader.objects.getStaticObjects();
                if (reader.data.hasCategories()) {
                    legendTitle = reader.data.getCategoryDisplayName(categoryRole);
                    for (var categoryIndex = 0, categoryCount = reader.data.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                        var categoryValue = reader.data.getCategoryValue(categoryRole, categoryIndex);
                        var label = visuals.valueFormatter.format(categoryValue, reader.objects.getCategoryFormatString(categoryRole));
                        var color = reader.colors.createByCategory(categoryIndex);
                        var identity = reader.identities.createForCategory(categoryIndex);
                        legendDataPoints.push({
                            color: color,
                            label: label,
                            icon: LegendIcon.Circle,
                            identity: identity,
                            selected: false,
                        });
                    }
                }
                var legendData = LegendData.create(staticObjects, legendDataPoints, options.showByDefault, legendTitle);
                return legendData;
            }
            Legend.buildCategoryLegendData = buildCategoryLegendData;
            function buildFromFirstMatrixRowLevel(options) {
                var dataView = options.dataView;
                var matrix = dataView.matrix;
                var staticObjects = dataView.metadata.objects;
                debug.assertValue(matrix, "there must be a valid matrix DataView");
                debug.assert(!_.isEmpty(matrix.rows.levels), "the matrix should have at least one level");
                var legendDataPoints = [];
                if (_.isEmpty(matrix.rows.levels)) {
                    return Legend.getDefaultLegendData();
                }
                var seriesMetadata = matrix.rows.levels[0].sources[0];
                var seriesColumnIdentifier = matrix.rows.root.childIdentityFields;
                var series = matrix.rows.root.children;
                if (!series) {
                    return Legend.getDefaultLegendData();
                }
                var markerShapePropIdentifier = options.markerShapePropIdentifier;
                var staticShape;
                if (markerShapePropIdentifier) {
                    staticShape = powerbi.DataViewObjects.getValue(staticObjects, options.markerShapePropIdentifier, visuals.markerShape.circle);
                }
                else {
                    staticShape = visuals.markerShape.circle;
                }
                for (var seriesIndex = 0, seriesCount = series.length; seriesIndex < seriesCount; seriesIndex++) {
                    var currentSeries = series[seriesIndex];
                    if (currentSeries.isSubtotal)
                        continue;
                    var seriesKey = currentSeries.value;
                    var seriesLabel = visuals.converterHelper.formatFromMetadataColumn(seriesKey, seriesMetadata, options.formatStringProp);
                    var color = options.colorHelper.getColorForSeriesValue(currentSeries.objects, seriesColumnIdentifier, seriesKey);
                    var idBuilder = new visuals.SelectionIdBuilder();
                    var identity = idBuilder.withColumnIdentity(currentSeries.identity, seriesMetadata.queryName).createSelectionId();
                    var seriesShape = markerShapePropIdentifier ? powerbi.DataViewObjects.getValue(currentSeries.objects, markerShapePropIdentifier, staticShape) : visuals.markerShape.circle;
                    legendDataPoints.push({
                        color: color,
                        label: seriesLabel,
                        icon: LegendIcon.Circle,
                        identity: identity,
                        selected: false,
                        markerShape: seriesShape,
                    });
                }
                var legendData = LegendData.create(staticObjects, legendDataPoints, options.showByDefault, seriesMetadata.displayName, !!series);
                return legendData;
            }
            Legend.buildFromFirstMatrixRowLevel = buildFromFirstMatrixRowLevel;
            function mergeLegendData(layerLegendData, showByDefault) {
                var dataPoints = [];
                var hasDynamicSeries = false;
                var firstLayerLegendData = layerLegendData[0];
                var _loop_1 = function (layerIndex, layerCount) {
                    var legendData = layerLegendData[layerIndex];
                    _.all(legendData.dataPoints, (function (dataPoint) { return dataPoint.layerNumber = layerIndex; }));
                    dataPoints.push.apply(dataPoints, legendData.dataPoints);
                    if (legendData.grouped) {
                        hasDynamicSeries = true;
                    }
                };
                for (var layerIndex = 0, layerCount = layerLegendData.length; layerIndex < layerCount; layerIndex++) {
                    _loop_1(layerIndex, layerCount);
                }
                return {
                    dataPoints: dataPoints,
                    show: firstLayerLegendData.show,
                    position: firstLayerLegendData.position,
                    showTitle: firstLayerLegendData.showTitle,
                    title: firstLayerLegendData.title,
                    grouped: hasDynamicSeries,
                    fontProperties: firstLayerLegendData.fontProperties,
                };
            }
            Legend.mergeLegendData = mergeLegendData;
            function enumerate(options) {
                var legendData = options.legendData;
                var instance = {
                    selector: null,
                    properties: {
                        show: legendData.show,
                        position: LegendPosition[legendData.position],
                        showTitle: legendData.showTitle,
                        titleText: legendData.title,
                        labelColor: legendData.fontProperties.color,
                        fontSize: legendData.fontProperties.size.pt,
                    },
                    objectName: options.objectName || 'legend',
                };
                if (options.customFontFamily) {
                    instance.properties['fontFamily'] = legendData.fontProperties.family;
                }
                if (options.legendMarkerRendering != null) {
                    instance.properties[visuals.lineChartProps.legend.legendMarkerRendering.propertyName] = options.legendMarkerRendering;
                }
                if (options.matchLineColor != null) {
                    instance.properties[visuals.lineChartProps.legend.matchLineColor.propertyName] = options.matchLineColor;
                }
                if (options.defaultToCircle != null) {
                    instance.properties[visuals.lineChartProps.legend.defaultToCircle.propertyName] = options.defaultToCircle;
                }
                options.enumeration.pushInstance(instance);
                return options.enumeration.complete();
            }
            Legend.enumerate = enumerate;
            function getTitleFontProperties(fontProperties) {
                var isDefaultFontFamily = fontProperties.family === Legend.DefaultFontFamily;
                // If we're using the default font, use the semibold version for the title
                // Otherwise, just bold the font
                return visuals.FontProperties.inherit(fontProperties, {
                    family: isDefaultFontFamily ? visuals.Font.Family.semibold.css : undefined,
                    weight: !isDefaultFontFamily ? 'bold' : undefined
                });
            }
            Legend.getTitleFontProperties = getTitleFontProperties;
        })(Legend = visuals.Legend || (visuals.Legend = {}));
        var LegendIconRadius = 5;
        var LegendIconRadiusFactor = 5;
        var LegendIconLineTotalWidth = 31;
        var LegendIconLineOffset = (LegendIconLineTotalWidth / 2) - LegendIconRadius;
        var MaxTextLength = 60;
        var MaxTitleLength = 80;
        var TextAndIconPadding = 5;
        var TitlePadding = 15;
        var LegendEdgeMariginWidth = 10;
        var LegendMaxWidthFactor = 0.3;
        var TopLegendHeight = 24;
        var DefaultTextMargin = Legend.DefaultFontSize.pt;
        var DefaultMaxLegendFactor = MaxTitleLength / DefaultTextMargin;
        var LegendIconYRatio = 0.52;
        // Navigation Arrow constants
        var LegendArrowLargeHitAreaSizes = {
            Horizontal: { arrowSize: 30, hitAreaWidthPx: 28, arrowsOffset: -10 },
            Vertical: { arrowSize: 12, hitAreaWidthPx: 18, arrowsOffset: -3 }
        };
        var LegendArrowSize = 10;
        var LegendArrowHeight = 15;
        var LegendArrowWidth = 7.5;
        var SVGLegend = /** @class */ (function () {
            function SVGLegend(element, legendPosition, interactivityService, isScrollable, legendSmallViewPortProperties) {
                this.interactivityService = interactivityService;
                this.isScrollable = isScrollable;
                this.legendSmallViewPortProperties = legendSmallViewPortProperties;
                this.legendDataStartIndex = 0;
                this.arrowPosWindow = 1;
                this.lastCalculatedWidth = 0;
                this.visibleLegendWidth = 0;
                this.visibleLegendHeight = 0;
                this.legendFontSizeMarginDifference = 0;
                this.legendFontSizeMarginValue = 0;
                this.svg = d3.select(element.get(0)).append('svg').style('position', 'absolute');
                this.svg.style('display', 'inherit');
                this.svg.classed('legend', true);
                if (interactivityService)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.group = this.svg.append('g').attr('id', 'legendGroup');
                this.changeOrientation(legendPosition);
                this.parentViewport = { height: 0, width: 0 };
                this.calculateViewport();
                this.updateLayout();
            }
            SVGLegend.prototype.getLegendShowFlag = function () {
                // if the show flag is null, set it to be true.
                return (this.data && this.data.show != null) ? this.data.show : true;
            };
            SVGLegend.prototype.updateLayout = function () {
                var legendViewport = this.viewport;
                var orientation = this.orientation;
                var show = this.getLegendShowFlag();
                this.svg.attr({
                    'height': legendViewport.height || (!show ? 0 : this.parentViewport.height),
                    'width': legendViewport.width || (!show ? 0 : this.parentViewport.width)
                });
                var isRight = orientation === LegendPosition.Right || orientation === LegendPosition.RightCenter;
                var isBottom = orientation === LegendPosition.Bottom || orientation === LegendPosition.BottomCenter;
                this.svg.style({
                    'margin-left': isRight ? (this.parentViewport.width - legendViewport.width) + 'px' : null,
                    'margin-top': isBottom ? (this.parentViewport.height - legendViewport.height) + 'px' : null,
                });
            };
            SVGLegend.prototype.calculateViewport = function () {
                var show = this.getLegendShowFlag();
                if (!show) {
                    this.viewport = { height: 0, width: 0 };
                    return;
                }
                switch (this.orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.Bottom:
                    case LegendPosition.TopCenter:
                    case LegendPosition.BottomCenter:
                        var pixelHeight = this.data && this.data.fontProperties ? this.data.fontProperties.size.px : PixelConverter.fromPointToPixel(Legend.DefaultFontSize.pt);
                        var fontHeightSize = TopLegendHeight + (pixelHeight - Legend.DefaultFontSize.pt);
                        this.viewport = { height: fontHeightSize, width: 0 };
                        return;
                    case LegendPosition.Right:
                    case LegendPosition.Left:
                    case LegendPosition.RightCenter:
                    case LegendPosition.LeftCenter:
                        var width = this.lastCalculatedWidth ? this.lastCalculatedWidth : this.parentViewport.width * LegendMaxWidthFactor;
                        this.viewport = { height: 0, width: width };
                        return;
                }
            };
            SVGLegend.prototype.getMargins = function () {
                return this.viewport;
            };
            SVGLegend.prototype.isVisible = function () {
                return this.getLegendShowFlag();
            };
            SVGLegend.prototype.changeOrientation = function (orientation) {
                if (orientation) {
                    this.orientation = orientation;
                }
                else {
                    this.orientation = LegendPosition.Top;
                }
                this.svg.attr('orientation', orientation);
            };
            SVGLegend.prototype.getOrientation = function () {
                return this.orientation;
            };
            SVGLegend.prototype.drawLegend = function (data, viewport) {
                // clone because we modify legend item label with ellipsis if it is truncated
                var clonedData = powerbi.Prototype.inherit(data);
                // Apply defaults for values that are undefined
                _.defaults(clonedData, {
                    fontProperties: Legend.getDefaultFontProperties(),
                });
                var newDataPoints = [];
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    newDataPoints.push(powerbi.Prototype.inherit(dp));
                }
                clonedData.dataPoints = newDataPoints;
                this.setTooltipToLegendItems(clonedData);
                this.drawLegendInternal(clonedData, viewport, true /* perform auto width */);
            };
            SVGLegend.prototype.drawLegendInternal = function (data, viewport, autoWidth) {
                this.parentViewport = viewport;
                var legacyLegendData = data;
                if (legacyLegendData.fontSize || legacyLegendData.labelColor) {
                    data.fontProperties = {
                        color: legacyLegendData.labelColor || Legend.DefaultLabelColor,
                        size: legacyLegendData.fontSize ? FontSize.createFromPt(legacyLegendData.fontSize) : Legend.DefaultFontSize,
                        family: Legend.DefaultFontFamily,
                    };
                }
                if (!data.fontProperties) {
                    data.fontProperties = Legend.getDefaultFontProperties();
                }
                this.data = data;
                var adjustedFontProperties = this.applyViewportSettings(data);
                if (this.interactivityService)
                    this.interactivityService.applySelectionStateToData(data.dataPoints);
                if (data.dataPoints.length === 0 || data.position === LegendPosition.None) {
                    this.data.show = false;
                }
                if (this.data.show === false) {
                    data.dataPoints = [];
                }
                this.calculateViewport();
                var layout = this.calculateLayout(data, autoWidth);
                var titleLayout = layout.title;
                var titleData = titleLayout ? [titleLayout] : [];
                var hasSelection = this.interactivityService && powerbi.visuals.dataHasSelection(data.dataPoints);
                var group = this.group;
                var isSmallViewport = false;
                if (data.allowSmallViewport) {
                    if (this.legendSmallViewPortProperties) {
                        isSmallViewport = this.parentViewport.height <= this.legendSmallViewPortProperties.minHeightForTransform;
                    }
                }
                //transform the wrapping group if position is centered
                if (Legend.isCentered(this.orientation) && !isSmallViewport) {
                    var centerOffset = 0;
                    if (Legend.isTopOrBottom(this.orientation)) {
                        centerOffset = Math.max(0, (this.parentViewport.width - this.visibleLegendWidth) / 2);
                        group.attr('transform', visuals.SVGUtil.translate(centerOffset, 0));
                    }
                    else {
                        centerOffset = Math.max((this.parentViewport.height - this.visibleLegendHeight) / 2);
                        group.attr('transform', visuals.SVGUtil.translate(0, centerOffset));
                    }
                }
                else {
                    group.attr('transform', null);
                }
                var legendTitle = group
                    .selectAll(SVGLegend.LegendTitle.selector)
                    .data(titleData);
                legendTitle.enter()
                    .append('text')
                    .classed(SVGLegend.LegendTitle.class, true);
                var legendTitleFontProperties = Legend.getTitleFontProperties(adjustedFontProperties);
                legendTitle
                    .style(visuals.FontProperties.toSVGStyle(legendTitleFontProperties))
                    .text((function (d) { return d.text; }))
                    .attr({
                    'x': function (d) { return d.x; },
                    'y': function (d) { return d.y; }
                })
                    .append('title').text(data.showTitle !== false ? data.title : null);
                legendTitle.exit().remove();
                var virtualizedDataPoints = data.dataPoints.slice(this.legendDataStartIndex, this.legendDataStartIndex + layout.numberOfItems);
                var iconRadius = powerbi.TextMeasurementService.estimateSvgTextHeight(visuals.FontProperties.toTextProperties(adjustedFontProperties)) / LegendIconRadiusFactor;
                iconRadius = (this.legendFontSizeMarginValue > DefaultTextMargin) && iconRadius > LegendIconRadius
                    ? iconRadius :
                    LegendIconRadius;
                var legendItems = group
                    .selectAll(SVGLegend.LegendItem.selector)
                    .data(virtualizedDataPoints, (function (d) { return d.identity.getKey() + (d.layerNumber != null ? d.layerNumber : ''); }));
                var itemsEnter = legendItems.enter()
                    .append('g')
                    .classed(SVGLegend.LegendItem.class, true);
                itemsEnter
                    .append('path')
                    .classed(SVGLegend.LegendIconLine.class, true);
                itemsEnter
                    .append('path')
                    .classed(SVGLegend.LegendIcon.class, true);
                itemsEnter
                    .append('text')
                    .classed(SVGLegend.LegendText.class, true);
                itemsEnter
                    .append('title')
                    .text((function (d) { return d.tooltip; }));
                legendItems
                    .select(SVGLegend.LegendIconLine.selector)
                    .attr({
                    'transform': function (d) { return visuals.SVGUtil.translate(d.glyphPosition.x, d.glyphPosition.y); },
                    'd': function (d) { return d.lineStyle ? 'M -' + (LegendIconLineTotalWidth / 2) + ' 0 L ' + (LegendIconLineTotalWidth / 2) + ' 0' : null; },
                    'stroke-width': 2,
                    'stroke-dasharray': function (d) { return d.lineStyle ? visuals.LineStyle.getSrokeDashArrayForLegend(d.lineStyle) : null; },
                })
                    .style({
                    'stroke': function (d) {
                        if (hasSelection && !d.selected)
                            return visuals.LegendBehavior.dimmedLegendColor;
                        else
                            return d.lineColor;
                    }
                });
                legendItems
                    .select(SVGLegend.LegendIcon.selector)
                    .attr({
                    'transform': function (d) { return visuals.SVGUtil.translateAndScale(d.glyphPosition.x, d.glyphPosition.y, iconRadius / visuals.Markers.defaultSize); },
                    'd': function (d) { return visuals.Markers.getPath(d.markerShape || visuals.markerShape.circle); },
                    'stroke-width': function (d) { return visuals.Markers.getStrokeWidth(d.markerShape || visuals.markerShape.circle); },
                })
                    .style({
                    'fill': function (d) {
                        if (hasSelection && !d.selected)
                            return visuals.LegendBehavior.dimmedLegendColor;
                        else
                            return d.color;
                    },
                    'stroke': function (d) {
                        if (hasSelection && !d.selected)
                            return visuals.LegendBehavior.dimmedLegendColor;
                        else
                            return d.color;
                    },
                    'stroke-linejoin': 'round',
                });
                legendItems
                    .select('title')
                    .text((function (d) { return d.tooltip; }));
                legendItems
                    .select(SVGLegend.LegendText.selector)
                    .attr({
                    'x': function (d) { return d.textPosition.x; },
                    'y': function (d) { return d.textPosition.y; },
                })
                    .text((function (d) { return d.label; }))
                    .style(adjustedFontProperties && visuals.FontProperties.toSVGStyle(adjustedFontProperties));
                if (this.interactivityService) {
                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector);
                    var linesSelection = legendItems.select(SVGLegend.LegendIconLine.selector);
                    var behaviorOptions = {
                        legendItems: legendItems,
                        legendIcons: iconsSelection,
                        legendLines: linesSelection,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.bind(data.dataPoints, new visuals.LegendBehavior(), behaviorOptions, { isLegend: true });
                }
                legendItems.exit().remove();
                this.drawNavigationArrows(layout.navigationArrows);
                this.updateLayout();
            };
            SVGLegend.prototype.applyViewportSettings = function (data) {
                var fontProperties = data.fontProperties;
                if (data.allowSmallViewport) {
                    if (this.legendSmallViewPortProperties) {
                        var sizePt = fontProperties.size.pt;
                        if (this.parentViewport.width <= this.legendSmallViewPortProperties.maxWidthForSmallFont) {
                            var minFontSize = Math.min(sizePt, SVGLegend.LegendSmallFontSmallViewportInPt);
                            var newFontProperties = visuals.FontProperties.inherit(fontProperties, { size: FontSize.createFromPt(minFontSize) });
                            return newFontProperties;
                        }
                        if (this.parentViewport.width <= this.legendSmallViewPortProperties.maxWidthForMediumFont) {
                            var minFontSize = Math.min(sizePt, SVGLegend.LegendMediumFontSmallViewportInPt);
                            var newFontProperties = visuals.FontProperties.inherit(fontProperties, { size: FontSize.createFromPt(minFontSize) });
                            return newFontProperties;
                        }
                    }
                }
                return fontProperties;
            };
            SVGLegend.prototype.normalizePosition = function (points) {
                if (this.legendDataStartIndex >= points.length) {
                    this.legendDataStartIndex = points.length - 1;
                }
                if (this.legendDataStartIndex < 0) {
                    this.legendDataStartIndex = 0;
                }
            };
            SVGLegend.prototype.calculateTitleLayout = function (title) {
                var width = 0;
                var hasTitle = !_.isEmpty(title);
                if (hasTitle) {
                    var isHorizontal = Legend.isTopOrBottom(this.orientation);
                    var maxMeasureLength = void 0;
                    if (isHorizontal) {
                        var fontSizeMargin = this.legendFontSizeMarginValue > DefaultTextMargin ? TextAndIconPadding + this.legendFontSizeMarginDifference : TextAndIconPadding;
                        var fixedHorizontalIconShift = TextAndIconPadding + LegendIconRadius;
                        var fixedHorizontalTextShift = LegendIconRadius + fontSizeMargin + fixedHorizontalIconShift;
                        // TODO This can be negative for narrow viewports. May need to rework this logic.
                        maxMeasureLength = this.parentViewport.width * LegendMaxWidthFactor - fixedHorizontalTextShift - LegendEdgeMariginWidth;
                    }
                    else {
                        maxMeasureLength = this.legendFontSizeMarginValue < DefaultTextMargin ? MaxTitleLength :
                            MaxTitleLength + (DefaultMaxLegendFactor * this.legendFontSizeMarginDifference);
                    }
                    var textProperties = visuals.FontProperties.toTextProperties(this.data.fontProperties, title);
                    var text = title;
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxMeasureLength) {
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxMeasureLength);
                        textProperties.text = text;
                        // Remeasure the text since its measurement may be different than the max (ex. when the max is negative, the text will be ellipsis, and not have a negative width)
                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    }
                    if (isHorizontal)
                        width += TitlePadding;
                    else
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, this.viewport.width);
                    return {
                        x: 0,
                        y: 0,
                        text: text,
                        width: width,
                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                    };
                }
                return null;
            };
            /** Performs layout offline for optimal perfomance */
            SVGLegend.prototype.calculateLayout = function (data, autoWidth) {
                var dataPoints = data.dataPoints;
                if (data.dataPoints.length === 0) {
                    return {
                        numberOfItems: 0,
                        title: null,
                        navigationArrows: []
                    };
                }
                this.legendFontSizeMarginValue = this.data && this.data.fontProperties !== undefined ? this.data.fontProperties.size.px : PixelConverter.fromPointToPixel(Legend.DefaultFontSize.pt);
                this.legendFontSizeMarginDifference = (this.legendFontSizeMarginValue - DefaultTextMargin);
                this.normalizePosition(dataPoints);
                if (this.legendDataStartIndex < dataPoints.length) {
                    dataPoints = dataPoints.slice(this.legendDataStartIndex);
                }
                var title = this.calculateTitleLayout(data.showTitle !== false ? data.title : null);
                var navArrows;
                var numberOfItems;
                if (Legend.isTopOrBottom(this.orientation)) {
                    navArrows = this.isScrollable ? this.calculateHorizontalNavigationArrowsLayout(title) : [];
                    numberOfItems = this.calculateHorizontalLayout(dataPoints, title, navArrows);
                }
                else {
                    navArrows = this.isScrollable ? this.calculateVerticalNavigationArrowsLayout(title) : [];
                    numberOfItems = this.calculateVerticalLayout(dataPoints, title, navArrows, autoWidth);
                }
                return {
                    numberOfItems: numberOfItems,
                    title: title,
                    navigationArrows: navArrows
                };
            };
            SVGLegend.prototype.updateNavigationArrowLayout = function (navigationArrows, remainingDataLength, visibleDataLength) {
                if (this.legendDataStartIndex === 0) {
                    navigationArrows.shift();
                }
                var lastWindow = this.arrowPosWindow;
                this.arrowPosWindow = visibleDataLength;
                if (navigationArrows && navigationArrows.length > 0 && this.arrowPosWindow === remainingDataLength) {
                    this.arrowPosWindow = lastWindow;
                    navigationArrows.length = navigationArrows.length - 1;
                }
            };
            SVGLegend.prototype.calculateHorizontalNavigationArrowsLayout = function (title) {
                var height = LegendArrowHeight;
                var width = LegendArrowWidth;
                var translateY = (this.viewport.height / 2) - (height / 2);
                var data = [];
                var rightShift = title ? title.x + title.width : 0;
                var arrowLeft = visuals.SVGUtil.createArrow(width, height, 180 /*angle*/);
                var arrowRight = visuals.SVGUtil.createArrow(width, height, 0 /*angle*/);
                var arrowOffset = 0;
                var hitAreaWidth;
                if (this.data.useLargeArrowHitArea) {
                    var hitAreaDetails = LegendArrowLargeHitAreaSizes.Horizontal;
                    arrowOffset = hitAreaDetails.arrowsOffset;
                    hitAreaWidth = hitAreaDetails.hitAreaWidthPx;
                }
                data.push({
                    x: rightShift,
                    y: translateY,
                    path: arrowLeft.path,
                    rotateTransform: arrowLeft.transform,
                    type: 1 /* Decrease */,
                    arrowOffset: arrowOffset,
                    hitAreaWidth: hitAreaWidth,
                });
                data.push({
                    x: this.parentViewport.width - width,
                    y: translateY,
                    path: arrowRight.path,
                    rotateTransform: arrowRight.transform,
                    type: 0 /* Increase */,
                    arrowOffset: arrowOffset,
                    hitAreaWidth: hitAreaWidth,
                });
                return data;
            };
            SVGLegend.prototype.calculateVerticalNavigationArrowsLayout = function (title) {
                var height = LegendArrowHeight;
                var width = LegendArrowWidth;
                var verticalCenter = this.viewport.height / 2;
                var data = [];
                var rightShift = verticalCenter + height / 2;
                var arrowTop = visuals.SVGUtil.createArrow(width, height, 270 /*angle*/);
                var arrowBottom = visuals.SVGUtil.createArrow(width, height, 90 /*angle*/);
                var titleHeight = title ? title.height : 0;
                var arrowOffset = 0;
                var hitAreaWidth;
                if (this.data.useLargeArrowHitArea) {
                    var hitAreaDetails = LegendArrowLargeHitAreaSizes.Vertical;
                    arrowOffset = hitAreaDetails.arrowsOffset;
                    hitAreaWidth = hitAreaDetails.hitAreaWidthPx;
                }
                data.push({
                    x: rightShift,
                    y: width + titleHeight,
                    path: arrowTop.path,
                    rotateTransform: arrowTop.transform,
                    type: 1 /* Decrease */,
                    arrowOffset: arrowOffset,
                    hitAreaWidth: hitAreaWidth,
                });
                data.push({
                    x: rightShift,
                    y: this.parentViewport.height - height,
                    path: arrowBottom.path,
                    rotateTransform: arrowBottom.transform,
                    type: 0 /* Increase */,
                    arrowOffset: arrowOffset,
                    hitAreaWidth: hitAreaWidth,
                });
                return data;
            };
            /**
             * Calculates the widths for each horizontal legend item.
             */
            SVGLegend.calculateHorizontalLegendItemsWidths = function (dataPoints, availableWidth, iconPadding, fontProperties) {
                var dataPointsLength = dataPoints.length;
                // Set the maximum amount of space available to each item. They can use less, but can't go over this number.
                var maxItemWidth = dataPointsLength > 0 ? availableWidth / dataPointsLength | 0 : 0;
                var maxItemTextWidth = maxItemWidth - iconPadding;
                // Makes sure the amount of space available to each item is at least MaxTextLength wide.
                // If you had many items and/or a narrow amount of available width, the availableTextWidthPerItem would be small, essentially making everything ellipsis.
                // This prevents that from happening by giving each item at least MaxTextLength of space.
                if (maxItemTextWidth < MaxTextLength) {
                    maxItemTextWidth = MaxTextLength;
                    maxItemWidth = maxItemTextWidth + iconPadding;
                }
                // Make sure the availableWidthPerItem is less than the availableWidth. This lets the long text properly add ellipsis when we're displaying one item at a time.
                if (maxItemWidth > availableWidth) {
                    maxItemWidth = availableWidth;
                    maxItemTextWidth = maxItemWidth - iconPadding;
                }
                var occupiedWidth = 0;
                var legendItems = [];
                // Add legend items until we can't fit any more (the last one doesn't fit) or we've added all of them
                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i];
                    var textProperties = visuals.FontProperties.toTextProperties(fontProperties, dataPoint.label);
                    var itemTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    var desiredWidth = itemTextWidth + iconPadding;
                    var overMaxWidth = desiredWidth > maxItemWidth;
                    var actualWidth = overMaxWidth ? maxItemWidth : desiredWidth;
                    occupiedWidth += actualWidth;
                    if (occupiedWidth >= availableWidth) {
                        // Always add at least 1 element
                        if (legendItems.length === 0) {
                            legendItems.push({
                                dataPoint: dataPoint,
                                textProperties: textProperties,
                                desiredWidth: desiredWidth,
                                desiredOverMaxWidth: true,
                                width: desiredWidth
                            });
                            // Set the width to the amount of space we actually have
                            occupiedWidth = availableWidth;
                        }
                        else {
                            // Subtract the width from what was just added since it won't fit
                            occupiedWidth -= actualWidth;
                        }
                        break;
                    }
                    legendItems.push({
                        dataPoint: dataPoint,
                        textProperties: textProperties,
                        desiredWidth: desiredWidth,
                        desiredOverMaxWidth: overMaxWidth,
                        width: desiredWidth
                    });
                }
                // If there are items at max width, evenly redistribute the extra space to them
                var itemsOverMax = _.filter(legendItems, (function (li) { return li.desiredOverMaxWidth; }));
                var numItemsOverMax = itemsOverMax.length;
                if (numItemsOverMax > 0) {
                    var extraWidth = availableWidth - occupiedWidth;
                    for (var _a = 0, itemsOverMax_1 = itemsOverMax; _a < itemsOverMax_1.length; _a++) {
                        var item = itemsOverMax_1[_a];
                        // Divvy up the extra space and add it to the max
                        // We need to do this calculation in every loop since the remainingWidth may not be changed by the same amount every time
                        var extraWidthPerItem = extraWidth / numItemsOverMax;
                        var newMaxItemWidth = maxItemWidth + extraWidthPerItem;
                        var usedExtraWidth = void 0;
                        if (item.desiredWidth <= newMaxItemWidth) {
                            // If the item doesn't need all the extra space, it's not at max anymore
                            item.desiredOverMaxWidth = false;
                            usedExtraWidth = item.desiredWidth - maxItemWidth;
                        }
                        else {
                            // Otherwise the item is taking up all the extra space so update the actual width to indicate that
                            item.width = newMaxItemWidth;
                            usedExtraWidth = newMaxItemWidth - maxItemWidth;
                        }
                        extraWidth -= usedExtraWidth;
                        numItemsOverMax--;
                    }
                }
                return legendItems;
            };
            SVGLegend.prototype.calculateHorizontalLayout = function (dataPoints, title, navigationArrows) {
                debug.assertValue(navigationArrows, 'navigationArrows');
                // calculate the text shift
                var HorizontalTextShift = 4 + LegendIconRadius;
                // check if we need more space for the margin, or use the default text padding
                var fontSizeBiggerThanDefault = this.legendFontSizeMarginDifference > 0;
                var fontSizeMargin = fontSizeBiggerThanDefault ? TextAndIconPadding + this.legendFontSizeMarginDifference : TextAndIconPadding;
                var fixedTextShift = (fontSizeMargin / (LegendIconRadiusFactor / 2)) + HorizontalTextShift;
                var occupiedWidth = 0;
                // calculate the size of the space for both sides of the radius
                var lineOffset = _.any(dataPoints, (function (dataPoint) { return dataPoint.lineStyle; })) ? LegendIconLineOffset : 0;
                var iconTotalItemPadding = LegendIconRadius * 2 + fontSizeMargin * 1.5 + lineOffset * 2;
                var numberOfItems = dataPoints.length;
                // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text
                var defaultTextProperties = visuals.FontProperties.toTextProperties(this.data.fontProperties);
                var verticalCenter = this.viewport.height / 2;
                var textYCoordinate = verticalCenter + powerbi.TextMeasurementService.estimateSvgTextHeight(defaultTextProperties) / 2
                    - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(defaultTextProperties);
                if (title) {
                    occupiedWidth += title.width;
                    // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text
                    title.y = verticalCenter + title.height / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(visuals.FontProperties.toTextProperties(this.data.fontProperties, title.text));
                }
                var legendArrowAreaSize = LegendArrowSize;
                if (this.data.useLargeArrowHitArea) {
                    legendArrowAreaSize = LegendArrowLargeHitAreaSizes.Horizontal.arrowSize;
                }
                // if an arrow should be added, we add space for it
                if (this.legendDataStartIndex > 0) {
                    occupiedWidth += legendArrowAreaSize;
                }
                // Calculate the width for each of the legend items
                var dataPointsLength = dataPoints.length;
                var availableWidth = this.parentViewport.width - occupiedWidth;
                var legendItems = SVGLegend.calculateHorizontalLegendItemsWidths(dataPoints, availableWidth, iconTotalItemPadding, this.data.fontProperties);
                numberOfItems = legendItems.length;
                // If we can't show all the legend items, subtract the "next" arrow space from the available space and re-run the width calculations
                if (numberOfItems !== dataPointsLength) {
                    availableWidth -= legendArrowAreaSize;
                    legendItems = SVGLegend.calculateHorizontalLegendItemsWidths(dataPoints, availableWidth, iconTotalItemPadding, this.data.fontProperties);
                    numberOfItems = legendItems.length;
                }
                for (var _i = 0, legendItems_1 = legendItems; _i < legendItems_1.length; _i++) {
                    var legendItem = legendItems_1[_i];
                    var dataPoint = legendItem.dataPoint;
                    dataPoint.glyphPosition = {
                        // the space taken so far + the radius + the margin / radiusFactor to prevent huge spaces
                        x: occupiedWidth + LegendIconRadius + (this.legendFontSizeMarginDifference / LegendIconRadiusFactor) + lineOffset,
                        // The middle of the container but a bit lower due to text not being in the middle (qP for example making middle between q and P)
                        y: (this.viewport.height * LegendIconYRatio),
                    };
                    dataPoint.textPosition = {
                        x: occupiedWidth + fixedTextShift + (2 * lineOffset),
                        y: textYCoordinate,
                    };
                    // If we're over the max width, process it so it fits
                    if (legendItem.desiredOverMaxWidth) {
                        var textWidth = legendItem.width - iconTotalItemPadding;
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(legendItem.textProperties, textWidth);
                        dataPoint.label = text;
                    }
                    occupiedWidth += legendItem.width;
                }
                this.visibleLegendWidth = occupiedWidth;
                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
                return numberOfItems;
            };
            SVGLegend.prototype.calculateVerticalLayout = function (dataPoints, title, navigationArrows, autoWidth) {
                var _this = this;
                // check if we need more space for the margin, or use the default text padding
                var fontSizeBiggerThenDefault = this.legendFontSizeMarginDifference > 0;
                var fontFactor = fontSizeBiggerThenDefault ? this.legendFontSizeMarginDifference : 0;
                // calculate the size needed after font size change
                var verticalLegendHeight = 20 + fontFactor;
                var spaceNeededByTitle = 15 + fontFactor;
                var extraShiftForTextAlignmentToIcon = 4 + fontFactor;
                var totalSpaceOccupiedThusFar = verticalLegendHeight;
                // the default space for text and icon radius + the margin after the font size change
                var fixedHorizontalIconShift = TextAndIconPadding + LegendIconRadius + (this.legendFontSizeMarginDifference / LegendIconRadiusFactor);
                var fixedHorizontalTextShift = fixedHorizontalIconShift * 2;
                // check how much space is needed
                var maxHorizontalSpaceAvaliable = autoWidth
                    ? this.parentViewport.width * LegendMaxWidthFactor
                        - fixedHorizontalTextShift - LegendEdgeMariginWidth
                    : this.lastCalculatedWidth
                        - fixedHorizontalTextShift - LegendEdgeMariginWidth;
                var numberOfItems = dataPoints.length;
                var maxHorizontalSpaceUsed = 0;
                var parentHeight = this.parentViewport.height;
                if (title) {
                    totalSpaceOccupiedThusFar += spaceNeededByTitle;
                    title.x = TextAndIconPadding;
                    title.y = spaceNeededByTitle;
                    maxHorizontalSpaceUsed = title.width || 0;
                }
                var legendArrowAreaSize = LegendArrowSize;
                if (this.data.useLargeArrowHitArea) {
                    legendArrowAreaSize = LegendArrowLargeHitAreaSizes.Vertical.arrowSize;
                }
                // if an arrow should be added, we add space for it
                if (this.legendDataStartIndex > 0) {
                    totalSpaceOccupiedThusFar += legendArrowAreaSize;
                }
                // calculate number of items to display and availableHeight:
                var availableHeight = parentHeight - totalSpaceOccupiedThusFar;
                numberOfItems = Math.floor(availableHeight / verticalLegendHeight);
                if (numberOfItems < dataPoints.length && this.data.useLargeArrowHitArea) {
                    availableHeight -= legendArrowAreaSize;
                    numberOfItems = Math.floor(availableHeight / verticalLegendHeight);
                }
                numberOfItems = ClampValue(numberOfItems, 0, dataPoints.length);
                for (var i = 0; i < numberOfItems; i++) {
                    var dp = dataPoints[i];
                    var textProperties = visuals.FontProperties.toTextProperties(this.data.fontProperties, dp.label);
                    dp.glyphPosition = {
                        x: fixedHorizontalIconShift,
                        y: (totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties)
                    };
                    dp.textPosition = {
                        x: fixedHorizontalTextShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                    };
                    // TODO: [PERF] Get rid of this extra measurement, and modify
                    // getTailoredTextToReturnWidth + Text
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxHorizontalSpaceUsed) {
                        maxHorizontalSpaceUsed = width;
                    }
                    if (width > maxHorizontalSpaceAvaliable) {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxHorizontalSpaceAvaliable);
                        dp.label = text;
                    }
                    totalSpaceOccupiedThusFar += verticalLegendHeight;
                }
                if (autoWidth) {
                    if (maxHorizontalSpaceUsed < maxHorizontalSpaceAvaliable) {
                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + LegendEdgeMariginWidth);
                    }
                    else {
                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(this.parentViewport.width * LegendMaxWidthFactor);
                    }
                }
                else {
                    this.viewport.width = this.lastCalculatedWidth;
                }
                this.visibleLegendHeight = totalSpaceOccupiedThusFar;
                navigationArrows.forEach((function (d) { return d.x = _this.lastCalculatedWidth / 2; }));
                this.updateNavigationArrowLayout(navigationArrows, dataPoints.length, numberOfItems);
                return numberOfItems;
            };
            SVGLegend.prototype.drawNavigationArrows = function (layout) {
                var _this = this;
                var arrows = this.group.selectAll(SVGLegend.NavigationArrow.selector)
                    .data(layout, (function (d) { return d.type; }));
                arrows
                    .enter()
                    .append('g')
                    .on('click', (function (d) {
                    var pos = _this.legendDataStartIndex;
                    _this.legendDataStartIndex = d.type === 0 /* Increase */
                        ? pos + _this.arrowPosWindow : pos - _this.arrowPosWindow;
                    _this.drawLegendInternal(_this.data, _this.parentViewport, false);
                }))
                    .classed(SVGLegend.NavigationArrow.class, true);
                arrows.attr('transform', (function (d) { return visuals.SVGUtil.translate(d.x, d.y); }));
                var arrowPaths = arrows.selectAll('path')
                    .data((function (d) { return _this.getNavigationArrowPathsData(d); }), (function (d) { return d.index; }));
                arrowPaths
                    .enter()
                    .append('path')
                    .attr({
                    'd': function (d) { return d.path; },
                    'transform': function (d) { return d.rotateTransform + " " + visuals.SVGUtil.translate(d.arrowOffset, 0); },
                    'stroke-width': function (d) { return d.isHitArea ? d.hitAreaWidth + "px" : undefined; },
                    'fill-opacity': function (d) { return d.isHitArea ? '0' : undefined; },
                    'stroke-opacity': function (d) { return d.isHitArea ? '0' : undefined; },
                });
                arrowPaths.exit().remove();
                arrows.exit().remove();
            };
            SVGLegend.prototype.getNavigationArrowPathsData = function (arrowData) {
                var arrowPath = arrowData;
                arrowPath.isHitArea = false;
                arrowPath.index = Math.abs(arrowPath.arrowOffset);
                if (!this.data.useLargeArrowHitArea)
                    return [arrowPath];
                var hitArea = Object.create(arrowPath);
                hitArea.isHitArea = true;
                hitArea.index++;
                return [hitArea, arrowPath];
            };
            SVGLegend.prototype.reset = function () {
                // Intentionally left blank.
            };
            SVGLegend.prototype.setTooltipToLegendItems = function (data) {
                //we save the values to tooltip before cut
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dataPoint = _a[_i];
                    dataPoint.tooltip = dataPoint.label;
                }
            };
            SVGLegend.DefaultFontSizeInPt = 8;
            SVGLegend.LegendSmallFontSmallViewportInPt = 7; //9px
            SVGLegend.LegendMediumFontSmallViewportInPt = 8; //11px
            SVGLegend.LegendItem = createClassAndSelector('legendItem');
            SVGLegend.LegendText = createClassAndSelector('legendText');
            SVGLegend.LegendIcon = createClassAndSelector('legendIcon');
            SVGLegend.LegendIconLine = createClassAndSelector('legendIconLine');
            SVGLegend.LegendTitle = createClassAndSelector('legendTitle');
            SVGLegend.NavigationArrow = createClassAndSelector('navArrow');
            return SVGLegend;
        }());
        visuals.SVGLegend = SVGLegend;
        var CartesianChartInteractiveLegend = /** @class */ (function () {
            function CartesianChartInteractiveLegend(element) {
                this.legendContainerParent = d3.select(element.get(0));
            }
            CartesianChartInteractiveLegend.prototype.getMargins = function () {
                return {
                    height: CartesianChartInteractiveLegend.LegendHeight,
                    width: 0
                };
            };
            CartesianChartInteractiveLegend.prototype.drawLegend = function (legendData) {
                debug.assertValue(legendData, 'legendData');
                var data = legendData.dataPoints;
                debug.assertValue(data, 'dataPoints');
                if (data.length < 1)
                    return;
                var legendContainerDiv = this.legendContainerParent.select(CartesianChartInteractiveLegend.LegendContainerSelector);
                if (legendContainerDiv.empty()) {
                    if (!data.length)
                        return;
                    var divToPrepend = $('<div></div>')
                        .height(this.getMargins().height)
                        .addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                    // Prepending, as legend should always be on topmost visual.
                    $(this.legendContainerParent[0]).prepend(divToPrepend);
                    legendContainerDiv = d3.select(divToPrepend.get(0));
                }
                this.legendContainerDiv = legendContainerDiv;
                // Construct the legend title and items.
                this.drawTitle(data);
                this.drawLegendItems(data);
            };
            CartesianChartInteractiveLegend.prototype.reset = function () {
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.remove();
                    this.legendContainerDiv = null;
                }
            };
            CartesianChartInteractiveLegend.prototype.isVisible = function () {
                return true;
            };
            CartesianChartInteractiveLegend.prototype.changeOrientation = function (orientation) {
                // Not supported
            };
            CartesianChartInteractiveLegend.prototype.getOrientation = function () {
                return LegendPosition.Top;
            };
            /**
             * Draw the legend title
             */
            CartesianChartInteractiveLegend.prototype.drawTitle = function (data) {
                debug.assert(data && data.length > 0, 'data is null or empty');
                var titleDiv = this.legendContainerDiv.selectAll('div.' + CartesianChartInteractiveLegend.LegendTitleClass);
                var item = titleDiv.data([data[0]]);
                // Enter
                var itemEnter = item.enter();
                var titleDivEnter = itemEnter.append('div').attr('class', CartesianChartInteractiveLegend.LegendTitleClass);
                titleDivEnter
                    .filter((function (d) { return d.iconOnlyOnLabel; }))
                    .append('span')
                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
                    .html(CartesianChartInteractiveLegend.legendPlaceSelector);
                titleDivEnter.append('span');
                // Update
                item.filter((function (d) { return d.iconOnlyOnLabel; }))
                    .select('span.' + CartesianChartInteractiveLegend.legendIconClass)
                    .style(CartesianChartInteractiveLegend.legendColorCss, (function (d) { return d.color; }));
                item.select('span:last-child').text((function (d) { return d.category; }));
            };
            /**
             * Draw the legend items
             */
            CartesianChartInteractiveLegend.prototype.drawLegendItems = function (data) {
                // Add Mesaures - the items of the category in the legend
                this.ensureLegendTableCreated();
                var dataPointsMatrix = [data];
                var legendItemsContainer = this.legendContainerDiv.select('tbody').selectAll('tr').data(dataPointsMatrix);
                // Enter
                var legendItemsEnter = legendItemsContainer.enter();
                var rowEnter = legendItemsEnter.append('tr');
                var cellEnter = rowEnter.selectAll('td')
                    .data((function (d) { return d; }), (function (d) { return d.label; }))
                    .enter()
                    .append('td').attr('class', CartesianChartInteractiveLegend.LegendItem);
                var cellSpanEnter = cellEnter.append('span');
                cellSpanEnter.filter((function (d) { return !d.iconOnlyOnLabel; }))
                    .append('span')
                    .html(CartesianChartInteractiveLegend.legendPlaceSelector)
                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
                    .attr('white-space', 'nowrap')
                    .style({
                    'font-size': '20px',
                    'margin-bottom': '7px'
                });
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemNameClass);
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemMeasureClass);
                // Update
                var legendCells = legendItemsContainer.selectAll('td').data((function (d) { return d; }), (function (d) { return d.label; }));
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemNameClass).html((function (d) { return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label); }));
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemMeasureClass).html((function (d) { return '&nbsp;' + d.measure; }));
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendIconClass).style('color', (function (d) { return d.color; }));
                // Exit
                legendCells.exit().remove();
            };
            /**
             * Ensure legend table is created and set horizontal pan gestures on it
             */
            CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function () {
                if (this.legendContainerDiv.select('div table').empty()) {
                    var legendTable = this.legendContainerDiv.append('div').append('table');
                    legendTable.style('table-layout', 'fixed').append('tbody');
                    // Setup Pan Gestures of the legend
                    this.setPanGestureOnLegend(legendTable);
                }
            };
            /**
             * Set Horizontal Pan gesture for the legend
             */
            CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function (legendTable) {
                var viewportWidth = $(this.legendContainerParent[0]).width();
                var xscale = d3.scale.linear().domain([0, viewportWidth]).range([0, viewportWidth]);
                var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 1]) // disable scaling
                    .x(xscale)
                    .on("zoom", (function () {
                    // horizontal pan is valid only in case the legend items width are bigger than the viewport width
                    if ($(legendTable[0]).width() > viewportWidth) {
                        var t = zoom.translate();
                        var tx_1 = t[0];
                        var ty = t[1];
                        tx_1 = Math.min(tx_1, 0);
                        tx_1 = Math.max(tx_1, viewportWidth - $(legendTable[0]).width());
                        zoom.translate([tx_1, ty]);
                        legendTable.style("-ms-transform", (function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        }));
                        legendTable.style("-webkit-transform", (function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        }));
                        legendTable.style("transform", (function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        }));
                    }
                }));
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.call(zoom);
                }
                else {
                    legendTable.call(zoom);
                }
            };
            CartesianChartInteractiveLegend.LegendHeight = 70;
            CartesianChartInteractiveLegend.LegendContainerClass = 'interactive-legend';
            CartesianChartInteractiveLegend.LegendContainerSelector = '.interactive-legend';
            CartesianChartInteractiveLegend.LegendTitleClass = 'title';
            CartesianChartInteractiveLegend.LegendItem = 'item';
            CartesianChartInteractiveLegend.legendPlaceSelector = '\u25CF';
            CartesianChartInteractiveLegend.legendIconClass = 'icon';
            CartesianChartInteractiveLegend.legendColorCss = 'color';
            CartesianChartInteractiveLegend.legendItemNameClass = 'itemName';
            CartesianChartInteractiveLegend.legendItemMeasureClass = 'itemMeasure';
            return CartesianChartInteractiveLegend;
        }());
        var LegendData;
        (function (LegendData) {
            // Kept around for backwards compatibility.  Use Legend.getDefaultFontProperties.
            LegendData.DefaultLegendLabelFillColor = '#666666';
            /**
             * Function for updating legendData from DataViewObjects.  This should be deprecate.
             * Use the buildLegendData functions instead.
             */
            function update(legendData, legendObject) {
                debug.assertValue(legendData, 'legendData');
                debug.assertValue(legendObject, 'legendObject');
                var color = Legend.DefaultLabelColor;
                var fontSize = Legend.DefaultFontSize;
                if (legendObject[visuals.legendProps.show] == null) {
                    legendObject[visuals.legendProps.show] = true;
                }
                if (legendObject[visuals.legendProps.show] === false)
                    legendData.dataPoints = [];
                if (legendObject[visuals.legendProps.show] === true && legendObject[visuals.legendProps.position] == null)
                    legendObject[visuals.legendProps.position] = visuals.legendPosition.top;
                if (legendObject[visuals.legendProps.fontSize] !== undefined) {
                    var fontSize_1;
                    var fontSizePtValue = legendObject[visuals.legendProps.fontSize];
                    if (fontSizePtValue != null) {
                        fontSize_1 = FontSize.createFromPt(+fontSizePtValue);
                    }
                    // Update the old fontSize property for backwards compatibibility
                    legendData.fontSize = fontSizePtValue;
                }
                if (legendObject[visuals.legendProps.labelColor] !== undefined) {
                    var fillColor = legendObject[visuals.legendProps.labelColor];
                    if (fillColor != null) {
                        color = fillColor.solid.color;
                        // Update the old labelColor property for backwards compatibibility
                        legendData.labelColor = fillColor.solid.color;
                    }
                }
                if (legendObject[visuals.legendProps.showTitle] === false)
                    legendData.title = "";
                else if (legendObject[visuals.legendProps.titleText] !== undefined) {
                    legendData.title = legendObject[visuals.legendProps.titleText];
                }
                legendData.fontProperties = { color: color, family: Legend.DefaultFontFamily, size: fontSize };
            }
            LegendData.update = update;
            function create(staticObjects, dataPoints, showByDefault, defaultTitleText, hasDynamicSeries) {
                if (hasDynamicSeries === void 0) { hasDynamicSeries = false; }
                var fontSize;
                var fontSizePtValue = powerbi.DataViewObjects.getValue(staticObjects, visuals.legendPropIdentifiers.fontSize);
                if (fontSizePtValue != null) {
                    fontSize = FontSize.createFromPt(+fontSizePtValue);
                }
                else {
                    fontSize = Legend.DefaultFontSize;
                }
                var show = powerbi.DataViewObjects.getValue(staticObjects, visuals.legendPropIdentifiers.show, showByDefault);
                var position = LegendPosition[powerbi.DataViewObjects.getValue(staticObjects, visuals.legendPropIdentifiers.position, Legend.DefaultPositionKey)];
                var showTitle = powerbi.DataViewObjects.getValue(staticObjects, visuals.legendPropIdentifiers.showTitle, true);
                return {
                    show: show,
                    position: position,
                    dataPoints: dataPoints,
                    showTitle: showTitle,
                    title: powerbi.DataViewObjects.getValue(staticObjects, visuals.legendPropIdentifiers.titleText, defaultTitleText),
                    grouped: hasDynamicSeries,
                    fontProperties: {
                        family: powerbi.DataViewObjects.getValue(staticObjects, visuals.legendPropIdentifiers.fontFamily, Legend.DefaultFontFamily),
                        size: fontSize,
                        color: powerbi.DataViewObjects.getFillColor(staticObjects, visuals.legendPropIdentifiers.labelColor, Legend.DefaultLabelColor),
                    }
                };
            }
            LegendData.create = create;
            function toIEnumerableDataPoints(legendData) {
                return _.map(legendData.dataPoints, (function (dataPoint) { return ({
                    color: dataPoint.color,
                    displayName: dataPoint.label,
                    identity: dataPoint.identity,
                }); }));
            }
            LegendData.toIEnumerableDataPoints = toIEnumerableDataPoints;
        })(LegendData = visuals.LegendData || (visuals.LegendData = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisScale;
        (function (axisScale) {
            axisScale.linear = 'linear';
            axisScale.log = 'log';
            axisScale.type = powerbi.createEnumType([
                { value: axisScale.linear, displayName: function (resources) { return resources.get('Visual_Axis_Linear'); } },
                { value: axisScale.log, displayName: function (resources) { return resources.get('Visual_Axis_Log'); } }
            ]);
        })(axisScale = visuals.axisScale || (visuals.axisScale = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisStyle;
        (function (axisStyle) {
            axisStyle.showBoth = 'showBoth';
            axisStyle.showTitleOnly = 'showTitleOnly';
            axisStyle.showUnitOnly = 'showUnitOnly';
            axisStyle.type = powerbi.createEnumType([
                { value: axisStyle.showTitleOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowTitleOnly'); } },
                { value: axisStyle.showUnitOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowUnitOnly'); } },
                { value: axisStyle.showBoth, displayName: function (resources) { return resources.get('Visual_Axis_ShowBoth'); } }
            ]);
        })(axisStyle = visuals.axisStyle || (visuals.axisStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisType;
        (function (axisType) {
            axisType.scalar = 'Scalar';
            axisType.categorical = 'Categorical';
            axisType.both = 'Both';
            axisType.type = powerbi.createEnumType([
                { value: axisType.scalar, displayName: function (resources) { return resources.get('Visual_Axis_Scalar'); } },
                { value: axisType.categorical, displayName: function (resources) { return resources.get('Visual_Axis_Categorical'); } },
            ]);
        })(axisType = visuals.axisType || (visuals.axisType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var basicShapeType;
        (function (basicShapeType) {
            basicShapeType.rectangle = 'rectangle';
            basicShapeType.oval = 'oval';
            basicShapeType.line = 'line';
            basicShapeType.arrow = 'arrow';
            basicShapeType.triangle = 'triangle';
            basicShapeType.arrowButton = 'arrowbutton';
            basicShapeType.type = powerbi.createEnumType([
                { value: basicShapeType.rectangle, displayName: 'rectangle' },
                { value: basicShapeType.oval, displayName: 'oval' },
                { value: basicShapeType.line, displayName: 'line' },
                { value: basicShapeType.arrow, displayName: 'arrow' },
                { value: basicShapeType.triangle, displayName: 'triangle' },
                { value: basicShapeType.arrowButton, displayName: 'arrowbutton' },
            ]);
        })(basicShapeType = visuals.basicShapeType || (visuals.basicShapeType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BingMapTheme;
        (function (BingMapTheme) {
            // values must select the MapTypeId - see MapUtil.mapTypeIdFromStyle
            BingMapTheme.aerial = 'aerial';
            BingMapTheme.canvasDark = 'canvasDark';
            BingMapTheme.canvasLight = 'canvasLight';
            BingMapTheme.grayscale = 'grayscale';
            BingMapTheme.road = 'road';
            BingMapTheme.defaultTheme = BingMapTheme.road;
            BingMapTheme.type = powerbi.createEnumType([
                { value: BingMapTheme.aerial, displayName: function (resources) { return resources.get('Visual_MapThemeAerial'); }, },
                { value: BingMapTheme.canvasDark, displayName: function (resources) { return resources.get('Visual_MapThemeDark'); }, },
                { value: BingMapTheme.canvasLight, displayName: function (resources) { return resources.get('Visual_MapThemeLight'); }, },
                { value: BingMapTheme.grayscale, displayName: function (resources) { return resources.get('Visual_MapThemeGrayScale'); }, },
                { value: BingMapTheme.road, displayName: function (resources) { return resources.get('Visual_MapThemeRoad'); }, },
            ]);
        })(BingMapTheme = visuals.BingMapTheme || (visuals.BingMapTheme = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var confidenceBandStyle;
        (function (confidenceBandStyle) {
            confidenceBandStyle.fill = 'fill';
            confidenceBandStyle.line = 'line';
            confidenceBandStyle.none = 'none';
            confidenceBandStyle.type = powerbi.createEnumType([
                { value: confidenceBandStyle.fill, displayName: function (resources) { return resources.get('Visual_Confidence_Band_Style_Fill'); } },
                { value: confidenceBandStyle.line, displayName: function (resources) { return resources.get('Visual_Confidence_Band_Style_Line'); } },
                { value: confidenceBandStyle.none, displayName: function (resources) { return resources.get('Visual_Confidence_Band_Style_None'); } }
            ]);
        })(confidenceBandStyle = visuals.confidenceBandStyle || (visuals.confidenceBandStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var forecastUnits;
        (function (forecastUnits) {
            forecastUnits.year = 'year';
            forecastUnits.quarter = 'quarter';
            forecastUnits.month = 'month';
            forecastUnits.day = 'day';
            forecastUnits.hour = 'hour';
            forecastUnits.minute = 'minute';
            forecastUnits.second = 'second';
            forecastUnits.point = 'point';
            forecastUnits.type = powerbi.createEnumType([
                { value: forecastUnits.year, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Year'); } },
                { value: forecastUnits.quarter, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Quarter'); } },
                { value: forecastUnits.month, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Month'); } },
                { value: forecastUnits.day, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Day'); } },
                { value: forecastUnits.hour, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Hour'); } },
                { value: forecastUnits.minute, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Minute'); } },
                { value: forecastUnits.second, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Second'); } },
                { value: forecastUnits.point, displayName: function (resources) { return resources.get('Visual_Forecast_Units_Point'); } },
            ]);
        })(forecastUnits = visuals.forecastUnits || (visuals.forecastUnits = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var forecastConfidenceIntervals;
        (function (forecastConfidenceIntervals) {
            forecastConfidenceIntervals.ninetyNine = '99%';
            forecastConfidenceIntervals.ninetyFive = '95%';
            forecastConfidenceIntervals.ninety = '90%';
            forecastConfidenceIntervals.eightyFive = '85%';
            forecastConfidenceIntervals.eighty = '80%';
            forecastConfidenceIntervals.seventyfive = '75%';
            forecastConfidenceIntervals.type = powerbi.createEnumType([
                { value: forecastConfidenceIntervals.ninetyNine, displayName: function () { return '99%'; } },
                { value: forecastConfidenceIntervals.ninetyFive, displayName: function () { return '95%'; } },
                { value: forecastConfidenceIntervals.ninety, displayName: function () { return '90%'; } },
                { value: forecastConfidenceIntervals.eightyFive, displayName: function () { return '85%'; } },
                { value: forecastConfidenceIntervals.eighty, displayName: function () { return '80%'; } },
                { value: forecastConfidenceIntervals.seventyfive, displayName: function () { return '75%'; } },
            ]);
        })(forecastConfidenceIntervals = visuals.forecastConfidenceIntervals || (visuals.forecastConfidenceIntervals = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var imageScalingType;
        (function (imageScalingType) {
            imageScalingType.normal = 'Normal';
            imageScalingType.fit = 'Fit';
            imageScalingType.fill = 'Fill';
            imageScalingType.type = powerbi.createEnumType([
                { value: imageScalingType.normal, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Normal'); } },
                { value: imageScalingType.fit, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fit'); } },
                { value: imageScalingType.fill, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fill'); } },
            ]);
        })(imageScalingType = visuals.imageScalingType || (visuals.imageScalingType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelOrientation;
        (function (labelOrientation) {
            labelOrientation.type = powerbi.createEnumType([
                { value: 0 /* Vertical */, displayName: function (resources) { return resources.get('Visual_LabelOrientation_Vertical'); } },
                { value: 1 /* Horizontal */, displayName: function (resources) { return resources.get('Visual_LabelOrientation_Horizontal'); } },
            ]);
        })(labelOrientation = visuals.labelOrientation || (visuals.labelOrientation = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelPosition;
        (function (labelPosition) {
            labelPosition.auto = 'Auto';
            labelPosition.insideEnd = 'InsideEnd';
            labelPosition.insideCenter = 'InsideCenter';
            labelPosition.outsideEnd = 'OutsideEnd';
            labelPosition.insideBase = 'InsideBase';
            labelPosition.type = powerbi.createEnumType([
                { value: labelPosition.auto, displayName: function (resources) { return resources.get('Visual_Auto'); } },
                { value: labelPosition.insideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideEnd'); } },
                { value: labelPosition.outsideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_OutsideEnd'); } },
                { value: labelPosition.insideCenter, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideCenter'); } },
                { value: labelPosition.insideBase, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideBase'); } },
            ]);
        })(labelPosition = visuals.labelPosition || (visuals.labelPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelStyle;
        (function (labelStyle) {
            labelStyle.flagLabelStyleCategory = 1 << 1;
            labelStyle.flagLabelStyleData = 1 << 2;
            labelStyle.flagLabelStylePercent = 1 << 3;
            var labelStyleFlagEnum;
            (function (labelStyleFlagEnum) {
                labelStyleFlagEnum[labelStyleFlagEnum["category"] = labelStyle.flagLabelStyleCategory] = "category";
                labelStyleFlagEnum[labelStyleFlagEnum["data"] = labelStyle.flagLabelStyleData] = "data";
                labelStyleFlagEnum[labelStyleFlagEnum["percent"] = labelStyle.flagLabelStylePercent] = "percent";
                labelStyleFlagEnum[labelStyleFlagEnum["categoryAndData"] = labelStyle.flagLabelStyleCategory | labelStyle.flagLabelStyleData] = "categoryAndData";
                labelStyleFlagEnum[labelStyleFlagEnum["categoryAndPercent"] = labelStyle.flagLabelStyleCategory | labelStyle.flagLabelStylePercent] = "categoryAndPercent";
                labelStyleFlagEnum[labelStyleFlagEnum["dataAndPercent"] = labelStyle.flagLabelStyleData | labelStyle.flagLabelStylePercent] = "dataAndPercent";
                labelStyleFlagEnum[labelStyleFlagEnum["categoryAndDataAndPercent"] = labelStyle.flagLabelStyleCategory | labelStyle.flagLabelStyleData | labelStyle.flagLabelStylePercent] = "categoryAndDataAndPercent";
            })(labelStyleFlagEnum = labelStyle.labelStyleFlagEnum || (labelStyle.labelStyleFlagEnum = {}));
            labelStyle.category = 'Category';
            labelStyle.data = 'Data';
            labelStyle.percent = 'Percent of total';
            // Category, Data Value
            // Keep the 'Both' name due to back compat and previous options
            labelStyle.categoryAndData = 'Both';
            labelStyle.categoryAndPercent = 'Category, percent of total';
            labelStyle.dataAndPercent = 'Data value, percent of total';
            labelStyle.categoryAndDataAndPercent = 'Category, data value, percent of total';
            labelStyle.type = powerbi.createEnumType([
                { value: labelStyle.category, displayName: function (resources) { return resources.get('Visual_LabelStyle_Category'); } },
                { value: labelStyle.data, displayName: function (resources) { return resources.get('Visual_LabelStyle_DataValue'); } },
                { value: labelStyle.percent, displayName: function (resources) { return resources.get('Visual_LabelStyle_Percent'); } },
                { value: labelStyle.categoryAndData, displayName: function (resources) { return resources.get('Visual_LabelStyle_CategoryAndData'); } },
                { value: labelStyle.categoryAndPercent, displayName: function (resources) { return resources.get('Visual_LabelStyle_CategoryAndPercent'); } },
                { value: labelStyle.dataAndPercent, displayName: function (resources) { return resources.get('Visual_LabelStyle_DataAndPercent'); } },
                { value: labelStyle.categoryAndDataAndPercent, displayName: function (resources) { return resources.get('Visual_LabelStyle_CategoryAndDataAndPercent'); } },
            ]);
        })(labelStyle = visuals.labelStyle || (visuals.labelStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelText;
        (function (labelText) {
            labelText.value = 'Value';
            labelText.name = 'Name';
            labelText.nameAndValue = 'ValueAndName';
            labelText.type = powerbi.createEnumType([
                { value: labelText.value, displayName: function (resources) { return resources.get('Visual_LabelText_Value'); } },
                { value: labelText.name, displayName: function (resources) { return resources.get('Visual_LabelText_Name'); } },
                { value: labelText.nameAndValue, displayName: function (resources) { return resources.get('Visual_LabelText_Name_Value'); } },
            ]);
        })(labelText = visuals.labelText || (visuals.labelText = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var legendPosition;
        (function (legendPosition) {
            legendPosition.top = 'Top';
            legendPosition.bottom = 'Bottom';
            legendPosition.left = 'Left';
            legendPosition.right = 'Right';
            legendPosition.topCenter = 'TopCenter';
            legendPosition.bottomCenter = 'BottomCenter';
            legendPosition.leftCenter = 'LeftCenter';
            legendPosition.rightCenter = 'RightCenter';
            legendPosition.type = powerbi.createEnumType([
                { value: legendPosition.top, displayName: function (resources) { return resources.get('Visual_LegendPosition_Top'); } },
                { value: legendPosition.bottom, displayName: function (resources) { return resources.get('Visual_LegendPosition_Bottom'); } },
                { value: legendPosition.left, displayName: function (resources) { return resources.get('Visual_LegendPosition_Left'); } },
                { value: legendPosition.right, displayName: function (resources) { return resources.get('Visual_LegendPosition_Right'); } },
                { value: legendPosition.topCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_TopCenter'); } },
                { value: legendPosition.bottomCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_BottomCenter'); } },
                { value: legendPosition.leftCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_LeftCenter'); } },
                { value: legendPosition.rightCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_RightCenter'); } },
            ]);
        })(legendPosition = visuals.legendPosition || (visuals.legendPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var kpiDirection;
        (function (kpiDirection) {
            kpiDirection.positive = 'Positive';
            kpiDirection.negative = 'Negative';
            kpiDirection.type = powerbi.createEnumType([
                { value: kpiDirection.positive, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Positive'); } },
                { value: kpiDirection.negative, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Negative'); } }
            ]);
        })(kpiDirection = visuals.kpiDirection || (visuals.kpiDirection = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var strokeLineJoin;
        (function (strokeLineJoin) {
            strokeLineJoin.miter = 'miter';
            strokeLineJoin.round = 'round';
            strokeLineJoin.bevel = 'bevel';
            strokeLineJoin.defaultValue = strokeLineJoin.round;
            strokeLineJoin.type = powerbi.createEnumType([
                { value: strokeLineJoin.miter, displayName: function (resources) { return resources.get('Visual_StrokeLineJoin_Miter'); } },
                { value: strokeLineJoin.round, displayName: function (resources) { return resources.get('Visual_StrokeLineJoin_Round'); } },
                { value: strokeLineJoin.bevel, displayName: function (resources) { return resources.get('Visual_StrokeLineJoin_Bevel'); } },
            ]);
        })(strokeLineJoin = visuals.strokeLineJoin || (visuals.strokeLineJoin = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var legendMarkerRendering;
        (function (legendMarkerRendering) {
            legendMarkerRendering.markerOnly = 'markerOnly';
            legendMarkerRendering.lineAndMarker = 'lineAndMarker';
            legendMarkerRendering.lineOnly = 'lineOnly';
            legendMarkerRendering.type = powerbi.createEnumType([
                { value: legendMarkerRendering.markerOnly, displayName: function (resources) { return resources.get('Visual_LegendMarkerOnly'); } },
                { value: legendMarkerRendering.lineAndMarker, displayName: function (resources) { return resources.get('Visual_LegendLineAndMarker'); } },
                { value: legendMarkerRendering.lineOnly, displayName: function (resources) { return resources.get('Visual_LegendLineOnly'); } }
            ]);
        })(legendMarkerRendering = visuals.legendMarkerRendering || (visuals.legendMarkerRendering = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var lineStyle;
        (function (lineStyle) {
            lineStyle.dashed = 'dashed';
            lineStyle.solid = 'solid';
            lineStyle.dotted = 'dotted';
            lineStyle.type = powerbi.createEnumType([
                { value: lineStyle.dashed, displayName: function (resources) { return resources.get('Visual_LineStyle_Dashed'); } },
                { value: lineStyle.solid, displayName: function (resources) { return resources.get('Visual_LineStyle_Solid'); } },
                { value: lineStyle.dotted, displayName: function (resources) { return resources.get('Visual_LineStyle_Dotted'); } }
            ]);
        })(lineStyle = visuals.lineStyle || (visuals.lineStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var markerShape;
        (function (markerShape) {
            markerShape.circle = 'circle';
            markerShape.square = 'square';
            markerShape.diamond = 'diamond';
            markerShape.triangle = 'triangle';
            markerShape.x = 'x';
            markerShape.shortDash = 'shortDash';
            markerShape.longDash = 'longDash';
            markerShape.plus = 'plus';
            markerShape.none = 'none';
            markerShape.defaultValue = markerShape.circle;
            markerShape.type = powerbi.createEnumType([
                { value: markerShape.circle, displayName: function (resources) { return resources.get('Visual_MarkerShape_Circle'); } },
                { value: markerShape.square, displayName: function (resources) { return resources.get('Visual_MarkerShape_Square'); } },
                { value: markerShape.diamond, displayName: function (resources) { return resources.get('Visual_MarkerShape_Diamond'); } },
                { value: markerShape.triangle, displayName: function (resources) { return resources.get('Visual_MarkerShape_Triangle'); } },
                { value: markerShape.x, displayName: function (resources) { return resources.get('Visual_MarkerShape_X'); } },
                { value: markerShape.shortDash, displayName: function (resources) { return resources.get('Visual_MarkerShape_ShortDash'); } },
                { value: markerShape.longDash, displayName: function (resources) { return resources.get('Visual_MarkerShape_LongDash'); } },
                { value: markerShape.plus, displayName: function (resources) { return resources.get('Visual_MarkerShape_Plus'); } },
            ]);
        })(markerShape = visuals.markerShape || (visuals.markerShape = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var outline;
        (function (outline_1) {
            outline_1.none = 'None';
            outline_1.bottomOnly = 'BottomOnly';
            outline_1.topOnly = 'TopOnly';
            outline_1.leftOnly = 'LeftOnly';
            outline_1.rightOnly = 'RightOnly';
            outline_1.topBottom = 'TopBottom';
            outline_1.leftRight = 'LeftRight';
            outline_1.frame = 'Frame';
            function showTop(outline) {
                return [outline_1.topOnly, outline_1.topBottom, outline_1.frame].some((function (o) { return o === outline; }));
            }
            outline_1.showTop = showTop;
            function showRight(outline) {
                return [outline_1.rightOnly, outline_1.leftRight, outline_1.frame].some((function (o) { return o === outline; }));
            }
            outline_1.showRight = showRight;
            function showBottom(outline) {
                return [outline_1.bottomOnly, outline_1.topBottom, outline_1.frame].some((function (o) { return o === outline; }));
            }
            outline_1.showBottom = showBottom;
            function showLeft(outline) {
                return [outline_1.leftOnly, outline_1.leftRight, outline_1.frame].some((function (o) { return o === outline; }));
            }
            outline_1.showLeft = showLeft;
            outline_1.type = powerbi.createEnumType([
                { value: outline_1.none, displayName: function (resources) { return resources.get('Visual_Outline_none'); } },
                { value: outline_1.bottomOnly, displayName: function (resources) { return resources.get('Visual_Outline_bottom_only'); } },
                { value: outline_1.topOnly, displayName: function (resources) { return resources.get('Visual_Outline_top_only'); } },
                { value: outline_1.leftOnly, displayName: function (resources) { return resources.get('Visual_Outline_LeftOnly'); } },
                { value: outline_1.rightOnly, displayName: function (resources) { return resources.get('Visual_Outline_RightOnly'); } },
                { value: outline_1.topBottom, displayName: function (resources) { return resources.get('Visual_Outline_top_Bottom'); } },
                { value: outline_1.leftRight, displayName: function (resources) { return resources.get('Visual_Outline_leftRight'); } },
                { value: outline_1.frame, displayName: function (resources) { return resources.get('Visual_Outline_frame'); } }
            ]);
        })(outline = visuals.outline || (visuals.outline = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var referenceLinePosition;
        (function (referenceLinePosition) {
            referenceLinePosition.back = 'back';
            referenceLinePosition.front = 'front';
            referenceLinePosition.type = powerbi.createEnumType([
                { value: referenceLinePosition.back, displayName: function (resources) { return resources.get('Visual_Reference_Line_Behind'); } },
                { value: referenceLinePosition.front, displayName: function (resources) { return resources.get('Visual_Reference_Line_InFront'); } },
            ]);
        })(referenceLinePosition = visuals.referenceLinePosition || (visuals.referenceLinePosition = {}));
        var referenceLineDataLabelHorizontalPosition;
        (function (referenceLineDataLabelHorizontalPosition) {
            referenceLineDataLabelHorizontalPosition.left = 'left';
            referenceLineDataLabelHorizontalPosition.right = 'right';
            referenceLineDataLabelHorizontalPosition.type = powerbi.createEnumType([
                { value: referenceLineDataLabelHorizontalPosition.left, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Left'); } },
                { value: referenceLineDataLabelHorizontalPosition.right, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Right'); } },
            ]);
        })(referenceLineDataLabelHorizontalPosition = visuals.referenceLineDataLabelHorizontalPosition || (visuals.referenceLineDataLabelHorizontalPosition = {}));
        var referenceLineDataLabelVerticalPosition;
        (function (referenceLineDataLabelVerticalPosition) {
            referenceLineDataLabelVerticalPosition.above = 'above';
            referenceLineDataLabelVerticalPosition.under = 'under';
            referenceLineDataLabelVerticalPosition.type = powerbi.createEnumType([
                { value: referenceLineDataLabelVerticalPosition.above, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Above'); } },
                { value: referenceLineDataLabelVerticalPosition.under, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Under'); } },
            ]);
        })(referenceLineDataLabelVerticalPosition = visuals.referenceLineDataLabelVerticalPosition || (visuals.referenceLineDataLabelVerticalPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var slicerOrientation;
        (function (slicerOrientation) {
            slicerOrientation.type = powerbi.createEnumType([
                { value: 0 /* Vertical */, displayName: function (resources) { return resources.get('Slicer_Orientation_Vertical'); } },
                { value: 1 /* Horizontal */, displayName: function (resources) { return resources.get('Slicer_Orientation_Horizontal'); } },
            ]);
        })(slicerOrientation = visuals.slicerOrientation || (visuals.slicerOrientation = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var standardGeoJson;
        (function (standardGeoJson) {
            standardGeoJson.australiaStates = "australia.states.topo";
            standardGeoJson.austriaStates = "austria.states.topo";
            standardGeoJson.brazilStates = "brazil.states.topo";
            standardGeoJson.canadaProvinces = "canada.provinces.topo";
            standardGeoJson.franceRegions = "france.regions.topo";
            standardGeoJson.germanyStates = "germany.states.topo";
            standardGeoJson.irelandCounties = "ireland.counties.topo";
            standardGeoJson.italyRegions = "italy.regions.topo";
            standardGeoJson.mexicoStates = "mexico.states.topo";
            standardGeoJson.netherlandsProvinces = "netherlands.provinces.topo";
            standardGeoJson.ukCountries = "uk.countries.topo";
            standardGeoJson.usaStates = "usa.states.topo";
            standardGeoJson.type = powerbi.createEnumType([
                { value: standardGeoJson.australiaStates, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_AustraliaStates'); } },
                { value: standardGeoJson.austriaStates, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_AustriaStates'); } },
                { value: standardGeoJson.brazilStates, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_BrazilStates'); } },
                { value: standardGeoJson.canadaProvinces, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_CanadaProvinces'); } },
                { value: standardGeoJson.franceRegions, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_FranceRegions'); } },
                { value: standardGeoJson.germanyStates, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_GermanyStates'); } },
                { value: standardGeoJson.irelandCounties, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_IrelandCounties'); } },
                { value: standardGeoJson.italyRegions, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_ItalyRegions'); } },
                { value: standardGeoJson.mexicoStates, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_MexicoStates'); } },
                { value: standardGeoJson.netherlandsProvinces, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_NetherlandsProvinces'); } },
                { value: standardGeoJson.ukCountries, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_UkCountries'); } },
                { value: standardGeoJson.usaStates, displayName: function (resources) { return resources.get('Visual_ShapeMap_StandardMaps_UsaStates'); } },
            ]);
        })(standardGeoJson = visuals.standardGeoJson || (visuals.standardGeoJson = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var yAxisPosition;
        (function (yAxisPosition) {
            yAxisPosition.left = 'Left';
            yAxisPosition.right = 'Right';
            yAxisPosition.type = powerbi.createEnumType([
                { value: yAxisPosition.left, displayName: function (resources) { return resources.get('Visual_yAxis_Left'); } },
                { value: yAxisPosition.right, displayName: function (resources) { return resources.get('Visual_yAxis_Right'); } },
            ]);
        })(yAxisPosition = visuals.yAxisPosition || (visuals.yAxisPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var rowSubtotalPosition;
        (function (rowSubtotalPosition) {
            rowSubtotalPosition.top = 'Top';
            rowSubtotalPosition.bottom = 'Bottom';
            rowSubtotalPosition.type = powerbi.createEnumType([
                { value: rowSubtotalPosition.top, displayName: function (resources) { return resources.get('Visual_SubtotalRow_Position_Top'); } },
                { value: rowSubtotalPosition.bottom, displayName: function (resources) { return resources.get('Visual_SubtotalRow_Position_Bottom'); } },
            ]);
        })(rowSubtotalPosition = visuals.rowSubtotalPosition || (visuals.rowSubtotalPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ShapeMapType;
        (function (ShapeMapType) {
            var Role;
            (function (Role) {
                Role.category = 'Category';
                Role.series = 'Series';
                Role.tooltips = 'Tooltips';
                Role.value = 'Value';
            })(Role = ShapeMapType.Role || (ShapeMapType.Role = {}));
            var Projection;
            (function (Projection) {
                Projection.albersUsa = 'albersUsa';
                Projection.equirectangular = 'equirectangular';
                Projection.mercator = 'mercator';
                Projection.orthographic = 'orthographic';
                Projection.type = powerbi.createEnumType([
                    { value: Projection.albersUsa, displayName: function (resources) { return resources.get('Visual_ShapeMap_Projection_AlbersUsa'); }, },
                    { value: Projection.equirectangular, displayName: function (resources) { return resources.get('Visual_ShapeMap_Projection_Equirectangular'); }, },
                    { value: Projection.mercator, displayName: function (resources) { return resources.get('Visual_ShapeMap_Projection_Mercator'); }, },
                    { value: Projection.orthographic, displayName: function (resources) { return resources.get('Visual_ShapeMap_Projection_Orthographic'); }, },
                ]);
            })(Projection = ShapeMapType.Projection || (ShapeMapType.Projection = {}));
        })(ShapeMapType = visuals.ShapeMapType || (visuals.ShapeMapType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var slicerMode;
        (function (slicerMode) {
            slicerMode.before = 'Before';
            slicerMode.after = 'After';
            slicerMode.between = 'Between';
            slicerMode.basic = "Basic";
            slicerMode.dropdown = "Dropdown";
            slicerMode.relative = "Relative";
            slicerMode.single = "Single";
            slicerMode.type = powerbi.createEnumType([
                { value: slicerMode.between, displayName: function (resources) { return resources.get('Visual_SliderMode_Between'); } },
                { value: slicerMode.before, displayName: function (resources) { return resources.get('Visual_SliderMode_Before'); } },
                { value: slicerMode.after, displayName: function (resources) { return resources.get('Visual_SliderMode_After'); } },
                { value: slicerMode.basic, displayName: function (resources) { return resources.get('Visual_SliderMode_Basic'); } },
                { value: slicerMode.dropdown, displayName: function (resources) { return resources.get('Visual_SliderMode_Dropdown'); } },
                { value: slicerMode.relative, displayName: function (resources) { return resources.get('Visual_SliderMode_Relative'); } },
                { value: slicerMode.single, displayName: function (resources) { return resources.get('Visual_SliderMode_SingleVal'); } }
            ]);
            function isRangeSlicerMode(mode) {
                return mode === slicerMode.before || mode === slicerMode.between || mode === slicerMode.after || mode === slicerMode.single;
            }
            slicerMode.isRangeSlicerMode = isRangeSlicerMode;
            function slicerModeSupportsMinMax(mode) {
                return mode === slicerMode.before || mode === slicerMode.between || mode === slicerMode.after;
            }
            slicerMode.slicerModeSupportsMinMax = slicerModeSupportsMinMax;
        })(slicerMode = visuals.slicerMode || (visuals.slicerMode = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var textAlignment;
        (function (textAlignment) {
            textAlignment.auto = "Auto";
            textAlignment.left = "Left";
            textAlignment.center = "Center";
            textAlignment.right = "Right";
            textAlignment.type = powerbi.createEnumType([
                { value: textAlignment.auto, displayName: function (resources) { return resources.get('Visual_TextAlignment_Auto'); } },
                { value: textAlignment.left, displayName: function (resources) { return resources.get('Visual_TextAlignment_Left'); } },
                { value: textAlignment.center, displayName: function (resources) { return resources.get('Visual_TextAlignment_Center'); } },
                { value: textAlignment.right, displayName: function (resources) { return resources.get('Visual_TextAlignment_Right'); } },
            ]);
        })(textAlignment = visuals.textAlignment || (visuals.textAlignment = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var relativeSlicerRelativeQualifier;
        (function (relativeSlicerRelativeQualifier) {
            relativeSlicerRelativeQualifier.last = 'Last';
            relativeSlicerRelativeQualifier.next = 'Next';
            relativeSlicerRelativeQualifier.current = 'This';
            relativeSlicerRelativeQualifier.type = powerbi.createEnumType([
                { value: relativeSlicerRelativeQualifier.last, displayName: function (resources) { return resources.get('Visual_SlicerRange_Last'); } },
                { value: relativeSlicerRelativeQualifier.next, displayName: function (resources) { return resources.get('Visual_SlicerRange_Next'); } },
                { value: relativeSlicerRelativeQualifier.current, displayName: function (resources) { return resources.get('Visual_SlicerRange_This'); } }
            ]);
        })(relativeSlicerRelativeQualifier = visuals.relativeSlicerRelativeQualifier || (visuals.relativeSlicerRelativeQualifier = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var relativeSlicerPeriod;
        (function (relativeSlicerPeriod) {
            relativeSlicerPeriod.none = "None";
            relativeSlicerPeriod.days = 'Days';
            relativeSlicerPeriod.weeks = 'Weeks';
            relativeSlicerPeriod.calendarWeeks = "Calendar Weeks";
            relativeSlicerPeriod.months = 'Months';
            relativeSlicerPeriod.calendarMonths = 'Calendar Months';
            relativeSlicerPeriod.years = 'Years';
            relativeSlicerPeriod.calendarYears = 'Calendar Years';
            relativeSlicerPeriod.type = powerbi.createEnumType([
                { value: relativeSlicerPeriod.none, displayName: function (resources) { return resources.get('Visual_SlicerPeriod_None'); } },
                { value: relativeSlicerPeriod.days, displayName: function (resources) { return resources.get('TimeUnit_Days'); } },
                { value: relativeSlicerPeriod.weeks, displayName: function (resources) { return resources.get('TimeUnit_Weeks'); } },
                { value: relativeSlicerPeriod.calendarWeeks, displayName: function (resources) { return resources.get('Visual_SlicerPeriod_CalWeeks'); } },
                { value: relativeSlicerPeriod.months, displayName: function (resources) { return resources.get('TimeUnit_Months'); } },
                { value: relativeSlicerPeriod.calendarMonths, displayName: function (resources) { return resources.get('Visual_SlicerPeriod_CalMonths'); } },
                { value: relativeSlicerPeriod.years, displayName: function (resources) { return resources.get('TimeUnit_Years'); } },
                { value: relativeSlicerPeriod.calendarYears, displayName: function (resources) { return resources.get('Visual_SlicerPeriod_CalYears'); } }
            ]);
        })(relativeSlicerPeriod = visuals.relativeSlicerPeriod || (visuals.relativeSlicerPeriod = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AnimatorCommon;
        (function (AnimatorCommon) {
            AnimatorCommon.MinervaAnimationDuration = 250;
            // The maximum number of data points we can performantly animate with SVG. If we have more, turn off animations.
            AnimatorCommon.MaxDataPointsToAnimate = 1000;
            function GetAnimationDuration(animator, suppressAnimations) {
                return (suppressAnimations || !animator) ? 0 : animator.getDuration();
            }
            AnimatorCommon.GetAnimationDuration = GetAnimationDuration;
        })(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
        /**
         * We just need to have a non-null animator to allow axis animations in cartesianChart.
         * Note: Use this temporarily for Line/Scatter until we add more animations (MinervaPlugins only).
         */
        var BaseAnimator = /** @class */ (function () {
            function BaseAnimator(options) {
                if (options && options.duration) {
                    this.animationDuration = options.duration;
                }
                this.animationDuration = this.animationDuration >= 0 ? this.animationDuration : AnimatorCommon.MinervaAnimationDuration;
            }
            BaseAnimator.prototype.getDuration = function () {
                return this.animationDuration;
            };
            BaseAnimator.prototype.animate = function (options) {
                return null;
            };
            BaseAnimator.prototype.getEasing = function () {
                return 'cubic-in-out';
            };
            return BaseAnimator;
        }());
        visuals.BaseAnimator = BaseAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        /**
         * This is the baseline for some most common used object properties across visuals.
         * When adding new properties, please try to reuse the existing ones.
         */
        visuals.StandardObjectProperties = {
            axisEnd: {
                displayName: createDisplayNameGetter('Visual_Axis_End'),
                description: createDisplayNameGetter('Visual_Axis_EndDescription'),
                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                type: { variant: [{ numeric: true }, { dateTime: true }] },
                suppressFormatPainterCopy: true,
            },
            axisScale: {
                displayName: createDisplayNameGetter('Visual_Axis_Scale'),
                type: { enumeration: visuals.axisScale.type }
            },
            axisStart: {
                displayName: createDisplayNameGetter('Visual_Axis_Start'),
                description: createDisplayNameGetter('Visual_Axis_StartDescription'),
                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                type: { variant: [{ numeric: true }, { dateTime: true }] },
                suppressFormatPainterCopy: true,
            },
            axisStyle: {
                displayName: createDisplayNameGetter('Visual_Axis_Style'),
                type: { enumeration: visuals.axisStyle.type }
            },
            axisType: {
                displayName: createDisplayNameGetter('Visual_Axis_Type'),
                type: { enumeration: visuals.axisType.type },
            },
            backColor: {
                displayName: createDisplayNameGetter('Visual_Tablix_BackColor'),
                description: createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                type: { fill: { solid: { color: true } } }
            },
            dataColor: {
                displayName: createDisplayNameGetter('Visual_LabelsFill'),
                description: createDisplayNameGetter('Visual_LabelsFillDescription'),
                type: { fill: { solid: { color: true } } }
            },
            dataLabelColor: {
                displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                description: createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                type: { fill: { solid: { color: true } } }
            },
            dataLabelDecimalPoints: {
                displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                type: { numeric: true }
            },
            dataLabelDisplayUnits: {
                displayName: createDisplayNameGetter('Visual_DisplayUnits'),
                description: createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                type: { formatting: { labelDisplayUnits: true } },
                suppressFormatPainterCopy: true,
            },
            dataLabelHorizontalPosition: {
                displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                description: createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
            },
            dataLabelText: {
                displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Label_Text"),
                description: createDisplayNameGetter('Visual_Reference_Line_Data_Label_Text_Description'),
                type: { enumeration: visuals.labelText.type }
            },
            dataLabelShow: {
                displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                description: createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                type: { bool: true }
            },
            dataLabelVerticalPosition: {
                displayName: createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                description: createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
            },
            /** defaultColor only exists for backwards compatibility.  It has been replaced by defaultCategoryColor for improved behavior. */
            defaultColor: {
                displayName: createDisplayNameGetter('Visual_DefaultColor'),
                type: { fill: { solid: { color: true } } }
            },
            defaultCategoryColor: {
                displayName: createDisplayNameGetter('Visual_DefaultColor'),
                type: { fill: { solid: { color: true } } }
            },
            fill: {
                displayName: createDisplayNameGetter('Visual_Fill'),
                type: { fill: { solid: { color: true } } }
            },
            fontColor: {
                displayName: createDisplayNameGetter('Visual_FontColor'),
                description: createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                type: { fill: { solid: { color: true } } }
            },
            fontSize: {
                displayName: createDisplayNameGetter('Visual_TextSize'),
                type: { formatting: { fontSize: true } }
            },
            fontFamily: {
                displayName: createDisplayNameGetter('Visual_FontFamily'),
                type: { formatting: { fontFamily: true } }
            },
            formatString: {
                type: { formatting: { formatString: true } },
            },
            image: {
                type: { image: {} },
            },
            labelColor: {
                displayName: createDisplayNameGetter('Visual_LegendTitleColor'),
                type: { fill: { solid: { color: true } } }
            },
            labelDisplayUnits: {
                displayName: createDisplayNameGetter('Visual_DisplayUnits'),
                description: createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                type: { formatting: { labelDisplayUnits: true } }
            },
            labelPrecision: {
                displayName: createDisplayNameGetter('Visual_Precision'),
                description: createDisplayNameGetter('Visual_PrecisionDescription'),
                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                type: { numeric: true }
            },
            percentageLabelPrecision: {
                displayName: createDisplayNameGetter('Visual_Percentage_Precision'),
                description: createDisplayNameGetter('Visual_Percentage_PrecisionDescription'),
                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                type: { numeric: true }
            },
            legendPosition: {
                displayName: createDisplayNameGetter('Visual_LegendPosition'),
                description: createDisplayNameGetter('Visual_LegendPositionDescription'),
                type: { enumeration: visuals.legendPosition.type },
            },
            legendTitle: {
                displayName: createDisplayNameGetter('Visual_LegendName'),
                description: createDisplayNameGetter('Visual_LegendNameDescription'),
                type: { text: true },
                suppressFormatPainterCopy: true,
            },
            lineColor: {
                displayName: createDisplayNameGetter('Visual_Reference_Line_Color'),
                description: createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                type: { fill: { solid: { color: true } } }
            },
            lineStyle: {
                displayName: createDisplayNameGetter('Visual_LineStyle'),
                type: { enumeration: visuals.lineStyle.type }
            },
            titleColor: {
                displayName: createDisplayNameGetter('Visual_AxisTitleColor'),
                type: { fill: { solid: { color: true } } }
            },
            titleFontSize: {
                displayName: createDisplayNameGetter('Visual_AxisTitleTextSize'),
                type: { formatting: { fontSize: true } }
            },
            titleText: {
                displayName: createDisplayNameGetter('Visual_AxisTitleText'),
                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                type: { text: true },
                suppressFormatPainterCopy: true
            },
            outline: {
                displayName: createDisplayNameGetter('Visual_Outline'),
                type: { enumeration: visuals.outline.type }
            },
            outlineColor: {
                displayName: createDisplayNameGetter('Visual_OutlineColor'),
                description: createDisplayNameGetter('Visual_OutlineColor_Desc'),
                type: { fill: { solid: { color: true } } }
            },
            outlineWeight: {
                displayName: createDisplayNameGetter('Visual_OutlineWeight'),
                description: createDisplayNameGetter('Visual_OutlineWeight_Desc'),
                type: { numeric: true }
            },
            referenceLinePosition: {
                displayName: createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                description: createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                type: { enumeration: visuals.referenceLinePosition.type }
            },
            show: {
                displayName: createDisplayNameGetter('Visual_Show'),
                type: { bool: true }
            },
            showAllDataPoints: {
                displayName: createDisplayNameGetter('ShowAll'),
                type: { bool: true }
            },
            showLegendTitle: {
                displayName: createDisplayNameGetter('Visual_LegendShowTitle'),
                description: createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                type: { bool: true }
            },
            strokeWidth: {
                displayName: createDisplayNameGetter('Visual_StrokeWidth'),
                type: { numeric: true },
            },
            strokeLineJoin: {
                displayName: createDisplayNameGetter('Visual_StrokeLineJoin'),
                type: { enumeration: visuals.strokeLineJoin.type }
            },
            lineDashType: {
                displayName: createDisplayNameGetter('Visual_LineDashType'),
                type: { enumeration: visuals.lineStyle.type }
            },
            showMarker: {
                displayName: createDisplayNameGetter("Visual_ShowMarker"),
                type: { bool: true }
            },
            markerShape: {
                displayName: createDisplayNameGetter("Visual_MarkerShape"),
                type: { enumeration: visuals.markerShape.type }
            },
            markerSize: {
                displayName: createDisplayNameGetter("Visual_MarkerSize"),
                type: { numeric: true }
            },
            markerColor: {
                displayName: createDisplayNameGetter("Visual_MarkerColor"),
                type: { fill: { solid: { color: true } } }
            },
            transparency: {
                displayName: createDisplayNameGetter('Visual_Background_Transparency'),
                description: createDisplayNameGetter('Visual_Background_TransparencyDescription'),
                type: { numeric: true }
            },
            lineTransparency: {
                displayName: createDisplayNameGetter('Visual_Background_Transparency'),
                description: createDisplayNameGetter('Visual_Background_TransparencyLineDescription'),
                type: { numeric: true }
            },
            yAxisPosition: {
                displayName: createDisplayNameGetter('Visual_YAxis_Position'),
                description: createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                type: { enumeration: visuals.yAxisPosition.type },
            },
            responsive: {
                displayName: createDisplayNameGetter('Visual_General_ResponsiveLabel'),
                description: createDisplayNameGetter('Visual_General_ResponsiveLabelDescription'),
                type: { bool: true }
            },
            responsiveLegacy: {
                type: { bool: true }
            },
            textAlignment: {
                displayName: createDisplayNameGetter('Visual_TextAlignment'),
                type: { enumeration: visuals.textAlignment.type },
            }
        };
        visuals.StandardObjectDescriptors = {
            legend: {
                displayName: createDisplayNameGetter('Visual_Legend'),
                description: createDisplayNameGetter('Visual_LegendDescription'),
                properties: {
                    show: {
                        displayName: createDisplayNameGetter('Visual_Show'),
                        type: { bool: true }
                    },
                    position: {
                        displayName: createDisplayNameGetter('Visual_LegendPosition'),
                        description: createDisplayNameGetter('Visual_LegendPositionDescription'),
                        type: { enumeration: visuals.legendPosition.type },
                    },
                    showTitle: {
                        displayName: createDisplayNameGetter('Visual_LegendShowTitle'),
                        description: createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                        type: { bool: true }
                    },
                    titleText: {
                        displayName: createDisplayNameGetter('Visual_LegendName'),
                        description: createDisplayNameGetter('Visual_LegendNameDescription'),
                        type: { text: true },
                        suppressFormatPainterCopy: true,
                    },
                    labelColor: {
                        displayName: createDisplayNameGetter('Visual_LegendTitleColor'),
                        type: { fill: { solid: { color: true } } }
                    },
                    fontFamily: {
                        displayName: createDisplayNameGetter('Visual_FontFamily'),
                        type: { formatting: { fontFamily: true } }
                    },
                    fontSize: {
                        displayName: createDisplayNameGetter('Visual_TextSize'),
                        type: { formatting: { fontSize: true } }
                    },
                }
            },
        };
        visuals.StandardObjectPropertyIdentifiers = {
            formatString: {
                objectName: 'general',
                propertyName: 'formatString',
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.animatedTextObjectDescs = {
            general: {
                properties: {
                    formatString: visuals.StandardObjectProperties.formatString,
                },
            }
        };
        visuals.animatedNumberCapabilities = {
            objects: visuals.animatedTextObjectDescs,
            dataViewMappings: [{
                    single: { role: "Values" }
                }],
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.basicShapeCapabilities = {
            objects: {
                line: {
                    displayName: createDisplayNameGetter('Visual_BasicShape_Line'),
                    properties: {
                        lineColor: {
                            displayName: createDisplayNameGetter('Visual_BasicShape_LineColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: StandardObjectProperties.transparency,
                        weight: {
                            displayName: createDisplayNameGetter('Visual_BasicShape_Weight'),
                            type: { numeric: true }
                        },
                        roundEdge: {
                            displayName: createDisplayNameGetter('Visual_BasicShape_RoundEdges'),
                            type: { numeric: true }
                        }
                    }
                },
                fill: {
                    displayName: createDisplayNameGetter('Visual_Fill'),
                    properties: {
                        show: StandardObjectProperties.show,
                        fillColor: {
                            displayName: createDisplayNameGetter('Visual_BasicShape_FillColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: StandardObjectProperties.transparency,
                    }
                },
                rotation: {
                    displayName: createDisplayNameGetter('Visual_BasicShape_Rotate'),
                    properties: {
                        angle: {
                            displayName: createDisplayNameGetter('Visual_BasicShape_Rotate'),
                            type: { numeric: true }
                        }
                    }
                },
                general: {
                    properties: {
                        shapeType: {
                            type: { text: true },
                            suppressFormatPainterCopy: true,
                        }
                    }
                }
            },
            suppressDefaultTitle: true,
            suppressDefaultPadding: true,
            canRotate: false,
            supportsSelection: false,
            supportsVisualLink: true
        };
        visuals.basicShapeProps = {
            general: {
                shapeType: { objectName: 'general', propertyName: 'shapeType' },
            },
            line: {
                transparency: { objectName: 'line', propertyName: 'transparency' },
                weight: { objectName: 'line', propertyName: 'weight' },
                roundEdge: { objectName: 'line', propertyName: 'roundEdge' },
                lineColor: { objectName: 'line', propertyName: 'lineColor' }
            },
            fill: {
                transparency: { objectName: 'fill', propertyName: 'transparency' },
                fillColor: { objectName: 'fill', propertyName: 'fillColor' },
                show: { objectName: 'fill', propertyName: 'show' }
            },
            rotation: {
                angle: { objectName: 'rotation', propertyName: 'angle' }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.columnRoleNames = {
            category: 'Category',
            series: 'Series',
            y: 'Y',
            gradient: 'Gradient',
            tooltips: 'Tooltips',
        };
        function getColumnChartCapabilities(transposeAxes, isStacked, isRibbonChart) {
            if (transposeAxes === void 0) { transposeAxes = false; }
            if (isStacked === void 0) { isStacked = false; }
            if (isRibbonChart === void 0) { isRibbonChart = false; }
            var capabilities = {
                dataRoles: getDataRoles(isRibbonChart),
                objects: {
                    // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                    general: {
                        displayName: createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: StandardObjectProperties.formatString,
                            responsive: StandardObjectProperties.responsive,
                            responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                        },
                    },
                    legend: visuals.StandardObjectDescriptors.legend,
                    categoryAxis: {
                        displayName: transposeAxes ? createDisplayNameGetter('Visual_YAxis') : createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            position: StandardObjectProperties.yAxisPosition,
                            axisScale: StandardObjectProperties.axisScale,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            axisType: StandardObjectProperties.axisType,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: transposeAxes ? createDisplayNameGetter('Visual_Axis_YTitleDescription') : createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            concatenateLabels: {
                                displayName: createDisplayNameGetter('Visual_Axis_ConcatenateLabels'),
                                description: createDisplayNameGetter('Visual_Axis_ConcatenateLabelsDescription'),
                                type: { bool: true }
                            },
                            preferredCategoryWidth: {
                                displayName: createDisplayNameGetter('Visual_Category_Width'),
                                type: { numeric: true },
                            },
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                        }
                    },
                    valueAxis: {
                        displayName: transposeAxes ? createDisplayNameGetter('Visual_XAxis') : createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            position: StandardObjectProperties.yAxisPosition,
                            axisScale: StandardObjectProperties.axisScale,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: transposeAxes ? createDisplayNameGetter('Visual_Axis_YTitleDescription') : createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                        }
                    },
                    dataPoint: {
                        displayName: createDisplayNameGetter('Visual_DataPoint'),
                        description: createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            defaultColor: StandardObjectProperties.defaultColor,
                            defaultCategoryColor: StandardObjectProperties.defaultCategoryColor,
                            showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                            fill: StandardObjectProperties.fill,
                            fillRule: {
                                displayName: createDisplayNameGetter('Visual_Gradient'),
                                type: { fillRule: {} },
                                rule: {
                                    inputRole: 'Gradient',
                                    output: {
                                        property: 'fill',
                                        selector: ['Category'],
                                    },
                                },
                            }
                        }
                    },
                    labels: {
                        displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                        description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                        properties: {
                            show: StandardObjectProperties.show,
                            // showSeries determines if a single series is shown.
                            showSeries: {
                                displayName: createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            color: StandardObjectProperties.dataColor,
                            labelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: __assign({}, StandardObjectProperties.labelPrecision, { suppressFormatPainterCopy: true }),
                            labelOrientation: {
                                displayName: createDisplayNameGetter('Visual_LabelOrientation'),
                                type: { enumeration: visuals.labelOrientation.type },
                            },
                            labelPosition: {
                                displayName: createDisplayNameGetter('Visual_Position'),
                                type: { enumeration: visuals.labelPosition.type },
                            },
                            // showAll determines if the options for series' labels are shown.
                            showAll: {
                                displayName: createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                                type: { bool: true }
                            },
                            fontSize: StandardObjectProperties.fontSize,
                            fontFamily: StandardObjectProperties.fontFamily,
                            labelDensity: {
                                displayName: createDisplayNameGetter('Visual_LabelDensity'),
                                type: { formatting: { labelDensity: true } },
                            },
                        },
                    },
                    plotArea: {
                        displayName: createDisplayNameGetter('Visual_Plot'),
                        properties: {
                            transparency: StandardObjectProperties.transparency,
                            image: StandardObjectProperties.image,
                        },
                    },
                    y1AxisReferenceLine: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                        suppressFormatPainterCopy: true,
                        properties: {
                            show: StandardObjectProperties.show,
                            displayName: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                                description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                                type: { text: true }
                            },
                            value: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                                description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                                type: { numeric: true }
                            },
                            lineColor: StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                                description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: StandardObjectProperties.lineStyle,
                            position: StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: StandardObjectProperties.dataLabelShow,
                            dataLabelText: StandardObjectProperties.dataLabelText,
                            dataLabelColor: StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                        },
                    },
                    trend: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line'),
                        suppressFormatPainterCopy: true,
                        properties: {
                            show: {
                                type: { bool: true }
                            },
                            displayName: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_DisplayName'),
                                description: createDisplayNameGetter('Visual_Trend_Line_DisplayName_Description'),
                                type: { text: true }
                            },
                            lineColor: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Color'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                                type: { fill: { solid: { color: true } } }
                            },
                            transparency: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Style'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                                type: { enumeration: visuals.lineStyle.type }
                            },
                            combineSeries: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                                type: { bool: true }
                            },
                            useHighlightValues: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
                                description: createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
                                type: { bool: true }
                            },
                        }
                    },
                    filters: {
                        properties: {
                            filteredToUniqueValue: {
                                type: { bool: true }
                            },
                        }
                    },
                },
                dataViewMappings: [{
                        conditions: [
                            { 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                            { 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { window: { count: 200 } }
                            },
                            values: {
                                group: {
                                    by: 'Series',
                                    select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }, { for: { in: 'Tooltips' } }],
                                    dataReductionAlgorithm: { top: { count: 60 } }
                                }
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        },
                    }, {
                        conditions: [
                            { 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                            { 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
                        ],
                        requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                        usage: {
                            regression: {
                                combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                            },
                        },
                        categorical: {
                            categories: {
                                for: { in: 'regression.X' },
                            },
                            values: {
                                group: {
                                    by: 'regression.Series',
                                    select: [{ for: { in: 'regression.Y' } }],
                                },
                            }
                        }
                    }],
                supportsHighlight: true,
                sorting: {
                    default: {},
                },
                drilldown: {
                    roles: ['Category']
                },
                grouping: {
                    groupingRules: [
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            groupingTargetRole: 'Series',
                            kind: 0 /* Color */,
                        },
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            groupingTargetRole: 'Category',
                            kind: 1 /* GroupInPlace */,
                        },
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 0, max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 1 } },
                            groupingTargetRole: 'Category',
                            kind: 1 /* GroupInPlace */,
                        },
                        {
                            condition: { 'Category': { max: 0 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 1 }, 'Gradient': { max: 0 } },
                            groupingTargetRole: 'Series',
                            kind: 0 /* Color */,
                        }
                    ]
                }
            };
            if (!isStacked) {
                capabilities.objects['referenceLine'] = {
                    displayName: createDisplayNameGetter('Visual_Reference_Line'),
                    description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                    suppressFormatPainterCopy: true,
                    properties: {
                        show: StandardObjectProperties.show,
                        displayName: {
                            displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                            description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                            type: { text: true }
                        },
                        value: {
                            displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: StandardObjectProperties.lineColor,
                        transparency: {
                            displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: StandardObjectProperties.lineStyle,
                        position: StandardObjectProperties.referenceLinePosition,
                        dataLabelShow: StandardObjectProperties.dataLabelShow,
                        dataLabelText: StandardObjectProperties.dataLabelText,
                        dataLabelColor: StandardObjectProperties.dataLabelColor,
                        dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                        dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                        dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                        dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                    },
                };
            }
            if (isRibbonChart) {
                capabilities.objects['ribbonChart'] = {
                    displayName: createDisplayNameGetter('RibbonChart'),
                    description: createDisplayNameGetter('RibbonChart_Description'),
                    properties: {
                        colorBands: {
                            displayName: createDisplayNameGetter('RibbonChart_Color'),
                            description: createDisplayNameGetter('RibbonChart_ColorDescription'),
                            type: { bool: true }
                        },
                        showBorder: {
                            displayName: createDisplayNameGetter('Visual_Border'),
                            description: createDisplayNameGetter('RibbonChart_BorderDescription'),
                            type: { bool: true }
                        },
                        seriesGapRatio: {
                            displayName: createDisplayNameGetter('RibbonChart_SeriesGapWidth'),
                            description: createDisplayNameGetter('RibbonChart_SeriesGapWidthDescription'),
                            type: { integer: true }
                        },
                        bandsTransparency: {
                            displayName: createDisplayNameGetter('Visual_Background_Transparency'),
                            description: createDisplayNameGetter('RibbonChart_ColorTransparencyDescription'),
                            type: { integer: true }
                        },
                    },
                };
            }
            return capabilities;
        }
        visuals.getColumnChartCapabilities = getColumnChartCapabilities;
        function getDataRoles(isRibbonChart) {
            var dataRoles = [
                {
                    name: visuals.columnRoleNames.category,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: createDisplayNameGetter('Role_DisplayName_AxisDescription'),
                    cartesianKind: 0 /* X */,
                }, {
                    name: visuals.columnRoleNames.series,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: visuals.columnRoleNames.y,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Value'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                }, {
                    name: visuals.columnRoleNames.gradient,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    joinPredicate: 0 /* None */,
                }, {
                    name: visuals.columnRoleNames.tooltips,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ];
            if (isRibbonChart)
                dataRoles.splice(3, 1);
            return dataRoles;
        }
        visuals.columnChartProps = {
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                defaultCategoryColor: { objectName: 'dataPoint', propertyName: 'defaultCategoryColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
                showBorder: { objectName: 'ribbonChart', propertyName: 'showBorder' },
            },
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
            ribbonChart: {
                colorBands: { objectName: 'ribbonChart', propertyName: 'colorBands' },
                bandsTransparency: { objectName: 'ribbonChart', propertyName: 'bandsTransparency' },
            },
            series: {
                seriesGapRatio: { objectName: 'ribbonChart', propertyName: 'seriesGapRatio' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        function getComboChartCapabilities(isStacked) {
            var capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_ComboChart_Category'),
                        description: createDisplayNameGetter('Role_ComboChart_CategoryDescription'),
                        cartesianKind: 0 /* X */,
                    }, {
                        name: 'Series',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_ComboChart_Series'),
                    }, {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_ComboChart_Y'),
                        description: createDisplayNameGetter('Role_ComboChart_YDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        cartesianKind: 1 /* Y */,
                    }, {
                        name: 'Y2',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_ComboChart_Y2'),
                        description: createDisplayNameGetter('Role_ComboChart_Y2Description'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        cartesianKind: 1 /* Y */,
                    }, {
                        name: 'Tooltips',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                        joinPredicate: 0 /* None */,
                    }
                ],
                objects: {
                    general: {
                        displayName: createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: StandardObjectProperties.formatString,
                            visualType1: {
                                type: { text: true }
                            },
                            visualType2: {
                                type: { text: true }
                            },
                            responsive: StandardObjectProperties.responsive,
                            responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                        },
                    },
                    legend: visuals.StandardObjectDescriptors.legend,
                    categoryAxis: {
                        displayName: createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            axisScale: StandardObjectProperties.axisScale,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            axisType: StandardObjectProperties.axisType,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            concatenateLabels: {
                                displayName: createDisplayNameGetter('Visual_Axis_ConcatenateLabels'),
                                description: createDisplayNameGetter('Visual_Axis_ConcatenateLabelsDescription'),
                                type: { bool: true }
                            },
                            preferredCategoryWidth: {
                                displayName: createDisplayNameGetter('Visual_Category_Width'),
                                type: { numeric: true },
                            },
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                        }
                    },
                    valueAxis: {
                        displayName: createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            axisLabel: {
                                displayName: createDisplayNameGetter('Visual_YAxis_ColumnTitle'),
                                type: { none: true },
                            },
                            position: StandardObjectProperties.yAxisPosition,
                            axisScale: StandardObjectProperties.axisScale,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                            secShow: {
                                displayName: createDisplayNameGetter('Visual_YAxis_ShowSecondary'),
                                type: { bool: true },
                            },
                            alignZeros: {
                                displayName: createDisplayNameGetter('Visual_YAxis_AlignZeros'),
                                description: createDisplayNameGetter('Visual_YAxis_AlignZeros_Description'),
                                type: { bool: true },
                            },
                            secAxisLabel: {
                                displayName: createDisplayNameGetter('Visual_YAxis_LineTitle'),
                                type: { none: true },
                            },
                            secPosition: StandardObjectProperties.yAxisPosition,
                            secAxisScale: StandardObjectProperties.axisScale,
                            secStart: {
                                displayName: createDisplayNameGetter('Visual_Axis_Start'),
                                description: createDisplayNameGetter('Visual_Axis_StartDescription'),
                                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                                type: { numeric: true },
                                suppressFormatPainterCopy: true,
                            },
                            secEnd: {
                                displayName: createDisplayNameGetter('Visual_Axis_End'),
                                description: createDisplayNameGetter('Visual_Axis_EndDescription'),
                                placeHolderText: createDisplayNameGetter('Visual_Auto'),
                                type: { numeric: true },
                                suppressFormatPainterCopy: true,
                            },
                            secShowAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                                type: { bool: true },
                            },
                            secAxisStyle: StandardObjectProperties.axisStyle,
                            secLabelColor: StandardObjectProperties.labelColor,
                            secFontFamily: StandardObjectProperties.fontFamily,
                            secFontSize: StandardObjectProperties.fontSize,
                            secLabelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            secLabelPrecision: StandardObjectProperties.labelPrecision,
                            secTitleColor: StandardObjectProperties.titleColor,
                            secTitleFontFamily: StandardObjectProperties.fontFamily,
                            secTitleFontSize: StandardObjectProperties.titleFontSize,
                            secTitleText: StandardObjectProperties.titleText,
                        }
                    },
                    dataPoint: {
                        displayName: createDisplayNameGetter('Visual_DataPoint'),
                        description: createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            defaultColor: __assign({}, StandardObjectProperties.defaultColor, { displayName: createDisplayNameGetter('Visual_DefaultColumnColor') }),
                            defaultCategoryColor: __assign({}, StandardObjectProperties.defaultCategoryColor, { displayName: createDisplayNameGetter('Visual_DefaultColumnColor') }),
                            showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                            fill: StandardObjectProperties.fill,
                            fillRule: {
                                displayName: createDisplayNameGetter('Visual_Gradient'),
                                type: { fillRule: {} },
                                rule: {
                                    inputRole: 'Gradient',
                                    output: {
                                        property: 'fill',
                                        selector: ['Category'],
                                    },
                                },
                            }
                        }
                    },
                    labels: {
                        displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                        description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                        properties: {
                            show: StandardObjectProperties.show,
                            color: StandardObjectProperties.dataColor,
                            labelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: __assign({}, StandardObjectProperties.labelPrecision, { suppressFormatPainterCopy: true }),
                            labelOrientation: {
                                displayName: createDisplayNameGetter('Visual_LabelOrientation'),
                                type: { enumeration: visuals.labelOrientation.type },
                            },
                            labelPosition: {
                                displayName: createDisplayNameGetter('Visual_Position'),
                                type: { enumeration: visuals.labelPosition.type },
                            },
                            fontSize: StandardObjectProperties.fontSize,
                            fontFamily: StandardObjectProperties.fontFamily,
                            labelDensity: {
                                displayName: createDisplayNameGetter('Visual_LabelDensity'),
                                type: { formatting: { labelDensity: true } },
                            },
                        },
                    },
                    lineStyles: {
                        displayName: createDisplayNameGetter('Visual_Shapes'),
                        description: createDisplayNameGetter('Visual_ShapesDescription'),
                        properties: {
                            shadeArea: {
                                displayName: createDisplayNameGetter('Visual_Shapes_ShadeArea'),
                                type: { bool: true },
                            },
                            strokeWidth: StandardObjectProperties.strokeWidth,
                            strokeLineJoin: StandardObjectProperties.strokeLineJoin,
                            showMarker: StandardObjectProperties.showMarker,
                            markerShape: StandardObjectProperties.markerShape,
                            markerSize: StandardObjectProperties.markerSize,
                            markerColor: StandardObjectProperties.markerColor,
                            showSeries: {
                                displayName: createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                                type: { bool: true }
                            },
                        },
                    },
                    plotArea: {
                        displayName: createDisplayNameGetter('Visual_Plot'),
                        properties: {
                            transparency: StandardObjectProperties.transparency,
                            image: StandardObjectProperties.image,
                        },
                    },
                    filters: {
                        properties: {
                            filteredToUniqueValue: {
                                type: { bool: true }
                            },
                        }
                    },
                },
                dataViewMappings: [
                    {
                        conditions: [
                            { 'Series': { max: 0 } },
                            { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { window: { count: 200 } }
                            },
                            values: {
                                group: {
                                    by: 'Series',
                                    select: [
                                        { for: { in: 'Y' } },
                                        { for: { in: 'Tooltips' } }
                                    ],
                                    dataReductionAlgorithm: { top: { count: 60 } }
                                }
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        }
                    }, {
                        conditions: [
                            { 'Series': { max: 0 }, 'Y2': { min: 1 } },
                            { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Y2': { min: 1 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { window: { count: 200 } }
                            },
                            values: {
                                select: [
                                    { for: { in: 'Y2' } }
                                ],
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        },
                    }, {
                        conditions: [
                            { 'Series': { max: 0 } },
                            { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                        ],
                        requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                        usage: {
                            regression: {
                                combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                            },
                        },
                        categorical: {
                            categories: {
                                for: { in: 'regression.X' }
                            },
                            values: {
                                group: {
                                    by: 'regression.Series',
                                    select: [{ for: { in: 'regression.Y' } }],
                                },
                            },
                        }
                    },
                ],
                supportsHighlight: true,
                sorting: {
                    default: {},
                },
                drilldown: {
                    roles: ['Category']
                },
                grouping: {
                    groupingRules: [
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            groupingTargetRole: 'Series',
                            kind: 0 /* Color */,
                        },
                        {
                            condition: { 'Category': { max: 0 }, 'Y': { min: 1, max: 1 }, 'Series': { min: 1, max: 1 }, 'Gradient': { max: 0 } },
                            groupingTargetRole: 'Series',
                            kind: 0 /* Color */,
                        }
                    ]
                }
            };
            if (!isStacked) {
                capabilities.objects['trend'] = {
                    displayName: createDisplayNameGetter('Visual_Trend_Line'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        displayName: {
                            type: { text: true }
                        },
                        lineColor: {
                            displayName: createDisplayNameGetter('Visual_Trend_Line_Color'),
                            description: createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                            description: createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: createDisplayNameGetter('Visual_Trend_Line_Style'),
                            description: createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        combineSeries: {
                            displayName: createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                            description: createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                            type: { bool: true }
                        },
                        useHighlightValues: {
                            displayName: createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
                            description: createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
                            type: { bool: true }
                        },
                    }
                };
            }
            return capabilities;
        }
        visuals.getComboChartCapabilities = getComboChartCapabilities;
        visuals.comboChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            valueAxis: {
                secShow: { objectName: 'valueAxis', propertyName: 'secShow' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            dataPoint: {
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.donutChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Details'),
                    description: createDisplayNameGetter('Role_DisplayName_DetailsDonutChartDescription'),
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                    description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Tooltips',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                legend: visuals.StandardObjectDescriptors.legend,
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: StandardObjectProperties.defaultColor,
                        fill: StandardObjectProperties.fill,
                    }
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DetailLabels'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: __assign({}, StandardObjectProperties.labelPrecision, { suppressFormatPainterCopy: true }),
                        percentageLabelPrecision: __assign({}, StandardObjectProperties.percentageLabelPrecision, { suppressFormatPainterCopy: true }),
                        fontSize: __assign({}, StandardObjectProperties.fontSize, { suppressFormatPainterCopy: true }),
                        fontFamily: StandardObjectProperties.fontFamily,
                        labelStyle: {
                            displayName: createDisplayNameGetter('Visual_LabelStyle'),
                            type: { enumeration: visuals.labelStyle.type }
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ bind: { to: 'Y' } }, { for: { in: 'Tooltips' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
                    },
                }],
            sorting: {
                default: {},
            },
            supportsHighlight: true,
            drilldown: {
                roles: ['Category']
            },
            grouping: {
                groupingRules: [
                    {
                        condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 0 } },
                        groupingTargetRole: 'Category',
                        groupSourceTargetRole: 'Series',
                        kind: 0 /* Color */,
                    },
                    {
                        condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 1 }, 'Series': { max: 0 } },
                        groupingTargetRole: 'Category',
                        kind: 1 /* GroupInPlace */,
                    },
                    {
                        condition: { 'Category': { max: 0 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 1 } },
                        groupingTargetRole: 'Series',
                        kind: 0 /* Color */,
                    }
                ]
            }
        };
        visuals.donutChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        // I support a categorical (ordinal) X with measure Y for a single series
        visuals.dataDotChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: createDisplayNameGetter('Role_DisplayName_AxisDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Value'),
                    requiredTypes: [{ numeric: true }, { integer: true }]
                },
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                        responsive: StandardObjectProperties.responsive,
                        responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{
                                    for: { in: 'Y' },
                                }]
                        },
                    },
                }]
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.filledMapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Location'),
                    description: createDisplayNameGetter('Role_DisplayName_LocationFilledMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Latitude'),
                    description: createDisplayNameGetter('Role_DisplayName_LatitudeFilledMapDescription'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Longitude'),
                    description: createDisplayNameGetter('Role_DisplayName_LongitudeFilledMapDescription'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ],
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Tooltips',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                legend: visuals.StandardObjectDescriptors.legend,
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: StandardObjectProperties.defaultColor,
                        defaultCategoryColor: StandardObjectProperties.defaultCategoryColor,
                        showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                        fill: StandardObjectProperties.fill,
                        fillRule: {
                            displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                            description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                            type: { fillRule: {} },
                            rule: {
                                conditions: [{ 'Series': { max: 0 } }],
                                inputRole: 'Size',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                    },
                },
                categoryLabels: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                    properties: {
                        show: StandardObjectProperties.show,
                    },
                },
                mapControls: {
                    displayName: createDisplayNameGetter('Visual_MapControls'),
                    description: createDisplayNameGetter('Visual_MapControlsDescription'),
                    properties: {
                        autoZoom: {
                            displayName: createDisplayNameGetter('Visual_AutoZoom'),
                            type: { bool: true },
                        },
                        zoomLevel: {
                            type: { numeric: true },
                        },
                        centerLatitude: {
                            type: { numeric: true },
                        },
                        centerLongitude: {
                            type: { numeric: true },
                        },
                    },
                },
                mapStyles: {
                    displayName: createDisplayNameGetter('Visual_MapStyles'),
                    description: createDisplayNameGetter('Visual_MapStylesDescription'),
                    properties: {
                        mapTheme: {
                            displayName: createDisplayNameGetter('Visual_MapTheme'),
                            type: { enumeration: visuals.BingMapTheme.type },
                        },
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': {}, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { min: 1, max: 1 } },
                        { 'Category': {}, 'Series': { max: 1 }, 'X': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } },
                        { 'Category': {}, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { min: 1, max: 1 }, 'Size': { max: 1 } },
                        { 'Category': {}, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Tooltips': { min: 1 } },
                        { 'Category': {}, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                    { for: { in: 'Tooltips' } }
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataVolume: 4,
                    },
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1, min: 1 }, 'X': { max: 0 }, 'Y': { max: 0 }, 'Size': { max: 0 }, 'Tooltips': { max: 0 } }
                    ],
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Series' } },
                                {
                                    composite: [
                                        { for: { in: 'Category' } },
                                    ],
                                },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        },
                        dataVolume: 4,
                    }
                }],
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Size', direction: 2 /* Descending */ }]
                },
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.filledMapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
            },
            mapControls: {
                autoZoom: { objectName: 'mapControls', propertyName: 'autoZoom' },
                zoomLevel: { objectName: 'mapControls', propertyName: 'zoomLevel' },
                centerLatitude: { objectName: 'mapControls', propertyName: 'centerLatitude' },
                centerLongitude: { objectName: 'mapControls', propertyName: 'centerLongitude' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.funnelChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Group'),
                    description: createDisplayNameGetter('Role_DisplayName_GroupFunnelDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                    description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    joinPredicate: 0 /* None */,
                }, {
                    name: 'Tooltips',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            dataViewMappings: [{
                    conditions: [
                        // NOTE: Ordering of the roles prefers to add measures to Y before Gradient.
                        { 'Category': { max: 0 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }, { for: { in: 'Tooltips' } }],
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            objects: {
                // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                categoryAxis: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                    description: createDisplayNameGetter('Visual_CategoryLabelOptionsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: StandardObjectProperties.defaultColor,
                        defaultCategoryColor: StandardObjectProperties.defaultCategoryColor,
                        showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                        fill: StandardObjectProperties.fill,
                        fillRule: {
                            displayName: createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelPosition: {
                            displayName: createDisplayNameGetter('Visual_Position'),
                            type: { enumeration: visuals.labelPosition.type },
                            suppressFormatPainterCopy: true,
                        },
                        labelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: __assign({}, StandardObjectProperties.labelPrecision, { suppressFormatPainterCopy: true }),
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                percentBarLabel: {
                    displayName: createDisplayNameGetter('Visual_PercentBarLabel'),
                    description: createDisplayNameGetter('Visual_PercentBarLabelDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
            },
            supportsHighlight: true,
            sorting: {
                default: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.funnelChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.gaugeRoleNames = {
            y: 'Y',
            minValue: 'MinValue',
            maxValue: 'MaxValue',
            targetValue: 'TargetValue'
        };
        visuals.gaugeCapabilities = {
            dataRoles: [
                {
                    name: visuals.gaugeRoleNames.y,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Value'),
                    description: createDisplayNameGetter('Role_DisplayName_ValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.minValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_MinValue'),
                    description: createDisplayNameGetter('Role_DisplayName_MinValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.maxValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_MaxValue'),
                    description: createDisplayNameGetter('Role_DisplayName_MaxValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.targetValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_TargetValue'),
                    description: createDisplayNameGetter('Role_DisplayName_TargetValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Tooltips',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            objects: {
                // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                general: {
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                axis: {
                    displayName: createDisplayNameGetter('Visual_Gauge_Axis'),
                    properties: {
                        min: {
                            displayName: createDisplayNameGetter('Visual_Gauge_Axis_Min'),
                            type: { numeric: true }
                        },
                        max: {
                            displayName: createDisplayNameGetter('Visual_Gauge_Axis_Max'),
                            type: { numeric: true }
                        },
                        target: {
                            displayName: createDisplayNameGetter('Visual_Gauge_Axis_Target'),
                            type: { numeric: true }
                        },
                    },
                },
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        fill: StandardObjectProperties.fill,
                        target: {
                            // TODO find a better string
                            displayName: createDisplayNameGetter('Visual_Gauge_Axis_Target'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    },
                },
                target: {
                    displayName: createDisplayNameGetter("Visual_Gauge_Axis_Target"),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                calloutValue: {
                    displayName: createDisplayNameGetter('Visual_Gauge_CalloutValue'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Y': { max: 1 }, 'MinValue': { max: 1 }, 'MaxValue': { max: 1 }, 'TargetValue': { max: 1 } },
                    ],
                    categorical: {
                        values: {
                            select: [
                                { bind: { to: 'Y' } },
                                { bind: { to: 'MinValue' } },
                                { bind: { to: 'MaxValue' } },
                                { bind: { to: 'TargetValue' } },
                                { for: { in: 'Tooltips' } }
                            ]
                        },
                    },
                }],
            supportsSelection: false,
        };
        visuals.gaugeProps = {
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                target: { objectName: 'dataPoint', propertyName: 'target' }
            },
            target: {
                show: { objectName: 'target', propertyName: 'show' },
                labelDisplayUnits: { objectName: 'target', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'target', propertyName: 'labelPrecision' },
                fontSize: { objectName: 'target', propertyName: 'fontSize' },
                fontFamily: { objectName: 'target', propertyName: 'fontFamily' },
                color: { objectName: 'target', propertyName: 'color' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                fontFamily: { objectName: 'labels', propertyName: 'fontFamily' },
                color: { objectName: 'labels', propertyName: 'color' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        visuals.imageVisualCapabilities = {
            objects: {
                general: {
                    properties: {
                        imageUrl: {
                            type: { misc: { imageUrl: true } },
                            suppressFormatPainterCopy: true,
                        }
                    }
                },
                imageScaling: {
                    displayName: createDisplayNameGetter('Visual_Image_Scaling_Type'),
                    properties: {
                        imageScalingType: {
                            displayName: createDisplayNameGetter('Visual_Image_Scaling_Type'),
                            type: { enumeration: visuals.imageScalingType.type }
                        },
                    }
                },
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            supportsVisualLink: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.realTimeLineChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: createDisplayNameGetter('Role_DisplayName_AxisDescription'),
                    requiredTypes: [{ numeric: true }, { dateTime: true }],
                    cartesianKind: 0 /* X */,
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                    description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                },
            ],
            objects: {
                // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                        responsive: StandardObjectProperties.responsive,
                        responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                    },
                },
                legend: {
                    displayName: createDisplayNameGetter('Visual_Legend'),
                    description: createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        position: StandardObjectProperties.legendPosition,
                        showTitle: StandardObjectProperties.showLegendTitle,
                        titleText: __assign({}, StandardObjectProperties.legendTitle, { suppressFormatPainterCopy: true }),
                        labelColor: StandardObjectProperties.labelColor,
                        fontSize: StandardObjectProperties.fontSize,
                    }
                },
                categoryAxis: {
                    displayName: createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: StandardObjectProperties.show,
                        axisType: StandardObjectProperties.axisType,
                        showAxisTitle: {
                            displayName: createDisplayNameGetter('Visual_Axis_Title'),
                            description: createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: StandardObjectProperties.axisStyle,
                        labelColor: StandardObjectProperties.labelColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                        duration: {
                            type: { numeric: true }
                        }
                    }
                },
                valueAxis: {
                    displayName: createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: StandardObjectProperties.show,
                        position: StandardObjectProperties.yAxisPosition,
                        showAxisTitle: {
                            displayName: createDisplayNameGetter('Visual_Axis_Title'),
                            description: createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: StandardObjectProperties.axisStyle,
                        labelColor: StandardObjectProperties.labelColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                    }
                },
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: StandardObjectProperties.defaultColor,
                        fill: StandardObjectProperties.fill,
                    }
                },
                plotArea: {
                    displayName: createDisplayNameGetter('Visual_Plot'),
                    properties: {
                        transparency: StandardObjectProperties.transparency,
                        image: StandardObjectProperties.image,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ for: { in: 'Y' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                    },
                }],
            sorting: {
                implicit: {
                    clauses: [{ role: 'Category', direction: 1 /* Ascending */ }]
                },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.scriptVisualCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                }],
            dataViewMappings: [{
                    scriptResult: {
                        dataInput: {
                            table: {
                                rows: {
                                    for: {
                                        in: 'Values'
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                            },
                        },
                        script: {
                            source: {
                                objectName: 'script',
                                propertyName: 'source'
                            },
                            provider: {
                                objectName: 'script',
                                propertyName: 'provider'
                            },
                        }
                    }
                }],
            objects: {
                script: {
                    properties: {
                        provider: {
                            type: { text: true }
                        },
                        source: {
                            type: { scripting: { source: true }
                            }
                        },
                    }
                },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
            samples.consoleWriterCapabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Axis'),
                        description: createDisplayNameGetter('Role_DisplayName_AxisDescription')
                    },
                    {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Y'),
                        description: createDisplayNameGetter('Role_DisplayName_YDescription')
                    },
                ],
                dataViewMappings: [{
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                        },
                    }],
            };
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ConsoleWriter = /** @class */ (function () {
                function ConsoleWriter() {
                }
                ConsoleWriter.converter = function (dataView) {
                    window.console.log('converter');
                    window.console.log(dataView);
                    return {};
                };
                ConsoleWriter.prototype.init = function (options) {
                    var div = d3.select(options.element.get(0)).append("div");
                    div.append("h1").text("ConsoleWriter");
                    div.append("p").text("This IVisual writes messages passed to it to the javscript console output. Check your console for the actual messages passed. For more information, click below");
                    var anchor = div.append('a');
                    anchor.attr('href', "https://microsoft.github.io/PowerBI-visuals/modules/powerbi.html")
                        .text("Online help");
                    window.console.log('init');
                    window.console.log(options);
                };
                ConsoleWriter.prototype.onResizing = function (viewport) { };
                ConsoleWriter.prototype.update = function (options) {
                    window.console.log('update');
                    window.console.log(options);
                };
                return ConsoleWriter;
            }());
            samples.ConsoleWriter = ConsoleWriter;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.cartesianRoleNames = {
            category: 'Category',
            series: 'Series',
            y: 'Y',
            gradient: 'Gradient',
            tooltips: 'Tooltips',
        };
        visuals.cartesianChartProps = {
            scalarKey: {
                scalarKeyMin: powerbi.data.scalarKeyMinPropertyIdentifier,
            },
            filters: {
                filteredToUniqueValue: { objectName: 'filters', propertyName: 'filteredToUniqueValue' }
            },
            categoryAxis: {
                show: { objectName: 'categoryAxis', propertyName: 'show' },
                fontFamily: { objectName: 'categoryAxis', propertyName: 'fontFamily' },
                fontSize: { objectName: 'categoryAxis', propertyName: 'fontSize' },
                showAxisTitle: { objectName: 'categoryAxis', propertyName: 'showAxisTitle' },
                titleFontFamily: { objectName: 'categoryAxis', propertyName: 'titleFontFamily' },
                titleFontSize: { objectName: 'categoryAxis', propertyName: 'titleFontSize' },
                concatenateLabels: { objectName: 'categoryAxis', propertyName: 'concatenateLabels' },
                start: { objectName: 'categoryAxis', propertyName: 'start' },
                end: { objectName: 'categoryAxis', propertyName: 'end' },
                position: { objectName: 'categoryAxis', propertyName: 'position' },
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
                axisScale: { objectName: 'categoryAxis', propertyName: 'axisScale' },
                axisStyle: { objectName: 'categoryAxis', propertyName: 'axisStyle' },
                labelDisplayUnits: { objectName: 'categoryAxis', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'categoryAxis', propertyName: 'labelPrecision' },
                labelColor: { objectName: 'categoryAxis', propertyName: 'labelColor' },
                titleText: { objectName: 'categoryAxis', propertyName: 'titleText' },
                titleColor: { objectName: 'categoryAxis', propertyName: 'titleColor' },
                preferredCategoryWidth: { objectName: 'categoryAxis', propertyName: 'preferredCategoryWidth' },
                gridlineShow: { objectName: 'categoryAxis', propertyName: 'gridlineShow' },
                gridlineColor: { objectName: 'categoryAxis', propertyName: 'gridlineColor' },
                gridlineThickness: { objectName: 'categoryAxis', propertyName: 'gridlineThickness' },
                gridlineStyle: { objectName: 'categoryAxis', propertyName: 'gridlineStyle' },
            },
            valueAxis: {
                show: { objectName: 'valueAxis', propertyName: 'show' },
                fontFamily: { objectName: 'valueAxis', propertyName: 'fontFamily' },
                fontSize: { objectName: 'valueAxis', propertyName: 'fontSize' },
                showAxisTitle: { objectName: 'valueAxis', propertyName: 'showAxisTitle' },
                titleFontFamily: { objectName: 'valueAxis', propertyName: 'titleFontFamily' },
                titleFontSize: { objectName: 'valueAxis', propertyName: 'titleFontSize' },
                concatenateLabels: { objectName: 'valueAxis', propertyName: 'concatenateLabels' },
                start: { objectName: 'valueAxis', propertyName: 'start' },
                end: { objectName: 'valueAxis', propertyName: 'end' },
                position: { objectName: 'valueAxis', propertyName: 'position' },
                axisType: { objectName: 'valueAxis', propertyName: 'axisType' },
                axisScale: { objectName: 'valueAxis', propertyName: 'axisScale' },
                axisStyle: { objectName: 'valueAxis', propertyName: 'axisStyle' },
                labelDisplayUnits: { objectName: 'valueAxis', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'valueAxis', propertyName: 'labelPrecision' },
                labelColor: { objectName: 'valueAxis', propertyName: 'labelColor' },
                titleText: { objectName: 'valueAxis', propertyName: 'titleText' },
                titleColor: { objectName: 'valueAxis', propertyName: 'titleColor' },
                preferredCategoryWidth: { objectName: 'valueAxis', propertyName: 'preferredCategoryWidth' },
                axisLabel: { objectName: 'valueAxis', propertyName: 'axisLabel' },
                gridlineShow: { objectName: 'valueAxis', propertyName: 'gridlineShow' },
                gridlineColor: { objectName: 'valueAxis', propertyName: 'gridlineColor' },
                gridlineThickness: { objectName: 'valueAxis', propertyName: 'gridlineThickness' },
                gridlineStyle: { objectName: 'valueAxis', propertyName: 'gridlineStyle' },
                secShow: { objectName: 'valueAxis', propertyName: 'secShow' },
                alignZeros: { objectName: 'valueAxis', propertyName: 'alignZeros' },
                secShowAxisTitle: { objectName: 'valueAxis', propertyName: 'secShowAxisTitle' },
                secFontFamily: { objectName: 'valueAxis', propertyName: 'secFontFamily' },
                secFontSize: { objectName: 'valueAxis', propertyName: 'secFontSize' },
                secTitleFontFamily: { objectName: 'valueAxis', propertyName: 'secTitleFontFamily' },
                secTitleFontSize: { objectName: 'valueAxis', propertyName: 'secTitleFontSize' },
                secStart: { objectName: 'valueAxis', propertyName: 'secStart' },
                secEnd: { objectName: 'valueAxis', propertyName: 'secEnd' },
                secPosition: { objectName: 'valueAxis', propertyName: 'secPosition' },
                secAxisScale: { objectName: 'valueAxis', propertyName: 'secAxisScale' },
                secAxisStyle: { objectName: 'valueAxis', propertyName: 'secAxisStyle' },
                secLabelDisplayUnits: { objectName: 'valueAxis', propertyName: 'secLabelDisplayUnits' },
                secLabelPrecision: { objectName: 'valueAxis', propertyName: 'secLabelPrecision' },
                secLabelColor: { objectName: 'valueAxis', propertyName: 'secLabelColor' },
                secTitleText: { objectName: 'valueAxis', propertyName: 'secTitleText' },
                secTitleColor: { objectName: 'valueAxis', propertyName: 'secTitleColor' },
            },
            general: {
                responsive: { objectName: 'general', propertyName: 'responsive' },
                responsiveLegacy: { objectName: 'general', propertyName: 'responsiveLegacy' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        function getLineChartCapabilities(isStacked, isArea, binnedLineSampling) {
            debug.assert(!isStacked || isArea, 'Non-area stacked line is not supported');
            var lineChartCapabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Axis'),
                        description: createDisplayNameGetter('Role_DisplayName_AxisDescription'),
                        cartesianKind: 0 /* X */,
                    }, {
                        name: 'Series',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                        description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                    }, {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                        description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        cartesianKind: 1 /* Y */,
                    }, {
                        name: 'Tooltips',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                        joinPredicate: 0 /* None */,
                    }
                ],
                objects: {
                    // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                    general: {
                        displayName: createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: StandardObjectProperties.formatString,
                            responsive: StandardObjectProperties.responsive,
                            responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                        },
                    },
                    legend: {
                        displayName: visuals.StandardObjectDescriptors.legend.displayName,
                        description: visuals.StandardObjectDescriptors.legend.description,
                        properties: __assign({}, visuals.StandardObjectDescriptors.legend.properties, { legendMarkerRendering: {
                                displayName: createDisplayNameGetter('Visual_Axis_Style'),
                                description: createDisplayNameGetter('Visual_LegendStyleDescription'),
                                type: { enumeration: powerbi.visuals.legendMarkerRendering.type }
                            }, defaultToCircle: {
                                displayName: createDisplayNameGetter('Visual_LegendDefaultToCircle'),
                                description: createDisplayNameGetter('Visual_LegendDefaultToCircleDescription'),
                                type: { bool: true }
                            }, matchLineColor: {
                                displayName: createDisplayNameGetter('Visual_LegendMatchLineColor'),
                                description: createDisplayNameGetter('Visual_LegendMatchLineColorDescription'),
                                type: { bool: true }
                            } })
                    },
                    categoryAxis: {
                        displayName: createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            axisScale: StandardObjectProperties.axisScale,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            axisType: StandardObjectProperties.axisType,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            concatenateLabels: {
                                displayName: createDisplayNameGetter('Visual_Axis_ConcatenateLabels'),
                                description: createDisplayNameGetter('Visual_Axis_ConcatenateLabelsDescription'),
                                type: { bool: true }
                            },
                            preferredCategoryWidth: {
                                displayName: createDisplayNameGetter('Visual_Category_Width'),
                                type: { numeric: true },
                            },
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                        }
                    },
                    valueAxis: {
                        displayName: createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            position: StandardObjectProperties.yAxisPosition,
                            axisScale: StandardObjectProperties.axisScale,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                        }
                    },
                    dataPoint: {
                        displayName: createDisplayNameGetter('Visual_DataPoint'),
                        description: createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            defaultColor: StandardObjectProperties.defaultColor,
                            fill: StandardObjectProperties.fill,
                        }
                    },
                    labels: {
                        displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                        description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                        properties: {
                            show: StandardObjectProperties.show,
                            showSeries: {
                                displayName: createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            color: StandardObjectProperties.dataColor,
                            labelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: __assign({}, StandardObjectProperties.labelPrecision, { suppressFormatPainterCopy: true }),
                            showAll: {
                                displayName: createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                                type: { bool: true }
                            },
                            fontSize: StandardObjectProperties.fontSize,
                            fontFamily: StandardObjectProperties.fontFamily,
                            labelDensity: {
                                displayName: createDisplayNameGetter('Visual_LabelDensity'),
                                type: { formatting: { labelDensity: true } },
                            },
                        },
                    },
                    lineStyles: {
                        displayName: createDisplayNameGetter('Visual_Shapes'),
                        description: createDisplayNameGetter('Visual_ShapesDescription'),
                        properties: {
                            strokeWidth: StandardObjectProperties.strokeWidth,
                            strokeLineJoin: StandardObjectProperties.strokeLineJoin,
                            lineStyle: StandardObjectProperties.lineStyle,
                            showMarker: StandardObjectProperties.showMarker,
                            markerShape: StandardObjectProperties.markerShape,
                            markerSize: StandardObjectProperties.markerSize,
                            markerColor: StandardObjectProperties.markerColor,
                            showSeries: {
                                displayName: createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                                type: { bool: true }
                            },
                        },
                    },
                    plotArea: {
                        displayName: createDisplayNameGetter('Visual_Plot'),
                        properties: {
                            transparency: StandardObjectProperties.transparency,
                            image: StandardObjectProperties.image,
                        },
                    },
                    trend: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line'),
                        suppressFormatPainterCopy: true,
                        properties: {
                            show: StandardObjectProperties.show,
                            displayName: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_DisplayName'),
                                description: createDisplayNameGetter('Visual_Trend_Line_DisplayName_Description'),
                                type: { text: true }
                            },
                            lineColor: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Color'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                                type: { fill: { solid: { color: true } } }
                            },
                            transparency: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Style'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                                type: { enumeration: visuals.lineStyle.type }
                            },
                            combineSeries: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                                description: createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                                type: { bool: true }
                            },
                            useHighlightValues: {
                                displayName: createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
                                description: createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
                                type: { bool: true }
                            },
                        }
                    },
                    scalarKey: {
                        // NOTE: This should match powerbi.data.scalarKeyMinPropertyIdentifier
                        properties: {
                            min: {
                                type: { dateTime: true }
                            },
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                        suppressFormatPainterCopy: true,
                        properties: {
                            show: StandardObjectProperties.show,
                            displayName: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                                description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                                type: { text: true }
                            },
                            value: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                                description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                                type: { numeric: true }
                            },
                            lineColor: StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                                description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: StandardObjectProperties.lineStyle,
                            position: StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: StandardObjectProperties.dataLabelShow,
                            dataLabelColor: StandardObjectProperties.dataLabelColor,
                            dataLabelText: StandardObjectProperties.dataLabelText,
                            dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                        },
                    },
                    filters: {
                        properties: {
                            filteredToUniqueValue: {
                                type: { bool: true }
                            },
                        }
                    },
                },
                dataViewMappings: [
                    getLineChartDataViewMapping(),
                    {
                        conditions: [
                            { 'Series': { max: 0 } },
                            { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                        ],
                        requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                        usage: {
                            regression: {
                                combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                            },
                        },
                        categorical: {
                            categories: {
                                for: { in: 'regression.X' },
                            },
                            values: {
                                group: {
                                    by: 'regression.Series',
                                    select: [{ for: { in: 'regression.Y' } }],
                                },
                            }
                        }
                    }, {
                        conditions: [
                            { 'Series': { max: 0 }, 'Y': { max: 1 } },
                        ],
                        requiredProperties: [{ objectName: 'forecast', propertyName: 'show' }],
                        usage: {
                            forecast: {},
                        },
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                            values: {
                                group: {
                                    by: 'Series',
                                    select: [{ for: { in: 'forecast.ForecastValue' } }, { for: { in: 'forecast.ConfidenceHighBound' } }, { for: { in: 'forecast.ConfidenceLowBound' } }],
                                },
                            }
                        }
                    }
                ],
                sorting: {
                    default: {},
                },
                drilldown: {
                    roles: ['Category']
                },
            };
            if (!isStacked) {
                lineChartCapabilities.objects['referenceLine'] = {
                    displayName: createDisplayNameGetter('Visual_Reference_Line'),
                    description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                    suppressFormatPainterCopy: true,
                    properties: {
                        show: StandardObjectProperties.show,
                        displayName: {
                            displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                            description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                            type: { text: true }
                        },
                        value: {
                            displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: StandardObjectProperties.lineColor,
                        transparency: {
                            displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: StandardObjectProperties.lineStyle,
                        position: StandardObjectProperties.referenceLinePosition,
                        dataLabelShow: StandardObjectProperties.dataLabelShow,
                        dataLabelColor: StandardObjectProperties.dataLabelColor,
                        dataLabelText: StandardObjectProperties.dataLabelText,
                        dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                        dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                        dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                        dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                    }
                };
            }
            if (!isStacked && !isArea) {
                lineChartCapabilities.objects['forecast'] = {
                    displayName: createDisplayNameGetter('Visual_Forecast'),
                    suppressFormatPainterCopy: true,
                    properties: {
                        show: StandardObjectProperties.show,
                        displayName: {
                            displayName: createDisplayNameGetter('Visual_Forecast_DisplayName'),
                            description: createDisplayNameGetter('Visual_Forecast_DisplayName_Description'),
                            type: { text: true }
                        },
                        confidenceBandStyle: {
                            displayName: createDisplayNameGetter('Visual_Forecast_Confidence_Band_Style'),
                            description: createDisplayNameGetter('Visual_Forecast_Confidence_Band_Style_Description'),
                            type: { enumeration: visuals.confidenceBandStyle.type }
                        },
                        lineColor: {
                            displayName: createDisplayNameGetter('Visual_Forecast_Line_Color'),
                            description: createDisplayNameGetter('Visual_Forecast_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: StandardObjectProperties.transparency,
                        style: StandardObjectProperties.lineStyle,
                        transform: {
                            type: { queryTransform: {} }
                        }
                    }
                };
            }
            function getLineChartDataViewMapping() {
                var mapping = {
                    conditions: [
                        { 'Series': { max: 0 } },
                        { 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ for: { in: 'Y' } }, { for: { in: 'Tooltips' } }],
                            }
                        },
                    },
                };
                if (binnedLineSampling && !isStacked) {
                    LineChartDataReduction.applyBinnedSampling(mapping);
                }
                else {
                    LineChartDataReduction.applyLegacySampling(mapping);
                }
                return mapping;
            }
            return lineChartCapabilities;
        }
        visuals.getLineChartCapabilities = getLineChartCapabilities;
        visuals.lineChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            trend: {
                show: { objectName: 'trend', propertyName: 'show' },
            },
            forecast: {
                show: { objectName: 'forecast', propertyName: 'show' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
                legendMarkerRendering: { objectName: 'legend', propertyName: 'legendMarkerRendering' },
                defaultToCircle: { objectName: 'legend', propertyName: 'defaultToCircle' },
                matchLineColor: { objectName: 'legend', propertyName: 'matchLineColor' },
            },
            labels: {
                labelDensity: { objectName: 'labels', propertyName: 'labelDensity' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
            lineStyles: {
                shadeArea: { objectName: 'lineStyles', propertyName: 'shadeArea' },
                strokeWidth: { objectName: 'lineStyles', propertyName: 'strokeWidth' },
                strokeLineJoin: { objectName: 'lineStyles', propertyName: 'strokeLineJoin' },
                lineStyle: { objectName: 'lineStyles', propertyName: 'lineStyle' },
                showMarker: { objectName: 'lineStyles', propertyName: 'showMarker' },
                markerShape: { objectName: 'lineStyles', propertyName: 'markerShape' },
                markerSize: { objectName: 'lineStyles', propertyName: 'markerSize' },
                markerColor: { objectName: 'lineStyles', propertyName: 'markerColor' },
                showSeries: { objectName: 'lineStyles', propertyName: 'showSeries' },
            },
        };
        var LineChartDataReduction;
        (function (LineChartDataReduction) {
            function applyLegacySampling(mapping) {
                debug.assertValue(mapping, 'mapping');
                var categorical = mapping.categorical;
                if (!categorical)
                    return;
                categorical.dataReductionAlgorithm = undefined;
                categorical.categories.dataReductionAlgorithm = { sample: {} };
                categorical.values.group.dataReductionAlgorithm = { top: {} };
            }
            LineChartDataReduction.applyLegacySampling = applyLegacySampling;
            function applyWindow(mapping) {
                debug.assertValue(mapping, 'mapping');
                var categorical = mapping.categorical;
                if (!categorical)
                    return;
                categorical.dataReductionAlgorithm = undefined;
                categorical.categories.dataReductionAlgorithm = { window: { count: 200 } };
                categorical.values.group.dataReductionAlgorithm = { top: { count: 60 } };
            }
            LineChartDataReduction.applyWindow = applyWindow;
            function applyBinnedSampling(mapping) {
                debug.assertValue(mapping, 'mapping');
                var categorical = mapping.categorical;
                if (!categorical)
                    return;
                categorical.dataReductionAlgorithm = { binnedLineSample: {} };
                categorical.categories.dataReductionAlgorithm = undefined;
                categorical.values.group.dataReductionAlgorithm = undefined;
            }
            LineChartDataReduction.applyBinnedSampling = applyBinnedSampling;
        })(LineChartDataReduction = visuals.LineChartDataReduction || (visuals.LineChartDataReduction = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.mapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Location'),
                    description: createDisplayNameGetter('Role_DisplayName_LocationMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Latitude'),
                    description: createDisplayNameGetter('Role_DisplayName_LatitudeMapDescription'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Longitude'),
                    description: createDisplayNameGetter('Role_DisplayName_LongitudeMapDescription'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ],
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Size'),
                    description: createDisplayNameGetter('Role_DisplayName_SizeDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    joinPredicate: 0 /* None */,
                }, {
                    name: 'Tooltips',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                legend: visuals.StandardObjectDescriptors.legend,
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: StandardObjectProperties.defaultColor,
                        defaultCategoryColor: StandardObjectProperties.defaultCategoryColor,
                        showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                        fill: StandardObjectProperties.fill,
                        fillRule: {
                            displayName: createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category', 'X', 'Y'],
                                },
                            },
                        }
                    }
                },
                categoryLabels: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                    description: createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    },
                },
                bubbles: {
                    displayName: createDisplayNameGetter('Visual_Bubbles'),
                    description: createDisplayNameGetter('Visual_BubblesDescription'),
                    properties: {
                        bubbleSize: {
                            displayName: createDisplayNameGetter('Visual_BubbleSize'),
                            type: { formatting: { bubbleSize: true } },
                        },
                    }
                },
                mapControls: {
                    displayName: createDisplayNameGetter('Visual_MapControls'),
                    description: createDisplayNameGetter('Visual_MapControlsDescription'),
                    properties: {
                        autoZoom: {
                            displayName: createDisplayNameGetter('Visual_AutoZoom'),
                            type: { bool: true },
                        },
                        zoomLevel: {
                            type: { numeric: true },
                        },
                        centerLatitude: {
                            type: { numeric: true },
                        },
                        centerLongitude: {
                            type: { numeric: true },
                        },
                    },
                },
                mapStyles: {
                    displayName: createDisplayNameGetter('Visual_MapStyles'),
                    description: createDisplayNameGetter('Visual_MapStylesDescription'),
                    properties: {
                        mapTheme: {
                            displayName: createDisplayNameGetter('Visual_MapTheme'),
                            type: { enumeration: visuals.BingMapTheme.type },
                        },
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { min: 1, }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1, min: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { min: 1, }, 'Series': { max: 1 }, 'X': { max: 1, min: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { min: 1, }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, min: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { min: 1, }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Tooltips': { min: 1 } },
                        { 'Category': { min: 1, }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                    { for: { in: 'Tooltips' } }
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataVolume: 4,
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 0 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1, min: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 0 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Tooltips': { min: 1 } },
                        { 'Category': { max: 0 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                    { for: { in: 'Tooltips' } }
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataVolume: 4,
                    },
                }, {
                    conditions: [
                        { 'Category': { max: 1, min: 1 }, 'Series': { max: 1, min: 1 }, 'X': { max: 0 }, 'Y': { max: 0 }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Tooltips': { max: 0 } }
                    ],
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Series' } },
                                {
                                    composite: [
                                        { for: { in: 'Category' } },
                                    ],
                                },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        },
                        dataVolume: 4,
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 0 }, 'Series': { max: 1, min: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Tooltips': { max: 0 } }
                    ],
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Series' } },
                                {
                                    composite: [
                                        { bind: { to: 'X' } },
                                        { bind: { to: 'Y' } },
                                    ],
                                },
                            ],
                            dataReductionAlgorithm: { sample: {} }
                        },
                        dataVolume: 4,
                    }
                }],
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Size', direction: 2 /* Descending */ }]
                },
            },
            drilldown: {
                roles: ['Category']
            },
            grouping: {
                groupingRules: [
                    {
                        condition: { 'Category': { min: 1, max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                        groupingTargetRole: 'Series',
                        kind: 0 /* Color */,
                    }
                ]
            },
        };
        visuals.mapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                defaultCategoryColor: { objectName: 'dataPoint', propertyName: 'defaultCategoryColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
            bubbles: {
                bubbleSize: { objectName: 'bubbles', propertyName: 'bubbleSize' },
            },
            mapControls: {
                autoZoom: { objectName: 'mapControls', propertyName: 'autoZoom' },
                zoomLevel: { objectName: 'mapControls', propertyName: 'zoomLevel' },
                centerLatitude: { objectName: 'mapControls', propertyName: 'centerLatitude' },
                centerLongitude: { objectName: 'mapControls', propertyName: 'centerLongitude' },
            },
            mapStyles: {
                mapTheme: { objectName: 'mapStyles', propertyName: 'mapTheme' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.multiRowCardCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Fields'),
                    description: createDisplayNameGetter('Role_DisplayName_FieldsDescription')
                }
            ],
            objects: {
                // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                general: {
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                dataLabels: {
                    displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                categoryLabels: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                    description: createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                cardTitle: {
                    displayName: createDisplayNameGetter('Visual_CardTitle'),
                    description: createDisplayNameGetter('Visual_CardTitleDescription'),
                    properties: {
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                card: {
                    displayName: createDisplayNameGetter('Card_ToolTip'),
                    properties: {
                        outline: {
                            displayName: createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        outlineColor: {
                            displayName: createDisplayNameGetter('Visual_OutlineColor'),
                            description: createDisplayNameGetter('Visual_OutlineColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outlineWeight: {
                            displayName: createDisplayNameGetter('Visual_OutlineWeight'),
                            description: createDisplayNameGetter('Visual_OutlineWeight_Desc'),
                            type: { numeric: true }
                        },
                        barShow: {
                            displayName: createDisplayNameGetter('Visual_MultiRowCard_BarShow'),
                            description: createDisplayNameGetter('Visual_MultiRowCard_BarShow_Desc'),
                            type: { bool: true }
                        },
                        barColor: {
                            displayName: createDisplayNameGetter('Visual_MultiRowCard_BarColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        barWeight: {
                            displayName: createDisplayNameGetter('Visual_MultiRowCard_BarWeight'),
                            description: createDisplayNameGetter('Visual_MultiRowCard_BarWeight_Desc'),
                            type: { numeric: true }
                        },
                        cardPadding: {
                            displayName: createDisplayNameGetter('Visual_MultiRowCard_CardPadding'),
                            description: createDisplayNameGetter('Visual_MultiRowCard_CardBackground'),
                            type: { numeric: true }
                        },
                        cardBackground: {
                            displayName: createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: {} }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            sorting: {
                default: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
        visuals.multiRowCardProps = {
            card: {
                outline: { objectName: 'card', propertyName: 'outline' },
                outlineColor: { objectName: 'card', propertyName: 'outlineColor' },
                outlineWeight: { objectName: 'card', propertyName: 'outlineWeight' },
                barShow: { objectName: 'card', propertyName: 'barShow' },
                barColor: { objectName: 'card', propertyName: 'barColor' },
                barWeight: { objectName: 'card', propertyName: 'barWeight' },
                cardPadding: { objectName: 'card', propertyName: 'cardPadding' },
                cardBackground: { objectName: 'card', propertyName: 'cardBackground' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.textboxCapabilities = {
            objects: {
                general: {
                    properties: {
                        paragraphs: {
                            type: { paragraphs: {} },
                            suppressFormatPainterCopy: true,
                        }
                    }
                }
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        visuals.cheerMeterCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: createDisplayNameGetter('Role_DisplayName_AxisDescription')
                },
                {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    displayName: createDisplayNameGetter('Role_DisplayName_Y'),
                    description: createDisplayNameGetter('Role_DisplayName_YDescription')
                },
            ],
            dataViewMappings: [{
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                    },
                }],
            objects: {
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        fill: visuals.StandardObjectProperties.fill,
                    }
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.scatterRoleNames = {
            category: 'Category',
            series: 'Series',
            x: 'X',
            y: 'Y',
            size: 'Size',
            gradient: 'Gradient',
            play: 'Play',
        };
        function getScatterChartCapabilities(useMatrixDV, overlappingPointsSampling, xyGrouping) {
            var capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Details'),
                        description: createDisplayNameGetter('Role_DisplayName_DetailsScatterChartDescription'),
                    }, {
                        name: 'Series',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                        description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                    }, {
                        name: 'X',
                        kind: xyGrouping ? powerbi.VisualDataRoleKind.GroupingOrMeasure : powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_X'),
                        description: createDisplayNameGetter('Role_DisplayName_XScatterChartDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        cartesianKind: 0 /* X */,
                    }, {
                        name: 'Y',
                        kind: xyGrouping ? powerbi.VisualDataRoleKind.GroupingOrMeasure : powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Y'),
                        description: createDisplayNameGetter('Role_DisplayName_YScatterChartDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        cartesianKind: 1 /* Y */,
                    }, {
                        name: 'Size',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Size'),
                        description: createDisplayNameGetter('Role_DisplayName_SizeDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                    }, {
                        name: 'Gradient',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                        description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        joinPredicate: 0 /* None */,
                    }, {
                        name: 'Play',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Play'),
                    }, {
                        name: 'Tooltips',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                        joinPredicate: 0 /* None */,
                    }
                ],
                objects: visuals.scatterChartObjectDescriptors,
                dataViewMappings: getDataViewMappings(useMatrixDV, overlappingPointsSampling, xyGrouping),
                sorting: {
                    custom: {},
                    implicit: {
                        clauses: [{ role: 'Play', direction: 1 /* Ascending */ }] //typically a datetime field, sort asc
                    },
                },
                drilldown: {
                    roles: ['Category']
                },
                grouping: {
                    groupingRules: [
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'X': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 }, 'Play': { max: 1 } },
                            groupingTargetRole: 'Category',
                            kind: 1 /* GroupInPlace */,
                        },
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Play': { max: 1 } },
                            groupingTargetRole: 'Series',
                            kind: 0 /* Color */,
                        },
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'X': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 1 }, 'Play': { max: 1 } },
                            groupingTargetRole: 'Category',
                            kind: 1 /* GroupInPlace */,
                        }
                    ],
                    cluster: {
                        clusteringRole: 'Series',
                        conditions: [
                            { 'Category': { min: 1, max: 1 }, 'X': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 }, 'Series': { max: 0 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                        ]
                    }
                }
            };
            return capabilities;
        }
        visuals.getScatterChartCapabilities = getScatterChartCapabilities;
        function getDataViewMappings(useMatrixDV, overlappingPointsSampling, xyGrouping) {
            var dataViewMappings = [
                getScatterChartDataViewMapping(useMatrixDV, overlappingPointsSampling, xyGrouping),
                getPlayChartDataViewMapping(useMatrixDV),
                getTrendLinesDataViewMapping(useMatrixDV)
            ];
            if (xyGrouping && useMatrixDV) {
                var groupedConditions = [
                    generateScatterChartXYGroupingDataViewMapping(overlappingPointsSampling, true, true),
                    generateScatterChartXYGroupingDataViewMapping(overlappingPointsSampling, true, false),
                    generateScatterChartXYGroupingDataViewMapping(overlappingPointsSampling, false, true),
                ];
                dataViewMappings.push.apply(dataViewMappings, groupedConditions);
            }
            return dataViewMappings;
        }
        function getScatterChartDataViewMapping(useMatrixDV, overlappingPointsSampling, xyGrouping) {
            var mapping = {
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                    { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                ],
                categorical: {
                    categories: {
                        for: { in: 'Category' },
                    },
                    values: {
                        group: {
                            by: 'Series',
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                                { bind: { to: 'Gradient' } },
                                { for: { in: 'Tooltips' } }
                            ],
                        }
                    },
                    rowCount: { preferred: { min: 2 } },
                    dataReductionAlgorithm: { sample: {} },
                    dataVolume: 4,
                }
            };
            if (useMatrixDV) {
                mapping = {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                    ],
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Series' } },
                                {
                                    /** composite mapping allows the categories to appear as peers in the same matrix row level */
                                    composite: [{ for: { in: 'Category' } },]
                                },
                            ],
                            dataReductionAlgorithm: { sample: {} },
                        },
                        values: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                                { bind: { to: 'Gradient' } },
                                { for: { in: 'Tooltips' } }
                            ]
                        },
                        dataVolume: 4,
                    }
                };
            }
            if (overlappingPointsSampling) {
                var reduction = { overlappingPointsSample: {} };
                if (mapping.categorical) {
                    mapping.categorical.dataReductionAlgorithm = reduction;
                }
                if (mapping.matrix) {
                    mapping.matrix.rows.dataReductionAlgorithm = reduction;
                }
            }
            if (xyGrouping) {
                mapping.conditions.forEach((function (condition) {
                    condition['X'].kind = powerbi.VisualDataRoleKind.Measure;
                    condition['Y'].kind = powerbi.VisualDataRoleKind.Measure;
                }));
            }
            return mapping;
        }
        function generateScatterChartXYGroupingDataViewMapping(overlappingPointsSampling, groupedX, groupedY) {
            debug.assert(groupedX || groupedY, 'At least one of groupedX or groupedY must be true');
            var groupCondition = { min: 1, max: 1, kind: powerbi.VisualDataRoleKind.Grouping };
            var measureCondition = { max: 1, kind: powerbi.VisualDataRoleKind.Measure };
            var xCondition = groupedX ? groupCondition : measureCondition;
            var yCondition = groupedY ? groupCondition : measureCondition;
            // decide how to position x and y based on their grouping: do they go into the rows or values?
            var innerRows = [{ bind: { to: 'X' } }, { bind: { to: 'Y' } }];
            var types = [];
            if (!groupedX)
                types.push(innerRows.splice(0, 1)[0]);
            if (!groupedY)
                types.push(innerRows.splice(-1, 1)[0]);
            // properly format grouping conditions, composite iff 2 or more, otherwise make singleton
            var groupedValues;
            if (innerRows.length >= 2) {
                groupedValues = { composite: innerRows };
            }
            else if (innerRows.length === 1) {
                groupedValues = innerRows[0];
            }
            var dataView = {
                conditions: [
                    { 'Category': { max: 0 }, 'Series': { max: 1 }, 'X': xCondition, 'Y': yCondition, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                    { 'Category': { max: 0 }, 'Series': { max: 0 }, 'X': xCondition, 'Y': yCondition, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                ],
                matrix: {
                    rows: {
                        select: [
                            { bind: { to: 'Series' } },
                            groupedValues,
                        ],
                        dataReductionAlgorithm: { sample: {} },
                    },
                    values: {
                        select: types.concat([
                            { bind: { to: 'Size' } },
                            { bind: { to: 'Gradient' } },
                            { for: { in: 'Tooltips' } },
                        ])
                    },
                    dataVolume: 4,
                }
            };
            if (overlappingPointsSampling) {
                dataView.matrix.rows.dataReductionAlgorithm = { overlappingPointsSample: {} };
            }
            return dataView;
        }
        function getPlayChartDataViewMapping(useMatrixDV) {
            var mapping = {
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { min: 1, max: 1 } },
                ],
                // Long term: consider adding the 'name' concept and have this be a reference to the other dataViewMapping above.
                // Then we'd also move the splitting logic of Matrix->Categorical[] into DataViewTransform, and other visuals would benefit.
                matrix: {
                    rows: {
                        select: [
                            { bind: { to: 'Play' } },
                            { bind: { to: 'Category' } },
                        ],
                        /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                        dataReductionAlgorithm: { bottom: { count: 5000 } }
                    },
                    columns: {
                        for: { in: 'Series' },
                        /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                        dataReductionAlgorithm: { top: { count: 60 } }
                    },
                    values: {
                        select: [
                            { bind: { to: 'X' } },
                            { bind: { to: 'Y' } },
                            { bind: { to: 'Size' } },
                            { for: { in: 'Tooltips' } }
                        ]
                    }
                }
            };
            if (useMatrixDV) {
                mapping = {
                    // TODO: Play chart mapping should subsume the DVM above
                    // For now, Play Chart requests for Series on columns and there is no strategy to get data reduction with Series, Category on Primary
                    // before Play chart would get matrix as per the mapping below and convert it to categorical and feed to ScatterChart.converter like before
                    // Till, we figure out how to do more advanced data reduction, Good intermediate solution is for playChart to feed the same Matrix to Scatter Chart
                    // And the scatter chart can handle both forms of Matrix Dataview
                    // Matrix DataView form 1: Series, Category on Row Hierarchy (See Mapping above)
                    // Matrix DataView form 2: Category on Row and Series on Column Hierarchy (See Mapping for Play below)
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { min: 1, max: 1 } },
                    ],
                    // Long term: consider adding the 'name' concept and have this be a reference to the other dataViewMapping above.
                    // Then we'd also move the splitting logic of Matrix->Categorical[] into DataViewTransform, and other visuals would benefit.
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Play' } },
                                { bind: { to: 'Category' } },
                            ],
                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                            dataReductionAlgorithm: { bottom: { count: 5000 } }
                        },
                        columns: {
                            for: { in: 'Series' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                            dataReductionAlgorithm: { top: { count: 60 } }
                        },
                        values: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                                { for: { in: 'Tooltips' } }
                            ]
                        }
                    }
                };
            }
            return mapping;
        }
        function getTrendLinesDataViewMapping(useMatrixDV) {
            var mapping = {
                conditions: [
                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                    { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                ],
                requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                usage: {
                    regression: {
                        combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                    },
                },
                categorical: {
                    categories: {
                        for: { in: 'regression.X' }
                    },
                    values: {
                        group: {
                            by: 'regression.Series',
                            select: [{ for: { in: 'regression.Y' } }],
                        },
                    },
                    dataReductionAlgorithm: { sample: {} },
                    dataVolume: 4,
                }
            };
            if (useMatrixDV) {
                mapping = {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                    ],
                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                    usage: {
                        regression: {
                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                        },
                    },
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'regression.Series' } },
                                { bind: { to: 'regression.X' } },
                            ],
                            dataReductionAlgorithm: { sample: {} },
                        },
                        values: {
                            select: [
                                { for: { in: 'regression.Y' } }
                            ]
                        },
                        dataVolume: 4,
                    }
                };
            }
            return mapping;
        }
        visuals.scatterChartObjectDescriptors = {
            // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
            general: {
                displayName: createDisplayNameGetter('Visual_General'),
                properties: {
                    formatString: StandardObjectProperties.formatString,
                    responsive: StandardObjectProperties.responsive,
                    responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                    dataVolume: {
                        displayName: createDisplayNameGetter('Visual_DataVolume'),
                        description: createDisplayNameGetter('Visual_DataVolumeDescription'),
                        type: { integer: true }
                    }
                },
            },
            legend: visuals.StandardObjectDescriptors.legend,
            categoryAxis: {
                displayName: createDisplayNameGetter('Visual_XAxis'),
                properties: {
                    show: StandardObjectProperties.show,
                    axisScale: StandardObjectProperties.axisScale,
                    start: StandardObjectProperties.axisStart,
                    end: StandardObjectProperties.axisEnd,
                    showAxisTitle: {
                        displayName: createDisplayNameGetter('Visual_Axis_Title'),
                        description: createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                        type: { bool: true }
                    },
                    axisStyle: StandardObjectProperties.axisStyle,
                    labelColor: StandardObjectProperties.labelColor,
                    fontFamily: StandardObjectProperties.fontFamily,
                    fontSize: StandardObjectProperties.fontSize,
                    labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                    labelPrecision: StandardObjectProperties.labelPrecision,
                    titleColor: StandardObjectProperties.titleColor,
                    titleFontFamily: StandardObjectProperties.fontFamily,
                    titleFontSize: StandardObjectProperties.titleFontSize,
                    titleText: StandardObjectProperties.titleText,
                    gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                    gridlineColor: StandardObjectProperties.lineColor,
                    gridlineThickness: StandardObjectProperties.strokeWidth,
                    gridlineStyle: StandardObjectProperties.lineStyle,
                }
            },
            valueAxis: {
                displayName: createDisplayNameGetter('Visual_YAxis'),
                properties: {
                    show: StandardObjectProperties.show,
                    position: StandardObjectProperties.yAxisPosition,
                    axisScale: StandardObjectProperties.axisScale,
                    start: StandardObjectProperties.axisStart,
                    end: StandardObjectProperties.axisEnd,
                    showAxisTitle: {
                        displayName: createDisplayNameGetter('Visual_Axis_Title'),
                        description: createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                        type: { bool: true }
                    },
                    axisStyle: StandardObjectProperties.axisStyle,
                    labelColor: StandardObjectProperties.labelColor,
                    fontFamily: StandardObjectProperties.fontFamily,
                    fontSize: StandardObjectProperties.fontSize,
                    labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                    labelPrecision: StandardObjectProperties.labelPrecision,
                    titleColor: StandardObjectProperties.titleColor,
                    titleFontFamily: StandardObjectProperties.fontFamily,
                    titleFontSize: StandardObjectProperties.titleFontSize,
                    titleText: StandardObjectProperties.titleText,
                    gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                    gridlineColor: StandardObjectProperties.lineColor,
                    gridlineThickness: StandardObjectProperties.strokeWidth,
                    gridlineStyle: StandardObjectProperties.lineStyle,
                }
            },
            dataPoint: {
                displayName: createDisplayNameGetter('Visual_DataPoint'),
                description: createDisplayNameGetter('Visual_DataPointDescription'),
                properties: {
                    defaultColor: StandardObjectProperties.defaultColor,
                    defaultCategoryColor: StandardObjectProperties.defaultCategoryColor,
                    showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                    fill: StandardObjectProperties.fill,
                    fillRule: {
                        displayName: createDisplayNameGetter('Visual_Gradient'),
                        type: { fillRule: {} },
                        rule: {
                            inputRole: 'Gradient',
                            output: {
                                property: 'fill',
                                selector: ['Category', 'X', 'Y'],
                            },
                        },
                    }
                }
            },
            bubbles: {
                displayName: createDisplayNameGetter('Visual_Shapes'),
                description: createDisplayNameGetter('Visual_ShapesDescription'),
                properties: {
                    bubbleSize: {
                        displayName: createDisplayNameGetter('Visual_BubbleSize'),
                        type: { formatting: { bubbleSize: true } },
                    },
                    markerShape: StandardObjectProperties.markerShape,
                    showSeries: {
                        displayName: createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                        type: { bool: true }
                    },
                }
            },
            plotArea: {
                displayName: createDisplayNameGetter('Visual_Plot'),
                properties: {
                    transparency: StandardObjectProperties.transparency,
                    image: StandardObjectProperties.image,
                },
            },
            categoryLabels: {
                displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                description: createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                properties: {
                    show: StandardObjectProperties.show,
                    color: StandardObjectProperties.dataColor,
                    fontSize: StandardObjectProperties.fontSize,
                    fontFamily: StandardObjectProperties.fontFamily,
                },
            },
            trend: {
                displayName: createDisplayNameGetter('Visual_Trend_Line'),
                suppressFormatPainterCopy: true,
                properties: {
                    show: StandardObjectProperties.show,
                    displayName: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line_DisplayName'),
                        description: createDisplayNameGetter('Visual_Trend_Line_DisplayName_Description'),
                        type: { text: true }
                    },
                    lineColor: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line_Color'),
                        description: createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                        type: { fill: { solid: { color: true } } }
                    },
                    transparency: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                        description: createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                        type: { numeric: true }
                    },
                    style: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line_Style'),
                        description: createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                        type: { enumeration: visuals.lineStyle.type }
                    },
                    combineSeries: {
                        displayName: createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                        description: createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                        type: { bool: true }
                    },
                }
            },
            xAxisReferenceLine: {
                displayName: createDisplayNameGetter('Visual_Reference_Line_X'),
                description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                suppressFormatPainterCopy: true,
                properties: {
                    show: StandardObjectProperties.show,
                    displayName: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                        description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                        type: { text: true }
                    },
                    value: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                        type: { numeric: true }
                    },
                    lineColor: StandardObjectProperties.lineColor,
                    transparency: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                        type: { numeric: true }
                    },
                    style: StandardObjectProperties.lineStyle,
                    position: StandardObjectProperties.referenceLinePosition,
                    dataLabelShow: StandardObjectProperties.dataLabelShow,
                    dataLabelColor: StandardObjectProperties.dataLabelColor,
                    dataLabelText: StandardObjectProperties.dataLabelText,
                    dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                    dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                    dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                    dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                },
            },
            y1AxisReferenceLine: {
                displayName: createDisplayNameGetter('Visual_Reference_Line_Y'),
                description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                suppressFormatPainterCopy: true,
                properties: {
                    show: StandardObjectProperties.show,
                    displayName: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                        description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                        type: { text: true }
                    },
                    value: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                        type: { numeric: true }
                    },
                    lineColor: StandardObjectProperties.lineColor,
                    transparency: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                        type: { numeric: true }
                    },
                    style: StandardObjectProperties.lineStyle,
                    position: StandardObjectProperties.referenceLinePosition,
                    dataLabelShow: StandardObjectProperties.dataLabelShow,
                    dataLabelColor: StandardObjectProperties.dataLabelColor,
                    dataLabelText: StandardObjectProperties.dataLabelText,
                    dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                    dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                    dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                    dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                },
            },
            referenceLine: {
                displayName: createDisplayNameGetter('Visual_Reference_Line'),
                description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                suppressFormatPainterCopy: true,
                properties: {
                    show: StandardObjectProperties.show,
                    displayName: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                        description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                        type: { text: true }
                    },
                    value: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                        type: { numeric: true }
                    },
                    lineColor: StandardObjectProperties.lineColor,
                    transparency: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                        type: { numeric: true }
                    },
                    style: StandardObjectProperties.lineStyle,
                    position: StandardObjectProperties.referenceLinePosition,
                    dataLabelShow: StandardObjectProperties.dataLabelShow,
                    dataLabelColor: StandardObjectProperties.dataLabelColor,
                    dataLabelText: StandardObjectProperties.dataLabelText,
                    dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                    dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                    dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                    dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                },
            },
            colorBorder: {
                displayName: createDisplayNameGetter('Visual_ColorBorder'),
                properties: {
                    show: StandardObjectProperties.show,
                },
            },
            fillPoint: {
                displayName: createDisplayNameGetter('Visual_FillPoint'),
                properties: {
                    show: StandardObjectProperties.show,
                },
            },
            colorByCategory: {
                displayName: createDisplayNameGetter('Visual_ColorByCategory'),
                properties: {
                    show: StandardObjectProperties.show,
                }
            },
            currentFrameIndex: {
                properties: {
                    index: {
                        type: { numeric: true },
                    }
                }
            },
            clustering: {
                suppressFormatPainterCopy: true,
                properties: {
                    transform: {
                        type: { queryTransform: {} }
                    }
                }
            },
            plotAreaShading: {
                displayName: createDisplayNameGetter('Visual_Scatter_SymmetryShading'),
                description: createDisplayNameGetter('Visual_Scatter_SymmetryShadingDescription'),
                properties: {
                    show: StandardObjectProperties.show,
                    upperShadingColor: {
                        displayName: createDisplayNameGetter('Visual_Scatter_SymmetryShadingUpper'),
                        description: createDisplayNameGetter('Visual_Scatter_SymmetryShadingUpperDescription'),
                        type: { fill: { solid: { color: true } } }
                    },
                    lowerShadingColor: {
                        displayName: createDisplayNameGetter('Visual_Scatter_SymmetryShadingLower'),
                        description: createDisplayNameGetter('Visual_Scatter_SymmetryShadingLowerDescription'),
                        type: { fill: { solid: { color: true } } }
                    },
                    transparency: StandardObjectProperties.transparency,
                }
            },
            ratioLine: {
                displayName: createDisplayNameGetter('Visual_Scatter_RatioLine'),
                description: createDisplayNameGetter('Visual_Scatter_RatioLineDescription'),
                properties: {
                    show: StandardObjectProperties.show,
                    lineColor: StandardObjectProperties.lineColor,
                    transparency: StandardObjectProperties.lineTransparency,
                    style: StandardObjectProperties.lineStyle,
                }
            },
        };
        visuals.scatterChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
                dataVolume: { objectName: 'general', propertyName: 'dataVolume' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            bubbles: {
                bubbleSize: { objectName: 'bubbles', propertyName: 'bubbleSize' },
                markerShape: { objectName: 'bubbles', propertyName: 'markerShape' },
                showSeries: { objectName: 'bubbles', propertyName: 'showSeries' },
            },
            trend: {
                show: { objectName: 'trend', propertyName: 'show' },
            },
            colorBorder: {
                show: { objectName: 'colorBorder', propertyName: 'show' },
            },
            fillPoint: {
                show: { objectName: 'fillPoint', propertyName: 'show' },
            },
            colorByCategory: {
                show: { objectName: 'colorByCategory', propertyName: 'show' },
            },
            currentFrameIndex: {
                index: { objectName: 'currentFrameIndex', propertyName: 'index' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
            plotAreaShading: {
                show: { objectName: 'plotAreaShading', propertyName: 'show' },
                upperShadingColor: { objectName: 'plotAreaShading', propertyName: 'upperShadingColor' },
                lowerShadingColor: { objectName: 'plotAreaShading', propertyName: 'lowerShadingColor' },
                transparency: { objectName: 'plotAreaShading', propertyName: 'transparency' },
            },
            ratioLine: {
                show: { objectName: 'ratioLine', propertyName: 'show' },
                lineColor: { objectName: 'ratioLine', propertyName: 'lineColor' },
                transparency: { objectName: 'ratioLine', propertyName: 'transparency' },
                style: { objectName: 'ratioLine', propertyName: 'style' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ''Software''), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.slicerRoles = {
            value: 'Values'
        };
        visuals.slicerCapabilities = {
            dataRoles: [
                {
                    name: visuals.slicerRoles.value,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Field'),
                    description: createDisplayNameGetter('Role_DisplayName_FieldDescription')
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        responsive: StandardObjectProperties.responsive,
                        filter: {
                            type: { filter: {} },
                        },
                        selfFilter: {
                            type: { filter: { selfFilter: true } },
                        },
                        defaultValue: {
                            type: { expression: { defaultValue: true } },
                        },
                        formatString: StandardObjectProperties.formatString,
                        outlineColor: StandardObjectProperties.outlineColor,
                        outlineWeight: StandardObjectProperties.outlineWeight,
                        orientation: {
                            displayName: createDisplayNameGetter('Slicer_Orientation'),
                            type: { enumeration: visuals.slicerOrientation.type }
                        },
                        count: {
                            type: { integer: true }
                        },
                        selfFilterEnabled: {
                            type: { operations: { searchEnabled: true } }
                        }
                    }
                },
                data: {
                    properties: {
                        startDate: {
                            type: { dateTime: true },
                            filterState: true
                        },
                        endDate: {
                            type: { dateTime: true },
                            filterState: true
                        },
                        numericStart: {
                            type: { numeric: true },
                            filterState: true
                        },
                        numericEnd: {
                            type: { numeric: true },
                            filterState: true
                        },
                        relativeRange: {
                            type: { enumeration: visuals.relativeSlicerRelativeQualifier.type },
                            filterState: true
                        },
                        relativePeriod: {
                            type: { enumeration: visuals.relativeSlicerPeriod.type },
                            filterState: true
                        },
                        relativeDuration: {
                            type: { numeric: true },
                            filterState: true
                        },
                        mode: {
                            type: { enumeration: visuals.slicerMode.type },
                            filterState: true
                        }
                    },
                },
                selection: {
                    displayName: createDisplayNameGetter('Visual_SelectionControls'),
                    properties: {
                        selectAllCheckboxEnabled: {
                            displayName: createDisplayNameGetter('Visual_SelectAll'),
                            description: createDisplayNameGetter('Visual_SelectAll_Description'),
                            type: { bool: true }
                        },
                        singleSelect: {
                            displayName: createDisplayNameGetter('Visual_SingleSelect'),
                            type: { bool: true }
                        }
                    },
                },
                header: {
                    displayName: createDisplayNameGetter('Visual_Header'),
                    properties: {
                        show: StandardObjectProperties.show,
                        fontColor: StandardObjectProperties.fontColor,
                        background: {
                            displayName: createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outline: StandardObjectProperties.outline,
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                items: {
                    displayName: createDisplayNameGetter('Role_DisplayName_Items'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        background: {
                            displayName: createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outline: StandardObjectProperties.outline,
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                date: {
                    displayName: createDisplayNameGetter('Slicer_DateInputs'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                        background: {
                            displayName: createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                numericInputStyle: {
                    displayName: createDisplayNameGetter('Slicer_NumericInputs'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                        background: {
                            displayName: createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                slider: {
                    displayName: createDisplayNameGetter('Slicer_Slider'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: {
                            displayName: createDisplayNameGetter('Visual_LegendTitleColor'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                },
                dateRange: {
                    displayName: createDisplayNameGetter('Slicer_DateRange'),
                    properties: {
                        includeToday: {
                            displayName: createDisplayNameGetter('Visual_IncludeToday'),
                            type: { bool: true }
                        }
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [(_a = {}, _a[visuals.slicerRoles.value] = { max: 1 }, _a)],
                    categorical: {
                        categories: {
                            for: { in: visuals.slicerRoles.value },
                            dataReductionAlgorithm: { window: {} }
                        },
                        includeEmptyGroups: true,
                    }
                }],
            sorting: {
                default: {},
            },
            suppressDefaultTitle: true,
        };
        // TODO: Generate these from above, defining twice just introduces potential for error
        visuals.slicerProps = {
            general: {
                filter: { objectName: 'general', propertyName: 'filter' },
                outlineColor: { objectName: 'general', propertyName: 'outlineColor' },
                outlineWeight: { objectName: 'general', propertyName: 'outlineWeight' },
                orientation: { objectName: 'general', propertyName: 'orientation' },
                responsive: { objectName: 'general', propertyName: 'responsive' },
                count: { objectName: 'general', propertyName: 'count' },
                selfFilterEnabled: { objectName: 'general', propertyName: 'selfFilterEnabled' },
            },
            data: {
                startDate: { objectName: 'data', propertyName: 'startDate' },
                endDate: { objectName: 'data', propertyName: 'endDate' },
                numericStart: { objectName: 'data', propertyName: 'numericStart' },
                numericEnd: { objectName: 'data', propertyName: 'numericEnd' },
                relativeRange: { objectName: 'data', propertyName: 'relativeRange' },
                relativePeriod: { objectName: 'data', propertyName: 'relativePeriod' },
                relativeDuration: { objectName: 'data', propertyName: 'relativeDuration' },
                mode: { objectName: 'data', propertyName: 'mode' }
            },
            selection: {
                selectAllCheckboxEnabled: { objectName: 'selection', propertyName: 'selectAllCheckboxEnabled' },
                singleSelect: { objectName: 'selection', propertyName: 'singleSelect' }
            },
            header: {
                show: { objectName: 'header', propertyName: 'show' },
                fontColor: { objectName: 'header', propertyName: 'fontColor' },
                background: { objectName: 'header', propertyName: 'background' },
                outline: { objectName: 'header', propertyName: 'outline' },
                textSize: { objectName: 'header', propertyName: 'textSize' },
                fontFamily: { objectName: 'header', propertyName: 'fontFamily' },
            },
            items: {
                fontColor: { objectName: 'items', propertyName: 'fontColor' },
                background: { objectName: 'items', propertyName: 'background' },
                outline: { objectName: 'items', propertyName: 'outline' },
                textSize: { objectName: 'items', propertyName: 'textSize' },
                fontFamily: { objectName: 'items', propertyName: 'fontFamily' },
            },
            date: {
                fontColor: { objectName: 'date', propertyName: 'fontColor' },
                textSize: { objectName: 'date', propertyName: 'textSize' },
                fontFamily: { objectName: 'date', propertyName: 'fontFamily' },
                background: { objectName: 'date', propertyName: 'background' }
            },
            numericInputStyle: {
                fontColor: { objectName: 'numericInputStyle', propertyName: 'fontColor' },
                textSize: { objectName: 'numericInputStyle', propertyName: 'textSize' },
                fontFamily: { objectName: 'numericInputStyle', propertyName: 'fontFamily' },
                background: { objectName: 'numericInputStyle', propertyName: 'background' }
            },
            slider: {
                show: { objectName: 'slider', propertyName: 'show' },
                color: { objectName: 'slider', propertyName: 'color' }
            },
            dateRange: {
                includeToday: { objectName: 'dateRange', propertyName: 'includeToday' }
            },
            filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
            selfFilterPropertyIdentifier: { objectName: 'general', propertyName: 'selfFilter' },
            formatString: { objectName: 'general', propertyName: 'formatString' },
            defaultValue: { objectName: 'general', propertyName: 'defaultValue' },
        };
        var _a;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.tableCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                }],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                        columnWidth: {
                            type: { numeric: true }
                        },
                        totals: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_Totals'),
                            suppressFormatPainterCopy: true,
                        },
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_Adjust_Column_Width'),
                            suppressFormatPainterCopy: true,
                        },
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    },
                },
                grid: {
                    displayName: createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: StandardObjectProperties.outlineColor,
                        outlineWeight: StandardObjectProperties.outlineWeight,
                        gridVertical: {
                            displayName: createDisplayNameGetter('Visual_GridVertical'),
                            description: createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: createDisplayNameGetter('Visual_RowPadding'),
                            description: createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                        imageHeight: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ImageHeight'),
                            description: createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
                            type: { numeric: true }
                        },
                    }
                },
                columnHeaders: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        },
                    }
                },
                values: {
                    displayName: createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        // backColor overrides backColorPrimary and Secondary (e.g., in the case of conditional formatting)
                        backColor: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        urlIcon: {
                            displayName: createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                    }
                },
                total: {
                    displayName: createDisplayNameGetter('Visual_Tablix_TotalGrand'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                    }
                },
                columnFormatting: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        styleHeader: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorHeader'),
                            type: { bool: true }
                        },
                        styleValues: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorValues'),
                            type: { bool: true }
                        },
                        styleTotal: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorTotal'),
                            type: { bool: true }
                        },
                    }
                },
                clustering: {
                    suppressFormatPainterCopy: true,
                    properties: {
                        transform: {
                            type: { queryTransform: {} }
                        }
                    }
                },
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            sorting: {
                custom: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            grouping: {
                cluster: {
                    clusteringRole: 'Values',
                    conditions: [
                        { 'Values': { min: 2 } },
                    ]
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.matrixRoleNames = {
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
        };
        visuals.matrixCapabilities = {
            dataRoles: [
                {
                    name: visuals.matrixRoleNames.rows,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Rows'),
                    description: createDisplayNameGetter('Role_DisplayName_RowsDescription')
                }, {
                    name: visuals.matrixRoleNames.columns,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Columns'),
                    description: createDisplayNameGetter('Role_DisplayName_ColumnsDescription')
                }, {
                    name: visuals.matrixRoleNames.values,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values')
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                        columnWidth: {
                            type: { numeric: true }
                        },
                        rowSubtotals: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_TotalRow'),
                            suppressFormatPainterCopy: true,
                        },
                        columnSubtotals: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_TotalColumn'),
                            suppressFormatPainterCopy: true,
                        },
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_Adjust_Column_Width'),
                            suppressFormatPainterCopy: true,
                        },
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    },
                },
                grid: {
                    displayName: createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: StandardObjectProperties.outlineColor,
                        outlineWeight: StandardObjectProperties.outlineWeight,
                        gridVertical: {
                            displayName: createDisplayNameGetter('Visual_GridVertical'),
                            description: createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: createDisplayNameGetter('Visual_RowPadding'),
                            description: createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                        imageHeight: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ImageHeight'),
                            description: createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
                            type: { numeric: true }
                        },
                    },
                },
                columnHeaders: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                    }
                },
                rowHeaders: {
                    displayName: createDisplayNameGetter('Visual_Tablix_RowHeaders'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        },
                    }
                },
                values: {
                    displayName: createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        // backColor overrides backColorPrimary and Secondary (e.g., in the case of conditional formatting)
                        backColor: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
                subTotals: {
                    displayName: createDisplayNameGetter('Visual_Tablix_TotalSub'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                    }
                },
                total: {
                    displayName: createDisplayNameGetter('Visual_Tablix_Matrix_TotalGrand'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        applyToHeaders: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ApplyToHeaders'),
                            type: { bool: true },
                        }
                    }
                },
                columnFormatting: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        styleHeader: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorHeader'),
                            type: { bool: true }
                        },
                        styleValues: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorValues'),
                            type: { bool: true }
                        },
                        styleSubtotals: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorSubTotals'),
                            type: { bool: true }
                        },
                        styleTotal: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorTotal'),
                            type: { bool: true }
                        },
                    }
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Rows': { max: 0 }, 'Columns': { max: 0 }, 'Values': { min: 1 } },
                        { 'Rows': { min: 1 }, 'Columns': { min: 0 }, 'Values': { min: 0 } },
                        { 'Rows': { min: 0 }, 'Columns': { min: 1 }, 'Values': { min: 0 } }
                    ],
                    matrix: {
                        rows: {
                            for: { in: 'Rows' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        columns: {
                            for: { in: 'Columns' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { top: { count: 100 } }
                        },
                        values: {
                            for: { in: 'Values' }
                        }
                    }
                }],
            filterMappings: {
                measureFilter: {
                    targetRoles: [visuals.matrixRoleNames.rows]
                }
            },
            sorting: {
                custom: {},
            },
            dataRoleTotals: [{
                    roles: [visuals.matrixRoleNames.columns],
                    displayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfColumnTotal'),
                    shortDisplayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfColumnTotalShort'),
                    tooltip: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfColumnTotalTooltip')
                }, {
                    roles: [visuals.matrixRoleNames.rows],
                    displayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfRowTotal'),
                    shortDisplayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfRowTotalShort'),
                    tooltip: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfRowTotalTooltip')
                }],
            suppressDefaultTitle: true,
            supportsSelection: false
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        visuals.accessibleTableCapabilities = {
            dataRoles: [
                {
                    name: visuals.matrixRoleNames.rows,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Rows'),
                    description: createDisplayNameGetter('Role_DisplayName_RowsDescription')
                }, {
                    name: visuals.matrixRoleNames.columns,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Columns'),
                    description: createDisplayNameGetter('Role_DisplayName_ColumnsDescription')
                }, {
                    name: visuals.matrixRoleNames.values,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values')
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
            },
            dataViewMappings: [
                {
                    matrix: {
                        rows: {
                            for: {
                                in: visuals.matrixRoleNames.rows
                            },
                            dataReductionAlgorithm: {
                                top: {
                                    count: 3000
                                }
                            }
                        },
                        columns: {
                            for: {
                                in: visuals.matrixRoleNames.columns
                            },
                            dataReductionAlgorithm: {
                                top: {
                                    count: 100
                                }
                            }
                        },
                        values: {
                            for: {
                                in: visuals.matrixRoleNames.values
                            }
                        }
                    }
                }
            ]
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.treemapRoles = {
            group: 'Group',
            details: 'Details',
            values: 'Values',
            gradient: 'Gradient'
        };
        visuals.treemapCapabilities = {
            dataRoles: [
                {
                    name: 'Group',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Group'),
                    description: createDisplayNameGetter('Role_DisplayName_GroupTreemapDescription')
                }, {
                    name: 'Details',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Details'),
                }, {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                    description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    joinPredicate: 0 /* None */,
                }, {
                    name: 'Tooltips',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                legend: visuals.StandardObjectDescriptors.legend,
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        fill: {
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Group'],
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                        fontSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { integer: true }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                    }
                },
                categoryLabels: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                    description: createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Group': { max: 1 }, 'Details': { max: 0 }, 'Gradient': { max: 1 } },
                        { 'Group': { max: 1 }, 'Details': { min: 1, max: 1 }, 'Values': { max: 1 }, 'Gradient': { max: 0 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Group' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Details',
                                select: [{ bind: { to: 'Values' } }, { bind: { to: 'Gradient' } }, { for: { in: 'Tooltips' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } }
                    }
                }],
            supportsHighlight: true,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Values', direction: 2 /* Descending */ }]
                },
            },
            drilldown: {
                roles: ['Group']
            },
            grouping: {
                groupingRules: [
                    {
                        condition: { 'Group': { min: 1, max: 1 }, 'Details': { max: 1 }, 'Values': { min: 1, max: 1 }, 'Gradient': { min: 0 } },
                        groupingTargetRole: 'Group',
                        kind: 1 /* GroupInPlace */,
                    },
                    {
                        condition: { 'Group': { min: 1, max: 1 }, 'Details': { max: 1 }, 'Values': { min: 1, max: 1 }, 'Gradient': { min: 0 } },
                        groupingTargetRole: 'Group',
                        groupSourceTargetRole: 'Details',
                        kind: 0 /* Color */,
                    },
                    {
                        condition: { 'Group': { min: 1, max: 1 }, 'Details': { min: 0 }, 'Values': { min: 1, max: 1 }, 'Gradient': { min: 1, max: 1 } },
                        groupingTargetRole: 'Group',
                        kind: 1 /* GroupInPlace */,
                    },
                ]
            }
        };
        visuals.treemapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                fontFamily: { objectName: 'labels', propertyName: 'fontFamily' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
                color: { objectName: 'categoryLabels', propertyName: 'color' },
                fontSize: { objectName: 'categoryLabels', propertyName: 'fontSize' },
                fontFamily: { objectName: 'categoryLabels', propertyName: 'fontFamily' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.cardCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Fields'),
                    description: createDisplayNameGetter('Role_DisplayName_FieldsDescription'),
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DataPointLabel'),
                    properties: {
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                        // NOTE: Consider adding a ValueType for fontSize.
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    },
                },
                categoryLabels: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabel'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        // NOTE: Consider adding a ValueType for fontSize.
                        fontSize: StandardObjectProperties.fontSize,
                        fontFamily: StandardObjectProperties.fontFamily,
                    },
                },
                wordWrap: {
                    displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                    properties: {
                        show: StandardObjectProperties.show,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Values': { max: 1 } }
                    ],
                    single: { role: "Values" }
                }],
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableFocusMode: true,
        };
        visuals.cardProps = {
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
                color: { objectName: 'categoryLabels', propertyName: 'color' },
                fontSize: { objectName: 'categoryLabels', propertyName: 'fontSize' },
                fontFamily: { objectName: 'categoryLabels', propertyName: 'fontFamily' },
            },
            labels: {
                color: { objectName: 'labels', propertyName: 'color' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                fontFamily: { objectName: 'labels', propertyName: 'fontFamily' },
            },
            wordWrap: {
                show: { objectName: 'wordWrap', propertyName: 'show' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        function getWaterfallChartCapabilities(breakdown) {
            var capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: createDisplayNameGetter('Role_DisplayName_Category'),
                        description: createDisplayNameGetter('Role_DisplayName_CategoryWaterfallDescription')
                    }, {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        displayName: createDisplayNameGetter('Role_DisplayName_Y'),
                    }, {
                        name: 'Tooltips',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                        joinPredicate: 0 /* None */,
                    }
                ],
                objects: {
                    // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                    general: {
                        displayName: createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: StandardObjectProperties.formatString,
                            responsive: StandardObjectProperties.responsive,
                            responsiveLegacy: StandardObjectProperties.responsiveLegacy,
                        },
                    },
                    legend: visuals.StandardObjectDescriptors.legend,
                    categoryAxis: {
                        displayName: createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            preferredCategoryWidth: {
                                displayName: createDisplayNameGetter('Visual_Category_Width'),
                                type: { numeric: true },
                            },
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                        }
                    },
                    valueAxis: {
                        displayName: createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: StandardObjectProperties.show,
                            position: StandardObjectProperties.yAxisPosition,
                            start: StandardObjectProperties.axisStart,
                            end: StandardObjectProperties.axisEnd,
                            showAxisTitle: {
                                displayName: createDisplayNameGetter('Visual_Axis_Title'),
                                description: createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: StandardObjectProperties.axisStyle,
                            labelColor: StandardObjectProperties.labelColor,
                            fontFamily: StandardObjectProperties.fontFamily,
                            fontSize: StandardObjectProperties.fontSize,
                            labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: StandardObjectProperties.labelPrecision,
                            titleColor: StandardObjectProperties.titleColor,
                            titleFontFamily: StandardObjectProperties.fontFamily,
                            titleFontSize: StandardObjectProperties.titleFontSize,
                            titleText: StandardObjectProperties.titleText,
                            gridlineShow: __assign({}, StandardObjectProperties.show, { displayName: createDisplayNameGetter('Visual_Gridline_Show') }),
                            gridlineColor: StandardObjectProperties.lineColor,
                            gridlineThickness: StandardObjectProperties.strokeWidth,
                            gridlineStyle: StandardObjectProperties.lineStyle,
                        }
                    },
                    labels: {
                        displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                        description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                        properties: {
                            show: StandardObjectProperties.show,
                            color: StandardObjectProperties.dataColor,
                            labelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: __assign({}, StandardObjectProperties.labelPrecision, { suppressFormatPainterCopy: true }),
                            fontSize: StandardObjectProperties.fontSize,
                            fontFamily: StandardObjectProperties.fontFamily,
                            labelOrientation: {
                                displayName: createDisplayNameGetter('Visual_LabelOrientation'),
                                type: { enumeration: visuals.labelOrientation.type },
                            },
                            labelPosition: {
                                displayName: createDisplayNameGetter('Visual_Position'),
                                type: { enumeration: visuals.labelPosition.type },
                            },
                        }
                    },
                    plotArea: {
                        displayName: createDisplayNameGetter('Visual_Plot'),
                        properties: {
                            transparency: StandardObjectProperties.transparency,
                            image: StandardObjectProperties.image,
                        },
                    },
                    sentimentColors: {
                        displayName: createDisplayNameGetter('Waterfall_SentimentColors'),
                        properties: {
                            increaseFill: {
                                displayName: createDisplayNameGetter('Waterfall_IncreaseLabel'),
                                type: { fill: { solid: { color: true } } }
                            },
                            decreaseFill: {
                                displayName: createDisplayNameGetter('Waterfall_DecreaseLabel'),
                                type: { fill: { solid: { color: true } } }
                            },
                            totalFill: {
                                displayName: createDisplayNameGetter('Waterfall_TotalLabel'),
                                type: { fill: { solid: { color: true } } }
                            },
                            otherFill: {
                                displayName: createDisplayNameGetter('Waterfall_OtherLabel'),
                                type: { fill: { solid: { color: true } } }
                            }
                        },
                    },
                    y1AxisReferenceLine: {
                        displayName: createDisplayNameGetter('Visual_Reference_Line'),
                        description: createDisplayNameGetter('Visual_Reference_Line_Description'),
                        properties: {
                            show: StandardObjectProperties.show,
                            displayName: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_DisplayName'),
                                description: createDisplayNameGetter('Visual_Reference_Line_DisplayName_Description'),
                                type: { text: true }
                            },
                            value: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_Value'),
                                description: createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                                type: { numeric: true }
                            },
                            lineColor: StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                                description: createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: StandardObjectProperties.lineStyle,
                            position: StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: StandardObjectProperties.dataLabelShow,
                            dataLabelColor: StandardObjectProperties.dataLabelColor,
                            dataLabelText: StandardObjectProperties.dataLabelText,
                            dataLabelDecimalPoints: StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: StandardObjectProperties.dataLabelDisplayUnits,
                        },
                    },
                    breakdown: {
                        displayName: createDisplayNameGetter('Visual_Waterfall_Breakdown'),
                        properties: {
                            maxBreakdowns: {
                                displayName: createDisplayNameGetter('Visual_Waterfall_MaxBreakdown'),
                                description: createDisplayNameGetter('Visual_Waterfall_MaxBreakdown_Description'),
                                type: { integer: true }
                            }
                        }
                    },
                },
                dataViewMappings: [{
                        conditions: [
                            { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Breakdown': { max: 0 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { top: {} }
                            },
                            values: {
                                select: [{ bind: { to: 'Y' } }, { for: { in: 'Tooltips' } }]
                            },
                        },
                    }, {
                        conditions: [
                            { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Breakdown': { min: 1, max: 1 } },
                        ],
                        matrix: {
                            rows: {
                                select: [{
                                        composite: [{
                                                for: { in: 'Category' },
                                            }]
                                    }],
                                /* Explicitly override the server data reduction to make it appropriate for breakdown waterfall. */
                                dataReductionAlgorithm: { window: { count: 30 } }
                            },
                            columns: {
                                for: { in: 'Breakdown' },
                                /* Explicitly override the server data reduction to make it appropriate for breakdown waterfall. */
                                dataReductionAlgorithm: { top: { count: 200 } }
                            },
                            values: {
                                select: [
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Tooltips' } },
                                ]
                            }
                        },
                    }],
                sorting: {
                    default: {},
                },
                drilldown: {
                    roles: ['Category']
                },
                grouping: {
                    groupingRules: [
                        {
                            condition: { 'Category': { min: 1, max: 1 }, 'Y': { min: 1, max: 1 } },
                            groupingTargetRole: 'Category',
                            kind: 1 /* GroupInPlace */,
                        }
                    ]
                }
            };
            if (breakdown) {
                capabilities.dataRoles.splice(1, 0, {
                    name: 'Breakdown',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_BreakdownWaterfall'),
                    description: createDisplayNameGetter('Role_DisplayName_BreakdownWaterfallDescription')
                });
            }
            return capabilities;
        }
        visuals.getWaterfallChartCapabilities = getWaterfallChartCapabilities;
        visuals.waterfallChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            sentimentColors: {
                increaseFill: { objectName: 'sentimentColors', propertyName: 'increaseFill' },
                decreaseFill: { objectName: 'sentimentColors', propertyName: 'decreaseFill' },
                totalFill: { objectName: 'sentimentColors', propertyName: 'totalFill' },
                otherFill: { objectName: 'sentimentColors', propertyName: 'otherFill' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            breakdown: {
                maxBreakdowns: { objectName: 'breakdown', propertyName: 'maxBreakdowns' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.sunburstCapabilities = {
            dataRoles: [
                {
                    name: 'Nodes',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Group'),
                }, {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                    description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: createDisplayNameGetter('Visual_Legend'),
                    description: createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        position: StandardObjectProperties.legendPosition,
                        showTitle: StandardObjectProperties.showLegendTitle,
                        titleText: StandardObjectProperties.legendTitle,
                        labelColor: StandardObjectProperties.labelColor,
                        fontSize: StandardObjectProperties.fontSize,
                    }
                },
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        fill: {
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Group'],
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                        color: StandardObjectProperties.dataColor,
                        labelDisplayUnits: StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: StandardObjectProperties.labelPrecision,
                    }
                },
                categoryLabels: {
                    displayName: createDisplayNameGetter('Visual_CategoryLabels'),
                    description: createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: StandardObjectProperties.show,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Nodes': { min: 0 }, 'Values': { max: 1 } },
                    ],
                    matrix: {
                        rows: {
                            for: { in: 'Nodes' },
                        },
                        columns: {
                            for: { in: '' },
                        },
                        values: {
                            for: { in: 'Values' }
                        },
                    }
                }],
            supportsHighlight: true,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Values', direction: 2 /* Descending */ }]
                },
            },
        };
        visuals.sunburstProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.bingSocialNewsCapabilities = {
            dataViewMappings: []
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
// -----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// -----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.bingSocialTweetsCapabilities = {
            dataViewMappings: []
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.KPIStatusWithHistoryCapabilities = {
            dataRoles: [
                {
                    name: 'Indicator',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }]
                }, {
                    name: 'TrendLine',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description')
                }, {
                    name: 'Goal',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_Goal'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_GoalDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }]
                }
            ],
            dataViewMappings: [{
                    conditions: [
                        { 'Indicator': { max: 1 }, 'TrendLine': { max: 1 }, 'Goal': { max: 2 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'TrendLine' },
                            dataReductionAlgorithm: { bottom: {} }
                        },
                        values: {
                            select: [
                                { bind: { to: 'Indicator' } },
                                { bind: { to: 'Goal' } }
                            ]
                        }
                    },
                }],
            objects: {
                general: {
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                indicator: {
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription'),
                    properties: {
                        indicatorDisplayUnits: {
                            displayName: createDisplayNameGetter('Visual_DisplayUnits'),
                            description: createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        indicatorPrecision: {
                            displayName: createDisplayNameGetter('Visual_Precision'),
                            description: createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: createDisplayNameGetter('Visual_Auto'),
                            type: { numeric: true }
                        },
                        kpiFormat: {
                            displayName: createDisplayNameGetter('TaskPane_Format'),
                            type: { text: true },
                        }
                    }
                },
                trendline: {
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description'),
                    properties: {
                        show: StandardObjectProperties.show,
                    }
                },
                goals: {
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
                    properties: {
                        showGoal: {
                            displayName: createDisplayNameGetter('Role_DisplayName_KPI_Show_Goal'),
                            type: { bool: true }
                        },
                        showDistance: {
                            displayName: createDisplayNameGetter('Role_DisplayName_KPI_Show_Distance'),
                            type: { bool: true }
                        },
                    }
                },
                status: {
                    displayName: createDisplayNameGetter('Role_DisplayName_KPI_Color_Coding'),
                    description: createDisplayNameGetter('Role_DisplayName_KPI_Color_Coding'),
                    properties: {
                        direction: {
                            displayName: createDisplayNameGetter('Visual_KPI_Direction'),
                            type: { enumeration: visuals.kpiDirection.type }
                        },
                        goodColor: {
                            displayName: createDisplayNameGetter('Visual_KPI_Good_Color'),
                            type: { fill: { solid: { color: true } } }
                        },
                        neutralColor: {
                            displayName: createDisplayNameGetter('Visual_KPI_Neutral_Color'),
                            type: { fill: { solid: { color: true } } }
                        },
                        badColor: {
                            displayName: createDisplayNameGetter('Visual_KPI_Bad_Color'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        var role = visuals.ShapeMapType.Role;
        visuals.shapeMapCapabilities = {
            dataRoles: [
                {
                    name: role.category,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Location'),
                    description: createDisplayNameGetter('Role_DisplayName_LocationMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: role.series,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: role.value,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: role.tooltips,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Tooltips'),
                    joinPredicate: 0 /* None */,
                }
            ],
            objects: {
                // Order of objects will affect UI layout and should be consistent between visuals that have the same properties.
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                legend: visuals.StandardObjectDescriptors.legend,
                dataPoint: {
                    displayName: createDisplayNameGetter('Visual_DataPoint'),
                    description: createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: StandardObjectProperties.defaultColor,
                        defaultCategoryColor: StandardObjectProperties.defaultCategoryColor,
                        showAllDataPoints: StandardObjectProperties.showAllDataPoints,
                        fill: StandardObjectProperties.fill,
                        fillRule: {
                            displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                            description: createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                            type: { fillRule: {} },
                            rule: {
                                conditions: [{ 'Series': { max: 0 } }],
                                inputRole: role.value,
                                output: {
                                    property: 'fill',
                                    selector: [role.category],
                                },
                            },
                        }
                    }
                },
                shape: {
                    displayName: createDisplayNameGetter('Visual_ShapeMap_Shape'),
                    description: createDisplayNameGetter('Visual_ShapeMap_Shape_Desc'),
                    properties: {
                        map: {
                            // no displayName - shapeMapSelectorController has its own internal label
                            type: { geoJson: {} },
                        },
                        projectionEnum: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_Projection'),
                            description: createDisplayNameGetter('Visual_ShapeMap_Projection_Desc'),
                            type: { enumeration: visuals.ShapeMapType.Projection.type },
                        },
                    },
                },
                defaultColors: {
                    displayName: createDisplayNameGetter('Visual_ShapeMap_DefaultColor'),
                    description: createDisplayNameGetter('Visual_ShapeMap_DefaultColor_Desc'),
                    properties: {
                        defaultShow: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_DefaultShow'),
                            description: createDisplayNameGetter('Visual_ShapeMap_DefaultShow_Desc'),
                            type: { bool: true },
                        },
                        defaultColor: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_DefaultColorColor'),
                            description: createDisplayNameGetter('Visual_ShapeMap_DefaultColorColor_Desc'),
                            type: { fill: { solid: { color: true } } },
                        },
                        borderColor: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_BorderColor'),
                            description: createDisplayNameGetter('Visual_ShapeMap_BorderColor_Desc'),
                            type: { fill: { solid: { color: true } } },
                        },
                        borderThickness: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_BorderThickness'),
                            description: createDisplayNameGetter('Visual_ShapeMap_BorderThickness_Desc'),
                            type: { numeric: true },
                        },
                    },
                },
                zoom: {
                    displayName: createDisplayNameGetter('Visual_ShapeMap_Zoom'),
                    description: createDisplayNameGetter('Visual_ShapeMap_Zoom_Desc'),
                    properties: {
                        autoZoom: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_AutoZoom'),
                            description: createDisplayNameGetter('Visual_ShapeMap_AutoZoom_Desc'),
                            type: { bool: true },
                        },
                        selectionZoom: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_SelectionZoom'),
                            description: createDisplayNameGetter('Visual_ShapeMap_SelectionZoom_Desc'),
                            type: { bool: true },
                        },
                        manualZoom: {
                            displayName: createDisplayNameGetter('Visual_ShapeMap_ManualZoom'),
                            description: createDisplayNameGetter('Visual_ShapeMap_ManualZoom_Desc'),
                            type: { bool: true },
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        (_a = {}, _a[role.category] = { min: 0, max: 1 }, _a[role.series] = { min: 0, max: 1 }, _a[role.value] = { min: 0, max: 1 }, _a),
                    ],
                    categorical: {
                        categories: {
                            for: { in: role.category },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: role.series,
                                select: [{ bind: { to: role.value } }, { for: { in: role.tooltips } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                    },
                }],
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: role.value, direction: 2 /* Descending */ }]
                },
            },
        };
        visuals.shapeMapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            shape: {
                mapId: { objectName: 'shape', propertyName: 'mapId', },
                projectionEnum: { objectName: 'shape', propertyName: 'projectionEnum', },
                map: { objectName: 'shape', propertyName: 'map', },
            },
            zoom: {
                autoZoom: { objectName: 'zoom', propertyName: 'autoZoom', },
                selectionZoom: { objectName: 'zoom', propertyName: 'selectionZoom', },
                manualZoom: { objectName: 'zoom', propertyName: 'manualZoom', },
            },
            defaultColors: {
                defaultShow: { objectName: 'defaultColors', propertyName: 'defaultShow', },
                defaultColor: { objectName: 'defaultColors', propertyName: 'defaultColor', },
                borderColor: { objectName: 'defaultColors', propertyName: 'borderColor', },
                borderThickness: { objectName: 'defaultColors', propertyName: 'borderThickness', },
            },
        };
        var _a;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.tableExCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values'),
                }],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                grid: {
                    displayName: createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: StandardObjectProperties.outlineColor,
                        outlineWeight: StandardObjectProperties.outlineWeight,
                        gridVertical: {
                            displayName: createDisplayNameGetter('Visual_GridVertical'),
                            description: createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: createDisplayNameGetter('Visual_RowPadding'),
                            description: createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                        imageHeight: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ImageHeight'),
                            description: createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
                            type: { numeric: true }
                        },
                    }
                },
                columnHeaders: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        backColor: StandardObjectProperties.backColor,
                        alignment: StandardObjectProperties.textAlignment,
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_Adjust_Column_Width'),
                            suppressFormatPainterCopy: true,
                        },
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        },
                    }
                },
                values: {
                    displayName: createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        // backColor overrides backColorPrimary and Secondary (e.g., in the case of conditional formatting)
                        backColor: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        // fontColor overrides fontColorPrimary and Secondary (e.g., in the case of conditional formatting)
                        fontColor: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_FontColor'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        fontColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        urlIcon: {
                            displayName: createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        },
                    }
                },
                total: {
                    displayName: createDisplayNameGetter('Visual_Tablix_TotalGrand'),
                    properties: {
                        totals: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_Totals'),
                            suppressFormatPainterCopy: true,
                        },
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        backColor: StandardObjectProperties.backColor,
                    }
                },
                columnFormatting: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        alignment: StandardObjectProperties.textAlignment,
                        styleHeader: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorHeader'),
                            type: { bool: true }
                        },
                        styleValues: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorValues'),
                            type: { bool: true }
                        },
                        styleTotal: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorTotal'),
                            type: { bool: true }
                        },
                        dataBars: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_DataBars'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_DataBars_Desc'),
                            type: { dataBars: {} },
                            suppressFormatPainterCopy: true,
                        }
                    }
                },
                columnWidth: {
                    properties: {
                        value: {
                            type: { numeric: true }
                        },
                    },
                },
                clustering: {
                    suppressFormatPainterCopy: true,
                    properties: {
                        transform: {
                            type: { queryTransform: {} }
                        }
                    }
                },
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            sorting: {
                default: {},
                custom: {},
            },
            suppressDefaultTitle: true,
            grouping: {
                cluster: {
                    clusteringRole: 'Values',
                    conditions: [
                        { 'Values': { min: 2 } },
                    ]
                }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
        var StandardObjectProperties = visuals.StandardObjectProperties;
        visuals.pivotTableCapabilities = {
            dataRoles: [
                {
                    name: visuals.matrixRoleNames.rows,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Rows'),
                    description: createDisplayNameGetter('Role_DisplayName_RowsDescription')
                }, {
                    name: visuals.matrixRoleNames.columns,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: createDisplayNameGetter('Role_DisplayName_Columns'),
                    description: createDisplayNameGetter('Role_DisplayName_ColumnsDescription')
                }, {
                    name: visuals.matrixRoleNames.values,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: createDisplayNameGetter('Role_DisplayName_Values')
                }
            ],
            objects: {
                general: {
                    displayName: createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: StandardObjectProperties.formatString,
                    },
                },
                grid: {
                    displayName: createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: StandardObjectProperties.outlineColor,
                        outlineWeight: StandardObjectProperties.outlineWeight,
                        gridVertical: {
                            displayName: createDisplayNameGetter('Visual_GridVertical'),
                            description: createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: createDisplayNameGetter('Visual_RowPadding'),
                            description: createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                        textSize: {
                            displayName: createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                        imageHeight: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ImageHeight'),
                            description: createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
                            type: { numeric: true }
                        },
                    },
                },
                columnHeaders: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        backColor: StandardObjectProperties.backColor,
                        alignment: StandardObjectProperties.textAlignment,
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_Adjust_Column_Width'),
                            suppressFormatPainterCopy: true,
                        },
                        urlIcon: {
                            displayName: createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        }
                    }
                },
                rowHeaders: {
                    displayName: createDisplayNameGetter('Visual_Tablix_RowHeaders'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        backColor: StandardObjectProperties.backColor,
                        alignment: StandardObjectProperties.textAlignment,
                        stepped: {
                            displayName: createDisplayNameGetter('Visual_PivotTable_SteppedLayout'),
                            description: createDisplayNameGetter('Visual_PivotTable_SteppedLayout_Description'),
                            type: { bool: true }
                        },
                        steppedLayoutIndentation: {
                            displayName: createDisplayNameGetter('Visual_PivotTable_SteppedLayoutIndentation'),
                            description: createDisplayNameGetter('Visual_PivotTable_SteppedLayoutIndentation_Description'),
                            type: { numeric: true }
                        },
                        urlIcon: {
                            displayName: createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        },
                    }
                },
                values: {
                    displayName: createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        // backColor overrides backColorPrimary and Secondary (e.g., in the case of conditional formatting)
                        backColor: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_BackColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        // fontColor overrides fontColorPrimary and Secondary (e.g., in the case of conditional formatting)
                        fontColor: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_FontColor'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_ColorScales_FontColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        fontColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        bandedRowHeaders: {
                            displayName: createDisplayNameGetter('Visual_PivotTable_ValuesBandedRowHeaders'),
                            description: createDisplayNameGetter('Visual_PivotTable_ValuesBandedRowHeaders_Description'),
                            type: { bool: true },
                        },
                        urlIcon: {
                            displayName: createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                        wordWrap: {
                            displayName: createDisplayNameGetter('Visual_Word_Wrap'),
                            type: { bool: true },
                        },
                        valuesOnRow: {
                            displayName: createDisplayNameGetter('Visual_PivotTable_ValuesOnRow'),
                            description: createDisplayNameGetter('Visual_PivotTable_ValuesOnRow_Description'),
                            type: { bool: true }
                        },
                    }
                },
                subTotals: {
                    displayName: createDisplayNameGetter('Visual_Tablix_TotalSub'),
                    properties: {
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        backColor: StandardObjectProperties.backColor,
                        rowSubtotals: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_SubtotalRow'),
                            description: createDisplayNameGetter('Visual_SubtotalRow_Desc'),
                            suppressFormatPainterCopy: true,
                        },
                        rowSubtotalsPosition: {
                            displayName: createDisplayNameGetter('Visual_SubtotalRow_Position'),
                            type: { enumeration: visuals.rowSubtotalPosition.type },
                            suppressFormatPainterCopy: true,
                        },
                        perRowLevel: {
                            displayName: createDisplayNameGetter('Visual_SubtotalRow_PerLevel'),
                            type: { bool: true },
                            suppressFormatPainterCopy: true,
                        },
                        columnSubtotals: {
                            type: { bool: true },
                            displayName: createDisplayNameGetter('Visual_SubtotalColumn'),
                            description: createDisplayNameGetter('Visual_SubtotalColumn_Desc'),
                            suppressFormatPainterCopy: true,
                        },
                        perColumnLevel: {
                            displayName: createDisplayNameGetter('Visual_SubtotalColumn_PerLevel'),
                            type: { bool: true },
                            suppressFormatPainterCopy: true,
                        },
                        applyToHeaders: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ApplyToHeaders'),
                            type: { bool: true },
                        },
                        /** Toggle for per-level Subtotal enabled */
                        levelSubtotalEnabled: {
                            type: { bool: true },
                        }
                    }
                },
                total: {
                    displayName: createDisplayNameGetter('Visual_Tablix_Matrix_TotalGrand'),
                    properties: {
                        // Unused
                        outline: StandardObjectProperties.outline,
                        fontColor: StandardObjectProperties.fontColor,
                        fontFamily: StandardObjectProperties.fontFamily,
                        fontSize: StandardObjectProperties.fontSize,
                        backColor: StandardObjectProperties.backColor,
                        applyToHeaders: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ApplyToHeaders'),
                            type: { bool: true },
                        }
                    }
                },
                columnFormatting: {
                    displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting'),
                    properties: {
                        fontColor: StandardObjectProperties.fontColor,
                        backColor: StandardObjectProperties.backColor,
                        alignment: StandardObjectProperties.textAlignment,
                        styleHeader: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorHeader'),
                            type: { bool: true }
                        },
                        styleValues: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorValues'),
                            type: { bool: true }
                        },
                        styleSubtotals: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorSubTotals'),
                            type: { bool: true }
                        },
                        styleTotal: {
                            displayName: createDisplayNameGetter('Visual_Tablix_ColumnFormatting_ColorTotal'),
                            type: { bool: true }
                        },
                        dataBars: {
                            displayName: createDisplayNameGetter('Visual_ConditionalFormatting_DataBars'),
                            description: createDisplayNameGetter('Visual_ConditionalFormatting_DataBars_Desc'),
                            type: { dataBars: {} },
                            suppressFormatPainterCopy: true,
                        }
                    }
                },
                columnWidth: {
                    properties: {
                        value: {
                            type: { numeric: true }
                        },
                    },
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Rows': { max: 0 }, 'Columns': { max: 0 }, 'Values': { min: 1 } },
                        { 'Rows': { min: 1 }, 'Columns': { min: 0 }, 'Values': { min: 0 } },
                        { 'Rows': { min: 0 }, 'Columns': { min: 1 }, 'Values': { min: 0 } }
                    ],
                    matrix: {
                        rows: {
                            for: { in: 'Rows' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        columns: {
                            for: { in: 'Columns' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { top: { count: 100 } }
                        },
                        values: {
                            for: { in: 'Values' }
                        }
                    }
                }],
            dataRoleTotals: [{
                    roles: [visuals.matrixRoleNames.columns],
                    displayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfColumnTotal'),
                    shortDisplayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfColumnTotalShort'),
                    tooltip: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfColumnTotalTooltip')
                }, {
                    roles: [visuals.matrixRoleNames.rows],
                    displayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfRowTotal'),
                    shortDisplayName: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfRowTotalShort'),
                    tooltip: createDisplayNameGetter('DisplayName_QuickCalc_PercentOfRowTotalTooltip')
                }],
            filterMappings: {
                measureFilter: {
                    targetRoles: [visuals.matrixRoleNames.rows]
                }
            },
            sorting: {
                default: {},
                custom: {},
            },
            drilldown: {
                roles: [visuals.matrixRoleNames.rows, visuals.matrixRoleNames.columns]
            },
            suppressDefaultTitle: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var capabilities;
        (function (capabilities) {
            // This file registers the built-in capabilities
            // Please use this file to register the capabilities in the plugins.ts/pluginsNotForOSS.ts
            capabilities.animatedNumber = powerbi.visuals.animatedNumberCapabilities;
            capabilities.areaChart = powerbi.visuals.getLineChartCapabilities(false /*isStacked*/, true /*isArea*/, false /* binnedLineSample */);
            capabilities.barChart = powerbi.visuals.getColumnChartCapabilities(true /* transposeAxes */, true /*isStacked*/);
            capabilities.card = powerbi.visuals.cardCapabilities;
            capabilities.multiRowCard = powerbi.visuals.multiRowCardCapabilities;
            capabilities.clusteredBarChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.clusteredColumnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.columnChart = powerbi.visuals.getColumnChartCapabilities(false /* transposeAxes */, true /*isStacked*/);
            capabilities.comboChart = powerbi.visuals.getComboChartCapabilities(false /*isStacked*/);
            capabilities.dataDotChart = powerbi.visuals.dataDotChartCapabilities;
            capabilities.dataDotClusteredColumnComboChart = powerbi.visuals.getComboChartCapabilities(false /*isStacked*/);
            capabilities.dataDotStackedColumnComboChart = powerbi.visuals.getComboChartCapabilities(true /*isStacked*/);
            capabilities.donutChart = powerbi.visuals.donutChartCapabilities;
            capabilities.funnel = powerbi.visuals.funnelChartCapabilities;
            capabilities.gauge = powerbi.visuals.gaugeCapabilities;
            capabilities.hundredPercentStackedBarChart = powerbi.visuals.getColumnChartCapabilities(true, true /*isStacked*/);
            capabilities.hundredPercentStackedColumnChart = powerbi.visuals.getColumnChartCapabilities(false, true /*isStacked*/);
            capabilities.ribbonChart = powerbi.visuals.getColumnChartCapabilities(false, true /*isStacked*/, true /*isRibbonChart*/);
            capabilities.image = powerbi.visuals.imageVisualCapabilities;
            capabilities.lineChart = powerbi.visuals.getLineChartCapabilities(false /*isStacked*/, false /*isArea*/, false /* binnedLineSampling */);
            capabilities.stackedAreaChart = powerbi.visuals.getLineChartCapabilities(true /*isStacked*/, true /*isArea*/, false /* binnedLineSampling */);
            capabilities.lineStackedColumnComboChart = powerbi.visuals.getComboChartCapabilities(true /*isStacked*/);
            capabilities.lineClusteredColumnComboChart = powerbi.visuals.getComboChartCapabilities(false /*isStacked*/);
            capabilities.map = powerbi.visuals.mapCapabilities;
            capabilities.filledMap = powerbi.visuals.filledMapCapabilities;
            capabilities.shapeMap = powerbi.visuals.shapeMapCapabilities;
            capabilities.treemap = powerbi.visuals.treemapCapabilities;
            capabilities.pieChart = powerbi.visuals.donutChartCapabilities;
            capabilities.scatterChart = powerbi.visuals.getScatterChartCapabilities(false /*useMatrixDV*/, false /*overlappingPointsSample*/, false /* scatterXYGrouping */);
            capabilities.table = powerbi.visuals.tableCapabilities;
            capabilities.matrix = powerbi.visuals.matrixCapabilities;
            capabilities.slicer = powerbi.visuals.slicerCapabilities;
            capabilities.textbox = powerbi.visuals.textboxCapabilities;
            capabilities.waterfallChart = powerbi.visuals.getWaterfallChartCapabilities(false /*breakdown*/);
            capabilities.cheerMeter = powerbi.visuals.cheerMeterCapabilities;
            capabilities.heatMap = powerbi.visuals.mapCapabilities;
            capabilities.sunburst = powerbi.visuals.sunburstCapabilities;
            capabilities.scriptVisual = powerbi.visuals.scriptVisualCapabilities;
            capabilities.kpi = powerbi.visuals.KPIStatusWithHistoryCapabilities;
            capabilities.realTimeLineChart = powerbi.visuals.realTimeLineChartCapabilities;
            capabilities.accessibleTable = powerbi.visuals.accessibleTableCapabilities;
        })(capabilities = visuals.capabilities || (visuals.capabilities = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LegendBehavior = /** @class */ (function () {
            function LegendBehavior() {
            }
            LegendBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var legendItems = options.legendItems;
                this.legendIcons = options.legendIcons;
                this.legendLines = options.legendLines;
                var clearCatcher = options.clearCatcher;
                visuals.InteractivityUtils.registerStandardSelectionHandler(legendItems, selectionHandler);
                clearCatcher.on('click', (function () {
                    if (!d3.event.ctrlKey) {
                        selectionHandler.handleClearSelection();
                    }
                }));
            };
            LegendBehavior.prototype.renderSelection = function (hasSelection) {
                if (hasSelection) {
                    this.legendIcons.style({
                        'fill': function (d) {
                            if (!d.selected)
                                return LegendBehavior.dimmedLegendColor;
                            else
                                return d.color;
                        },
                        'stroke': function (d) {
                            if (!d.selected)
                                return LegendBehavior.dimmedLegendColor;
                            else
                                return d.color;
                        }
                    });
                    this.legendLines.style({
                        'stroke': function (d) {
                            if (!d.selected)
                                return LegendBehavior.dimmedLegendColor;
                            else
                                return d.lineColor;
                        }
                    });
                }
                else {
                    this.legendIcons.style({
                        'fill': function (d) {
                            return d.color;
                        },
                        'stroke': function (d) {
                            return d.color;
                        }
                    });
                    this.legendLines.style({
                        'stroke': function (d) {
                            return d.lineColor;
                        }
                    });
                }
            };
            LegendBehavior.dimmedLegendColor = '#A6A6A6';
            return LegendBehavior;
        }());
        visuals.LegendBehavior = LegendBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LabelsBehavior = /** @class */ (function () {
            function LabelsBehavior() {
            }
            LabelsBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.labelItems = options.labelItems;
                visuals.InteractivityUtils.registerStandardSelectionHandler(this.labelItems, selectionHandler);
            };
            LabelsBehavior.prototype.renderSelection = function (hasSelection) {
                if (hasSelection) {
                    this.labelItems.style({
                        'opacity': function (d) {
                            if (!d.selected)
                                return LabelsBehavior.DimmedLabelOpacity;
                            else
                                return LabelsBehavior.DefaultLabelOpacity;
                        }
                    });
                }
                else {
                    this.labelItems.style({
                        'opacity': LabelsBehavior.DefaultLabelOpacity,
                    });
                }
            };
            LabelsBehavior.DefaultLabelOpacity = 1;
            LabelsBehavior.DimmedLabelOpacity = 0.6;
            return LabelsBehavior;
        }());
        visuals.LabelsBehavior = LabelsBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AxisTickCollisionUtils;
        (function (AxisTickCollisionUtils) {
            var NoCollisionDetector = /** @class */ (function () {
                function NoCollisionDetector() {
                }
                NoCollisionDetector.prototype.willCollide = function (center) {
                    return false;
                };
                NoCollisionDetector.prototype.addItem = function (center) {
                    // No action needed
                };
                NoCollisionDetector.prototype.skipItem = function (center) {
                    // No action needed
                };
                return NoCollisionDetector;
            }());
            AxisTickCollisionUtils.NoCollisionDetector = NoCollisionDetector;
            var CollisionDetector = /** @class */ (function () {
                function CollisionDetector(startLeftEdge, fontOffsetLeft, fontOffsetRight) {
                    this.fontOffsetLeft = fontOffsetLeft;
                    this.fontOffsetRight = fontOffsetRight;
                    this.previousLabelRightEdge = startLeftEdge;
                }
                CollisionDetector.prototype.willCollide = function (center) {
                    var leftEdge = center - this.fontOffsetLeft;
                    return leftEdge <= this.previousLabelRightEdge;
                };
                CollisionDetector.prototype.addItem = function (center) {
                    this.previousLabelRightEdge = center + this.fontOffsetRight;
                };
                CollisionDetector.prototype.skipItem = function (center) {
                    // No action needed
                };
                return CollisionDetector;
            }());
            AxisTickCollisionUtils.CollisionDetector = CollisionDetector;
            var HierarchicalCollisionDetector = /** @class */ (function () {
                function HierarchicalCollisionDetector(startLeftEdge, fontOffsetLeft, fontOffsetRight, currentNode, scale, halfCategoryThickness, rotationPadding) {
                    this.fontOffsetLeft = fontOffsetLeft;
                    this.fontOffsetRight = fontOffsetRight;
                    this.currentNode = currentNode;
                    this.scale = scale;
                    this.halfCategoryThickness = halfCategoryThickness;
                    this.rotationPadding = rotationPadding;
                    this.previousLabelRightEdge = startLeftEdge;
                    this.index = 0;
                    var lastChildIndex = HierarchicalCollisionDetector.getLastChildIndex(currentNode, 0);
                    this.groupEndPosition = scale(lastChildIndex) + halfCategoryThickness - rotationPadding;
                }
                HierarchicalCollisionDetector.prototype.willCollide = function (center) {
                    if (!HierarchicalCollisionDetector.isLastChild(this.currentNode)) {
                        var labelRightEdge = center + this.fontOffsetRight;
                        return labelRightEdge > this.groupEndPosition;
                    }
                    var leftEdge = center - this.fontOffsetLeft;
                    return leftEdge <= this.previousLabelRightEdge;
                };
                HierarchicalCollisionDetector.prototype.addItem = function (center) {
                    this.moveToNextNode(center);
                };
                HierarchicalCollisionDetector.prototype.skipItem = function (center) {
                    this.moveToNextNode(center);
                };
                HierarchicalCollisionDetector.prototype.moveToNextNode = function (center) {
                    var previousNode = this.currentNode;
                    var currentNode = this.currentNode = this.currentNode.next;
                    this.index++;
                    if (HierarchicalCollisionDetector.isLastChild(previousNode)) {
                        this.previousLabelRightEdge = this.groupEndPosition + (this.rotationPadding * 2);
                        var newLastChildIndex = HierarchicalCollisionDetector.getLastChildIndex(currentNode, this.index);
                        this.groupEndPosition = this.scale(newLastChildIndex) + this.halfCategoryThickness - this.rotationPadding;
                    }
                    else {
                        this.previousLabelRightEdge = center + this.fontOffsetRight;
                    }
                };
                HierarchicalCollisionDetector.isLastChild = function (node) {
                    return node.next == null || node.parent !== node.next.parent;
                };
                HierarchicalCollisionDetector.getLastChildIndex = function (startNode, startIndex) {
                    var currentNode = startNode;
                    var currentIndex = startIndex;
                    while (!HierarchicalCollisionDetector.isLastChild(currentNode)) {
                        currentIndex++;
                        currentNode = currentNode.next;
                    }
                    return currentIndex;
                };
                return HierarchicalCollisionDetector;
            }());
            AxisTickCollisionUtils.HierarchicalCollisionDetector = HierarchicalCollisionDetector;
        })(AxisTickCollisionUtils = visuals.AxisTickCollisionUtils || (visuals.AxisTickCollisionUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AxisTickCollisionUtils = powerbi.visuals.AxisTickCollisionUtils;
        var API = jsCommon.API;
        var FontSize = visuals.Units.FontSize;
        var PixelConverter = jsCommon.PixelConverter;
        /**
         * Default ranges are for when we have a field chosen for the axis,
         * but no values are returned by the query.
         */
        visuals.emptyDomain = [0, 0];
        var AxisOrientation;
        (function (AxisOrientation) {
            // Names of these enums match the values passed into axis.orient([orientation])
            AxisOrientation[AxisOrientation["top"] = 0] = "top";
            AxisOrientation[AxisOrientation["bottom"] = 1] = "bottom";
            AxisOrientation[AxisOrientation["left"] = 2] = "left";
            AxisOrientation[AxisOrientation["right"] = 3] = "right";
        })(AxisOrientation = visuals.AxisOrientation || (visuals.AxisOrientation = {}));
        var AxisHelper;
        (function (AxisHelper) {
            var XLabelMaxAllowedOverflow = 35;
            var MinTickCount = 2;
            var DefaultBestTickCount = 3;
            var LeftPadding = 10;
            var ScalarTickLabelPadding = 3;
            AxisHelper.stackedAxisPadding = 5;
            AxisHelper.DefaultInnerTickSize = 6;
            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                if (availableWidth < 300)
                    return 3;
                if (availableWidth < 500)
                    return 5;
                return 8;
            }
            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                if (availableWidth < 150)
                    return 3;
                if (availableWidth < 300)
                    return 5;
                return 8;
            }
            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
            /**
             * Get the best number of ticks based on minimum value, maximum value,
             * measure metadata and max tick count.
             *
             * @param min The minimum of the data domain.
             * @param max The maximum of the data domain.
             * @param valuesMetadata The measure metadata array.
             * @param maxTickCount The max count of intervals.
             * @param isDateTime - flag to show single tick when min is equal to max.
             * @param allowSingleTick - flag to indicate whether a single tick can be used when min === max
             */
            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime, allowSingleTick) {
                debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
                if (isNaN(min) || isNaN(max))
                    return DefaultBestTickCount;
                // If the min and max are the same, we only have 1 value.
                // Suggest showing 1 tick if we're allowed, otherwise use the default.
                if (min === max) {
                    return allowSingleTick || !!isDateTime ? 1 : DefaultBestTickCount;
                }
                debug.assert(min <= max, "min value needs to be less or equal to max value");
                if (maxTickCount <= 1 || (max <= 1 && min >= -1))
                    return maxTickCount;
                if (hasNonIntegerData(valuesMetadata))
                    return maxTickCount;
                // e.g. 5 - 2 + 1 = 4, => [2,3,4,5]
                return Math.min(max - min + 1, maxTickCount);
            }
            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
            function hasNonIntegerData(valuesMetadata) {
                for (var i = 0, len = valuesMetadata.length; i < len; i++) {
                    var currentMetadata = valuesMetadata[i];
                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
                        return true;
                    }
                }
                return false;
            }
            AxisHelper.hasNonIntegerData = hasNonIntegerData;
            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
                if (!isScalar || isOrdinalScale(scale)) {
                    return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
                }
                else if (isDateTime(axisType)) {
                    return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
                }
                return getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
            }
            AxisHelper.getRecommendedTickValues = getRecommendedTickValues;
            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                var tickLabels = [];
                // return no ticks in this case
                if (maxTicks <= 0)
                    return tickLabels;
                var len = labels.length;
                if (maxTicks > len)
                    return labels;
                for (var i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) {
                    tickLabels.push(labels[i]);
                }
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
            function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
                var tickLabels = [];
                //if maxticks is zero return none
                if (maxTicks === 0)
                    return tickLabels;
                var quantitiveScale = scale;
                var tickCount = maxTicks;
                if (quantitiveScale.ticks) {
                    tickLabels = quantitiveScale.ticks(tickCount);
                    if (tickLabels.length > maxTicks && maxTicks > 1) {
                        tickCount = maxTicks - 1;
                        tickLabels = quantitiveScale.ticks(tickCount);
                    }
                    if (tickLabels.length < MinTickCount) {
                        tickCount = maxTicks + 1;
                        tickLabels = quantitiveScale.ticks(tickCount);
                    }
                    if (minInterval && tickLabels.length > 1) {
                        var tickInterval = tickLabels[1] - tickLabels[0];
                        while (tickInterval > 0 && powerbi.Double.lessWithPrecision(tickInterval, minInterval) && tickCount > 2) {
                            tickCount--;
                            tickLabels = quantitiveScale.ticks(tickCount);
                            if (tickLabels.length < MinTickCount) {
                                tickLabels = quantitiveScale.ticks(++tickCount);
                                break;
                            }
                            tickInterval = tickLabels[1] - tickLabels[0];
                        }
                    }
                    tickLabels = createTrueZeroTickLabel(tickLabels);
                    debug.assert(tickLabels.length === 0 || (tickLabels[0] >= scale.domain()[0] && tickLabels[tickLabels.length - 1] <= scale.domain()[1]), "getRecommendedTickValuesForAQuantitativeRange should not generate tick values outside the scale");
                    return tickLabels;
                }
                debug.assertFail('must pass a quantitative scale to this method');
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange;
            /**
             * Round out very small zero tick values (e.g. -1e-33 becomes 0).
             *
             * @param ticks Array of numbers (from d3.scale.ticks([maxTicks])).
             * @param epsilon Max ratio of calculated tick interval which we will recognize as zero.
             *
             * e.g.
             *     ticks = [-2, -1, 1e-10, 3, 4]; epsilon = 1e-5;
             *     closeZero = 1e-5 * | 2 - 1 | = 1e-5
             *     // Tick values <= 1e-5 replaced with 0
             *     return [-2, -1, 0, 3, 4];
             */
            function createTrueZeroTickLabel(ticks, epsilon) {
                if (epsilon === void 0) { epsilon = 1e-5; }
                if (!ticks || ticks.length < 2)
                    return ticks;
                var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                return ticks.map((function (tick) { return Math.abs(tick) <= closeZero ? 0 : tick; }));
            }
            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                var tickLabels = [];
                if (dataDomain[0] === 0 && dataDomain[1] === 0)
                    return [];
                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                tickLabels = dateTimeTickLabels.map((function (d) { return d.getTime(); }));
                tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                return tickLabels;
            }
            function normalizeLinearDomain(domain, minInterval) {
                if (isNaN(domain.min) || isNaN(domain.max)) {
                    domain.min = visuals.emptyDomain[0];
                    domain.max = visuals.emptyDomain[1];
                }
                else if (domain.min === domain.max) {
                    // d3 linear scale will give zero tickValues if max === min, so we extend
                    // the extents 20% or minInterval, whichever is greater. If the domain
                    // is only 0, we ignore the minInterval.
                    if (minInterval == null || Math.abs(domain.max) * 0.2 >= minInterval) {
                        domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * 0.8;
                        domain.max = domain.max < 0 ? domain.max * 0.8 : domain.max * 1.2;
                    }
                    else if (domain.max !== 0) {
                        domain.min = domain.min - minInterval;
                        domain.max = domain.max + minInterval;
                    }
                }
                else {
                    // Check that min is very small and is a negligable portion of the whole domain.
                    // (fix floating pt precision bugs)
                    // sometimes highlight value math causes small negative numbers which makes the axis add
                    // a large tick interval instead of just rendering at zero.
                    if (Math.abs(domain.min) < 0.0001 && domain.min / (domain.max - domain.min) < 0.0001) {
                        domain.min = 0;
                    }
                }
                return domain;
            }
            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                if (getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) === 0
                    || getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) === 0) {
                    return {
                        top: 0,
                        right: xMargin,
                        bottom: yMargin,
                        left: 0
                    };
                }
                return {
                    top: 20,
                    right: 30,
                    bottom: 40,
                    left: 30
                };
            }
            AxisHelper.getMargin = getMargin;
            function getTickLabelMargins(arg1, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, properties, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                var options = arg1;
                var plotArea;
                var isHierarchical = false;
                var axesFontProperties;
                // If options.viewport exists, assume we have a property bag and pull out the information
                if (options.plotArea) {
                    plotArea = options.plotArea;
                    yMarginLimit = options.yMarginLimit;
                    textWidthMeasurer = options.textWidthMeasurer;
                    textHeightMeasurer = options.textHeightMeasurer;
                    axes = options.axes;
                    bottomMarginLimit = options.bottomMarginLimit;
                    axesFontProperties = options.axesFontProperties;
                    scrollbarVisible = options.scrollbarVisible;
                    showOnRight = options.showOnRight;
                    renderXAxis = options.renderXAxis;
                    renderY1Axis = options.renderY1Axis;
                    renderY2Axis = options.renderY2Axis;
                    isHierarchical = options.numHierarchyLevels != null && options.numHierarchyLevels > 0;
                }
                else {
                    API.deprecated('Calling getTickLabelMargins without a property bag is deprecated');
                    plotArea = arg1;
                    var axisFont = properties.fontFamily;
                    // TODO fontSize may be in em instead of px, but we assume pixels. We should make a helper to handle this conversion.
                    var fontSizeInPx = parseInt(properties.fontSize, 10);
                    axesFontProperties = {
                        x: {
                            tickLabels: { family: axisFont, size: FontSize.createFromPx(fontSizeInPx) },
                            title: { family: axisFont, size: FontSize.createFromPx(fontSizeInPx) }
                        },
                        y: {
                            tickLabels: { family: axisFont, size: FontSize.createFromPx(fontSizeInPx) },
                            title: { family: axisFont, size: FontSize.createFromPx(fontSizeInPx) }
                        },
                        y2: {
                            tickLabels: { family: axisFont, size: FontSize.createFromPx(fontSizeInPx) },
                            title: { family: axisFont, size: FontSize.createFromPx(fontSizeInPx) }
                        },
                    };
                    if (properties.fontWeight || properties.fontStyle || properties.fontVariant || properties.whiteSpace) {
                        API.deprecated('getTickLabelMargins now ignores the following properties in the "properties" object: fontWeight, fontStyle, fontVariant, whiteSpace');
                    }
                }
                debug.assertValue(axes, 'axes');
                var xAxisProperties = axes.x;
                var y1AxisProperties = axes.y1;
                var y2AxisProperties = axes.y2;
                debug.assertValue(plotArea, 'plotArea');
                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');
                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');
                debug.assertValue(xAxisProperties, 'xAxis');
                debug.assertValue(y1AxisProperties, 'yAxis');
                var xLabels = xAxisProperties.values;
                var leftOverflow = 0;
                var rightOverflow = 0;
                var topOverflow = 0;
                var bottomOverflow = 0;
                var maxWidthY1 = 0;
                var maxWidthY2 = 0;
                var xMax = 0; // bottom margin
                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;
                var scaleIsOrdinal = isOrdinalScale(xAxisProperties.scale);
                // Used for back-compat.
                // Old code used an incorrect constant for the height of non-rotated text. Changing this to the correct value resulted in margin changes and existing visuals shifting.
                // This offset converts the measured font size to old, incorrect height value (at the default font height) to prevent existing visuals from shifting. 
                var NonRotatedPaddingOffset = -5;
                var xLabelOuterPadding = 0;
                if (xAxisProperties.outerPadding !== undefined) {
                    xLabelOuterPadding = xAxisProperties.outerPadding;
                }
                else if (xAxisProperties.xLabelMaxWidth !== undefined) {
                    xLabelOuterPadding = Math.max(0, (plotArea.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
                }
                var canRenderXAxis = renderXAxis && !_.isEmpty(xLabels);
                var textHeight;
                if (getRecommendedNumberOfTicksForXAxis(plotArea.width) !== 0
                    || getRecommendedNumberOfTicksForYAxis(plotArea.height) !== 0) {
                    var rotation = void 0;
                    if (scrollbarVisible || isHierarchical)
                        rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        rotation = LabelLayoutStrategy.DefaultRotation;
                    if (renderY1Axis) {
                        var margins = visuals.AxesLayoutUtils.getAxisTickLabelMargins(y1AxisProperties, axesFontProperties.y.tickLabels, textWidthMeasurer, textHeightMeasurer);
                        maxWidthY1 = margins.maxWidth;
                        topOverflow = Math.max(topOverflow, margins.overflow.top);
                        bottomOverflow = Math.max(bottomOverflow, margins.overflow.bottom);
                    }
                    if (y2AxisProperties && renderY2Axis) {
                        var margins = visuals.AxesLayoutUtils.getAxisTickLabelMargins(y2AxisProperties, axesFontProperties.y2.tickLabels, textWidthMeasurer, textHeightMeasurer);
                        maxWidthY2 = margins.maxWidth;
                        topOverflow = Math.max(topOverflow, margins.overflow.top);
                        bottomOverflow = Math.max(bottomOverflow, margins.overflow.bottom);
                    }
                    var xAxisLabelFontProperties = axesFontProperties.x.tickLabels;
                    var xTextProperties = visuals.FontProperties.toTextProperties(xAxisLabelFontProperties);
                    var xScale = xAxisProperties.scale;
                    var xDomain = xScale.domain();
                    textHeight = textHeightMeasurer(xTextProperties);
                    if (canRenderXAxis) {
                        var maxNumLines = Math.floor(bottomMarginLimit / textHeight);
                        for (var i = 0, len = xLabels.length; i < len; i++) {
                            // find the max height of the x-labels, perhaps rotated or wrapped
                            // TODO This height doesn't account for padding
                            var height = void 0;
                            xTextProperties.text = xLabels[i];
                            var width = textWidthMeasurer(xTextProperties);
                            if (xAxisProperties.willLabelsWordBreak) {
                                var maxWidth = !_.isEmpty(xAxisProperties.xLabelMaxWidths) ? xAxisProperties.xLabelMaxWidths[i] : xAxisProperties.xLabelMaxWidth;
                                // Split label and count rows
                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(xTextProperties.text, xTextProperties, textWidthMeasurer, maxWidth, maxNumLines);
                                height = wordBreaks.length * textHeight;
                                // word wrapping will truncate at maxWidth
                                width = maxWidth;
                            }
                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
                                // Project the font heights onto the X/Y axes. 
                                // Existing logic didn't account for this space, so skip this for the default size and smaller to prevent regressions.
                                var defaultOrSmaller = xAxisLabelFontProperties.size.px <= visuals.CartesianHelper.DefaultAxisFontSizeInPx;
                                var projectedFontWidth = defaultOrSmaller ? 0 : textHeight * rotation.sine;
                                var projectedFontHeight = defaultOrSmaller ? 0 : textHeight * rotation.cosine;
                                // Add the projected values to text width projected onto the X/Y axes.
                                // This accounts for the space above the anchor point occupies. Assumes the anchor-point is at the bottom of text.
                                height = width * rotation.sine + projectedFontHeight;
                                width = width * rotation.cosine + projectedFontWidth;
                            }
                            else {
                                height = textHeight + NonRotatedPaddingOffset;
                            }
                            // calculate left and right overflow due to wide X labels
                            // (Note: no right overflow when rotated)
                            if (i === 0) {
                                if (scaleIsOrdinal) {
                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)
                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;
                                    else
                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[0]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    leftOverflow = (width / 2) - xPos;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                            }
                            else if (i === len - 1) {
                                if (scaleIsOrdinal) {
                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow
                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {
                                        // assume this label is placed near the edge
                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                        rightOverflow = Math.max(rightOverflow, 0);
                                    }
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[1]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    rightOverflow = (width / 2) - (plotArea.width - xPos);
                                    rightOverflow = Math.max(rightOverflow, 0);
                                }
                            }
                            xMax = Math.max(xMax, height);
                        }
                        // trim any actual overflow to the limit
                        leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow);
                        rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
                    }
                }
                var rightMargin = 0, leftMargin = 0, 
                // Bottom margin is the larger of either the space needed for the X-Axis labels or overflow of the Y-Axis labels capped at the bottomMarginLimit
                bottomMargin = Math.min(Math.max(bottomOverflow, Math.ceil(xMax)), bottomMarginLimit);
                if (showOnRight) {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);
                }
                else {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);
                }
                if (isHierarchical && canRenderXAxis) {
                    // Add the extra stacks for the hierarchy. bottomMargin already includes the leaf level.
                    bottomMargin += (textHeight + AxisHelper.stackedAxisPadding) * (options.numHierarchyLevels - 1);
                }
                return {
                    yTop: Math.ceil(topOverflow),
                    yLeft: Math.ceil(leftMargin),
                    yBottom: Math.ceil(bottomOverflow),
                    yRight: Math.ceil(rightMargin),
                    xMax: Math.ceil(bottomMargin),
                    stackHeight: isHierarchical ? textHeight + AxisHelper.stackedAxisPadding : undefined
                };
            }
            AxisHelper.getTickLabelMargins = getTickLabelMargins;
            /**
             * Gets the tick label margins and overflow for the given axis.
             * Currently only works for vertical axes.
             */
            function getTickLabelMarginsForAxis(axisProperties, font, fontSize, textWidthMeasurer, textHeightMeasurer) {
                // NOTE: Core visuals should use AxesLayoutUtils.getAxisTickLabelMargins instead.
                var scale = axisProperties.scale;
                var tickValues = axisProperties.axis.tickValues();
                if (_.isEmpty(tickValues)) {
                    return {
                        maxWidth: 0,
                        overflow: {
                            top: 0,
                            bottom: 0,
                        }
                    };
                }
                var axisStartValue;
                var axisEndValue;
                if (AxisHelper.isOrdinalScale(scale)) {
                    // Use rangeExtent if we have an ordinal scale to account for outerPadding
                    _a = scale.rangeExtent(), axisStartValue = _a[0], axisEndValue = _a[1];
                }
                else {
                    // otherwise just use the range
                    var range = scale.range();
                    axisStartValue = _.first(range);
                    axisEndValue = _.last(range);
                }
                var labels = axisProperties.values;
                var axisTopPosition;
                var axisTopLabelPosition;
                var axisBottomPosition;
                var axisBottomLabelPosition;
                if (axisStartValue < axisEndValue) {
                    axisTopPosition = axisStartValue;
                    axisTopLabelPosition = scale(_.first(tickValues));
                    axisBottomPosition = axisEndValue;
                    axisBottomLabelPosition = scale(_.last(tickValues));
                }
                else {
                    axisTopPosition = axisEndValue;
                    axisTopLabelPosition = scale(_.last(tickValues));
                    axisBottomPosition = axisStartValue;
                    axisBottomLabelPosition = scale(_.first(tickValues));
                }
                var textProperties = {
                    text: '' + _.first(labels),
                    fontFamily: font,
                    fontSize: PixelConverter.toString(fontSize),
                };
                var textHeight = textHeightMeasurer(textProperties);
                var topOverflow = Math.max(0, -(axisTopLabelPosition - textHeight / 2 - axisTopPosition));
                var bottomOverflow = Math.max(0, axisBottomLabelPosition + textHeight / 2 - axisBottomPosition);
                var maxWidth = 0;
                for (var i = 0, len = labels.length; i < len; i++) {
                    var textProperties_1 = {
                        text: '' + labels[i],
                        fontFamily: font,
                        fontSize: PixelConverter.toString(fontSize),
                    };
                    maxWidth = Math.max(maxWidth, textWidthMeasurer(textProperties_1));
                }
                return {
                    maxWidth: maxWidth,
                    overflow: {
                        top: topOverflow,
                        bottom: bottomOverflow,
                    }
                };
                var _a;
            }
            AxisHelper.getTickLabelMarginsForAxis = getTickLabelMarginsForAxis;
            function columnDataTypeHasValue(dataType) {
                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
            }
            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
            function createOrdinalType() {
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.createOrdinalType = createOrdinalType;
            function isOrdinal(type) {
                return !!(type && (type.text || type.bool || (type.misc && type.misc.barcode) || (type.geography && type.geography.postalCode)));
            }
            AxisHelper.isOrdinal = isOrdinal;
            function isOrdinalScale(scale) {
                return typeof scale.rangePoints === "function";
            }
            AxisHelper.isOrdinalScale = isOrdinalScale;
            function isDateTime(type) {
                return !!(type && type.dateTime);
            }
            AxisHelper.isDateTime = isDateTime;
            function invertScale(scale, x) {
                if (isOrdinalScale(scale)) {
                    return invertOrdinalScale(scale, x);
                }
                return scale.invert(x);
            }
            AxisHelper.invertScale = invertScale;
            function extent(scale) {
                if (isOrdinalScale(scale)) {
                    return scale.rangeExtent();
                }
                return scale.range();
            }
            AxisHelper.extent = extent;
            /**
             * Uses the D3 scale to get the actual category thickness.
             * @return The difference between the 1st and 2nd items in the range if there are 2 or more items in the range.
             * Otherwise, the length of the entire range.
             */
            function getCategoryThickness(scale) {
                var leftEdges = scale.range();
                if (leftEdges.length < 2) {
                    // We have 1 item if we don't have 2 edges. If we have 1 item, just use the entire axis length as the thickness.
                    if (AxisHelper.isOrdinalScale(scale)) {
                        // We should only hit this if we have an ordinal scale. Other scales should always have 2 items in their range.
                        var rangeExtent = scale.rangeExtent();
                        return rangeExtent[1] - rangeExtent[0];
                    }
                    else {
                        debug.assertFail('Unsupported axis type');
                    }
                }
                return leftEdges[1] - leftEdges[0];
            }
            AxisHelper.getCategoryThickness = getCategoryThickness;
            /**
             * Inverts the ordinal scale. If x < scale.range()[0], then scale.domain()[0] is returned.
             * Otherwise, it returns the greatest item in scale.domain() that's <= x.
             */
            function invertOrdinalScale(scale, x) {
                var width = scale.rangeBand();
                var range = scale.range();
                var domain = scale.domain();
                // If the range length is smaller than 2 or x is less than the range, just return the 1st item in the domain
                if (range.length < 2 || range[0] > x) {
                    return domain[0] || 0;
                }
                var halfInnerPadding = (range[1] - range[0] - width) / 2;
                // d3.bisect returns the index at which we can insert something so that everything before it is lesser and everything after it is greater.
                // The leftEdges don't include the inner padding, so we need to shift x over by halfInnerPadding to account it.
                // We want index - 1 since that's the greatest value less than x, meaning that's the band we're in.
                // Use that index to find the right value in the domain.
                return domain[d3.bisect(range, x + halfInnerPadding) - 1];
            }
            AxisHelper.invertOrdinalScale = invertOrdinalScale;
            function findClosestXAxisIndex(categoryValue, categoryAxisValues) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                for (var i in categoryAxisValues) {
                    var distance = Math.abs(categoryValue - categoryAxisValues[i].categoryValue);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = parseInt(i, 10);
                    }
                }
                return closestValueIndex;
            }
            AxisHelper.findClosestXAxisIndex = findClosestXAxisIndex;
            function lookupOrdinalIndex(scale, pixelValue) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var domain = scale.domain();
                if (domain.length < 2)
                    return 0;
                var halfWidth = (scale(1) - scale(0)) / 2;
                for (var idx in domain) {
                    var leftEdgeInPixels = scale(idx);
                    var midPoint = leftEdgeInPixels + halfWidth;
                    var distance = Math.abs(pixelValue - midPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = parseInt(idx, 10);
                    }
                }
                return closestValueIndex;
            }
            AxisHelper.lookupOrdinalIndex = lookupOrdinalIndex;
            /** scale(value1) - scale(value2) with zero checking and min(+/-1, result) */
            function diffScaled(scale, value1, value2) {
                debug.assertValue(scale, 'scale');
                var value = scale(value1) - scale(value2);
                if (value === 0)
                    return 0;
                if (value < 0)
                    return Math.min(value, -1);
                return Math.max(value, 1);
            }
            AxisHelper.diffScaled = diffScaled;
            function createDomain(data, axisType, isScalar, forcedScalarDomain, ensureDomain) {
                if (isScalar && !isOrdinal(axisType)) {
                    var userMin = void 0, userMax = void 0;
                    if (forcedScalarDomain && forcedScalarDomain.length === 2) {
                        userMin = forcedScalarDomain[0];
                        userMax = forcedScalarDomain[1];
                    }
                    return createScalarDomain(data, userMin, userMax, axisType, ensureDomain);
                }
                return createOrdinalDomain(data);
            }
            AxisHelper.createDomain = createDomain;
            function ensureValuesInRange(values, min, max) {
                debug.assert(min <= max, "min must be less or equal to max");
                var filteredValues = values.filter((function (v) { return v >= min && v <= max; }));
                if (filteredValues.length < 2)
                    filteredValues = [min, max];
                return filteredValues;
            }
            AxisHelper.ensureValuesInRange = ensureValuesInRange;
            /**
             * Gets the ValueType of a category column, defaults to Text if the type is not present.
             */
            function getCategoryValueType(metadataColumn, isScalar) {
                if (metadataColumn && columnDataTypeHasValue(metadataColumn.type))
                    return metadataColumn.type;
                if (isScalar) {
                    return powerbi.ValueType.fromDescriptor({ numeric: true });
                }
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.getCategoryValueType = getCategoryValueType;
            /**
             * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
             * @param options The properties used to create the axis.
             */
            function createAxis(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, outerPaddingRatio = options.outerPaddingRatio || 0, innerPaddingRatio = options.innerPaddingRatio || visuals.DefaultInnerPaddingRatio, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
                getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct, margin = options.margin;
                // line and combo charts need this to show horizontal lines at the extreme edges. CRI fix.
                // TODO: look at line thickness and/or marker size and pass in actual half width as an improvement
                if (outerPadding === 0 && isScalar && isVertical) {
                    outerPadding = 1;
                    options.outerPadding = 1; // for createScale below
                }
                var firstMetadataColumn = metaDataColumn instanceof Array ? metaDataColumn[0] : metaDataColumn;
                var dataType = AxisHelper.getCategoryValueType(firstMetadataColumn, isScalar);
                var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : undefined;
                // If a categorical axis, see if commas should be suppressed (e.g. range of years).
                if (isCategoryAxis && shouldSuppressCommasAndAutoDisplayUnits(dataType, formatString, axisDisplayUnits, dataDomain)) {
                    formatString = "0";
                    useTickIntervalForDisplayUnits = false;
                }
                // Create the Scale
                var scaleResult = AxisHelper.createScale(options, minTickInterval);
                var scale = scaleResult.scale;
                var bestTickCount = scaleResult.bestTickCount;
                var scaleDomain = scale.domain();
                var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
                // fix categoryThickness if scalar and the domain was adjusted when making the scale "nice"
                if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
                    var oldSpan = dataDomain[1] - dataDomain[0];
                    var newSpan = scaleDomain[1] - scaleDomain[0];
                    if (oldSpan > 0 && newSpan > 0) {
                        categoryThickness = categoryThickness * oldSpan / newSpan;
                    }
                }
                // Prepare Tick Values for formatting
                var tickValues;
                if (isScalar && !_.isEmpty(dataDomain) && bestTickCount === 1) {
                    tickValues = [dataDomain[0]];
                }
                else {
                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
                }
                if (options.scaleType && options.scaleType === visuals.axisScale.log && isLogScaleAllowed) {
                    tickValues = tickValues.filter((function (d) { return AxisHelper.powerOfTen(d); }));
                }
                var formatter = AxisHelper.createFormatter({
                    scaleDomain: scaleDomain,
                    dataDomain: dataDomain,
                    dataType: dataType,
                    isScalar: isScalar,
                    formatString: formatString,
                    bestTickCount: bestTickCount,
                    tickValues: tickValues,
                    useTickIntervalForDisplayUnits: useTickIntervalForDisplayUnits,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision
                });
                // sets default orientation only, cartesianChart will fix y2 for comboChart
                // tickSize(pixelSpan) is used to create gridLines
                var axis = d3.svg.axis()
                    .scale(scale)
                    .tickSize(AxisHelper.DefaultInnerTickSize, 0)
                    .orient(isVertical ? 'left' : 'bottom')
                    .ticks(bestTickCount)
                    .tickValues(tickValues);
                var formattedTickValues = [];
                if (!_.isEmpty(metaDataColumn))
                    formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn);
                var xLabelMaxWidth;
                var xLabelMaxWidths;
                // Use category layout of labels if specified, otherwise use scalar layout of labels
                if (!isScalar && categoryThickness) {
                    xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianHelper.TickLabelPadding * 2);
                }
                else {
                    if (tickValues.length > 1) {
                        // Only pass margin in when necessary
                        xLabelMaxWidth = getScalarLabelMaxWidth(scale, tickValues);
                        xLabelMaxWidth = xLabelMaxWidth - ScalarTickLabelPadding * 2;
                        if (margin) {
                            xLabelMaxWidths = getScalarLabelMaxWidths(scale, tickValues, margin, outerPadding, xLabelMaxWidth);
                            xLabelMaxWidth = undefined;
                        }
                    }
                    else {
                        xLabelMaxWidth = pixelSpan - ScalarTickLabelPadding * 2;
                    }
                }
                return {
                    scale: scale,
                    axis: axis,
                    formatter: formatter,
                    values: formattedTickValues,
                    axisType: dataType,
                    axisLabel: visuals.converterHelper.createAxisLabel(metaDataColumn),
                    isCategoryAxis: isCategoryAxis,
                    xLabelMaxWidth: xLabelMaxWidth,
                    xLabelMaxWidths: xLabelMaxWidths,
                    categoryThickness: categoryThickness,
                    outerPadding: outerPadding,
                    outerPaddingRatio: outerPaddingRatio,
                    innerPaddingRatio: innerPaddingRatio,
                    usingDefaultDomain: scaleResult.usingDefaultDomain,
                    isLogScaleAllowed: isLogScaleAllowed,
                    dataDomain: dataDomain,
                };
            }
            AxisHelper.createAxis = createAxis;
            // primarily, ensure we don't show commas in year axis
            // more generally, don't show commas or automatic display units when domain is integers with four or fewer digits
            function shouldSuppressCommasAndAutoDisplayUnits(dataType, formatString, axisDisplayUnits, dataDomain) {
                if (!dataType)
                    return false;
                if (formatString && formatString !== '0' && formatString !== 'g' && formatString !== 'G')
                    return false;
                if (axisDisplayUnits && axisDisplayUnits !== 1)
                    return false;
                if (dataType.temporal && dataType.temporal.year)
                    return true;
                if (dataType.integer && dataDomain && dataDomain.length === 2 && isFourOrFewerDigitInteger(dataDomain[0]) && isFourOrFewerDigitInteger(dataDomain[1]))
                    return true;
                return false;
            }
            function isFourOrFewerDigitInteger(n) {
                return _.isNumber(n) && n === Math.floor(n) && n > -10000 && n < 10000;
            }
            /**
             * Creates a D3 axis for stacked axis usage. `options.innerTickSize` and `options.outerTickSize` will be defaulted to 0 if not set.
             * `options.orientation` will be defaulted to "bottom" if not specified.
             */
            function createStackedAxis(options) {
                debug.assertValue(options, "options is null or undefined");
                debug.assertValue(options.axis, "options.axis is null or undefined");
                debug.assertValue(options.scale, "options.scale is null or undefined");
                debug.assertValue(options.tickFormat, "options.tickFormat is null or undefined");
                var axis = options.axis;
                var orientation = options.orient != null ? AxisOrientation[options.orient] : AxisOrientation[AxisOrientation.bottom];
                return d3.svg.axis()
                    .scale(options.scale)
                    .tickSize(options.innerTickSize || 0, options.outerTickSize || 0)
                    .orient(orientation)
                    .ticks(axis.ticks())
                    .tickValues(axis.tickValues())
                    .tickFormat(options.tickFormat);
            }
            AxisHelper.createStackedAxis = createStackedAxis;
            function getScalarLabelMaxWidth(scale, tickValues) {
                debug.assertValue(scale, "scale");
                debug.assertNonEmpty(tickValues, "tickValues");
                // find the distance between two ticks. scalar ticks can be anywhere, such as:
                // |---50----------100--------|
                if (scale && !_.isEmpty(tickValues)) {
                    return Math.abs(scale(tickValues[1]) - scale(tickValues[0]));
                }
                return 1;
            }
            // The xLabelMaxWidths only works for horizontal axis that's rendered left to right.
            function getScalarLabelMaxWidths(scale, tickValues, margin, outerPadding, maxLabelWidth) {
                var xLabelMaxWidths = _.times(tickValues.length, _.constant(maxLabelWidth));
                var marginLeft = margin.left;
                var marginRight = margin.right;
                var firstTickPosition = scale(_.first(tickValues));
                var lastTickPosition = scale(_.last(tickValues));
                var range = scale.range();
                var axisBeginPosition = range[0];
                var axisEndPosition = range[1];
                // static outer padding for scalar axes, dynamic outer padding only for ordinal axes
                // The avaliabelMaxWidth for first and last tick is 2 times the distance between the tick and begin/end of axis plus the outerPadding and the margin on the side, 
                // but it should not bigger than xLabelMaxWidth.
                // Outerpadding is set to show the whole column.
                var firstLabelMaxAllowedSpace = 2 * (Math.abs(firstTickPosition - axisBeginPosition) + marginLeft + outerPadding);
                var lastLabelMaxAllowedSpace = 2 * (Math.abs(lastTickPosition - axisEndPosition) + marginRight + outerPadding);
                xLabelMaxWidths[0] = Math.min(firstLabelMaxAllowedSpace, maxLabelWidth);
                xLabelMaxWidths[tickValues.length - 1] = Math.min(lastLabelMaxAllowedSpace, maxLabelWidth);
                return xLabelMaxWidths;
            }
            function createScale(options, minTickInterval) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, innerPadding = options.innerPaddingRatio !== undefined ? options.innerPaddingRatio : visuals.DefaultInnerPaddingRatio, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp, maxTickCount = options.maxTickCount, allowSingleTick = options.allowSingleScalarTick, preventNice = options.preventNice;
                debug.assert(!allowSingleTick || (allowSingleTick && isScalar), 'allowSingleTick should only be true if the chart is scalar');
                // Static multi-measure case will have multiple metadataColumns.
                // e.g. plotting Sales and Profit over time - Sales and Profit may have different format strings, and we need to combine their display names for the axis title.
                // Support single column also for back compat.
                var metadataColumnArray = metaDataColumn instanceof Array ? metaDataColumn : [metaDataColumn];
                var firstMetadataColumn = metadataColumnArray[0];
                var dataType = AxisHelper.getCategoryValueType(firstMetadataColumn, isScalar);
                var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                if (maxTickCount && maxTicks > maxTickCount)
                    maxTicks = maxTickCount;
                var scalarDomain = dataDomain ? dataDomain.slice() : null;
                var bestTickCount = maxTicks;
                var scale;
                var usingDefaultDomain = false;
                if (dataDomain == null || (dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null) || (dataDomain.length !== 2 && isScalar)) {
                    usingDefaultDomain = true;
                    if (dataType.dateTime || !isOrdinal(dataType))
                        dataDomain = visuals.emptyDomain;
                    else
                        dataDomain = [];
                    if (isOrdinal(dataType)) {
                        scale = createOrdinalScale(pixelSpan, dataDomain, categoryThickness ? outerPadding / categoryThickness : 0, innerPadding);
                    }
                    else {
                        scale = createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount);
                    }
                }
                else {
                    if (isScalar && dataDomain.length > 0) {
                        bestTickCount = forcedTickCount !== undefined
                            ? (maxTicks !== 0 ? forcedTickCount : 0)
                            : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], metadataColumnArray, maxTicks, dataType.dateTime, allowSingleTick);
                        var normalizedRange = normalizeLinearDomain({ min: dataDomain[0], max: dataDomain[dataDomain.length - 1] }, minTickInterval);
                        scalarDomain = [normalizedRange.min, normalizedRange.max];
                    }
                    if (isScalar && dataType.numeric && !dataType.dateTime) {
                        if (scalarDomain && scalarDomain.length === 2 && scalarDomain[0] === 0 && scalarDomain[1] === 0 && options.zeroScalarDomain) {
                            scalarDomain[0] = options.zeroScalarDomain[0];
                            scalarDomain[1] = options.zeroScalarDomain[1];
                            // If we are using a zeroScalarDomain, recalculate the best number of ticks
                            if (forcedTickCount === undefined) {
                                bestTickCount = AxisHelper.getBestNumberOfTicks(scalarDomain[0], scalarDomain[1], metadataColumnArray, maxTicks, dataType.dateTime, allowSingleTick);
                            }
                        }
                        var niceCount = bestTickCount;
                        // If we're showing a single tick, set the niceCount to 0 so the tick is centered.
                        if (preventNice || (allowSingleTick && scalarDomain.length === 2 && scalarDomain[0] === scalarDomain[1]))
                            niceCount = 0;
                        scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, niceCount, shouldClamp);
                    }
                    else if (isScalar && dataType.dateTime) {
                        // Use of a linear scale, instead of a D3.time.scale, is intentional since we want
                        // to control the formatting of the time values, since d3's implementation isn't
                        // in accordance to our design.
                        //     scalarDomain: should already be in long-int time (via category.values[0].getTime())
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp); // DO NOT PASS TICKCOUNT
                    }
                    else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
                        scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0, options.innerPaddingRatio ? options.innerPaddingRatio : visuals.DefaultInnerPaddingRatio);
                        bestTickCount = maxTicks === 0 ? 0
                            : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / visuals.CartesianHelper.MinOrdinalRectThickness);
                    }
                    else {
                        debug.assertFail('unsupported dataType, something other than text or numeric');
                    }
                }
                // vertical ordinal axis (e.g. categorical bar chart) does not need to reverse
                if (isVertical && isScalar) {
                    scale.range(scale.range().reverse());
                }
                visuals.ColumnUtil.normalizeInfinityInScale(scale);
                return {
                    scale: scale,
                    bestTickCount: bestTickCount,
                    usingDefaultDomain: usingDefaultDomain,
                };
            }
            AxisHelper.createScale = createScale;
            function createFormatter(arg1, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
                var options = arg1;
                var scaleDomain;
                if (options.scaleDomain) {
                    scaleDomain = options.scaleDomain;
                    dataDomain = options.dataDomain;
                    dataType = options.dataType;
                    isScalar = options.isScalar;
                    formatString = options.formatString;
                    bestTickCount = options.bestTickCount;
                    tickValues = options.tickValues;
                    useTickIntervalForDisplayUnits = options.useTickIntervalForDisplayUnits || false;
                    axisDisplayUnits = options.axisDisplayUnits;
                    axisPrecision = options.axisPrecision;
                    // getValueFn is not used, so it's not included in the options
                }
                else {
                    API.deprecated('Calling createFormatter without a property bag is deprecated.');
                    scaleDomain = arg1;
                    useTickIntervalForDisplayUnits = useTickIntervalForDisplayUnits || false;
                }
                var formatter;
                if (dataType.dateTime) {
                    if (isScalar) {
                        var value = new Date(scaleDomain[0]);
                        var value2 = new Date(scaleDomain[1]);
                        // datetime with only one value needs to pass the same value
                        // (from the original dataDomain value, not the adjusted scaleDomain)
                        // so formatting works correctly.
                        if (bestTickCount === 1)
                            value = value2 = new Date(dataDomain[0]);
                        // this will ignore the formatString and create one based on the smallest non-zero portion of the values supplied.
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: value,
                            value2: value2,
                            tickCount: bestTickCount,
                            columnType: dataType,
                        });
                    }
                    else {
                        // Use the model formatString for ordinal datetime
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                else {
                    if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0];
                        var options_1 = {
                            format: formatString,
                            value: value1,
                            value2: 0,
                            allowFormatBeautification: true,
                            columnType: dataType,
                        };
                        if (axisPrecision)
                            options_1.precision = axisPrecision;
                        else
                            options_1.precision = calculateAxisPrecision(tickValues[0], tickValues[1], axisDisplayUnits, formatString);
                        formatter = visuals.valueFormatter.create(options_1);
                    }
                    else if (isScalar && tickValues.length === 1) {
                        if (!axisDisplayUnits)
                            axisDisplayUnits = useTickIntervalForDisplayUnits ? _.first(tickValues) : 0;
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: axisDisplayUnits,
                            allowFormatBeautification: true,
                            precision: axisPrecision
                        });
                    }
                    else {
                        // do not use display units, just the basic value formatter
                        // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                return formatter;
            }
            AxisHelper.createFormatter = createFormatter;
            // returns # of decimal places necessary to distinguish between tick mark values
            function calculateAxisPrecision(tickValue0, tickValue1, axisDisplayUnits, formatString) {
                if (!axisDisplayUnits) {
                    var displayUnitSystem = visuals.valueFormatter.createDisplayUnitSystem();
                    displayUnitSystem.update(tickValue1 - tickValue0);
                    axisDisplayUnits = displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value || 1;
                }
                var value0 = (tickValue0 || 0) / axisDisplayUnits;
                var value1 = (tickValue1 || 0) / axisDisplayUnits;
                if (formatString) {
                    var partsPerScale = powerbi.NumberFormat.getCustomFormatMetadata(formatString, false, false, true).partsPerScale;
                    value0 *= partsPerScale;
                    value1 *= partsPerScale;
                }
                return Math.max(calculateAxisPrecisionForValue(value0), calculateAxisPrecisionForValue(value1));
            }
            AxisHelper.calculateAxisPrecision = calculateAxisPrecision;
            function calculateAxisPrecisionForValue(value) {
                if (value === 0)
                    return 0;
                if (value < 0)
                    value = -value;
                // calculate place of of the most significant decimal digit.
                // 1 means tens digit
                // 0 means the ones digit
                // -1 means tenths digit
                var mostSignificantDigit = Math.floor(powerbi.Double.log10(value));
                // rounding in various calculations can introduce extraneous amounts of precision in the number
                // no need in an axis label to allow more than this number of digits as the *difference* between
                // ticks
                var MaxDigits = 5;
                if (mostSignificantDigit >= 0) {
                    // value has an integer part but may also have a fraction part. get the number of significant
                    // digits in the integer part then see how many that leaves us for the fractional part
                    var integerSignificantDigits = mostSignificantDigit + 1;
                    var maxFractionDigits = MaxDigits - integerSignificantDigits;
                    if (maxFractionDigits <= 0) {
                        // the value's integer part has at least MaxDigits of precision
                        // so there aren't any left for the fractional part
                        return 0;
                    }
                    return numberOfDecimalPlaces(value, maxFractionDigits);
                }
                else {
                    // the interval has no integer part - it is a pure decimal fraction. we want the number
                    // of decimal places we have to allow so the precision doesn't exceed MaxDigits.
                    // knowing where there most significant digit is in the fraction, we can scale
                    // the number to the range [0.1, 1)
                    var rescaledValue = value / powerbi.Double.pow10(mostSignificantDigit + 1);
                    // get the actual number of significant digits respecting the maximum
                    var fractionSignificantDigits = numberOfDecimalPlaces(rescaledValue, MaxDigits);
                    // this is the number of zeroes that are required due to the true scale of the decimal fraction
                    var fractionScaleDigits = -mostSignificantDigit - 1;
                    // number of decimal places is the number of zeros plus the limited number of significant digits
                    return fractionScaleDigits + fractionSignificantDigits;
                }
            }
            // if we're limiting the decimal places to maxDecimalPlaces, how many decimal places do
            // we actually need to avoid trailing zeroes? for example, if the value is 1.500001 and
            // we want a maximum of three decimal places, the number rounded to three places is 1.500
            // so only one decimal place is necessary.
            function numberOfDecimalPlaces(value, maxDecimalPlaces) {
                var formattedValue = value.toFixed(maxDecimalPlaces);
                var decimalPoint = formattedValue.indexOf('.');
                if (decimalPoint !== -1) {
                    for (var i = formattedValue.length; i-- > decimalPoint;) {
                        if (formattedValue[i] !== '0') {
                            return i - decimalPoint;
                        }
                    }
                }
                return 0;
            }
            /**
             * Format the linear tick labels or the category labels.
             */
            function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
                var formattedTickValues = [];
                if (!getValueFn)
                    getValueFn = function (data) { return data; };
                if (formatter) {
                    axis.tickFormat((function (d) { return formatter.format(getValueFn(d, dataType)); }));
                    formattedTickValues = tickValues.map((function (d) { return formatter.format(getValueFn(d, dataType)); }));
                }
                else {
                    formattedTickValues = tickValues.map((function (d) { return getValueFn(d, dataType); }));
                }
                return formattedTickValues;
            }
            function getMinTickValueInterval(formatString, columnType, is100Pct) {
                var isCustomFormat = formatString && !powerbi.NumberFormat.isStandardFormat(formatString);
                if (isCustomFormat) {
                    var precision = powerbi.NumberFormat.getCustomFormatMetadata(formatString, true /*calculatePrecision*/).precision;
                    if (formatString.indexOf('%') > -1)
                        precision += 2; //percent values are multiplied by 100 during formatting
                    return Math.pow(10, -precision);
                }
                else if (is100Pct)
                    return 0.01;
                else if (columnType.integer)
                    return 1;
                return 0;
            }
            AxisHelper.getMinTickValueInterval = getMinTickValueInterval;
            function createScalarDomain(data, userMin, userMax, axisType, ensureDomain) {
                debug.assertValue(data, 'data');
                if (data.length === 0) {
                    return null;
                }
                var defaultMinX = d3.min(data, (function (kv) { return d3.min(kv.data, (function (d) { return d && d.categoryValue; })); }));
                var defaultMaxX = d3.max(data, (function (kv) { return d3.max(kv.data, (function (d) { return d && d.categoryValue; })); }));
                return combineDomain([userMin, userMax], [defaultMinX, defaultMaxX], ensureDomain);
            }
            /**
             * Creates a [min,max] from your Cartiesian data values.
             *
             * @param data The series array of CartesianDataPoints.
             * @param includeZero Columns and bars includeZero, line and scatter do not.
             */
            function createValueDomain(data, includeZero) {
                debug.assertValue(data, 'data');
                if (data.length === 0)
                    return null;
                var minY = d3.min(data, (function (kv) { return d3.min(kv.data, (function (d) { return d && d.value; })); }));
                var maxY = d3.max(data, (function (kv) { return d3.max(kv.data, (function (d) { return d && d.value; })); }));
                if (includeZero)
                    return [Math.min(minY, 0), Math.max(maxY, 0)];
                return [minY, maxY];
            }
            AxisHelper.createValueDomain = createValueDomain;
            function createOrdinalDomain(data) {
                if (_.isEmpty(data))
                    return [];
                // each series shares the same categories for oridinal axes (even if a series has some nulls)
                var domain = [];
                var firstSeries = data[0];
                for (var _i = 0, _a = firstSeries.data; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    if (!dp.highlight)
                        domain.push(dp.categoryIndex);
                }
                return domain;
            }
            var LabelLayoutStrategy;
            (function (LabelLayoutStrategy) {
                function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
                    var labels = axisProperties.values;
                    if (labels.length === 0)
                        return false;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
                        ? axisProperties.xLabelMaxWidth
                        : availableWidth / labels.length;
                    return !labels.some((function (d) {
                        properties.text = d;
                        return textMeasurer(properties) > labelMaxWidth;
                    }));
                }
                LabelLayoutStrategy.willLabelsFit = willLabelsFit;
                function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
                    var labels = axisProperties.values;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
                        ? axisProperties.xLabelMaxWidth
                        : availableWidth / labels.length;
                    var maxRotatedLength = margin.bottom / LabelLayoutStrategy.DefaultRotation.sine;
                    var height = textHeightMeasurer(properties);
                    var maxNumLines = Math.max(1, Math.floor(margin.bottom / height)); // TODO: not taking axis label into account
                    if (labels.length === 0)
                        return false;
                    // If no break character and exceeds max width, word breaking will not work, return false
                    var mustRotate = labels.some((function (label) {
                        // Detect must rotate and return immediately
                        properties.text = label;
                        return !jsCommon.WordBreaker.hasBreakers(label) && textWidthMeasurer(properties) > labelMaxWidth;
                    }));
                    if (mustRotate)
                        return false;
                    var moreWordBreakChars = labels.filter((function (label, index) {
                        // ...otherwise compare rotation versus word breaking
                        var allowedLengthProjectedOnXAxis = 
                        // Left margin is the width of Y axis.
                        margin.left
                            // There could be a padding before the first category.
                            + axisProperties.outerPadding
                            // Align the rotated text's top right corner to the middle of the corresponding category first.
                            + axisProperties.categoryThickness * (index + 0.5)
                            // Subtracting the left padding space from the allowed length
                            - LeftPadding;
                        var allowedLength = allowedLengthProjectedOnXAxis / LabelLayoutStrategy.DefaultRotation.cosine;
                        var rotatedLength = Math.min(allowedLength, maxRotatedLength);
                        // Which shows more characters? Rotated or maxNumLines truncated to labelMaxWidth?
                        var wordBreakChars = jsCommon.WordBreaker.splitByWidth(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(' ');
                        properties.text = label;
                        var rotateChars = textTruncator(properties, rotatedLength);
                        // prefer word break (>=) as it takes up less plot area
                        return visuals.TextUtil.removeEllipses(wordBreakChars).length >= visuals.TextUtil.removeEllipses(rotateChars).length;
                    }));
                    // prefer word break (>=) as it takes up less plot area
                    return moreWordBreakChars.length >= (labels.length >> 1);
                }
                LabelLayoutStrategy.willLabelsWordBreak = willLabelsWordBreak;
                LabelLayoutStrategy.DefaultRotation = {
                    sine: Math.sin(Math.PI * (35 / 180)),
                    cosine: Math.cos(Math.PI * (35 / 180)),
                    tangent: Math.tan(Math.PI * (35 / 180)),
                    transform: 'rotate(-35)',
                    dy: '-0.5em',
                };
                LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                    sine: Math.sin(Math.PI * (90 / 180)),
                    cosine: Math.cos(Math.PI * (90 / 180)),
                    tangent: Math.tan(Math.PI * (90 / 180)),
                    transform: 'rotate(-90)',
                    dy: '-0.8em',
                };
                function rotate(labelSelection, arg1, textTruncator, textProperties, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                    var currentNode;
                    var rotationPadding = 0;
                    var dropLabelsOnOverlap;
                    var height;
                    if (typeof arg1 === "object") {
                        var options = arg1;
                        textTruncator = options.textTruncator;
                        textProperties = options.textProperties;
                        needRotate = options.needRotate;
                        needEllipsis = options.needEllipsis;
                        axisProperties = options.axisProperties;
                        margin = options.margin;
                        scrollbarVisible = options.scrollbarVisible;
                        currentNode = options.firstVisibleNode;
                        rotationPadding = options.rotationPadding || 0;
                        dropLabelsOnOverlap = options.dropLabelsOnOverlap;
                        height = options.height;
                    }
                    else {
                        height = arg1; // Set height = maxBottomMargin
                        API.deprecated('Calling rotate without using the property bag is deprecated.');
                    }
                    var rotation;
                    // Clear the rotation if we don't need to rotate
                    if (!needRotate) {
                        labelSelection.each((function (datum) {
                            var axisLabel = d3.select(this);
                            var labelText = axisLabel.text();
                            textProperties.text = labelText;
                            var maxLabelWidth = getMaxWidth(axisProperties, datum);
                            var newLabelText = textTruncator(textProperties, maxLabelWidth);
                            if (newLabelText !== labelText)
                                axisLabel.text(newLabelText);
                            // TODO don't do these rotations if we already did them
                            axisLabel.style('text-anchor', 'middle')
                                .attr({
                                'dx': '0em',
                                'dy': '1em',
                                'transform': 'rotate(0)'
                            });
                        }));
                        return;
                    }
                    debug.assert(AxisHelper.isOrdinalScale(axisProperties.scale), 'Rotating non-ordinal scales is currently not supported');
                    // Otherwise, get the information needed to rotate the text
                    // TODO Add support for vertical collision detection
                    if (scrollbarVisible) {
                        rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    }
                    else {
                        rotation = LabelLayoutStrategy.DefaultRotation;
                    }
                    // cos(90) is 0, but we get a small number back rather than 0 due to floating point issues
                    var isVertical = powerbi.Double.equalWithPrecision(Math.abs(rotation.cosine), 0, 1e-10);
                    var leftMarginWithPadding = margin.left - (isVertical ? LeftPadding : 0);
                    // Get the default font size and compare it to the given font size to see if we need to fallback to old code to maintain back-compat
                    var defaultFontHeightInPx = visuals.CartesianHelper.DefaultAxisFontSizeInPx;
                    var fontSizeString = textProperties.fontSize;
                    var fontSizeInPx = parseInt(fontSizeString, 10);
                    var defaultOrSmaller = fontSizeInPx <= defaultFontHeightInPx;
                    var fontHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                    var scale = axisProperties.scale;
                    var range = scale.range();
                    var categoryThickness = AxisHelper.getCategoryThickness(scale);
                    // projectedFontWidth (pFW) is the font height projected onto the x-axis (width).
                    // projectedFontHeight (pFH) is the font height projected onto the y-axis (height).
                    // xOffset (xOff) is the extra space on the x-axis that the label wil take up.
                    //      | xOff | pFW |
                    // _ _ _|_ _ _ |_ _ _|_ _ _ _ _ _ _ 
                    //      |     /\     |     /\
                    //      |    /  \    |    /  \
                    //      |   /    \   |   /    \
                    //  pFh |  /      \  |  /      \
                    //      | / Label1 \ | / Label2 \
                    // _ _ _|/ _ _ _ _ _\|/ _ _ _ _ _\
                    //      /           /            /
                    //     /    Text   /    Text    /
                    var projectedFontWidth = fontHeight * rotation.sine;
                    var projectedFontHeight = isVertical ? 0 : fontHeight * rotation.cosine;
                    var xOffset = isVertical ? 0 : projectedFontHeight / rotation.tangent;
                    var halfProjectedFontWidth = projectedFontWidth / 2;
                    // fontOffsetLeft is the offset needed to get from the anchor point to the left-most position of this label that 
                    // could overlap with the right-most position of the previous label.
                    // fontOffsetRight is the offset needed to get from the anchor point to the right-most position of this label.
                    // maxLabelLength is how long the label can be. projectedFontHeight is subtracted since there is padding.
                    // All of these assume the anchor point is at 1/2 the projected font width. 
                    var fontOffsetLeft = xOffset + halfProjectedFontWidth;
                    var fontOffsetRight = halfProjectedFontWidth;
                    var maxLabelLength;
                    var rotatedXAxisPaddingString;
                    if (defaultOrSmaller) {
                        // If we're the default label or smaller, use the old padding and label length to prevent regressions
                        // This old logic does not account for the space occupied by the padding or edges of angled text.
                        // These issues were masked by using maxBottomMargin (the value of `height`) instead of margin.bottom and various paddings.
                        maxLabelLength = height / rotation.sine;
                        rotatedXAxisPaddingString = "-5.5px";
                    }
                    else {
                        // Shift the label down by the projected font height and add some padding to make sure the top corner is below the axis.
                        // The values are relative to the y-axis, so project them onto the rotated x-axis.
                        var yAxisPadding = defaultFontHeightInPx / 2;
                        var rotatedXAxisPadding = (yAxisPadding + projectedFontHeight) * rotation.sine;
                        rotatedXAxisPaddingString = "-" + rotatedXAxisPadding + "px";
                        // Get the amount of space available for the label relative to the y-axis (add  extra padding if we have a scrollbar).
                        // Then project it onto the rotate X axis.
                        var availableYAxisSpace = height - yAxisPadding - projectedFontHeight - (scrollbarVisible ? yAxisPadding : 0);
                        maxLabelLength = needRotate ? availableYAxisSpace / rotation.sine : undefined;
                    }
                    var halfRangeBand = scale.rangeBand() / 2;
                    var halfCategoryThickness = categoryThickness / 2;
                    var isHierarchical = !!currentNode;
                    var collisionDetector;
                    if (!dropLabelsOnOverlap) {
                        collisionDetector = new AxisTickCollisionUtils.NoCollisionDetector();
                    }
                    else if (isHierarchical) {
                        // Set the overlap position to be where the line to the left of the label is
                        var leftEdge = rotationPadding + range[0] + halfRangeBand - halfCategoryThickness;
                        collisionDetector = new AxisTickCollisionUtils.HierarchicalCollisionDetector(leftEdge, fontOffsetLeft, fontOffsetRight, currentNode, scale, halfCategoryThickness, rotationPadding);
                    }
                    else {
                        // Set the overlap position to be the edge of the viewport
                        // If we have a scrollbar, we can't use leftMarginWithPadding since the labels will get cutoff as the chart is in a separate SVG.
                        var leftEdge = rotationPadding - (scrollbarVisible ? 0 : leftMarginWithPadding);
                        collisionDetector = new AxisTickCollisionUtils.CollisionDetector(leftEdge, fontOffsetLeft, fontOffsetRight);
                    }
                    labelSelection.each((function (datum, index) {
                        var axisLabel = d3.select(this);
                        // If the start of this label will overlap with the last rendered one, don't render this one.
                        var categoryCenter = range[index] + halfRangeBand;
                        if (dropLabelsOnOverlap && collisionDetector.willCollide(categoryCenter)) {
                            collisionDetector.skipItem(categoryCenter);
                            axisLabel.text(null);
                            return;
                        }
                        collisionDetector.addItem(categoryCenter);
                        var labelText = axisLabel.text();
                        textProperties.text = labelText;
                        var allowedLength;
                        if (!isVertical) {
                            // If we're not vertical, the text can occupy the space from the left edge of the visual to the center of the current category.
                            // leftMarginWithPadding represents the space from the left viewport edge + padding to the axis start.
                            // categoryCenter is the distance from the axis start to the center of the current item.
                            // Reserve space for the projected font width so the the top of the rotated font doesn't get cut off on the left side.
                            // If we're the default size or smaller, use the old (incorrect) logic to maintain back-compat.
                            // Old logic would typically be a few pxiels larger than the actual center, resulting in an incorrect length being calculated.
                            var center = defaultOrSmaller ? axisProperties.outerPadding + axisProperties.categoryThickness * (index + 0.5) : categoryCenter;
                            var availableXAxisWidth = center + leftMarginWithPadding - projectedFontWidth;
                            allowedLength = availableXAxisWidth / rotation.cosine;
                        }
                        else {
                            allowedLength = maxLabelLength;
                        }
                        // Truncate if scrollbar is visible or rotatedLength exceeds allowedLength
                        if (scrollbarVisible || needEllipsis || (allowedLength < maxLabelLength)) {
                            labelText = textTruncator(textProperties, Math.min(allowedLength, maxLabelLength));
                            axisLabel.text(labelText);
                        }
                        // NOTE: see note above - rotation only lines up with default d3 tickSize(6,0)
                        // TODO don't do these rotations if we already did them
                        axisLabel.style('text-anchor', 'end')
                            .attr({
                            'y': textProperties.fontSize,
                            'dx': rotatedXAxisPaddingString,
                            'dy': rotation.dy,
                            'transform': rotation.transform
                        });
                    }));
                }
                LabelLayoutStrategy.rotate = rotate;
                function wordBreak(text, axisProperties, maxHeight) {
                    // TODO Add support for collision detection
                    var topPadding = 10;
                    var y = null;
                    text.each((function (datum) {
                        var allowedLength = getMaxWidth(axisProperties, datum);
                        // Set Y to shift the text down below the axis plus some padding
                        if (y == null) {
                            var properties = powerbi.TextMeasurementService.getSvgMeasurementProperties(this);
                            var fontHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                            var baselineDelta = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(properties);
                            y = topPadding + fontHeight - baselineDelta;
                        }
                        var node = d3.select(this);
                        // Reset style of text node
                        node
                            .style('text-anchor', 'middle')
                            .attr({
                            'dx': null,
                            'dy': null,
                            'y': y + 'px',
                            'transform': 'rotate(0)'
                        });
                        visuals.TextUtil.wordBreak(this, allowedLength, maxHeight);
                    }));
                }
                LabelLayoutStrategy.wordBreak = wordBreak;
                function clip(text, availableWidth, svgEllipsis) {
                    if (text.size() === 0)
                        return;
                    // TODO Add support for collision detection
                    text.each((function () {
                        var text = d3.select(this);
                        svgEllipsis(text[0][0], availableWidth);
                    }));
                }
                LabelLayoutStrategy.clip = clip;
            })(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {}));
            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio, innerPaddingRatio) {
                if (outerPaddingRatio === void 0) { outerPaddingRatio = 0; }
                if (innerPaddingRatio === void 0) { innerPaddingRatio = visuals.DefaultInnerPaddingRatio; }
                debug.assert(outerPaddingRatio >= 0 && outerPaddingRatio < 4, 'outerPaddingRatio should be a value between zero and four');
                var scale = d3.scale.ordinal()
                    .rangeBands([0, pixelSpan], innerPaddingRatio, outerPaddingRatio)
                    .domain(dataDomain);
                return scale;
            }
            AxisHelper.createOrdinalScale = createOrdinalScale;
            function isLogScalePossible(domain, axisType) {
                if (domain == null)
                    return false;
                if (isDateTime(axisType))
                    return false;
                return (domain[0] > 0 && domain[1] > 0) || (domain[0] < 0 && domain[1] < 0); //doman must exclude 0
            }
            AxisHelper.isLogScalePossible = isLogScalePossible;
            //this function can return different scales e.g. log, linear
            // NOTE: export only for testing, do not access directly
            function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
                if (outerPadding === void 0) { outerPadding = 0; }
                if (axisScaleType === visuals.axisScale.log && isLogScalePossible(dataDomain, dataType)) {
                    return createLogScale(pixelSpan, dataDomain, outerPadding, niceCount);
                }
                else {
                    return createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
                }
            }
            AxisHelper.createNumericalScale = createNumericalScale;
            function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                if (outerPadding === void 0) { outerPadding = 0; }
                debug.assert(isLogScalePossible(dataDomain), "dataDomain cannot include 0");
                var scale = d3.scale.log()
                    .range([outerPadding, pixelSpan - outerPadding])
                    .domain([dataDomain[0], dataDomain[1]])
                    .clamp(true);
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            // NOTE: export only for testing, do not access directly
            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
                if (outerPadding === void 0) { outerPadding = 0; }
                var scale = d3.scale.linear()
                    .range([outerPadding, pixelSpan - outerPadding])
                    .domain([dataDomain[0], dataDomain[1]])
                    .clamp(shouldClamp);
                // .nice(undefined) still modifies the scale boundaries, and for datetime this messes things up.
                // we use millisecond ticks since epoch for datetime, so we don't want any "nice" with numbers like 17398203392.
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            AxisHelper.createLinearScale = createLinearScale;
            function getRangeForColumn(sizeColumn) {
                var result = {};
                if (sizeColumn) {
                    result.min = (sizeColumn.min == null
                        ? sizeColumn.minLocal == null ? d3.min(sizeColumn.values) : sizeColumn.minLocal
                        : sizeColumn.min);
                    result.max = (sizeColumn.max == null
                        ? sizeColumn.maxLocal == null ? d3.max(sizeColumn.values) : sizeColumn.maxLocal
                        : sizeColumn.max);
                }
                return result;
            }
            AxisHelper.getRangeForColumn = getRangeForColumn;
            /**
             * Set customized domain, but don't change when nothing is set
             */
            function applyCustomizedDomain(customizedDomain, originalDomain) {
                var domain = [undefined, undefined];
                if (originalDomain && originalDomain.length === 2) {
                    domain = [originalDomain[0], originalDomain[1]];
                }
                if (customizedDomain && customizedDomain.length === 2) {
                    if (customizedDomain[0] != null) {
                        domain[0] = customizedDomain[0];
                    }
                    if (customizedDomain[1] != null) {
                        domain[1] = customizedDomain[1];
                    }
                }
                if (domain[0] == null && domain[1] == null) {
                    return originalDomain; //return untouched object
                }
                //do extra check to see if the user input was valid with the merged axis values.
                if (domain[0] != null && domain[1] != null) {
                    if (domain[0] > domain[1]) {
                        return originalDomain;
                    }
                }
                return domain;
            }
            AxisHelper.applyCustomizedDomain = applyCustomizedDomain;
            /**
             * Combine the forced domain with the actual domain if one of the values was set.
             * The forcedDomain is in 1st priority. Extends the domain if the any reference point requires it.
             */
            function combineDomain(forcedDomain, domain, ensureDomain) {
                var combinedDomain = domain ? [domain[0], domain[1]] : [];
                if (ensureDomain) {
                    if (combinedDomain[0] == null || ensureDomain.min < combinedDomain[0])
                        combinedDomain[0] = ensureDomain.min;
                    if (combinedDomain[1] == null || ensureDomain.max > combinedDomain[1])
                        combinedDomain[1] = ensureDomain.max;
                }
                var domainBeforeForced = [combinedDomain[0], combinedDomain[1]];
                if (forcedDomain && forcedDomain.length === 2) {
                    if (forcedDomain[0] != null) {
                        combinedDomain[0] = forcedDomain[0];
                    }
                    if (forcedDomain[1] != null) {
                        combinedDomain[1] = forcedDomain[1];
                    }
                    if (combinedDomain[0] > combinedDomain[1]) {
                        combinedDomain = domainBeforeForced; //this is invalid, so take the original domain considering the values and the reference line
                    }
                }
                return combinedDomain;
            }
            AxisHelper.combineDomain = combineDomain;
            function createAxisLabel(properties, label, unitType, y2) {
                if (y2 === void 0) { y2 = false; }
                var propertyName = y2 ? 'secAxisStyle' : 'axisStyle';
                if (!properties || !properties[propertyName]) {
                    return label;
                }
                var styleString = properties[propertyName];
                return visuals.AxisViewModel.createAxisLabel(styleString, label, unitType);
            }
            AxisHelper.createAxisLabel = createAxisLabel;
            function scaleShouldClamp(combinedDomain, domain) {
                if (!combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2)
                    return false;
                //when the start or end is different, clamp it
                return combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
            }
            AxisHelper.scaleShouldClamp = scaleShouldClamp;
            function normalizeNonFiniteNumber(value) {
                if (isNaN(value))
                    return null;
                else if (value === Number.POSITIVE_INFINITY)
                    return Number.MAX_VALUE;
                else if (value === Number.NEGATIVE_INFINITY)
                    return -Number.MAX_VALUE;
                return value;
            }
            AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber;
            /**
             * Indicates whether the number is power of 10.
             */
            function powerOfTen(d) {
                var value = Math.abs(d);
                // formula log2(Y)/log2(10) = log10(Y)
                // because double issues this won't return exact value
                // we need to ceil it to nearest number.
                var log10 = Math.log(value) / Math.LN10;
                log10 = Math.ceil(log10 - 1e-12);
                return value / Math.pow(10, log10) === 1;
            }
            AxisHelper.powerOfTen = powerOfTen;
            function isHierarchical(axisProperties) {
                var hierarchicalAxisProperties = axisProperties;
                return hierarchicalAxisProperties.isHierarchical;
            }
            AxisHelper.isHierarchical = isHierarchical;
            function isStackedAxisProperties(properties) {
                var stackedProperties = properties;
                return stackedProperties.isStacked === true;
            }
            AxisHelper.isStackedAxisProperties = isStackedAxisProperties;
            function getMaxWidth(axisProperties, datum) {
                // For categorical non-hierarchical charts, we don't set the xLabelMaxWidths, so return the single max width
                if (_.isEmpty(axisProperties.xLabelMaxWidths)) {
                    return axisProperties.xLabelMaxWidth;
                }
                // For categorical hierarchies, the maxLabelWidth assigned for each category in every level, datum is the category index
                if (isStackedAxisProperties(axisProperties)) {
                    return axisProperties.xLabelMaxWidths[datum];
                }
                else {
                    var tickValues = axisProperties.axis.tickValues();
                    var tickIndex = tickValues.indexOf(datum);
                    return axisProperties.xLabelMaxWidths[tickIndex];
                }
            }
            AxisHelper.getMaxWidth = getMaxWidth;
        })(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
powerbi.define('PowerBIVisuals/Visuals/common/colorEnumerationHelper', (function (imports) {
    var DataViewObjects = powerbi.DataViewObjects;
    var visuals = powerbi.visuals;
    var showAllDataPointsProp = { objectName: 'dataPoint', propertyName: 'showAllDataPoints' };
    function enumerateCategoryDataColors(options) {
        if (!options.dataView)
            return;
        var enumeration = options.enumeration;
        var dataPoints = options.dataPoints;
        var staticObjects = options.dataView.metadata && options.dataView.metadata.objects;
        var showAllDataPoints = DataViewObjects.getValue(staticObjects, showAllDataPointsProp, false);
        var defaultCategoryColor = DataViewObjects.getFillColor(staticObjects, visuals.columnChartProps.dataPoint.defaultCategoryColor);
        if (!defaultCategoryColor) {
            var defaultColor = DataViewObjects.getFillColor(staticObjects, visuals.columnChartProps.dataPoint.defaultColor);
            if (defaultColor) {
                defaultCategoryColor = defaultColor;
            }
            else {
                defaultCategoryColor = options.style.colorPalette.dataColors.getColorByIndex(0).value;
            }
        }
        enumeration.pushInstance({
            objectName: 'dataPoint',
            selector: null,
            properties: {
                defaultCategoryColor: {
                    solid: {
                        color: defaultCategoryColor,
                    }
                },
                showAllDataPoints: showAllDataPoints,
            }
        });
        if (showAllDataPoints) {
            for (var i = 0, ilen = dataPoints.length; i < ilen; i++) {
                var dataPoint = dataPoints[i];
                enumeration.pushInstance({
                    objectName: 'dataPoint',
                    displayName: dataPoint.displayName,
                    selector: powerbi.data.Selector.normalizeSelector(dataPoint.identity.getSelector()),
                    properties: {
                        fill: { solid: { color: dataPoint.color } },
                    }
                });
            }
        }
    }
    function enumerateSeriesDataColors(options) {
        var enumeration = options.enumeration;
        var dataPoints = options.dataPoints;
        for (var i = 0, ilen = dataPoints.length; i < ilen; i++) {
            var dataPoint = dataPoints[i];
            enumeration.pushInstance({
                objectName: 'dataPoint',
                displayName: dataPoint.displayName,
                selector: powerbi.data.Selector.normalizeSelector(dataPoint.identity.getSelector()),
                properties: {
                    fill: { solid: { color: dataPoint.color } },
                }
            });
        }
    }
    return {
        enumerateCategoryDataColors: enumerateCategoryDataColors,
        enumerateSeriesDataColors: enumerateSeriesDataColors,
    };
}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var rectName = 'rect';
        var ColumnUtil;
        (function (ColumnUtil) {
            ColumnUtil.DimmedOpacity = 0.4;
            ColumnUtil.DefaultOpacity = 1.0;
            ColumnUtil.SeriesClasses = jsCommon.CssConstants.createClassAndSelector('series');
            ColumnUtil.validLabelPositionsAutoClustered = [16 /* OutsideEnd */, 4 /* InsideEnd */, 1 /* InsideCenter */, 2 /* InsideBase */];
            ColumnUtil.validLabelPositionsAutoStacked = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
            var minimumLabelsToRender = 4;
            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain, margin, preventNice, innerPaddingRatio) {
                var categoryThickness = layout.categoryThickness;
                var isScalar = layout.isScalar;
                var outerPaddingRatio = layout.outerPaddingRatio;
                var domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({ text: true }), isScalar, [forcedXMin, forcedXMax], ensureXDomain);
                var axisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: size,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, visuals.columnChartProps.general.formatString),
                    outerPadding: categoryThickness * outerPaddingRatio,
                    outerPaddingRatio: outerPaddingRatio,
                    isCategoryAxis: true,
                    isScalar: isScalar,
                    isVertical: isVertical,
                    categoryThickness: categoryThickness,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(data, index, type, isScalar); },
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    margin: margin,
                    allowSingleScalarTick: isScalar,
                    preventNice: preventNice,
                    innerPaddingRatio: innerPaddingRatio,
                });
                // intentionally updating the input layout by ref
                layout.categoryThickness = axisProperties.categoryThickness;
                return axisProperties;
            }
            ColumnUtil.getCategoryAxis = getCategoryAxis;
            function applyInteractivity(columns, onDragStart) {
                debug.assertValue(columns, 'columns');
                if (onDragStart) {
                    columns
                        .attr('draggable', 'true')
                        .on('dragstart', onDragStart);
                }
            }
            ColumnUtil.applyInteractivity = applyInteractivity;
            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights, baseOpacity) {
                if (baseOpacity === void 0) { baseOpacity = ColumnUtil.DefaultOpacity; }
                if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
                    return ColumnUtil.DimmedOpacity * baseOpacity;
                return baseOpacity;
            }
            ColumnUtil.getFillOpacity = getFillOpacity;
            function getClosestColumnIndex(coordinate, columnsCenters) {
                var currentIndex = 0;
                var distance = Number.MAX_VALUE;
                for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    if (currentDistance < distance) {
                        distance = currentDistance;
                        currentIndex = i;
                    }
                }
                return currentIndex;
            }
            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex;
            function setSelectedColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastSelectedColumnIndex, forceDimAll) {
                // TODO: forceDimAll is actually a hack. render() in column chart draws all column with opacity 1, we use forceDimAll
                // to detect when we should set the opacity of all columns but the selected to dimmed value. The problem with always
                // setting the opacity of all columns is a noticable flicker on some mobile devices.
                // A real solution for mobile would be moving to use interactivity service properly (and not its own 'interactive' flags)
                var useAnimation = !forceDimAll;
                var allColumnDataPoints = mainGraphicsContext
                    .selectAll(ColumnUtil.SeriesClasses.selector)
                    .selectAll(rectName + columnGroupSelector);
                var dataPointsToHighlight = allColumnDataPoints.filter((function (d) { return d.categoryIndex === selectedColumnIndex; }));
                dataPointsToHighlight
                    .transition().duration(0) // disable any ongoing transition
                    .style('fill-opacity', ColumnUtil.DefaultOpacity);
                var dataPointsToDim = allColumnDataPoints.filter((function (d) {
                    var isFirstColumnBeingSelected = (lastSelectedColumnIndex === undefined);
                    if (isFirstColumnBeingSelected || forceDimAll) {
                        return d.categoryIndex !== selectedColumnIndex;
                    }
                    else {
                        // performance improvment, dim only necessary columns
                        var isLastSelectedColumnIndex = (d.categoryIndex === lastSelectedColumnIndex);
                        var isNotSelectedColumnIndex = (d.categoryIndex !== selectedColumnIndex);
                        return isLastSelectedColumnIndex && isNotSelectedColumnIndex;
                    }
                }));
                var dimSelectionConfiguredWithTransition = useAnimation ? dataPointsToDim.transition() : dataPointsToDim;
                dimSelectionConfiguredWithTransition.style('fill-opacity', ColumnUtil.DimmedOpacity);
            }
            ColumnUtil.setSelectedColumnOpacity = setSelectedColumnOpacity;
            function drawSeries(data, graphicsContext, axisOptions) {
                var colGroupSelection = graphicsContext.selectAll(ColumnUtil.SeriesClasses.selector);
                var series = colGroupSelection.data(data.series, (function (d) { return d.key; }));
                series
                    .enter()
                    .append('g')
                    .classed(ColumnUtil.SeriesClasses.class, true);
                series
                    .style({
                    fill: function (d) { return d.color; },
                });
                series
                    .exit()
                    .remove();
                return series;
            }
            ColumnUtil.drawSeries = drawSeries;
            function drawDefaultShapes(data, series, layout, itemCS, filterZeros, hasSelection) {
                // We filter out invisible (0, null, etc.) values from the dataset
                // based on whether animations are enabled or not, Dashboard and
                // Exploration mode, respectively.
                var dataSelector;
                if (filterZeros) {
                    dataSelector = function (d) {
                        var filteredData = _.filter(d.data, (function (datapoint) { return !!datapoint.value; }));
                        return filteredData;
                    };
                }
                else {
                    dataSelector = function (d) { return d.data; };
                }
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(dataSelector, (function (d) { return d.key; }));
                shapes.enter()
                    .append(rectName)
                    .attr("class", (function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); }));
                shapes
                    .style("fill-opacity", (function (d) { return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); }))
                    .style("fill", (function (d) { return d.color !== data.series[d.seriesIndex].color ? d.color : null; })) // PERF: Only set the fill color if it is different than series.
                    .attr(layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return shapes;
            }
            ColumnUtil.drawDefaultShapes = drawDefaultShapes;
            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                if (series) {
                    var seriesData = series.data();
                    var dataPoints = [];
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        Array.prototype.push.apply(dataPoints, seriesData[i].data);
                    }
                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(context);
                }
            }
            ColumnUtil.drawDefaultLabels = drawDefaultLabels;
            function normalizeInfinityInScale(scale) {
                // When large values (eg Number.MAX_VALUE) are involved, a call to scale.nice occasionally
                // results in infinite values being included in the domain. To correct for that, we need to
                // re-normalize the domain now to not include infinities.
                var scaledDomain = scale.domain();
                for (var i = 0, len = scaledDomain.length; i < len; ++i) {
                    if (scaledDomain[i] === Number.POSITIVE_INFINITY)
                        scaledDomain[i] = Number.MAX_VALUE;
                    else if (scaledDomain[i] === Number.NEGATIVE_INFINITY)
                        scaledDomain[i] = -Number.MAX_VALUE;
                }
                scale.domain(scaledDomain);
            }
            ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale;
            // TODO: remove ColumnChartDataPointOld
            function calculatePosition(d, axisOptions) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledY0 = yScale(0);
                var scaledX0 = xScale(0);
                switch (d.chartType) {
                    case 18 /* stackedBar */:
                    case 50 /* hundredPercentStackedBar */:
                        return scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.valueAbsolute)) +
                            visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case 10 /* clusteredBar */:
                        return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case 20 /* stackedColumn */:
                    case 52 /* hundredPercentStackedColumn */:
                    case 68 /* ribbonChart */:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case 12 /* clusteredColumn */:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                }
            }
            ColumnUtil.calculatePosition = calculatePosition;
            function createLabelDataPoints(data, layout, graphicsContext, yProps, isBar, isClustered) {
                var labelDataPointGroups = [];
                var series = data.series;
                var formattersCache = visuals.LabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = layout.shapeLayout;
                var isScalar = data.scalarCategoryAxis;
                var _loop_2 = function (seriesIndex, seriesCount) {
                    var currentSeries = series[seriesIndex];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.dataLabelsSettings;
                    if (!labelSettings.show) {
                        labelDataPointGroups[seriesIndex] = {
                            labelDataPoints: [],
                            maxNumberOfLabels: 0,
                        };
                        return "continue";
                    }
                    var densityAtMax = labelSettings.labelDensity === "100";
                    var maxNumberOfLabels = void 0;
                    if (!densityAtMax && isScalar) {
                        var numberOfLabelsToRender = visuals.LabelUtils.getNumberOfLabelsToRender(graphicsContext.viewportWidth, _.parseInt(labelSettings.labelDensity), minimumLabelsToRender, visuals.MinMaxLabelDataPointSorter.estimatedLabelWidth);
                        maxNumberOfLabels = numberOfLabelsToRender;
                    }
                    else {
                        maxNumberOfLabels = currentSeries.data.length;
                    }
                    var labelUnitsAndPrecision = visuals.LabelUtils.getLabelUnitAndPrecisionForAxis(yProps, labelSettings);
                    var seriesLabelDataPoints = [];
                    var createLabelDataPoint = function (dataPoint) {
                        // Calculate label text
                        var formatString;
                        if (graphicsContext.is100Pct) {
                            formatString = visuals.LabelUtils.hundredPercentFormat;
                        }
                        else {
                            formatString = dataPoint.labelFormatString;
                        }
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, labelUnitsAndPrecision.units, labelUnitsAndPrecision.getPrecision(!!formatString, currentSeries.type));
                        var text = visuals.LabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        var fontProperties = labelSettings ? labelSettings.fontProperties : visuals.LabelUtils.defaultFontProperties;
                        // Calculate text size
                        var properties = visuals.FontProperties.toTextProperties(fontProperties, text);
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        var validPositions;
                        if (isClustered) {
                            validPositions = getValidClusteredPositions(labelSettings.position);
                        }
                        else {
                            validPositions = getValidStackedPositions(labelSettings.position);
                        }
                        var orientation;
                        if (isBar) {
                            orientation = dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */;
                        }
                        else {
                            orientation = dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */;
                        }
                        var labelDataPoint = {
                            isPreferred: false,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: getLabelFill(labelSettings.fontProperties.color, false, graphicsContext.isComboChart),
                            insideFill: getLabelFill(labelSettings.fontProperties.color, true, graphicsContext.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: orientation,
                                validPositions: validPositions,
                            },
                            identity: dataPoint.identity,
                            fontProperties: fontProperties,
                        };
                        return labelDataPoint;
                    };
                    for (var _i = 0, _a = currentSeries.data; _i < _a.length; _i++) {
                        var dataPoint = _a[_i];
                        if (dataPoint == null || dataPoint.value == null || (data.hasHighlights && !dataPoint.highlight)) {
                            continue;
                        }
                        var labelDataPoint = createLabelDataPoint(dataPoint);
                        seriesLabelDataPoints.push(labelDataPoint);
                    }
                    labelDataPointGroups[seriesIndex] = {
                        labelDataPoints: seriesLabelDataPoints,
                        maxNumberOfLabels: maxNumberOfLabels,
                    };
                };
                for (var seriesIndex = 0, seriesCount = series.length; seriesIndex < seriesCount; seriesIndex++) {
                    _loop_2(seriesIndex, seriesCount);
                }
                if (data && data.scalarCategoryAxis) {
                    var sorter = new visuals.MinMaxLabelDataPointSorter({
                        unsortedLabelDataPointGroups: labelDataPointGroups,
                        series: series,
                        viewport: { width: graphicsContext.viewportWidth, height: graphicsContext.viewportHeight },
                        yAxisProperties: yProps,
                    });
                    return sorter.getSortedDataLabels();
                }
                return labelDataPointGroups;
            }
            ColumnUtil.createLabelDataPoints = createLabelDataPoints;
            function getLabelFill(labelColor, isInside, isCombo) {
                if (labelColor) {
                    return labelColor;
                }
                if (isInside && !isCombo) {
                    return visuals.LabelUtils.defaultInsideLabelColor;
                }
                return visuals.LabelUtils.defaultLabelColor;
            }
            function getValidClusteredPositions(position) {
                switch (position) {
                    case visuals.labelPosition.insideEnd:
                        return [4 /* InsideEnd */];
                    case visuals.labelPosition.insideCenter:
                        return [1 /* InsideCenter */];
                    case visuals.labelPosition.insideBase:
                        return [2 /* InsideBase */];
                    case visuals.labelPosition.outsideEnd:
                        return [16 /* OutsideEnd */];
                    default:
                        return ColumnUtil.validLabelPositionsAutoClustered;
                }
            }
            function getValidStackedPositions(position) {
                switch (position) {
                    case visuals.labelPosition.insideEnd:
                        return [4 /* InsideEnd */];
                    case visuals.labelPosition.insideBase:
                        return [2 /* InsideBase */];
                    case visuals.labelPosition.insideCenter:
                        return [1 /* InsideCenter */];
                    default:
                        return ColumnUtil.validLabelPositionsAutoStacked;
                }
            }
        })(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
        var ClusteredUtil;
        (function (ClusteredUtil) {
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var cols = mainGraphicsContext.selectAll(itemCS.selector)
                    .data([]);
                cols.exit().remove();
            }
            ClusteredUtil.clearColumns = clearColumns;
        })(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
        var StackedUtil;
        (function (StackedUtil) {
            var PctRoundingError = 0.0001;
            function getSize(scale, size, zeroVal) {
                if (zeroVal === void 0) { zeroVal = 0; }
                return visuals.AxisHelper.diffScaled(scale, zeroVal, size);
            }
            StackedUtil.getSize = getSize;
            function calcValueDomain(data, is100pct) {
                var defaultNumberRange = {
                    min: 0,
                    max: 10
                };
                if (data.length === 0)
                    return defaultNumberRange;
                // Can't use AxisHelper because Stacked column layout has a slightly different calc for min, (position - valueAbs),
                // since we draw rect from top-left corner.
                var min = d3.min(data, (function (d) { return d3.min(d.data, (function (e) { return e.position - e.valueAbsolute; })); }));
                var max = d3.max(data, (function (d) { return d3.max(d.data, (function (e) { return e.position; })); }));
                if (is100pct) {
                    min = powerbi.Double.roundToPrecision(min, PctRoundingError);
                    max = powerbi.Double.roundToPrecision(max, PctRoundingError);
                }
                return {
                    min: min,
                    max: max,
                };
            }
            StackedUtil.calcValueDomain = calcValueDomain;
            function getStackedMultiplier(rawValues, // This is a 2D array of values that is series x category
                categoryIndex) {
                debug.assertValue(rawValues, 'rawValues');
                var pos = 0, neg = 0;
                for (var seriesIndex = 0, seriesCount = rawValues.length; seriesIndex < seriesCount; seriesIndex++) {
                    var value = rawValues[seriesIndex][categoryIndex];
                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                    if (value > 0)
                        pos += value;
                    else if (value < 0)
                        neg -= value;
                }
                var absTotal = pos + neg;
                return {
                    pos: pos ? (pos / absTotal) / pos : 1,
                    neg: neg ? (neg / absTotal) / neg : 1,
                };
            }
            StackedUtil.getStackedMultiplier = getStackedMultiplier;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var bars = mainGraphicsContext.selectAll(itemCS.selector)
                    .data([]);
                bars.exit().remove();
            }
            StackedUtil.clearColumns = clearColumns;
        })(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var HierarchyVisitor = powerbi.data.HierarchyVisitor;
        var DataViewConcatenateUtil;
        (function (DataViewConcatenateUtil) {
            function concatenateCategories(dataView, formatStringProp, roleName) {
                if (!dataView || !dataView.categorical || _.isEmpty(dataView.categorical.categories)) {
                    return dataView;
                }
                var categories = dataView.categorical.categories;
                var concatenatedValues = buildConcatenatedValues(categories, formatStringProp);
                var concatenatedMetadataColumn = buildConcatenatedMetadataColumn(categories, roleName);
                var newDataView = powerbi.Prototype.inheritSingle(dataView);
                var newColumns = powerbi.Prototype.inheritSingle(newDataView.metadata.columns);
                newColumns.push(concatenatedMetadataColumn);
                var newMetadata = powerbi.Prototype.inheritSingle(newDataView.metadata);
                newMetadata.columns = newColumns;
                newDataView.metadata = newMetadata;
                var dataViewCategorical = dataView.categorical;
                var dataViewObjects = powerbi.data.DataViewCategoricalUtils.getCategoriesDataViewObjects(dataViewCategorical.categories);
                var newCategoryColumn = {
                    source: concatenatedMetadataColumn,
                    values: concatenatedValues
                };
                var firstColumn = dataView.categorical.categories[0];
                if (firstColumn.identity) {
                    newCategoryColumn.identity = firstColumn.identity;
                }
                if (firstColumn.identityFields) {
                    newCategoryColumn.identityFields = firstColumn.identityFields;
                }
                if (dataViewObjects) {
                    newCategoryColumn.objects = dataViewObjects;
                }
                var newCategories = [newCategoryColumn];
                var newCategorical = powerbi.Prototype.inheritSingle(dataViewCategorical);
                newCategorical.categories = newCategories;
                newDataView.categorical = newCategorical;
                return newDataView;
            }
            DataViewConcatenateUtil.concatenateCategories = concatenateCategories;
            function buildConcatenatedValues(categoryColumns, formatStringProp) {
                var valuesParts = [];
                for (var _i = 0, categoryColumns_1 = categoryColumns; _i < categoryColumns_1.length; _i++) {
                    var categoryColumn = categoryColumns_1[_i];
                    var values = categoryColumn.values;
                    var formatString = visuals.valueFormatter.getFormatString(categoryColumn.source, formatStringProp);
                    var formatter = visuals.valueFormatter.create({
                        format: formatString,
                        value: values[0],
                        value2: values[values.length - 1],
                        displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose,
                        columnType: categoryColumn.source.type,
                    });
                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {
                        var value = categoryColumn.values[i];
                        var formattedValue = formatter.format(value);
                        var valueParts = valuesParts[i];
                        if (!valueParts) {
                            valueParts = [];
                            valuesParts.splice(i, 0, valueParts);
                        }
                        valueParts.push(formattedValue);
                    }
                }
                return _.map(valuesParts, (function (concatenatedValueParts) { return concatenatedValueParts.join(' '); }));
            }
            DataViewConcatenateUtil.buildConcatenatedValues = buildConcatenatedValues;
            function buildConcatenatedMetadataColumn(categoryColumns, roleName) {
                var categoryLevels = CategoryLevelUtils.getCategoryLevels(categoryColumns);
                var concatenatedCategoryLevels = CategoryLevelUtils.concatenateCategoryLevels(categoryLevels);
                var newRoles = {};
                newRoles[roleName] = true;
                var newColumnMetadata = {
                    displayName: concatenatedCategoryLevels.displayName,
                    roles: newRoles,
                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(1 /* Text */)
                };
                var columnSourceForCurrentDrillLevel = _.last(categoryColumns).source;
                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {
                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;
                }
                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.
                // If queryName is not set at all, the column chart visual will only render column for the first group instance.
                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).
                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;
                return newColumnMetadata;
            }
            DataViewConcatenateUtil.buildConcatenatedMetadataColumn = buildConcatenatedMetadataColumn;
            function concatenateValues(formattedValues) {
                return formattedValues.join(' ');
            }
            DataViewConcatenateUtil.concatenateValues = concatenateValues;
        })(DataViewConcatenateUtil = visuals.DataViewConcatenateUtil || (visuals.DataViewConcatenateUtil = {}));
        var CategoryLevelUtils;
        (function (CategoryLevelUtils) {
            function concatenateCategoryLevels(categoryLevels) {
                return {
                    displayName: _.map(categoryLevels, (function (categoryLevel) { return categoryLevel.displayName; })).join(' '),
                    value: _.map(categoryLevels, (function (categoryLevel) { return categoryLevel.value; })).join(' ')
                };
            }
            CategoryLevelUtils.concatenateCategoryLevels = concatenateCategoryLevels;
            /**
             * Gets the information for each level of the category. Always gets the display name for each category level.
             * If categoryIndex and formatStringProp are set, the formatted values will also be included.
             */
            function getCategoryLevels(categories, categoryIndex, formatStringProp) {
                var includeValue = categoryIndex != null;
                // If you set include value, assert that we have a formatStringProp 
                debug.assert(!includeValue || !!formatStringProp, 'formatStringProp');
                var currentHierarchyName = null;
                var deepestHierarchyLevel = null;
                var currentValueParts = null;
                var categoryLevels = [];
                for (var _i = 0, categories_2 = categories; _i < categories_2.length; _i++) {
                    var categoryColumn = categories_2[_i];
                    var metadataColumn = categoryColumn.source;
                    if (!metadataColumn) {
                        continue;
                    }
                    var hierarchyName = metadataColumn.expr ? HierarchyVisitor.getProperty(metadataColumn.expr) : null;
                    if (hierarchyName != null) {
                        if (hierarchyName === currentHierarchyName) {
                            // If we're processing a hierarchy, update the deepest level
                            deepestHierarchyLevel = metadataColumn.displayName;
                        }
                        else {
                            // We've hit a new hierarchy while building a different one
                            if (currentHierarchyName !== null) {
                                // If we were building one, add that
                                categoryLevels.push({
                                    displayName: currentHierarchyName + ' ' + deepestHierarchyLevel,
                                    value: currentValueParts.join(' ')
                                });
                            }
                            // Setup for the next one
                            currentHierarchyName = hierarchyName;
                            deepestHierarchyLevel = metadataColumn.displayName;
                            currentValueParts = null;
                            if (includeValue) {
                                currentValueParts = [];
                            }
                        }
                        // Always add teh current value if requested
                        if (includeValue) {
                            currentValueParts.push(visuals.converterHelper.formatFromMetadataColumn(categoryColumn.values[categoryIndex], metadataColumn, formatStringProp, false));
                        }
                    }
                    else if (currentHierarchyName != null) {
                        // We've hit something that's not a hierarchy while building one, so add the one we're building, clear the state and then add the new item
                        categoryLevels.push({
                            displayName: currentHierarchyName + ' ' + deepestHierarchyLevel,
                            value: currentValueParts ? currentValueParts.join(' ') : null
                        });
                        currentHierarchyName = null;
                        deepestHierarchyLevel = null;
                        currentValueParts = null;
                        categoryLevels.push({
                            displayName: metadataColumn.displayName,
                            value: includeValue ? visuals.converterHelper.formatFromMetadataColumn(categoryColumn.values[categoryIndex], metadataColumn, formatStringProp, false) : null
                        });
                    }
                    else {
                        // Nothing to do with hierarchies, just add it
                        categoryLevels.push({
                            displayName: metadataColumn.displayName,
                            value: includeValue ? visuals.converterHelper.formatFromMetadataColumn(categoryColumn.values[categoryIndex], metadataColumn, formatStringProp, false) : null
                        });
                    }
                }
                if (currentHierarchyName != null) {
                    categoryLevels.push({
                        displayName: currentHierarchyName + " " + deepestHierarchyLevel,
                        value: includeValue ? currentValueParts.join(' ') : null
                    });
                }
                return categoryLevels;
            }
            CategoryLevelUtils.getCategoryLevels = getCategoryLevels;
        })(CategoryLevelUtils = visuals.CategoryLevelUtils || (visuals.CategoryLevelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var converterHelper;
        (function (converterHelper) {
            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                if (dataView.categories && dataView.categories.length > 0) {
                    // Need to pivot data if our category soure is a series role
                    var category = dataView.categories[0];
                    return category.source &&
                        DataRoleHelper.hasRole(category.source, seriesRoleName) &&
                        DataRoleHelper.hasRole(category.source, categoryRoleName);
                }
                return false;
            }
            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;
            function getPivotedCategories(dataView, formatStringProp) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = _.last(dataView.categories); //get leaf values in case of hierarchy
                    var categoryValues = category.values;
                    return category.values.length > 0
                        ? {
                            categories: categoryValues,
                            categoryFormatter: visuals.valueFormatter.create({
                                format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                                value: categoryValues[0],
                                value2: categoryValues[categoryValues.length - 1],
                                // Do not use display units such as K/M/bn etc. on the x-axis.
                                // PowerView does not use units either as large ranges will make the x-axis indecipherable.
                                displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose,
                                columnType: category.source.type,
                            }),
                            categoryIdentities: category.identity,
                            categoryObjects: category.objects,
                        }
                        : {
                            categories: [],
                            categoryFormatter: { format: visuals.valueFormatter.format },
                        };
                }
                // For cases where the category source is just a series role, we are pivoting the data on the role which means we
                // will have no categories.
                return defaultCategories();
            }
            converterHelper.getPivotedCategories = getPivotedCategories;
            function getSeriesName(source) {
                debug.assertValue(source, 'source');
                return (source.groupName !== undefined)
                    ? source.groupName
                    : source.queryName;
            }
            converterHelper.getSeriesName = getSeriesName;
            function getFormattedLegendLabel(source, values, formatStringProp) {
                debug.assertValue(source, 'source');
                debug.assertValue(values, 'values');
                var sourceForFormat = source;
                var nameForFormat = source.displayName;
                if (source.groupName !== undefined) {
                    sourceForFormat = values.source;
                    nameForFormat = source.groupName;
                }
                return visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
            }
            converterHelper.getFormattedLegendLabel = getFormattedLegendLabel;
            function defaultCategories() {
                return {
                    categories: [null],
                    categoryFormatter: { format: visuals.valueFormatter.format },
                };
            }
            function createAxisLabel(metadataColumns) {
                var label;
                if (metadataColumns instanceof Array) {
                    var displayNames = [];
                    // Take the name from the metadata columns, and make it unique because there are sometimes duplications
                    displayNames = metadataColumns.map((function (m) { return m ? m.displayName : ''; })).filter((function (value, index, self) { return value !== '' && self.indexOf(value) === index; }));
                    label = visuals.valueFormatter.formatListAnd(displayNames);
                }
                else if (metadataColumns) {
                    label = metadataColumns.displayName;
                }
                return label;
            }
            converterHelper.createAxisLabel = createAxisLabel;
            /** deprecated */
            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                var xAxisLabel = null;
                var yAxisLabel = null;
                if (categoryAxisProperties) {
                    // Take the value only if it's there
                    if (category && category.displayName) {
                        xAxisLabel = category.displayName;
                    }
                }
                if (valueAxisProperties) {
                    var valuesNames = [];
                    if (values) {
                        // Take the name from the values, and make it unique because there are sometimes duplications
                        valuesNames = values.map((function (v) { return v ? v.displayName : ''; })).filter((function (value, index, self) { return value !== '' && self.indexOf(value) === index; }));
                        yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames);
                    }
                }
                return { xAxisLabel: xAxisLabel, yAxisLabel: yAxisLabel };
            }
            converterHelper.createAxesLabels = createAxesLabels;
            function isImageUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return misc != null && misc.imageUrl === true;
            }
            converterHelper.isImageUrlColumn = isImageUrlColumn;
            function isWebUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return misc != null && misc.webUrl === true;
            }
            converterHelper.isWebUrlColumn = isWebUrlColumn;
            function getMiscellaneousTypeDescriptor(column) {
                return column
                    && column.type
                    && column.type.misc;
            }
            function hasImageUrlColumn(dataView) {
                if (!dataView || !dataView.metadata || _.isEmpty(dataView.metadata.columns))
                    return false;
                return _.any(dataView.metadata.columns, (function (column) { return isImageUrlColumn(column) === true; }));
            }
            converterHelper.hasImageUrlColumn = hasImageUrlColumn;
            function formatFromMetadataColumn(value, column, formatStringProp, suppressTypeFallback) {
                if (suppressTypeFallback === void 0) { suppressTypeFallback = true; }
                debug.assertValue(column, 'column should exist');
                if (!suppressTypeFallback && column && column.format)
                    suppressTypeFallback = true;
                var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, suppressTypeFallback);
                if (!formatString && column) {
                    formatString = column.format;
                }
                return visuals.valueFormatter.format(value, formatString);
            }
            converterHelper.formatFromMetadataColumn = formatFromMetadataColumn;
        })(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var EnumExtensions = jsCommon.EnumExtensions;
        var LabelStyle = visuals.labelStyle;
        var PixelConverter = jsCommon.PixelConverter;
        var dataLabelUtils;
        (function (dataLabelUtils) {
            dataLabelUtils.minLabelFontSize = 8;
            dataLabelUtils.labelMargin = 8;
            dataLabelUtils.maxLabelWidth = 50;
            dataLabelUtils.defaultColumnLabelMargin = 5;
            dataLabelUtils.defaultColumnHalfLabelHeight = 4;
            dataLabelUtils.defaultLabelDensity = "50";
            dataLabelUtils.DefaultDy = '-0.15em';
            dataLabelUtils.DefaultFontSizeInPt = 9;
            dataLabelUtils.DefaultLabelFontFamily = visuals.Font.Family.regularSecondary.css;
            dataLabelUtils.StandardFontFamily = visuals.Font.Family.regular.css;
            dataLabelUtils.LabelTextProperties = {
                fontFamily: visuals.Font.Family.regularSecondary.css,
                fontSize: PixelConverter.fromPoint(dataLabelUtils.DefaultFontSizeInPt),
                fontWeight: 'normal',
            };
            dataLabelUtils.defaultLabelColor = "#777777";
            dataLabelUtils.defaultInsideLabelColor = "#ffffff";
            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
            dataLabelUtils.defaultLabelPrecision = undefined;
            dataLabelUtils.defaultPercentageLabelPrecision = undefined;
            var defaultCountLabelPrecision = 0;
            var labelGraphicsContextClass = createClassAndSelector('labels');
            var linesGraphicsContextClass = createClassAndSelector('lines');
            var labelsClass = createClassAndSelector('data-labels');
            var lineClass = createClassAndSelector('line-label');
            function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings, supportsLabelOrientation) {
                if (labelsObj) {
                    if (labelsObj.show !== undefined)
                        labelSettings.show = labelsObj.show;
                    if (labelsObj.showSeries !== undefined)
                        labelSettings.show = labelsObj.showSeries;
                    if (labelsObj.color !== undefined)
                        labelSettings.labelColor = labelsObj.color.solid.color;
                    if (labelsObj.labelDisplayUnits !== undefined)
                        labelSettings.displayUnits = labelsObj.labelDisplayUnits;
                    if (labelsObj.labelPrecision !== undefined)
                        labelSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : dataLabelUtils.defaultLabelPrecision;
                    if (labelsObj.fontSize !== undefined)
                        labelSettings.fontSize = labelsObj.fontSize;
                    if (labelsObj.showAll !== undefined)
                        labelSettings.showLabelPerSeries = labelsObj.showAll;
                    if (labelsObj.labelStyle !== undefined)
                        labelSettings.labelStyle = labelsObj.labelStyle;
                    if (labelsObj.labelOrientation !== undefined)
                        labelSettings.labelOrientation = supportsLabelOrientation ? labelsObj.labelOrientation : labelSettings.labelOrientation;
                    if (labelsObj.labelPosition) {
                        labelSettings.position = labelsObj.labelPosition;
                    }
                }
            }
            dataLabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject;
            function getDefaultLabelSettings(show, labelColor, fontSize) {
                if (show === void 0) { show = false; }
                return {
                    show: show,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
            function getDefaultCardLabelSettings(labelColor, categoryLabelColor, fontSize) {
                var labelSettings = getDefaultLabelSettings(true, labelColor, fontSize);
                labelSettings.showCategory = true;
                labelSettings.categoryLabelColor = categoryLabelColor;
                return labelSettings;
            }
            dataLabelUtils.getDefaultCardLabelSettings = getDefaultCardLabelSettings;
            function getDefaultTreemapLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    showCategory: true,
                };
            }
            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings;
            function getDefaultSunburstLabelSettings() {
                return {
                    show: false,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    showCategory: true,
                };
            }
            dataLabelUtils.getDefaultSunburstLabelSettings = getDefaultSunburstLabelSettings;
            function getDefaultWaterfallLabelSettings(show, labelColor, fontSize) {
                if (show === void 0) { show = false; }
                return {
                    show: show,
                    labelOrientation: 1 /* Horizontal */,
                    position: visuals.labelPosition.auto,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultWaterfallLabelSettings = getDefaultWaterfallLabelSettings;
            function getDefaultColumnLabelSettings(isLabelPositionInside) {
                var labelSettings = getDefaultLabelSettings(false, undefined);
                labelSettings.position = null;
                labelSettings.labelColor = undefined;
                labelSettings.labelDensity = dataLabelUtils.defaultLabelDensity;
                labelSettings.labelOrientation = 1 /* Horizontal */;
                return labelSettings;
            }
            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings;
            function getDefaultPointLabelSettings() {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
            function getDefaultLineChartLabelSettings(isComboChart) {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    labelDensity: dataLabelUtils.defaultLabelDensity,
                };
            }
            dataLabelUtils.getDefaultLineChartLabelSettings = getDefaultLineChartLabelSettings;
            function getDefaultMapLabelSettings() {
                return {
                    show: false,
                    showCategory: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultMapLabelSettings = getDefaultMapLabelSettings;
            function getDefaultDonutLabelSettings() {
                var labelSettings = dataLabelUtils.getDefaultLabelSettings(true, dataLabelUtils.defaultLabelColor, dataLabelUtils.DefaultFontSizeInPt);
                labelSettings.labelStyle = LabelStyle.category;
                return labelSettings;
            }
            dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings;
            function getDefaultGaugeLabelSettings() {
                return {
                    show: true,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: null,
                    position: null,
                    fontSize: dataLabelUtils.minLabelFontSize,
                };
            }
            dataLabelUtils.getDefaultGaugeLabelSettings = getDefaultGaugeLabelSettings;
            function getDefaultKpiLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    position: null,
                    showCategory: true,
                };
            }
            dataLabelUtils.getDefaultKpiLabelSettings = getDefaultKpiLabelSettings;
            function getLabelPrecision(precision, format) {
                debug.assertAnyValue(format, 'format');
                if (precision !== dataLabelUtils.defaultLabelPrecision)
                    return precision;
                if (format === 'g' || format === 'G')
                    return;
                if (format) {
                    // Calculate precision from positive format by default
                    var positiveFormat = powerbi.NumberFormat.getComponents(format).positive;
                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
                    if (formatMetadata.hasDots) {
                        if (formatMetadata.optionalPrecision)
                            return;
                        return formatMetadata.precision;
                    }
                }
                // For count fields we do not want a precision by default
                return defaultCountLabelPrecision;
            }
            dataLabelUtils.getLabelPrecision = getLabelPrecision;
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data cannot be null or undefined');
                // Hide and reposition labels that overlap
                var dataLabelManager = new powerbi.DataLabelManager();
                var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout);
                var hasAnimation = isAnimator && !!animationDuration;
                var labels = selectLabels(filteredData, context, false, hasAnimation);
                if (!labels)
                    return;
                if (hasAnimation) {
                    labels
                        .text((function (d) { return d.labeltext; }))
                        .transition()
                        .duration(animationDuration)
                        .style(layout.style)
                        .style('opacity', hasSelection ? function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); } : 1)
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } });
                    labels
                        .exit()
                        .transition()
                        .duration(animationDuration)
                        .style('opacity', 0) //fade out labels that are removed
                        .remove();
                }
                else {
                    labels
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } })
                        .text((function (d) { return d.labeltext; }))
                        .style(layout.style);
                    labels
                        .exit()
                        .remove();
                }
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
            function selectLabels(filteredData, context, isDonut, forAnimation) {
                if (isDonut === void 0) { isDonut = false; }
                if (forAnimation === void 0) { forAnimation = false; }
                // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'
                if (filteredData.length === 0) {
                    cleanDataLabels(context, true);
                    return null;
                }
                if (context.select(labelGraphicsContextClass.selector).empty())
                    context.append('g').classed(labelGraphicsContextClass.class, true);
                // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity
                var hasKey = filteredData[0].key != null;
                var hasDataPointIdentity = filteredData[0].identity != null;
                var getIdentifier = hasKey ?
                    function (d) { return d.key; }
                    : hasDataPointIdentity ?
                        function (d) { return d.identity.getKey(); }
                        : undefined;
                var labels = isDonut ?
                    context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, (function (d) { return d.data.identity.getKey(); }))
                    : getIdentifier != null ?
                        context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, getIdentifier)
                        : context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData);
                var newLabels = labels.enter()
                    .append('text')
                    .classed(labelsClass.class, true);
                if (forAnimation)
                    newLabels.style('opacity', 0);
                return labels;
            }
            function cleanDataLabels(context, removeLines) {
                if (removeLines === void 0) { removeLines = false; }
                var empty = [];
                var labels = context.selectAll(labelsClass.selector).data(empty);
                labels.exit().remove();
                context.selectAll(labelGraphicsContextClass.selector).remove();
                if (removeLines) {
                    var lines = context.selectAll(lineClass.selector).data(empty);
                    lines.exit().remove();
                    context.selectAll(linesGraphicsContextClass.selector).remove();
                }
            }
            dataLabelUtils.cleanDataLabels = cleanDataLabels;
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                context.selectAll(labelsClass.selector).style("fill-opacity", (function (d) {
                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                    return labelOpacity;
                }));
            }
            dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
            function getLabelFormattedText(options) {
                var properties = {
                    text: options.formatter
                        ? options.formatter.format(options.label)
                        : powerbi.formattingService.formatValue(options.label, options.format),
                    fontFamily: options.fontFamily ? options.fontFamily : dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: PixelConverter.fromPoint(options.fontSize),
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, options.maxWidth ? options.maxWidth : dataLabelUtils.maxLabelWidth);
            }
            dataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                return visuals.CartesianHelper.getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain);
            }
            dataLabelUtils.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall;
            function doesDataLabelFitInShape(d, yAxisProperties, layout) {
                if (d == null || d.value === null)
                    return false;
                var properties = {
                    text: layout.labelText(d),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var outsidePosition = visuals.CartesianHelper.getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelUtils.labelMargin;
                // The shape is fit to be outside
                if (outsidePosition > 0)
                    return true;
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var shapeWidth = layout.categoryWidth;
                var shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
                //checking that labels aren't greater than shape
                if ((textWidth > shapeWidth) || (textHeight > shapeHeight))
                    return false;
                return true;
            }
            dataLabelUtils.doesDataLabelFitInShape = doesDataLabelFitInShape;
            function getMapLabelLayout(labelSettings) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText({
                            label: d.labeltext,
                            fontSize: labelSettings.fontSize,
                            fontFamily: labelSettings.fontFamily,
                        });
                    },
                    labelLayout: {
                        x: function (d) { return d.x; },
                        y: function (d) {
                            var margin = d.radius + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? d.y - margin : d.y + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.labeltext != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'font-size': PixelConverter.fromPoint(labelSettings.fontSize),
                        'font-family': labelSettings.fontFamily,
                    },
                };
            }
            dataLabelUtils.getMapLabelLayout = getMapLabelLayout;
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
                var formatOverride = (isHundredPercent) ? dataLabelUtils.hundredPercentFormat : null;
                var formattersCache = createColumnFormatterCacheManager();
                var hasSelection = interactivityService ? interactivityService.hasSelection() : false;
                return {
                    labelText: function (d) {
                        var formatString = (formatOverride != null) ? formatOverride : d.labelFormatString;
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
                        var formatter = formattersCache.getOrCreate(formatString, d.labelSettings, value2);
                        return getLabelFormattedText({
                            label: formatter.format(d.value),
                            maxWidth: dataLabelUtils.maxLabelWidth
                        });
                    },
                    labelLayout: labelLayoutXY,
                    filter: function (d) { return dataLabelUtils.getColumnChartLabelFilter(d, hasSelection, data.hasHighlights, axisOptions, visualWidth); },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'text-anchor': isColumn ? 'middle' : 'start',
                    },
                };
            }
            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
            /**
             * Valide for stacked column/bar chart and 100% stacked column/bar chart,
             * that labels that should to be inside the shape aren't bigger then shapes.
             */
            function validateLabelsSize(d, axisOptions, visualWidth) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var columnWidth = axisOptions.columnWidth;
                var properties = {
                    text: d.labeltext,
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var shapeWidth, shapeHeight;
                var inside = false;
                var outsidePosition = visuals.ColumnUtil.calculatePosition(d, axisOptions);
                switch (d.chartType) {
                    case 18 /* stackedBar */:
                    case 50 /* hundredPercentStackedBar */:
                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
                        if (!d.lastSeries || (outsidePosition + textWidth > visualWidth) || d.chartType === 50 /* hundredPercentStackedBar */) {
                            shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                            shapeHeight = columnWidth;
                            inside = true;
                        }
                        break;
                    case 10 /* clusteredBar */:
                        // if the label doesn't fit where specified, then it should be inside 
                        if ((outsidePosition + textWidth) > visualWidth) {
                            shapeWidth = Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
                            shapeHeight = columnWidth;
                            inside = true;
                        }
                        break;
                    case 20 /* stackedColumn */:
                    case 52 /* hundredPercentStackedColumn */:
                    case 68 /* ribbonChart */:
                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
                        if (!d.lastSeries || outsidePosition <= 0 || d.chartType === 52 /* hundredPercentStackedColumn */) {
                            shapeWidth = columnWidth;
                            shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            inside = true;
                        }
                        break;
                    case 12 /* clusteredColumn */:
                        // if the label doesn't fit where specified, then it should be inside 
                        if (outsidePosition <= 0) {
                            shapeWidth = columnWidth;
                            shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
                            inside = true;
                        }
                        break;
                    default:
                        return true;
                }
                //checking that labels aren't greater than shape
                if (inside && ((textWidth > shapeWidth) || textHeight > shapeHeight))
                    return false;
                return true;
            }
            function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
                //labels of dimmed are hidden
                var shapesOpacity = hasSelection ? visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) :
                    visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                return (d != null && d.value != null && validateLabelsSize(d, axisOptions, visualWidth) && shapesOpacity === 1);
            }
            dataLabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter;
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText({
                            label: d.formattedCategory.getValue(),
                            maxWidth: dataLabelUtils.maxLabelWidth * 2.0
                        });
                    },
                    labelLayout: {
                        x: function (d) { return xScale(d.x); },
                        y: function (d) {
                            var margin = visuals.CartesianHelper.getBubbleRadius(d.radius, sizeRange, viewport, visuals.shapeUtil.MinBubbleMultiplier) + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.formattedCategory.getValue() != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                    },
                };
            }
            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function (d) {
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, d.labelSettings, value2);
                        return getLabelFormattedText({ label: formatter.format(d.value) });
                    },
                    labelLayout: {
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex); },
                        y: function (d) { return labelSettings.position === 0 /* Above */ ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin; },
                    },
                    filter: function (d) {
                        return (d != null && d.value != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'font-size': function (d) { return PixelConverter.fromPoint(d.labelSettings.fontSize); },
                        'font-family': function (d) { return d.labelSettings.fontFamily; },
                    },
                };
            }
            dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
            function enumerateDataLabels(options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.enumeration, 'enumeration');
                if (!options.dataLabelsSettings)
                    return;
                var instance = {
                    objectName: 'labels',
                    selector: options.selector,
                    properties: {},
                };
                if (options.show && options.selector) {
                    // If options.selector is defined, we are customizing a single serie.
                    instance.properties['showSeries'] = options.dataLabelsSettings.show;
                }
                else if (options.show) {
                    // Otherwise, we are customizing all the serie.
                    instance.properties['show'] = options.dataLabelsSettings.show;
                }
                var labelSettingsStyle;
                if (options.labelStyle) {
                    instance.properties['labelStyle'] = options.dataLabelsSettings.labelStyle;
                    labelSettingsStyle = visuals.LabelUtils.getLabelStyleFlagType(options.dataLabelsSettings.labelStyle);
                }
                instance.properties['color'] = options.dataLabelsSettings.labelColor || dataLabelUtils.defaultLabelColor;
                if (options.displayUnits) {
                    instance.properties['labelDisplayUnits'] = options.dataLabelsSettings.displayUnits;
                }
                if ((options.precision && labelSettingsStyle && EnumExtensions.hasFlag(labelSettingsStyle, LabelStyle.flagLabelStyleData))
                    || (options.precision && !labelSettingsStyle)) {
                    var precision = options.dataLabelsSettings.precision;
                    instance.properties['labelPrecision'] = precision === dataLabelUtils.defaultLabelPrecision ? null : precision;
                }
                if ((options.percentagePrecision && labelSettingsStyle && EnumExtensions.hasFlag(labelSettingsStyle, LabelStyle.flagLabelStylePercent))
                    || (options.percentagePrecision && !labelSettingsStyle)) {
                    var percentagePrecision = options.dataLabelsSettings.percentagePrecision;
                    instance.properties['percentageLabelPrecision'] = percentagePrecision === dataLabelUtils.defaultPercentageLabelPrecision ? null : percentagePrecision;
                }
                if (options.labelOrientation) {
                    instance.properties['labelOrientation'] = options.dataLabelsSettings.labelOrientation;
                }
                if (options.position) {
                    instance.properties['labelPosition'] = options.dataLabelsSettings.position;
                    if (options.positionObject) {
                        if (instance.validValues)
                            instance.validValues['labelPosition'] = options.positionObject;
                        else
                            instance.validValues = { 'labelPosition': options.positionObject };
                    }
                }
                if (options.fontSize) {
                    instance.properties['fontSize'] = options.dataLabelsSettings.fontSize;
                    if (options.fontSizeRange) {
                        var numberRange = {
                            numberRange: {
                                min: options.dataLabelsSettings.minFontSize,
                                max: options.dataLabelsSettings.maxFontSize
                            }
                        };
                        if (instance.validValues) {
                            instance.validValues['fontSize'] = numberRange;
                        }
                        else {
                            instance.validValues = { 'fontSize': numberRange };
                        }
                    }
                }
                if (options.fontFamily) {
                    instance.properties['fontFamily'] = options.dataLabelsSettings.fontFamily || visuals.DEFAULT_FONT_FAMILY;
                }
                if (options.labelDensity) {
                    var lineChartSettings = options.dataLabelsSettings;
                    if (lineChartSettings)
                        instance.properties['labelDensity'] = lineChartSettings.labelDensity;
                }
                //Keep show all as the last property of the instance.
                if (options.showAll)
                    instance.properties['showAll'] = !!options.dataLabelsSettings.showLabelPerSeries;
                return options.enumeration.pushInstance(instance);
            }
            dataLabelUtils.enumerateDataLabels = enumerateDataLabels;
            function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
                if (isShowCategory === void 0) { isShowCategory = false; }
                var labelSettings = (dataLabelsSettings)
                    ? dataLabelsSettings
                    : getDefaultPointLabelSettings();
                var instance = {
                    objectName: 'categoryLabels',
                    selector: null,
                    properties: {
                        show: isShowCategory
                            ? labelSettings.showCategory
                            : labelSettings.show,
                        fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : dataLabelUtils.DefaultFontSizeInPt,
                        fontFamily: dataLabelsSettings ? dataLabelsSettings.fontFamily : dataLabelUtils.DefaultLabelFontFamily,
                    },
                };
                if (withFill) {
                    instance.properties['color'] = labelSettings.categoryLabelColor
                        ? labelSettings.categoryLabelColor
                        : labelSettings.labelColor;
                }
                if (fontSize) {
                    instance.properties['fontSize'] = fontSize;
                }
                enumeration.pushInstance(instance);
            }
            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
                    return axisFormatter.displayUnit.value;
                return null;
            }
            dataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter;
            function createColumnFormatterCacheManager() {
                return new ColumnFormatterCacheManager();
            }
            dataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            dataLabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter;
            function isTextWidthOverflows(textWidth, maxTextWidth) {
                return textWidth > maxTextWidth;
            }
            dataLabelUtils.isTextWidthOverflows = isTextWidthOverflows;
            function isTextHeightOverflows(textHeight, innerChordLength) {
                return textHeight > innerChordLength;
            }
            dataLabelUtils.isTextHeightOverflows = isTextHeightOverflows;
            var ColumnFormatterCacheManager = /** @class */ (function () {
                function ColumnFormatterCacheManager() {
                    this.cache = {};
                }
                ColumnFormatterCacheManager.prototype.getOrCreate = function (formatString, labelSetting, value2) {
                    var cacheKeyObject = {
                        formatString: formatString,
                        displayUnits: labelSetting.displayUnits,
                        precision: formatString ? getLabelPrecision(labelSetting.precision, formatString) : labelSetting.precision,
                        value2: value2
                    };
                    var cacheKey = JSON.stringify(cacheKeyObject);
                    if (!this.cache[cacheKey])
                        this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                    return this.cache[cacheKey];
                };
                return ColumnFormatterCacheManager;
            }());
        })(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EventBubblingUtil;
        (function (EventBubblingUtil) {
            /** Returns whether the D3 Event has been marked as handled */
            function handled(e) {
                if (!e)
                    return;
                var source = e;
                var handled = source.handled;
                return !!handled;
            }
            EventBubblingUtil.handled = handled;
            /** Marks the D3 Event as having been handled */
            function markAsHandled(e) {
                if (!e)
                    return;
                var source = e;
                source.handled = true;
            }
            EventBubblingUtil.markAsHandled = markAsHandled;
        })(EventBubblingUtil = visuals.EventBubblingUtil || (visuals.EventBubblingUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var pbi = powerbi;
        var DataViewObject = pbi.DataViewObject;
        var FontProperties;
        (function (FontProperties) {
            function createFromDataViewObject(properties, propertyNames, parent) {
                debug.assertValue(propertyNames, 'propertyNames');
                var size;
                if (propertyNames.size) {
                    var value = DataViewObject.getValue(properties, propertyNames.size);
                    if (value != null) {
                        if (propertyNames.sizeInPixels) {
                            size = visuals.Units.FontSize.createFromPx(+value); // Coerce into a number
                        }
                        else {
                            size = visuals.Units.FontSize.createFromPt(+value); // Coerce into a number
                        }
                    }
                }
                var fontProperties = {
                    color: propertyNames.color && DataViewObject.getFillColorByPropertyName(properties, propertyNames.color),
                    family: propertyNames.family && DataViewObject.getValue(properties, propertyNames.family),
                    lineHeight: propertyNames.lineHeight && DataViewObject.getValue(properties, propertyNames.lineHeight),
                    size: size,
                    style: propertyNames.style && DataViewObject.getValue(properties, propertyNames.style),
                    variant: propertyNames.variant && DataViewObject.getValue(properties, propertyNames.variant),
                    weight: propertyNames.weight && DataViewObject.getValue(properties, propertyNames.weight),
                    whiteSpace: propertyNames.whiteSpace && DataViewObject.getValue(properties, propertyNames.whiteSpace)
                };
                return parent ? FontProperties.inherit(parent, fontProperties) : fontProperties;
            }
            FontProperties.createFromDataViewObject = createFromDataViewObject;
            /**
             * Inherits a `FontProperties` object allowing specific properties to be overriden.
             * Typically used for changing values on an existing object as all properties are readonly.
             * @param fontProperties The existing `FontProperties` object
             * @param newFontProperties The properties to override
             * @returns A new object inherited from `fontProperties`.
             */
            function inherit(fontProperties, newFontProperties) {
                debug.assertValue(fontProperties, 'fontProperties');
                // Cast to FontPropertiesInt so we can set the properties
                var inheritedFontProperties = powerbi.Prototype.inherit(fontProperties);
                if (!newFontProperties) {
                    return inheritedFontProperties;
                }
                if (newFontProperties.color)
                    inheritedFontProperties.color = newFontProperties.color;
                if (newFontProperties.family)
                    inheritedFontProperties.family = newFontProperties.family;
                if (newFontProperties.lineHeight)
                    inheritedFontProperties.lineHeight = newFontProperties.lineHeight;
                if (newFontProperties.size)
                    inheritedFontProperties.size = newFontProperties.size;
                if (newFontProperties.style)
                    inheritedFontProperties.style = newFontProperties.style;
                if (newFontProperties.variant)
                    inheritedFontProperties.variant = newFontProperties.variant;
                if (newFontProperties.weight)
                    inheritedFontProperties.weight = newFontProperties.weight;
                if (newFontProperties.whiteSpace)
                    inheritedFontProperties.whiteSpace = newFontProperties.whiteSpace;
                return inheritedFontProperties;
            }
            FontProperties.inherit = inherit;
            function toTextProperties(fontProperties, text, excludeInherited) {
                debug.assertValue(fontProperties, 'fontProperties');
                if (excludeInherited) {
                    fontProperties = excludeInheritedProperties(fontProperties);
                }
                // TODO TextProperties doesn't have line height
                return {
                    text: text,
                    fontFamily: fontProperties.family,
                    fontSize: fontProperties.size ? PixelConverter.toString(fontProperties.size.px) : undefined,
                    fontWeight: fontProperties.weight,
                    fontStyle: fontProperties.style,
                    fontVariant: fontProperties.variant,
                    whiteSpace: fontProperties.whiteSpace
                };
            }
            FontProperties.toTextProperties = toTextProperties;
            function toHTMLStyle(fontProperties) {
                debug.assertValue(fontProperties, 'fontProperties');
                var style = {};
                if (fontProperties.color)
                    style['color'] = fontProperties.color;
                if (fontProperties.family)
                    style['font-family'] = fontProperties.family;
                if (fontProperties.lineHeight)
                    style['line-height'] = fontProperties.lineHeight;
                if (fontProperties.size)
                    style['font-size'] = fontProperties.size ? PixelConverter.toString(fontProperties.size.px) : undefined;
                if (fontProperties.style)
                    style['font-style'] = fontProperties.style;
                if (fontProperties.variant)
                    style['font-variant'] = fontProperties.variant;
                if (fontProperties.weight)
                    style['font-weight'] = fontProperties.weight;
                if (fontProperties.whiteSpace)
                    style['white-space'] = fontProperties.whiteSpace;
                return style;
            }
            FontProperties.toHTMLStyle = toHTMLStyle;
            function applyStyleToElement(fontProperties, element) {
                debug.assertValue(fontProperties, 'fontProperties');
                debug.assertValue(element, 'element');
                applyStyle(fontProperties, element.style);
                return element;
            }
            FontProperties.applyStyleToElement = applyStyleToElement;
            function applyStyle(fontProperties, style) {
                debug.assertValue(fontProperties, 'fontProperties');
                debug.assertValue(style, 'style');
                if (fontProperties.color)
                    style.fill = fontProperties.color;
                if (fontProperties.family)
                    style.fontFamily = fontProperties.family;
                if (fontProperties.lineHeight)
                    style.lineHeight = fontProperties.lineHeight;
                if (fontProperties.size)
                    style.fontSize = fontProperties.size ? PixelConverter.toString(fontProperties.size.px) : undefined;
                if (fontProperties.style)
                    style.fontStyle = fontProperties.style;
                if (fontProperties.variant)
                    style.fontVariant = fontProperties.variant;
                if (fontProperties.weight)
                    style.fontWeight = fontProperties.weight;
                if (fontProperties.whiteSpace)
                    style.whiteSpace = fontProperties.whiteSpace;
            }
            FontProperties.applyStyle = applyStyle;
            function toSVGStyle(fontProperties) {
                debug.assertValue(fontProperties, 'fontProperties');
                var style = {};
                if (fontProperties.color)
                    style['fill'] = fontProperties.color;
                if (fontProperties.family)
                    style['font-family'] = fontProperties.family;
                if (fontProperties.lineHeight)
                    style['line-height'] = fontProperties.lineHeight;
                if (fontProperties.size)
                    style['font-size'] = fontProperties.size ? PixelConverter.toString(fontProperties.size.px) : undefined;
                if (fontProperties.style)
                    style['font-style'] = fontProperties.style;
                if (fontProperties.variant)
                    style['font-variant'] = fontProperties.variant;
                if (fontProperties.weight)
                    style['font-weight'] = fontProperties.weight;
                if (fontProperties.whiteSpace)
                    style['white-space'] = fontProperties.whiteSpace;
                return style;
            }
            FontProperties.toSVGStyle = toSVGStyle;
            function excludeInheritedProperties(fontProperties, includeLevels) {
                if (includeLevels === void 0) { includeLevels = 0; }
                var newFontProperties = {};
                for (var i = 0; i <= includeLevels; i++) {
                    _.forOwn(fontProperties, (function (value, key) {
                        if (newFontProperties[key] === undefined) {
                            newFontProperties[key] = value;
                        }
                    }));
                    fontProperties = Object.getPrototypeOf(fontProperties);
                }
                return newFontProperties;
            }
            FontProperties.excludeInheritedProperties = excludeInheritedProperties;
            function toD3Style(fontPropertiesGetter) {
                return {
                    'fill': function (d) { return fontPropertiesGetter(d).color; },
                    'font-family': function (d) { return fontPropertiesGetter(d).family; },
                    'font-size': function (d) { return fontPropertiesGetter(d).size ? PixelConverter.toString(fontPropertiesGetter(d).size.px) : undefined; },
                    'font-style': function (d) { return fontPropertiesGetter(d).style; },
                    'font-variant': function (d) { return fontPropertiesGetter(d).variant; },
                    'font-weight': function (d) { return fontPropertiesGetter(d).weight; },
                    'white-space': function (d) { return fontPropertiesGetter(d).whiteSpace; },
                };
            }
            FontProperties.toD3Style = toD3Style;
        })(FontProperties = visuals.FontProperties || (visuals.FontProperties = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var ForecastHelper;
        (function (ForecastHelper) {
            var ForecastPropertyNames;
            (function (ForecastPropertyNames) {
                ForecastPropertyNames.show = 'show';
                ForecastPropertyNames.displayName = 'displayName';
                ForecastPropertyNames.lineColor = 'lineColor';
                ForecastPropertyNames.confidenceBandStyle = 'confidenceBandStyle';
                ForecastPropertyNames.transparency = 'transparency';
                ForecastPropertyNames.style = 'style';
            })(ForecastPropertyNames || (ForecastPropertyNames = {}));
            ForecastHelper.forecastObjectName = 'forecast';
            ForecastHelper.forecastValueRole = 'forecast.ForecastValue';
            ForecastHelper.forecastConfidenceHighBoundRole = 'forecast.ConfidenceHighBound';
            ForecastHelper.forecastConfidenceLowBoundRole = 'forecast.ConfidenceLowBound';
            ForecastHelper.defaults = {
                lineColor: { solid: { color: '#000' } },
                displayName: '',
                confidenceBandStyle: visuals.confidenceBandStyle.fill,
                transparency: 80,
                style: visuals.lineStyle.solid
            };
            ForecastHelper.quarterHierarchyLevelPrefixResorceKey = 'Visual_Quarter_Abbreviated';
            var ForecastClassSelector = createClassAndSelector('forecast-line');
            var ForecastErrorRangeClassSelector = createClassAndSelector('forecast-error-range');
            var ForecastLayerClassSelector = createClassAndSelector('forecast-line-layer');
            function enumerateObjectInstances(enumeration, forecasts) {
                debug.assertValue(enumeration, 'enumeration');
                var forecast;
                if (!_.isEmpty(forecasts))
                    forecast = forecasts[0];
                if (!forecast) {
                    enumeration.pushInstance({
                        selector: {
                            id: '0'
                        },
                        properties: {
                            show: false,
                            lineColor: ForecastHelper.defaults.lineColor,
                            style: ForecastHelper.defaults.style,
                            confidenceBandStyle: ForecastHelper.defaults.confidenceBandStyle,
                            transparency: ForecastHelper.defaults.transparency,
                        },
                        objectName: ForecastHelper.forecastObjectName,
                    });
                    return;
                }
                var properties = (_a = {},
                    _a[ForecastPropertyNames.show] = forecast.show,
                    _a[ForecastPropertyNames.displayName] = forecast.displayName,
                    _a[ForecastPropertyNames.lineColor] = forecast.lineColor,
                    _a[ForecastPropertyNames.style] = forecast.style,
                    _a[ForecastPropertyNames.confidenceBandStyle] = forecast.confidenceBandStyle,
                    _a[ForecastPropertyNames.transparency] = forecast.transparency,
                    _a);
                enumeration.pushInstance({
                    selector: forecast.selector,
                    properties: properties,
                    objectName: ForecastHelper.forecastObjectName,
                });
                var _a;
            }
            ForecastHelper.enumerateObjectInstances = enumerateObjectInstances;
            function isDataViewForForecast(dataView) {
                if (!dataView || !dataView.categorical || !dataView.categorical.values)
                    return false;
                var grouped = dataView.categorical.values.grouped();
                for (var _i = 0, grouped_1 = grouped; _i < grouped_1.length; _i++) {
                    var group = grouped_1[_i];
                    var hasRole = _.any(group.values, (function (value) { return DataRoleHelper.hasRoleInValueColumn(value, 'forecast.ForecastValue'); }));
                    if (hasRole)
                        return true;
                }
                return false;
            }
            ForecastHelper.isDataViewForForecast = isDataViewForForecast;
            function readDataView(dataView, sourceDataView, colors) {
                if (!dataView || !dataView.categorical || !sourceDataView || !sourceDataView.categorical)
                    return [];
                var categorical = dataView.categorical;
                if (_.isEmpty(categorical.categories) || _.isEmpty(categorical.values))
                    return [];
                var scalarKeys = visuals.ScalarUtils.getScalarKeys(categorical.categories[0]);
                var categories = scalarKeys ? _.map(scalarKeys.values, (function (value) { return value.min; })) : categorical.categories[0].values;
                var groups = categorical.values.grouped();
                if (_.isEmpty(categories) || _.isEmpty(groups))
                    return [];
                var valueColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, ForecastHelper.forecastValueRole);
                var upperBoundColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, ForecastHelper.forecastConfidenceHighBoundRole);
                var lowerBoundColumnIndex = DataRoleHelper.getMeasureIndexOfRole(groups, ForecastHelper.forecastConfidenceLowBoundRole);
                var forecastLines = [];
                var forecastsByColumn = getForecastLineObjects(sourceDataView);
                var groupIndex = 0;
                for (var columnName in forecastsByColumn) {
                    var forecastObjects = forecastsByColumn[columnName];
                    for (var id in forecastObjects) {
                        var forecastObject = forecastObjects[id];
                        var show = powerbi.DataViewObject.getValue(forecastObject, ForecastPropertyNames.show, false);
                        var displayName = powerbi.DataViewObject.getValue(forecastObject, ForecastPropertyNames.displayName);
                        var lineColor = powerbi.DataViewObject.getValue(forecastObject, ForecastPropertyNames.lineColor, ForecastHelper.defaults.lineColor);
                        var confidenceBandStyle_1 = powerbi.DataViewObject.getValue(forecastObject, ForecastPropertyNames.confidenceBandStyle, ForecastHelper.defaults.confidenceBandStyle);
                        var transparency = powerbi.DataViewObject.getValue(forecastObject, ForecastPropertyNames.transparency, ForecastHelper.defaults.transparency);
                        var style = powerbi.DataViewObject.getValue(forecastObject, ForecastPropertyNames.style, ForecastHelper.defaults.style);
                        var colorHelper = new visuals.ColorHelper(colors, { objectName: 'dataPoint', propertyName: 'fill' }, ForecastHelper.defaults.lineColor.solid.color);
                        var group = groups[groupIndex];
                        var points = [];
                        var values = group.values[valueColumnIndex].highlights ? group.values[valueColumnIndex].highlights : group.values[valueColumnIndex].values;
                        var upperBoundValues = group.values[upperBoundColumnIndex].highlights ? group.values[upperBoundColumnIndex].highlights : group.values[upperBoundColumnIndex].values;
                        var lowerBoundValues = group.values[lowerBoundColumnIndex].highlights ? group.values[lowerBoundColumnIndex].highlights : group.values[lowerBoundColumnIndex].values;
                        for (var i = 0; i < categories.length; i++) {
                            var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]);
                            var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                            if (x != null && y != null) {
                                var upperBoundY = visuals.AxisHelper.normalizeNonFiniteNumber(upperBoundValues[i]);
                                var lowerBoundY = visuals.AxisHelper.normalizeNonFiniteNumber(lowerBoundValues[i]);
                                points.push({
                                    point: { x: x, y: y },
                                    upperBound: { x: x, y: upperBoundY },
                                    lowerBound: { x: x, y: lowerBoundY },
                                });
                            }
                        }
                        var seriesLineColor = void 0;
                        if (lineColor) {
                            seriesLineColor = lineColor;
                        }
                        else {
                            if (sourceDataView.categorical.values.source) {
                                // Dynamic series
                                var sourceGroups = sourceDataView.categorical.values.grouped();
                                var color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
                                seriesLineColor = { solid: { color: color } };
                            }
                            else {
                                // Static series
                                var matchingMeasure = sourceDataView.categorical.values[groupIndex];
                                var color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
                                seriesLineColor = { solid: { color: color } };
                            }
                        }
                        forecastLines.push({
                            selector: { id: id, metadata: columnName },
                            points: points,
                            show: show,
                            displayName: displayName,
                            lineColor: seriesLineColor,
                            confidenceBandStyle: confidenceBandStyle_1,
                            transparency: transparency,
                            style: style
                        });
                        groupIndex++;
                    }
                }
                return forecastLines;
            }
            ForecastHelper.readDataView = readDataView;
            function getForecastLineObjects(forecastDataView) {
                var forecastObjects = [];
                if (forecastDataView && forecastDataView.categorical && forecastDataView.categorical.values) {
                    var columnGroup = _.first(forecastDataView.categorical.values.grouped());
                    if (columnGroup) {
                        for (var _i = 0, _a = columnGroup.values; _i < _a.length; _i++) {
                            var valueColumn = _a[_i];
                            var column = valueColumn.source.queryName;
                            var objects = powerbi.DataViewObjects.getUserDefinedObjects(valueColumn.source.objects, ForecastHelper.forecastObjectName);
                            forecastObjects[column] = objects;
                        }
                    }
                }
                return forecastObjects;
            }
            // TODO: add a view model for these parameters.
            function render(forecastLines, graphicsContext, xScale, yScale, viewport, animationDuration) {
                var layer = graphicsContext.select(ForecastLayerClassSelector.selector);
                if (layer.empty()) {
                    layer = graphicsContext.insert('g', ':first-child').classed(ForecastLayerClassSelector.class, true);
                }
                var errorRange = layer.selectAll(ForecastErrorRangeClassSelector.selector).data(forecastLines || []);
                errorRange.enter().insert('path', ':first-child').classed(ForecastErrorRangeClassSelector.class, true);
                errorRange
                    .transition()
                    .ease('linear')
                    .duration(animationDuration)
                    .attr('d', (function (d) {
                    var pathGen = d3.svg.line()
                        .x((function (point) { return xScale(point.x); }))
                        .y((function (point) { return yScale(point.y); }));
                    var points = [];
                    // add lowerBound points in reverse order so that the area created is properly closed and the points are in order
                    for (var _i = 0, _a = d.points.slice().reverse(); _i < _a.length; _i++) {
                        var point = _a[_i];
                        points.push({ x: point.lowerBound.x, y: point.lowerBound.y });
                    }
                    for (var _b = 0, _c = d.points; _b < _c.length; _b++) {
                        var point = _c[_b];
                        points.push({ x: point.upperBound.x, y: point.upperBound.y });
                    }
                    return pathGen(points);
                }));
                errorRange.each((function (d) {
                    var errorRangeArea = d3.select(this);
                    var style = {};
                    var opacity = (100 - d.transparency) / 100;
                    style['fill-opacity'] = opacity;
                    style['stroke-opacity'] = opacity;
                    if (d.confidenceBandStyle === visuals.confidenceBandStyle.fill) {
                        style['stroke'] = 'transparent';
                        style['fill'] = d.lineColor.solid.color;
                    }
                    else if (d.confidenceBandStyle === visuals.confidenceBandStyle.line) {
                        style['stroke'] = d.lineColor.solid.color;
                        style['fill'] = 'transparent';
                    }
                    else if (d.confidenceBandStyle === visuals.confidenceBandStyle.none) {
                        style['stroke'] = 'transparent';
                        style['fill'] = 'transparent';
                    }
                    errorRangeArea.style(style);
                }));
                errorRange.exit().remove();
                var lines = layer.selectAll(ForecastClassSelector.selector).data(forecastLines || []);
                lines.enter().append('path').classed(ForecastClassSelector.class, true);
                lines
                    .transition()
                    .ease('linear')
                    .duration(animationDuration)
                    .attr('d', (function (d) {
                    var pathGen = d3.svg.line()
                        .x((function (point) { return xScale(point.point.x); }))
                        .y((function (point) { return yScale(point.point.y); }));
                    return pathGen(d.points);
                }));
                lines.each((function (d) {
                    var line = d3.select(this);
                    var style = {};
                    style['stroke'] = d.lineColor.solid.color;
                    style['fill'] = 'transparent';
                    if (d.style === visuals.lineStyle.dashed) {
                        style['stroke-dasharray'] = '5, 5';
                    }
                    else if (d.style === visuals.lineStyle.dotted) {
                        style['stroke-dasharray'] = '1, 5';
                        style['stroke-linecap'] = "round";
                    }
                    else if (d.style === visuals.lineStyle.solid) {
                        style['stroke-dasharray'] = null;
                        style['stroke-linecap'] = null;
                    }
                    line.style(style);
                }));
                lines.exit().remove();
            }
            ForecastHelper.render = render;
        })(ForecastHelper = visuals.ForecastHelper || (visuals.ForecastHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var GeoJsonHelper;
        (function (GeoJsonHelper) {
            function getTopoJsonShapeKeys(topojson) {
                try {
                    var shapes_1 = topojson.objects[Object.keys(topojson.objects)[0]].geometries;
                    var idPresent = false;
                    var propertyNamesSet = {};
                    for (var _i = 0, shapes_2 = shapes_1; _i < shapes_2.length; _i++) {
                        var shape = shapes_2[_i];
                        idPresent = idPresent || shape.id != null;
                        if (shape.properties) {
                            var shapeProperties = Object.keys(shape.properties);
                            for (var _a = 0, shapeProperties_1 = shapeProperties; _a < shapeProperties_1.length; _a++) {
                                var shapeProperty = shapeProperties_1[_a];
                                propertyNamesSet[shapeProperty] = true;
                            }
                        }
                    }
                    var propertyNamesArray = Object.keys(propertyNamesSet).sort();
                    _.pull(propertyNamesArray, 'id'); // Remove property named "id", if it is present.
                    //TopoJSON format has a peculiarity where "id" property is defined on the shape object,
                    //while all other properties are defined on the shape's "properties" property.
                    //TODO: Communicate this situation to the user when it arises.
                    var allShapesPropertyValues = [];
                    for (var _b = 0, shapes_3 = shapes_1; _b < shapes_3.length; _b++) {
                        var shape = shapes_3[_b];
                        var thisShapePropertyValues = [];
                        if (idPresent)
                            thisShapePropertyValues.push(shape.id);
                        if (shape.properties) {
                            for (var _c = 0, propertyNamesArray_1 = propertyNamesArray; _c < propertyNamesArray_1.length; _c++) {
                                var propertyName = propertyNamesArray_1[_c];
                                thisShapePropertyValues.push(shape.properties[propertyName]);
                            }
                        }
                        allShapesPropertyValues.push(thisShapePropertyValues);
                    }
                    propertyNamesArray = (idPresent ? ['id'] : []).concat(propertyNamesArray);
                    if (!_.isEmpty(propertyNamesArray) && !_.isEmpty(allShapesPropertyValues)) {
                        // If there are no shapes or no keys, we will return undefined
                        return {
                            names: propertyNamesArray,
                            values: allShapesPropertyValues
                        };
                    }
                    // At this point, TopoJSON is valid, but it doesn't have shapes and keys like we expect
                }
                catch (e) {
                    // An exception can be raised if there are problems with TopoJSON file that can be out of our control.
                    // If that is the case, we let the method fall through and return undefined.
                }
                // If topojson is malformed or does not contain at least one shape with at least one key,
                // we fall through to here, and let the method return undefined.
            }
            GeoJsonHelper.getTopoJsonShapeKeys = getTopoJsonShapeKeys;
        })(GeoJsonHelper = visuals.GeoJsonHelper || (visuals.GeoJsonHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var FontSize = visuals.Units.FontSize;
        var PixelConverter = jsCommon.PixelConverter;
        var LabelUtils;
        (function (LabelUtils) {
            LabelUtils.DefaultLabelFontSizeInPt = 9;
            LabelUtils.minLabelFontSize = 8;
            LabelUtils.labelMargin = 8;
            LabelUtils.defaultLabelDensity = "50";
            LabelUtils.MapPolylineOpacity = 0.5;
            LabelUtils.LabelDensityBufferFactor = 3;
            LabelUtils.LabelDensityPadding = 6;
            LabelUtils.startingLabelOffset = 8;
            LabelUtils.maxLabelOffset = 8;
            LabelUtils.maxLabelWidth = 50;
            LabelUtils.hundredPercentFormat = '0.00 %;-0.00 %;0.00 %';
            LabelUtils.DefaultFontSizeInPt = 9;
            LabelUtils.DefaultLabelFontFamily = visuals.Font.Family.regularSecondary.css;
            LabelUtils.StandardFontFamily = visuals.Font.Family.regular.css;
            LabelUtils.defaultFontProperties = {
                family: LabelUtils.DefaultLabelFontFamily,
                size: FontSize.createFromPt(LabelUtils.DefaultFontSizeInPt),
                weight: 'normal',
            };
            LabelUtils.LabelTextProperties = {
                fontFamily: visuals.Font.Family.regularSecondary.css,
                fontSize: PixelConverter.fromPoint(LabelUtils.DefaultFontSizeInPt),
                fontWeight: 'normal',
            };
            LabelUtils.defaultLabelColor = "#777777";
            LabelUtils.defaultInsideLabelColor = "#ffffff"; //white
            LabelUtils.horizontalLabelBackgroundPadding = 4;
            LabelUtils.verticalLabelBackgroundPadding = 2;
            LabelUtils.defaultTreeMapMinorLabelTextSize = 10;
            LabelUtils.defaultTreeMapMajorLabelTextSize = 12;
            LabelUtils.DefaultTreeMapDataLabelMinFontSize = 7;
            LabelUtils.DefaultTreeMapDataLabelMaxFontSize = 40;
            LabelUtils.labelGraphicsContextClass = createClassAndSelector('labelGraphicsContext');
            LabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector('labelBackgroundGraphicsContext');
            function downgradeToVisualDataLabelsSettingsOld(labelSettings) {
                if (!labelSettings)
                    return;
                var inheritedLabelSettings = powerbi.Prototype.inherit(labelSettings);
                inheritedLabelSettings.fontProperties = null;
                var labelSettingOld = inheritedLabelSettings;
                labelSettingOld.labelColor = labelSettings.fontProperties ? labelSettings.fontProperties.color : undefined;
                labelSettingOld.fontSize = (labelSettings.fontProperties && labelSettings.fontProperties.size) ? labelSettings.fontProperties.size.pt : undefined;
                labelSettingOld.fontFamily = labelSettings.fontProperties ? labelSettings.fontProperties.family : undefined;
                return labelSettingOld;
            }
            function downgradeToColumnOrLineDataLabelsSettingsOld(labelSettings) {
                if (!labelSettings)
                    return;
                var inheritedLabelSettings = powerbi.Prototype.inherit(labelSettings);
                inheritedLabelSettings.fontProperties = null;
                var labelSettingOld = inheritedLabelSettings;
                labelSettingOld.labelColor = labelSettings.fontProperties ? labelSettings.fontProperties.color : undefined;
                labelSettingOld.fontSize = (labelSettings.fontProperties && labelSettings.fontProperties.size) ? labelSettings.fontProperties.size.pt : undefined;
                labelSettingOld.fontFamily = labelSettings.fontProperties ? labelSettings.fontProperties.family : undefined;
                return labelSettingOld;
            }
            function downgradeToColumnChartDataPointOld(dataPoint) {
                if (!dataPoint)
                    return;
                var inheritedDataPoint = powerbi.Prototype.inherit(dataPoint);
                var dataPointOld = inheritedDataPoint;
                dataPointOld.labelSettings = downgradeToColumnOrLineDataLabelsSettingsOld(dataPoint.labelSettings);
                return dataPointOld;
            }
            function downgradeToVisualDataLabelsSettingsOptionsOld(options) {
                if (!options)
                    return;
                var inheritedOptions = powerbi.Prototype.inherit(options);
                var optionsOld = inheritedOptions;
                optionsOld.dataLabelsSettings = downgradeToVisualDataLabelsSettingsOld(options.dataLabelsSettings);
                return optionsOld;
            }
            function downgradeToOldLabels(labels) {
                if (!labels)
                    return;
                return _.map(labels, (function (label) {
                    var inheritedLabel = powerbi.Prototype.inherit(label);
                    inheritedLabel.fontProperties = null;
                    var oldLabel = inheritedLabel;
                    oldLabel.fill = label.fontProperties ? label.fontProperties.color : undefined;
                    oldLabel.fontSize = (label.fontProperties && label.fontProperties.size) ? label.fontProperties.size.pt : undefined;
                    oldLabel.fontFamily = label.fontProperties ? label.fontProperties.family : undefined;
                    return oldLabel;
                }));
            }
            LabelUtils.downgradeToOldLabels = downgradeToOldLabels;
            function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
                if (numeric === void 0) { numeric = false; }
                if (twoRows === void 0) { twoRows = false; }
                if (hasTooltip === void 0) { hasTooltip = false; }
                return visuals.NewDataLabelUtils.drawDefaultLabels(context, downgradeToOldLabels(dataLabels), numeric, twoRows, hasTooltip);
            }
            LabelUtils.drawDefaultLabels = drawDefaultLabels;
            function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
                if (numeric === void 0) { numeric = false; }
                if (easeType === void 0) { easeType = 'cubic-in-out'; }
                return visuals.NewDataLabelUtils.animateDefaultLabels(context, downgradeToOldLabels(dataLabels), duration, numeric, easeType);
            }
            LabelUtils.animateDefaultLabels = animateDefaultLabels;
            /** Draws black rectangles based on the bounding bx of labels, to be used in debugging */
            function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
                return visuals.NewDataLabelUtils.drawLabelBackground(context, downgradeToOldLabels(dataLabels), fill, fillOpacity);
            }
            LabelUtils.drawLabelBackground = drawLabelBackground;
            function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
                return visuals.NewDataLabelUtils.drawLabelLeaderLines(context, downgradeToOldLabels(filteredDataLabels), key, leaderLineColor);
            }
            LabelUtils.drawLabelLeaderLines = drawLabelLeaderLines;
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
                if (isAnimator === void 0) { isAnimator = false; }
                return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection);
            }
            LabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
            function cleanDataLabels(context, removeLines) {
                if (removeLines === void 0) { removeLines = false; }
                return visuals.dataLabelUtils.cleanDataLabels(context, removeLines);
            }
            LabelUtils.cleanDataLabels = cleanDataLabels;
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                return visuals.dataLabelUtils.setHighlightedLabelsOpacity(context, hasSelection, hasHighlights);
            }
            LabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
            function getLabelFormattedText(label, format, formatter) {
                return visuals.NewDataLabelUtils.getLabelFormattedText(label, format, formatter);
            }
            LabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getLabelTailoredText(options) {
                var optionsOld = {
                    label: options.label,
                    maxWidth: options.maxWidth,
                    format: options.format,
                    formatter: options.formatter,
                    fontSize: (options.fontProperties && options.fontProperties.size) ? options.fontProperties.size.pt : undefined,
                    fontFamily: options.fontProperties ? options.fontProperties.family : undefined,
                };
                return visuals.dataLabelUtils.getLabelFormattedText(optionsOld);
            }
            LabelUtils.getLabelTailoredText = getLabelTailoredText;
            function getMapLabelLayout(labelSettings) {
                return visuals.dataLabelUtils.getMapLabelLayout(downgradeToVisualDataLabelsSettingsOld(labelSettings));
            }
            LabelUtils.getMapLabelLayout = getMapLabelLayout;
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
                return visuals.dataLabelUtils.getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth);
            }
            LabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
            function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
                var dOld = downgradeToColumnChartDataPointOld(d);
                return visuals.dataLabelUtils.getColumnChartLabelFilter(dOld, hasSelection, hasHighlights, axisOptions, visualWidth);
            }
            LabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter;
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return visuals.dataLabelUtils.getScatterChartLabelLayout(xScale, yScale, downgradeToVisualDataLabelsSettingsOld(labelSettings), viewport, sizeRange);
            }
            LabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
                return visuals.dataLabelUtils.getLineChartLabelLayout(xScale, yScale, downgradeToVisualDataLabelsSettingsOld(labelSettings), isScalar, axisFormatter);
            }
            LabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
            // unless user has specified otherwise, labels should use units and decimal places appropriate to the value axis
            function getLabelUnitAndPrecisionForAxis(axisProperties, labelSettings) {
                return new visuals.NewDataLabelUtils.UnitsAndPrecision(axisProperties, downgradeToVisualDataLabelsSettingsOld(labelSettings));
            }
            LabelUtils.getLabelUnitAndPrecisionForAxis = getLabelUnitAndPrecisionForAxis;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                return visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(axisFormatter, downgradeToVisualDataLabelsSettingsOld(labelSettings));
            }
            LabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter;
            function createColumnFormatterCacheManager() {
                return new ColumnFormatterCacheManager();
            }
            LabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            LabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter;
            function removeDuplicates(labelDataPoints) {
                return visuals.NewDataLabelUtils.removeDuplicates(labelDataPoints);
            }
            LabelUtils.removeDuplicates = removeDuplicates;
            function getDataLabelLayoutOptions(type) {
                return visuals.NewDataLabelUtils.getDataLabelLayoutOptions(type);
            }
            LabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions;
            function getTextSize(text, fontProperties) {
                return visuals.NewDataLabelUtils.getTextSize(text, (fontProperties && fontProperties.size) ? fontProperties.size.pt : undefined, fontProperties ? fontProperties.family : undefined);
            }
            LabelUtils.getTextSize = getTextSize;
            function getNumberOfLabelsToRender(viewportWidth, labelDensity, minimumLabelsToRender, estimatedLabelWidth) {
                return visuals.NewDataLabelUtils.getNumberOfLabelsToRender(viewportWidth, labelDensity, minimumLabelsToRender, estimatedLabelWidth);
            }
            LabelUtils.getNumberOfLabelsToRender = getNumberOfLabelsToRender;
            function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings, supportsLabelOrientation) {
                if (labelsObj) {
                    if (labelsObj.show !== undefined)
                        labelSettings.show = labelsObj.show;
                    if (labelsObj.showSeries !== undefined)
                        labelSettings.show = labelsObj.showSeries;
                    if (labelsObj.labelDisplayUnits !== undefined)
                        labelSettings.displayUnits = labelsObj.labelDisplayUnits;
                    if (labelsObj.labelPrecision !== undefined)
                        labelSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : visuals.dataLabelUtils.defaultLabelPrecision;
                    if (labelsObj.percentageLabelPrecision !== undefined)
                        labelSettings.percentagePrecision = (labelsObj.percentageLabelPrecision >= 0) ? labelsObj.percentageLabelPrecision : visuals.dataLabelUtils.defaultPercentageLabelPrecision;
                    labelSettings.fontProperties = {
                        color: (labelsObj.color !== undefined) ? labelsObj.color.solid.color : labelSettings.fontProperties.color,
                        size: (labelsObj.fontSize !== undefined) ? FontSize.createFromPt(+labelsObj.fontSize) : labelSettings.fontProperties.size,
                        family: (labelsObj.fontFamily !== undefined) ? labelsObj.fontFamily : labelSettings.fontProperties.family,
                    };
                    if (labelsObj.showAll !== undefined)
                        labelSettings.showLabelPerSeries = labelsObj.showAll;
                    if (labelsObj.labelStyle !== undefined)
                        labelSettings.labelStyle = labelsObj.labelStyle;
                    if (labelsObj.labelOrientation !== undefined)
                        labelSettings.labelOrientation = supportsLabelOrientation ? labelsObj.labelOrientation : labelSettings.labelOrientation;
                    if (labelsObj.labelPosition) {
                        labelSettings.position = labelsObj.labelPosition;
                    }
                }
            }
            LabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject;
            function updateLabelSettingsFromLabelsObjectWithLabelDensity(labelsObj, labelSettings, supportsLabelOrientation) {
                LabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings, supportsLabelOrientation);
                if (labelsObj && labelsObj.labelDensity !== undefined)
                    labelSettings.labelDensity = labelsObj.labelDensity;
            }
            LabelUtils.updateLabelSettingsFromLabelsObjectWithLabelDensity = updateLabelSettingsFromLabelsObjectWithLabelDensity;
            function getDefaultLabelSettings(show, labelColor, fontSize, fontFamily) {
                if (show === void 0) { show = false; }
                return {
                    show: show,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: visuals.dataLabelUtils.defaultLabelPrecision,
                    fontProperties: visuals.FontProperties.inherit(LabelUtils.defaultFontProperties, {
                        size: fontSize ? FontSize.createFromPt(fontSize) : undefined,
                        family: fontFamily,
                        color: labelColor || LabelUtils.defaultLabelColor,
                    }),
                };
            }
            LabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
            function getDefaultPointLabelSettings() {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: visuals.dataLabelUtils.defaultLabelPrecision,
                    fontProperties: visuals.FontProperties.inherit(LabelUtils.defaultFontProperties, { color: LabelUtils.defaultLabelColor }),
                };
            }
            LabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
            function enumerateDataLabels(options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.enumeration, 'enumeration');
                return visuals.dataLabelUtils.enumerateDataLabels(downgradeToVisualDataLabelsSettingsOptionsOld(options));
            }
            LabelUtils.enumerateDataLabels = enumerateDataLabels;
            function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
                if (isShowCategory === void 0) { isShowCategory = false; }
                return visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, downgradeToVisualDataLabelsSettingsOld(dataLabelsSettings), withFill, isShowCategory, fontSize);
            }
            LabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
            function isTextWidthOverflows(textWidth, maxTextWidth) {
                return visuals.dataLabelUtils.isTextWidthOverflows(textWidth, maxTextWidth);
            }
            LabelUtils.isTextWidthOverflows = isTextWidthOverflows;
            function isTextHeightOverflows(textHeight, innerChordLength) {
                return visuals.dataLabelUtils.isTextHeightOverflows(textHeight, innerChordLength);
            }
            LabelUtils.isTextHeightOverflows = isTextHeightOverflows;
            function getLabelStyleFlagType(labelStyleName) {
                switch (labelStyleName) {
                    case visuals.labelStyle.data:
                        return visuals.labelStyle.labelStyleFlagEnum.data;
                    case visuals.labelStyle.percent:
                        return visuals.labelStyle.labelStyleFlagEnum.percent;
                    case visuals.labelStyle.categoryAndData:
                        return visuals.labelStyle.labelStyleFlagEnum.categoryAndData;
                    case visuals.labelStyle.categoryAndPercent:
                        return visuals.labelStyle.labelStyleFlagEnum.categoryAndPercent;
                    case visuals.labelStyle.dataAndPercent:
                        return visuals.labelStyle.labelStyleFlagEnum.dataAndPercent;
                    case visuals.labelStyle.categoryAndDataAndPercent:
                        return visuals.labelStyle.labelStyleFlagEnum.categoryAndDataAndPercent;
                    case visuals.labelStyle.category:
                        return visuals.labelStyle.labelStyleFlagEnum.category;
                    default:
                        debug.assertFail('Unexpected labelStyle: ' + labelStyleName);
                        return visuals.labelStyle.labelStyleFlagEnum.category;
                }
            }
            LabelUtils.getLabelStyleFlagType = getLabelStyleFlagType;
            var ColumnFormatterCacheManager = /** @class */ (function () {
                function ColumnFormatterCacheManager() {
                    this.cache = {};
                }
                ColumnFormatterCacheManager.prototype.getOrCreate = function (formatString, labelSetting, value2, precision) {
                    if (precision == null)
                        precision = labelSetting.precision;
                    var cacheKeyObject = {
                        formatString: formatString,
                        displayUnits: labelSetting.displayUnits,
                        precision: formatString ? visuals.dataLabelUtils.getLabelPrecision(precision, formatString) : precision,
                        value2: value2
                    };
                    var cacheKey = JSON.stringify(cacheKeyObject);
                    if (!this.cache[cacheKey])
                        this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                    return this.cache[cacheKey];
                };
                return ColumnFormatterCacheManager;
            }());
        })(LabelUtils = visuals.LabelUtils || (visuals.LabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var NewDataLabelUtils;
        (function (NewDataLabelUtils) {
            NewDataLabelUtils.DefaultLabelFontSizeInPt = 9;
            NewDataLabelUtils.MapPolylineOpacity = 0.5;
            NewDataLabelUtils.LabelDensityBufferFactor = 3;
            NewDataLabelUtils.LabelDensityPadding = 6;
            NewDataLabelUtils.LineStrokeWidth = 1;
            NewDataLabelUtils.startingLabelOffset = 8;
            NewDataLabelUtils.maxLabelOffset = 8;
            NewDataLabelUtils.maxLabelWidth = 50;
            NewDataLabelUtils.hundredPercentFormat = '0.00 %;-0.00 %;0.00 %';
            NewDataLabelUtils.DefaultFontSizeInPt = 9;
            NewDataLabelUtils.DefaultLabelFontFamily = visuals.Font.Family.regularSecondary.css;
            NewDataLabelUtils.defaultFontProperties = {
                family: NewDataLabelUtils.DefaultLabelFontFamily,
                size: visuals.Units.FontSize.createFromPt(NewDataLabelUtils.DefaultFontSizeInPt),
                weight: 'normal',
            };
            NewDataLabelUtils.LabelTextProperties = {
                fontFamily: visuals.Font.Family.regularSecondary.css,
                fontSize: PixelConverter.fromPoint(NewDataLabelUtils.DefaultLabelFontSizeInPt),
                fontWeight: 'normal',
            };
            NewDataLabelUtils.defaultLabelColor = "#777777";
            NewDataLabelUtils.defaultInsideLabelColor = "#ffffff"; //white
            NewDataLabelUtils.horizontalLabelBackgroundPadding = 4;
            NewDataLabelUtils.verticalLabelBackgroundPadding = 2;
            var labelBackgroundRounding = 4;
            var defaultLabelPrecision;
            var defaultCountLabelPrecision = 0;
            NewDataLabelUtils.labelGraphicsContextClass = createClassAndSelector('labelGraphicsContext');
            NewDataLabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector('labelBackgroundGraphicsContext');
            var labelsClass = createClassAndSelector('label');
            var secondLineLabelClass = createClassAndSelector('label-second-line');
            var linesGraphicsContextClass = createClassAndSelector('leader-lines');
            var lineClass = createClassAndSelector('line-label');
            function getLabelX(label) {
                return label.labelOrientation === 0 /* Vertical */ ?
                    (label.boundingBox.left + label.boundingBox.width) : (label.boundingBox.left + (label.boundingBox.width / 2));
            }
            function getLabelY(label) {
                if (label.hasBackground)
                    return label.labelOrientation === 0 /* Vertical */ ?
                        (label.boundingBox.top + (label.boundingBox.height / 2) - NewDataLabelUtils.horizontalLabelBackgroundPadding) : (label.boundingBox.top + label.boundingBox.height - NewDataLabelUtils.verticalLabelBackgroundPadding);
                else
                    return label.labelOrientation === 0 /* Vertical */ ? (label.boundingBox.top + (label.boundingBox.height / 2)) : (label.boundingBox.top + label.boundingBox.height);
            }
            function getLabelX2ndLine(label) {
                return (label.boundingBox.left + (label.boundingBox.width / 2));
            }
            function getLabelY2ndLine(label) {
                var boundingBoxHeight = (label.text !== undefined) ? (label.boundingBox.height / 2) : label.boundingBox.height;
                if (label.hasBackground)
                    return label.boundingBox.top + boundingBoxHeight - NewDataLabelUtils.verticalLabelBackgroundPadding;
                else
                    return label.boundingBox.top + boundingBoxHeight;
            }
            function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
                if (numeric === void 0) { numeric = false; }
                if (twoRows === void 0) { twoRows = false; }
                if (hasTooltip === void 0) { hasTooltip = false; }
                var labels = context.selectAll(labelsClass.selector)
                    .data(dataLabels, labelKeyFunction);
                labels.enter()
                    .append("text")
                    .classed(labelsClass.class, true);
                var labelAttr = {
                    transform: function (d) {
                        var translate = "translate(" + getLabelX(d) + "," + getLabelY(d) + ")";
                        return (d.labelOrientation === 0 /* Vertical */) ? (translate + "rotate(-90)") : translate;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                labels
                    .interrupt()
                    .text((function (d) { return d.text; }))
                    .attr(labelAttr)
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'font-family': function (d) { return d.fontFamily ? d.fontFamily : undefined; },
                    'text-anchor': function (d) { return d.textAnchor; },
                });
                labels.exit()
                    .remove();
                var filteredCategoryLabels = _.filter(twoRows ? dataLabels : [], (function (d) { return !_.isEmpty(d.secondRowText); }));
                var secondLineLabels = context.selectAll(secondLineLabelClass.selector)
                    .data(filteredCategoryLabels, (function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; }));
                secondLineLabels.enter()
                    .append("text")
                    .classed(secondLineLabelClass.class, true);
                // Second line label doesn't support vertical rotation
                labelAttr = {
                    transform: function (d) {
                        return "translate(" + getLabelX2ndLine(d) + "," + getLabelY2ndLine(d) + ")";
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                secondLineLabels
                    .interrupt()
                    .text((function (d) { return d.secondRowText; }))
                    .attr(labelAttr)
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'font-family': function (d) { return d.fontFamily ? d.fontFamily : undefined; },
                    'text-anchor': function (d) { return d.textAnchor; },
                });
                secondLineLabels.exit()
                    .remove();
                if (hasTooltip) {
                    labels.append('title').text((function (d) { return d.tooltip; }));
                    secondLineLabels.append('title').text((function (d) { return d.tooltip; }));
                    labels.style("pointer-events", "all");
                    secondLineLabels.style("pointer-events", "all");
                }
                return labels;
            }
            NewDataLabelUtils.drawDefaultLabels = drawDefaultLabels;
            function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
                if (numeric === void 0) { numeric = false; }
                if (easeType === void 0) { easeType = 'cubic-in-out'; }
                var labels = context.selectAll(labelsClass.selector)
                    .data(dataLabels, labelKeyFunction);
                var labelAttr = {
                    transform: function (d) {
                        var translate = "translate(" + getLabelX(d) + "," + getLabelY(d) + ")";
                        return (d.labelOrientation === 0 /* Vertical */) ? (translate + "rotate(-90)") : translate;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                labels.enter()
                    .append("text")
                    .classed(labelsClass.class, true)
                    .style('opacity', 0)
                    .attr(labelAttr);
                labels.text((function (d) { return d.text; }))
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'font-family': function (d) { return d.fontFamily ? d.fontFamily : undefined; },
                })
                    .transition()
                    .ease(easeType)
                    .duration(duration)
                    .attr(labelAttr)
                    .style('opacity', 1);
                labels.exit()
                    .transition()
                    .duration(duration)
                    .style('opacity', 0)
                    .remove();
                return labels;
            }
            NewDataLabelUtils.animateDefaultLabels = animateDefaultLabels;
            /** Draws black rectangles based on the bounding bx of labels, to be used in debugging */
            function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
                var labelRects = context.selectAll("rect")
                    .data(dataLabels, labelKeyFunction);
                labelRects.enter()
                    .append("rect");
                labelRects
                    .attr({
                    x: function (d) {
                        return d.boundingBox.left - NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    y: function (d) {
                        return d.boundingBox.top - NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                    rx: labelBackgroundRounding,
                    ry: labelBackgroundRounding,
                    width: function (d) {
                        return d.boundingBox.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    height: function (d) {
                        if (d.text === undefined && d.secondRowText === undefined) {
                            return 0;
                        }
                        return d.boundingBox.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                })
                    .style("fill", fill ? fill : "#000000")
                    .style("fill-opacity", fillOpacity != null ? fillOpacity : 1);
                labelRects.exit()
                    .remove();
                return labelRects;
            }
            NewDataLabelUtils.drawLabelBackground = drawLabelBackground;
            function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
                if (context.select(linesGraphicsContextClass.selector).empty())
                    context.append('g').classed(linesGraphicsContextClass.class, true);
                var lines = context.select(linesGraphicsContextClass.selector).selectAll('polyline')
                    .data(filteredDataLabels, key);
                lines.enter()
                    .append('polyline')
                    .classed(lineClass.class, true);
                lines
                    .attr('points', (function (d) {
                    return d.leaderLinePoints;
                })).
                    style({
                    'stroke': function (d) { return leaderLineColor ? leaderLineColor : d.fill; },
                    'stroke-width': NewDataLabelUtils.LineStrokeWidth,
                });
                lines
                    .exit()
                    .remove();
            }
            NewDataLabelUtils.drawLabelLeaderLines = drawLabelLeaderLines;
            function getLabelFormattedText(label, format, formatter) {
                return formatter ? formatter.format(label) : powerbi.formattingService.formatValue(label, format);
            }
            NewDataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            var UnitsAndPrecision = /** @class */ (function () {
                function UnitsAndPrecision(axisProperties, labelSettings) {
                    this.noPrecision = true;
                    // TODO: really this function should calculate data label units and precision for all
                    // axis and labelSettings cases. but considering explicitly set label units would add
                    // complexity and so excluding it for now.
                    if (labelSettings.displayUnits === 0) {
                        var axisFormatter = axisProperties.formatter;
                        this.units = axisFormatter && axisFormatter.displayUnit && axisFormatter.displayUnit.value;
                        // if label setting decimal places are auto, ensure at least one digit of precision more than axis tick interval
                        if (labelSettings.precision == null) {
                            this.noPrecision = false;
                            var axisFormatterOptions = axisFormatter && axisFormatter.options;
                            if (axisFormatterOptions && axisFormatterOptions.precision) {
                                this.precisionForAxis = axisProperties.formatter.options.precision + 1;
                            }
                            else {
                                // axis precision will be zero if tick difference is in the ones or higher. but labels need
                                // to distinguish between difference in ones (so labels need one decimal place) and tens
                                // or higher (and labels need no decimal places). to distinguish the cases, the axis units
                                // are multiplied by ten.
                                var ticks = axisProperties.axis.tickValues();
                                if (ticks && ticks.length) {
                                    var tick0 = ticks[0];
                                    var tick1 = ticks.length > 1 ? ticks[1] : undefined;
                                    var axisScale_1 = this.units || 1;
                                    this.precisionForAxis = visuals.AxisHelper.calculateAxisPrecision(tick0, tick1, axisScale_1 * 10, axisFormatterOptions && axisFormatterOptions.format);
                                }
                            }
                        }
                    }
                }
                UnitsAndPrecision.prototype.getPrecision = function (hasFormatString, valueType) {
                    if (this.noPrecision)
                        return;
                    if (this.units)
                        return this.precisionForAxis;
                    // when axis is not scaled, format determines precision
                    if (hasFormatString)
                        return;
                    // unscaled integer value types should not have decimal places
                    if (valueType && valueType.integer)
                        return 0;
                    // axis is unscaled and no precision from the format string so make label precision relative to axis
                    return this.precisionForAxis;
                };
                return UnitsAndPrecision;
            }());
            NewDataLabelUtils.UnitsAndPrecision = UnitsAndPrecision;
            // unless user has specified otherwise, labels should use units and decimal places appropriate to the value axis
            function getLabelUnitAndPrecisionForAxis(axisProperties, labelSettings) {
                return new UnitsAndPrecision(axisProperties, labelSettings);
            }
            NewDataLabelUtils.getLabelUnitAndPrecisionForAxis = getLabelUnitAndPrecisionForAxis;
            function createColumnFormatterCacheManager() {
                return new ColumnFormatterCacheManager();
            }
            NewDataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
                    return axisFormatter.displayUnit.value;
                return null;
            }
            NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter;
            function getLabelPrecision(precision, format) {
                debug.assertAnyValue(format, 'format');
                if (precision !== defaultLabelPrecision)
                    return precision;
                if (format === 'g' || format === 'G')
                    return;
                if (format) {
                    // Calculate precision from positive format by default
                    var positiveFormat = format.split(";")[0];
                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
                    if (formatMetadata.hasDots) {
                        if (formatMetadata.optionalPrecision)
                            return;
                        return formatMetadata.precision;
                    }
                }
                // For count fields we do not want a precision by default
                return defaultCountLabelPrecision;
            }
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            function removeDuplicates(labelDataPoints) {
                var uniqueLabelDataPoints = [];
                var labelDataPointMap = {};
                var sameParentIsInArray = function (newValue, array, parentIsRect) {
                    return array.some((function (arrayValue) {
                        if (parentIsRect) {
                            return visuals.shapes.Rect.equals(newValue.parentShape.rect, arrayValue.rect);
                        }
                        else {
                            return visuals.shapes.Point.equals(newValue.parentShape.point, arrayValue.point);
                        }
                    }));
                };
                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                    var dataPoint = labelDataPoints_1[_i];
                    debug.assertValue(dataPoint, 'dataPoint');
                    if (dataPoint == null)
                        continue;
                    var parentIsRect = dataPoint.parentType === 1 /* Rectangle */;
                    var resultsFromMap = labelDataPointMap[dataPoint.text];
                    if (!resultsFromMap) {
                        uniqueLabelDataPoints.push(dataPoint);
                        labelDataPointMap[dataPoint.text] = [dataPoint.parentShape];
                    }
                    else {
                        if (!sameParentIsInArray(dataPoint, resultsFromMap, parentIsRect)) {
                            uniqueLabelDataPoints.push(dataPoint);
                            resultsFromMap.push(dataPoint.parentShape);
                        }
                    }
                }
                return uniqueLabelDataPoints;
            }
            NewDataLabelUtils.removeDuplicates = removeDuplicates;
            function getDataLabelLayoutOptions(type) {
                switch (type) {
                    case 10 /* Scatter */:
                        return {
                            maximumOffset: visuals.CartesianHelper.dataLabelLayoutMaximumOffset,
                            startingOffset: visuals.CartesianHelper.dataLabelLayoutStartingOffset,
                            offsetIterationDelta: visuals.CartesianHelper.dataLabelLayoutOffsetIterationDelta,
                            allowLeaderLines: true,
                            attemptToMoveLabelsIntoViewport: true,
                        };
                    default:
                        return {
                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
                            startingOffset: NewDataLabelUtils.startingLabelOffset,
                            attemptToMoveLabelsIntoViewport: true,
                        };
                }
            }
            NewDataLabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions;
            function getTextSize(text, fontSize, fontFamily) {
                var labelTextProperties = NewDataLabelUtils.LabelTextProperties;
                var properties = {
                    text: text,
                    fontFamily: fontFamily ? fontFamily : labelTextProperties.fontFamily,
                    fontSize: jsCommon.PixelConverter.fromPoint(fontSize),
                    fontWeight: labelTextProperties.fontWeight,
                };
                return {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
                };
            }
            NewDataLabelUtils.getTextSize = getTextSize;
            /**
             * Obtains the key from the label.  Index is required to use as a backup in cases
             * where labels have no key or identity.
             */
            function labelKeyFunction(label, index) {
                if (label.key) {
                    return label.key;
                }
                if (label.identity) {
                    return label.identity.getKeyWithoutHighlight();
                }
                return index;
            }
            function getNumberOfLabelsToRender(viewportWidth, labelDensity, minimumLabelsToRender, estimatedLabelWidth) {
                if (labelDensity == null || labelDensity === 0) {
                    return minimumLabelsToRender;
                }
                var parsedAndNormalizedDensity = labelDensity / 100;
                var maxNumberForViewport = Math.ceil(viewportWidth / estimatedLabelWidth);
                if (parsedAndNormalizedDensity === 1) {
                    return maxNumberForViewport;
                }
                return minimumLabelsToRender + Math.floor(parsedAndNormalizedDensity * (maxNumberForViewport - minimumLabelsToRender));
            }
            NewDataLabelUtils.getNumberOfLabelsToRender = getNumberOfLabelsToRender;
            function updateLabelSettingsFromLabelsObjectWithLabelDensity(labelsObj, labelSettings, supportsLabelOrientation) {
                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings, supportsLabelOrientation);
                if (labelsObj && labelsObj.labelDensity !== undefined)
                    labelSettings.labelDensity = labelsObj.labelDensity;
            }
            NewDataLabelUtils.updateLabelSettingsFromLabelsObjectWithLabelDensity = updateLabelSettingsFromLabelsObjectWithLabelDensity;
            var ColumnFormatterCacheManager = /** @class */ (function () {
                function ColumnFormatterCacheManager() {
                    this.cache = {};
                }
                ColumnFormatterCacheManager.prototype.getOrCreate = function (formatString, labelSetting, value2, precision) {
                    if (precision == null)
                        precision = labelSetting.precision;
                    var cacheKeyObject = {
                        formatString: formatString,
                        displayUnits: labelSetting.displayUnits,
                        precision: formatString ? getLabelPrecision(precision, formatString) : precision,
                        value2: value2
                    };
                    var cacheKey = JSON.stringify(cacheKeyObject);
                    if (!this.cache[cacheKey])
                        this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                    return this.cache[cacheKey];
                };
                return ColumnFormatterCacheManager;
            }());
        })(NewDataLabelUtils = visuals.NewDataLabelUtils || (visuals.NewDataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var KpiUtil;
        (function (KpiUtil) {
            var KPIImageClassName = 'powervisuals-glyph';
            var BigImageClassName = 'big-kpi';
            var RYGStatusIconClassNames = ['kpi-red', 'kpi-yellow', 'kpi-green'];
            var threeLights = {
                kpiIconClass: 'circle',
                statusValues: RYGStatusIconClassNames,
            };
            var roadSigns = {
                kpiIconClass: '',
                statusValues: ['circle-x kpi-red', 'circle-exclamation kpi-yellow', 'circle-checkmark kpi-green'],
            };
            var trafficLight = {
                kpiIconClass: 'traffic-light',
                statusValues: RYGStatusIconClassNames,
            };
            var shapes = {
                kpiIconClass: '',
                statusValues: ['rhombus kpi-red', 'triangle kpi-yellow', 'circle kpi-green'],
            };
            var gauge = {
                kpiIconClass: '',
                statusValues: ['circle-empty', 'circle-one-quarter', 'circle-half', 'circle-three-quarters', 'circle-full'],
            };
            var statusGraphicFormatStrings = {
                'THREE CIRCLES COLORED': threeLights,
                'TRAFFIC LIGHT - SINGLE': threeLights,
                'THREE FLAGS COLORED': {
                    kpiIconClass: 'flag',
                    statusValues: RYGStatusIconClassNames,
                },
                'ROAD SIGNS': roadSigns,
                'THREE SYMBOLS CIRCLED COLORED': roadSigns,
                'TRAFFIC LIGHT': trafficLight,
                'THREE TRAFFIC LIGHTS RIMMED COLORED': trafficLight,
                'THREE SYMBOLS UNCIRCLED COLORED': {
                    kpiIconClass: '',
                    statusValues: ['x kpi-red', 'exclamation kpi-yellow', 'checkmark kpi-green'],
                },
                'SHAPES': shapes,
                'SMILEY FACE': shapes,
                'THERMOMETER': shapes,
                'CYLINDER': shapes,
                'THREE SIGNS COLORED': shapes,
                'THREE STARS COLORED': {
                    kpiIconClass: 'star-stacked',
                    statusValues: ['star-empty', 'star-half-full', 'star-full'],
                },
                'FIVE BARS COLORED': {
                    kpiIconClass: 'bars-stacked',
                    statusValues: ['bars-zero', 'bars-one', 'bars-two', 'bars-three', 'bars-four'],
                },
                'FIVE BOXES COLORED': {
                    kpiIconClass: 'boxes-stacked',
                    statusValues: ['boxes-zero', 'boxes-one', 'boxes-two', 'boxes-three', 'boxes-four'],
                },
                'FIVE QUARTERS COLORED': gauge,
                'GAUGE - ASCENDING': gauge,
                'GAUGE - DESCENDING': {
                    kpiIconClass: '',
                    statusValues: ['circle-full', 'circle-three-quarters', 'circle-half', 'circle-one-quarter', 'circle-empty'],
                },
                'STANDARD ARROW': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down', 'arrow-right-down', 'arrow-right', 'arrow-right-up', 'arrow-up'],
                },
                'VARIANCE ARROW': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down kpi-red', 'arrow-right kpi-yellow', 'arrow-up kpi-green'],
                },
                'STATUS ARROW - ASCENDING': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down kpi-red', 'arrow-right-down kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-up kpi-yellow', 'arrow-up kpi-green'],
                },
                'STATUS ARROW - DESCENDING': {
                    kpiIconClass: '',
                    statusValues: ['arrow-up kpi-green', 'arrow-right-up kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-down kpi-yellow', 'arrow-down kpi-red'],
                },
            };
            function getKpiIcon(kpi, value) {
                var numValue = parseFloat(value);
                if (!kpi)
                    return;
                var statusGraphicFormat = statusGraphicFormatStrings[kpi.graphic.toUpperCase()];
                if (!statusGraphicFormat || isNaN(numValue))
                    return undefined;
                var statusValues = statusGraphicFormat.statusValues;
                // Normalize range of (-1, -0.5, 0, 0.5, 1) to (-2, -1, 0, 1, 2)
                if (kpi.normalizedFiveStateKpiRange && statusValues.length === 5)
                    numValue = numValue * 2;
                // Convert values from the range of (-n/2, ..., 0, ..., n/2) to (0, 1, ..., n-1)
                var num = numValue + (statusValues.length >> 1);
                return [statusGraphicFormat.kpiIconClass, statusValues[num]].join(' ').trim();
            }
            function getKpiIconClassName(kpiIcon, kpiImageSize) {
                if (!kpiIcon)
                    return undefined;
                if (kpiImageSize === 1 /* Big */)
                    return [KPIImageClassName, BigImageClassName, kpiIcon].join(' ');
                else
                    return [KPIImageClassName, kpiIcon].join(' ');
            }
            function getClassForKpi(kpi, value, kpiImageSize) {
                debug.assertValue(kpi, 'kpi');
                debug.assertValue(value, 'value');
                var kpiIcon = getKpiIcon(kpi, value);
                return getKpiIconClassName(kpiIcon, kpiImageSize);
            }
            KpiUtil.getClassForKpi = getClassForKpi;
            function getKpiImageMetadata(metaDataColumn, value, kpiImageSize) {
                var kpi = metaDataColumn && metaDataColumn.kpi;
                if (kpi) {
                    var kpiIcon = getKpiIcon(kpi, value);
                    if (kpiIcon) {
                        return {
                            caption: kpiIcon,
                            statusGraphic: kpi.graphic,
                            class: getKpiIconClassName(kpiIcon, kpiImageSize),
                        };
                    }
                }
            }
            KpiUtil.getKpiImageMetadata = getKpiImageMetadata;
        })(KpiUtil = visuals.KpiUtil || (visuals.KpiUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DateUtil;
        (function (DateUtil) {
            function isEqual(date1, date2) {
                if (date1 == null && date2 == null) {
                    return true;
                }
                else if (date1 == null || date2 == null) {
                    return false;
                }
                return date1.getTime() === date2.getTime();
            }
            DateUtil.isEqual = isEqual;
        })(DateUtil = visuals.DateUtil || (visuals.DateUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MinMaxType;
        (function (MinMaxType) {
            MinMaxType[MinMaxType["Minimum"] = 0] = "Minimum";
            MinMaxType[MinMaxType["Maximum"] = 1] = "Maximum";
            MinMaxType[MinMaxType["Neither"] = 2] = "Neither";
        })(MinMaxType || (MinMaxType = {}));
        var MinMaxLabelDataPointSorter = /** @class */ (function () {
            function MinMaxLabelDataPointSorter(options) {
                this.unsortedLabelDataPointGroups = options.unsortedLabelDataPointGroups;
                this.series = options.series;
                this.yScale = options.yAxisProperties.scale;
                this.viewport = options.viewport;
            }
            MinMaxLabelDataPointSorter.prototype.getSortedDataLabels = function () {
                var unsortedLabelDataPointGroups = this.unsortedLabelDataPointGroups;
                var sortedLabelDataPointGroups = [];
                for (var seriesIndex = 0, seriesCount = unsortedLabelDataPointGroups.length; seriesIndex < seriesCount; seriesIndex++) {
                    var unsortedLabelDataPointGroup = unsortedLabelDataPointGroups[seriesIndex];
                    var numberOfLabelsToSort = MinMaxLabelDataPointSorter.maxNumberToSortFactor * unsortedLabelDataPointGroup.maxNumberOfLabels;
                    if (_.isEmpty(unsortedLabelDataPointGroup.labelDataPoints))
                        continue;
                    var unsortedLabelDataPoints = unsortedLabelDataPointGroup.labelDataPoints;
                    var sortedLabelDataPoints = [];
                    var data_1 = _.filter(this.series[seriesIndex].data, (function (dataPoint) { return dataPoint && dataPoint.value != null; }));
                    // Iterate over the data points to find the min and max index and values
                    var globalMinMaxInRange = MinMaxLabelDataPointSorter.getMinMaxInRange(0, data_1.length - 1, data_1);
                    // Add first, last, max, and min
                    var numberOfLabelsAdded = this.addFirstLastMaxMin(unsortedLabelDataPoints, sortedLabelDataPoints, globalMinMaxInRange.maxIndex, globalMinMaxInRange.minIndex);
                    var unsortedWeightedLabelDataPoints = void 0;
                    // If we have enough labels added, don't bother adding local min/maxes
                    if (!(numberOfLabelsAdded >= numberOfLabelsToSort)) {
                        // Prepare the data to calculate weights and find global min/max
                        unsortedWeightedLabelDataPoints = this.calculateWeights(unsortedLabelDataPoints, data_1, numberOfLabelsToSort, globalMinMaxInRange);
                        // Add all mins and maxes, sorted by weight (skipping first/last/min/max)
                        var maximumnMinMaxesToAdd = Math.max(numberOfLabelsToSort - numberOfLabelsAdded, 0);
                        numberOfLabelsAdded += this.addLocalMinMaxes(unsortedWeightedLabelDataPoints, sortedLabelDataPoints, globalMinMaxInRange.maxIndex, globalMinMaxInRange.minIndex, maximumnMinMaxesToAdd);
                    }
                    // If we have enough labels added, don't bother adding non-min/maxes
                    if (!(numberOfLabelsAdded >= numberOfLabelsToSort)) {
                        // Split the remaining array and add labels at the mid point of the largest sections until all labels
                        //   are added or we've added maxNumber
                        var maximumNonMinMaxesToAdd = Math.max(numberOfLabelsToSort - numberOfLabelsAdded, 0);
                        this.addNonMinMaxes(unsortedWeightedLabelDataPoints, sortedLabelDataPoints, maximumNonMinMaxesToAdd);
                    }
                    sortedLabelDataPointGroups.push({ labelDataPoints: sortedLabelDataPoints, maxNumberOfLabels: unsortedLabelDataPointGroup.maxNumberOfLabels });
                }
                return sortedLabelDataPointGroups;
            };
            /**
             * The weight for each min/max is made up of four values, which are averaged into
             * a single weight.  You have a weight based on the value difference for both the
             * left and right side and a weight for the index difference for both left and
             * right.  These values are normalized as such:
             *
             * valueWeight = abs(scaledValueDifference / totalScaledValueDifference)
             * indexWeight = abs(indexDifference / categoryCount)
             *
             * Since we don't care about the direction of these change, we take the absolute
             * value for both.  We use scaled coordinates for the valueWeight because this
             * will more accurately represent what the user sees (consider a log scale; small
             * visual changes at the top would otherwise trump large visual changes at the
             * bottom of the axis)
             *
             * In code, the averaging is done by averaging together the "current" value and
             * index weights and then assigning it to the current dataPoint.  Then, when the
             * "next" data point's weight is calculated, that weight (with respect to "current")
             * is then averaged with the weight originally assigned.  Data points next to nulls
             * or on the edge of the visual only have a weight associated with the one side that
             * is non-null.
             *
             * Also note that weights are only calculated for minimums and maximums.
             *
             * @param labelDataPoints The labelDataPoints to apply the weighting to
             */
            MinMaxLabelDataPointSorter.prototype.calculateWeights = function (labelDataPoints, data, numberOfLabelsToSort, globalMinMax) {
                var previousMinMaxPoint;
                var currentMinMaxPoint;
                var categoryCount = data.length;
                var yScale = this.yScale;
                // Obtain all maximums and minimums
                var minMaxPoints = this.findMinMaxesBasedOnSmoothedValues(labelDataPoints, data);
                // Iterate over the mins/maxes, calcuating the weight as you go.  "Current" weight is calcuated with
                //   regard to previous, which is used for the "current" data point's left weight and the "previous"
                //   data point's right weight.
                var totalValueDifference = Math.abs(yScale(globalMinMax.maxValue) - yScale(globalMinMax.minValue));
                for (var minMaxIndex = 0, minMaxCount = minMaxPoints.length; minMaxIndex < minMaxCount; minMaxIndex++) {
                    currentMinMaxPoint = minMaxPoints[minMaxIndex];
                    var weight = void 0;
                    if (previousMinMaxPoint) {
                        var valueWeight = Math.abs((yScale(previousMinMaxPoint.value) - yScale(currentMinMaxPoint.value)) / totalValueDifference);
                        var indexWeight = Math.abs((previousMinMaxPoint.index - currentMinMaxPoint.index)) / (categoryCount - 1);
                        weight = (valueWeight + indexWeight) / 2;
                    } // Note: if there is no previous data point, do not calculate a weight because there is no left weight
                    if (weight != null && previousMinMaxPoint) {
                        var previousLabelDataPoint = labelDataPoints[previousMinMaxPoint.index];
                        if (previousLabelDataPoint.weight != null) {
                            // Previous has a left weight; average that with this weight which provides the right weight
                            previousLabelDataPoint.weight = (previousLabelDataPoint.weight + weight) / 2;
                        }
                        else {
                            // Previous has no left weight because it's the first of a line segment; just use the right weight
                            previousLabelDataPoint.weight = weight;
                        }
                        // Current's left weight is set
                        labelDataPoints[currentMinMaxPoint.index].weight = weight;
                    } // Current's right weight will be applied by the next iteration unless it has none
                    previousMinMaxPoint = currentMinMaxPoint;
                }
                // Cull min/maxes that are extremely low weight.
                for (var _i = 0, labelDataPoints_2 = labelDataPoints; _i < labelDataPoints_2.length; _i++) {
                    var labelDataPoint = labelDataPoints_2[_i];
                    if (labelDataPoint.weight < MinMaxLabelDataPointSorter.minimumWeightToConsiderMinMax) {
                        labelDataPoint.weight = undefined;
                    }
                }
                return labelDataPoints;
            };
            MinMaxLabelDataPointSorter.prototype.findMinMaxesBasedOnSmoothedValues = function (labelDataPoints, data) {
                var minMaxPoints = [];
                var windowSize = this.getWindowSize(data);
                var halfWindowSize = windowSize >> 1;
                var scaledSmoothedValues = this.calculateSmoothedValues(data, windowSize);
                // Find mins and maxes based on the scaled and smooth values
                for (var categoryIndex = 0, categoryCount = labelDataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var minMaxType = this.getMinMaxType(categoryIndex, scaledSmoothedValues);
                    if (minMaxType === MinMaxType.Neither)
                        continue;
                    var currentMinMaxPoint = {
                        index: categoryIndex,
                        type: minMaxType,
                        value: data[categoryIndex].value,
                    };
                    minMaxPoints.push(currentMinMaxPoint);
                }
                // Adjust mins and maxes to be the actual mins/maxes based on the data, because the min/max of the smoothed values
                //   may not be the actual min max in the data within the window, and we want to apply the weight to the actual min/max
                var previousMinMax;
                var currentMinMax;
                var nextMinMax;
                for (var minMaxIndex = 0, minMaxCount = minMaxPoints.length; minMaxIndex < minMaxCount; minMaxIndex++) {
                    previousMinMax = minMaxPoints[minMaxIndex - 1];
                    currentMinMax = minMaxPoints[minMaxIndex];
                    nextMinMax = minMaxPoints[minMaxIndex + 1];
                    if (!previousMinMax || !nextMinMax)
                        continue;
                    var actualMinMaxInRange = MinMaxLabelDataPointSorter.getMinMaxInRange(Math.max(previousMinMax.index, currentMinMax.index - halfWindowSize), Math.min(nextMinMax.index, currentMinMax.index + halfWindowSize), data);
                    if (currentMinMax.type === MinMaxType.Maximum) {
                        var actualIndex = actualMinMaxInRange.maxIndex;
                        currentMinMax.index = actualIndex;
                        currentMinMax.value = data[actualIndex].value;
                    }
                    else {
                        var actualIndex = actualMinMaxInRange.minIndex;
                        currentMinMax.index = actualIndex;
                        currentMinMax.value = data[actualIndex].value;
                    }
                }
                return minMaxPoints;
            };
            MinMaxLabelDataPointSorter.getMinMaxInRange = function (startIndex, endIndex, data) {
                var minValue;
                var maxValue;
                var minIndex;
                var maxIndex;
                // Iterate over the data points to find the min and max index and values
                for (var categoryIndex = startIndex, dataLength = data.length; categoryIndex <= endIndex && categoryIndex < dataLength; categoryIndex++) {
                    var value = data[categoryIndex].value;
                    if (value == null)
                        continue;
                    if (minValue === undefined || value < minValue) {
                        minValue = value;
                        minIndex = categoryIndex;
                    }
                    if (maxValue === undefined || value > maxValue) {
                        maxValue = value;
                        maxIndex = categoryIndex;
                    }
                }
                return {
                    minIndex: minIndex,
                    minValue: minValue,
                    maxIndex: maxIndex,
                    maxValue: maxValue,
                };
            };
            MinMaxLabelDataPointSorter.prototype.getWindowSize = function (data) {
                var idealSize = (data.length / this.viewport.width) * MinMaxLabelDataPointSorter.estimatedLabelWidth;
                var actualsize = idealSize | 1; // Force the window size to be a nearby odd number
                return actualsize;
            };
            MinMaxLabelDataPointSorter.prototype.calculateSmoothedValues = function (data, windowSize) {
                var gaussianValues = MinMaxLabelDataPointSorter.getGaussianDistribution(windowSize);
                var scaledAndSmoothedValues = [];
                for (var categoryIndex = 0, categoryCount = data.length; categoryIndex < categoryCount; categoryIndex++) {
                    if (windowSize === 1) {
                        scaledAndSmoothedValues.push(data[categoryIndex].value);
                    }
                    else {
                        var scaledValue = this.getSmoothedValue(data, categoryIndex, windowSize, gaussianValues);
                        scaledAndSmoothedValues.push(scaledValue);
                    }
                }
                return scaledAndSmoothedValues;
            };
            MinMaxLabelDataPointSorter.getGaussianDistribution = function (windowSize) {
                debug.assert(windowSize / 2 !== (windowSize >> 1), "window size should be a whole odd number");
                var gaussianDistribution = [];
                var halfWayIndex = windowSize >> 1; // Value at which, value should be 1.
                // Standard gaussian equation:
                //   y = a * e ^ -((x-b)^2 / (2c^2))
                //   height: 1 (height at the maximum)
                //   maxPosition: 1 (position of maximum)
                //   standardDeviation: 0.5 (standard deviation; this ratio places the edge of the window around 0.1)
                var height = 1;
                var maxPosition = halfWayIndex;
                var standardDeviation = halfWayIndex / 2;
                for (var i = 0; i < halfWayIndex; i++) {
                    var gaussianValue = height * Math.pow(Math.E, (-1 * ((i - maxPosition) * (i - maxPosition)) / (2 * standardDeviation * standardDeviation)));
                    gaussianDistribution.push(gaussianValue);
                }
                gaussianDistribution.push(1); // Add the maximum, which should always be 1
                for (var i = halfWayIndex - 1; i >= 0; i--) {
                    gaussianDistribution.push(gaussianDistribution[i]);
                }
                return gaussianDistribution;
            };
            MinMaxLabelDataPointSorter.prototype.getSmoothedValue = function (data, categoryIndex, windowSize, gaussianValues) {
                if (data[categoryIndex].value == null)
                    return data[categoryIndex].value;
                var halfWindowSize = windowSize >> 1;
                var startingIndex = categoryIndex - halfWindowSize;
                var endingIndex = categoryIndex + halfWindowSize;
                var totalValue = 0;
                var totalValueCount = 0;
                var lastDataIndex = data.length - 1;
                for (var currentIndex = startingIndex, gaussianIndex = 0; currentIndex <= endingIndex; currentIndex++, gaussianIndex++) {
                    var valueIndex = Math.max(0, Math.min(currentIndex, lastDataIndex));
                    var value = data[valueIndex].value;
                    if (value != null) {
                        totalValue += value * gaussianValues[gaussianIndex];
                        totalValueCount++;
                    }
                }
                return totalValue / totalValueCount;
            };
            MinMaxLabelDataPointSorter.prototype.addFirstLastMaxMin = function (unsorted, sorted, maxIndex, minIndex) {
                var labelsAdded = 0;
                // Don't add anything if unsorted is empty
                if (_.isEmpty(unsorted))
                    return labelsAdded;
                // Push first
                sorted.push(unsorted[0]);
                labelsAdded++;
                // Push last only last != first
                var lastIndex = unsorted.length - 1;
                if (lastIndex !== 0) {
                    sorted.push(unsorted[lastIndex]);
                    labelsAdded++;
                }
                // Push max if it is neither first nor last
                if (maxIndex !== 0 && maxIndex !== lastIndex) {
                    sorted.push(unsorted[maxIndex]);
                    labelsAdded++;
                }
                // Push min if it is neither first nor last
                if (minIndex !== 0 && minIndex !== lastIndex) {
                    sorted.push(unsorted[minIndex]);
                    labelsAdded++;
                }
                return labelsAdded;
            };
            MinMaxLabelDataPointSorter.prototype.addLocalMinMaxes = function (unsorted, sorted, maxIndex, minIndex, maxNumberOfLabels) {
                var lastIndex = unsorted.length - 1;
                // Obtain all local min/maxes; all min/maxes should have weights now and we filter out first/last/max/min
                var localMinMaxes = _.filter(unsorted, (function (labelDataPoint, index) {
                    if (index === 0 || index === lastIndex || index === maxIndex || index === minIndex) {
                        return false;
                    }
                    return labelDataPoint.weight != null;
                }));
                var sortedMinMaxes = _.sortBy(localMinMaxes, (function (weighedLabelDataPoint) {
                    return -weighedLabelDataPoint.weight; // Return weight as a negative since _.sortBy sorts ascending, and we want descending
                }));
                var labelsAdded = 0;
                // Add labels until you run out of max/mins or you've sorted enough labels
                for (var i = 0, ilen = Math.min(sortedMinMaxes.length, maxNumberOfLabels); i < ilen; i++) {
                    sorted.push(sortedMinMaxes[i]);
                    labelsAdded++;
                }
                return labelsAdded;
            };
            MinMaxLabelDataPointSorter.prototype.addNonMinMaxes = function (unsorted, sorted, maxNumberOfLabels) {
                // First construct sets of non-min/maxes by iterating over the unsorted data points.
                var nonMinMaxSets = [];
                var currentNonMinMaxSet;
                for (var categoryIndex = 0, categoryCount = unsorted.length; categoryIndex < categoryCount; categoryIndex++) {
                    if (unsorted[categoryIndex].weight != null) {
                        // If the current data point is a min/max, we add the old NonMinMaxSet to the array, reset it so that
                        //   a new one will be constructed, and then continue
                        if (currentNonMinMaxSet && currentNonMinMaxSet.count > 0) {
                            nonMinMaxSets.push(currentNonMinMaxSet);
                            currentNonMinMaxSet = null;
                        }
                        continue;
                    }
                    if (!currentNonMinMaxSet) {
                        // If the previous data point was a min/max and this one isn't, set up a new NonMinMaxSet
                        currentNonMinMaxSet = {
                            startingIndex: categoryIndex,
                            count: 1,
                        };
                    }
                    else {
                        // Otherwise, we're just "adding" another non-min/max point to the set, so increase count.
                        currentNonMinMaxSet.count++;
                    }
                }
                var numberOfLabelsAdded = 0;
                while (nonMinMaxSets.length > 0 && numberOfLabelsAdded < maxNumberOfLabels) {
                    // Find the index of the largest set
                    var currentMaxCount = 0;
                    var maxIndex = 0;
                    for (var i = 0, ilen = nonMinMaxSets.length; i < ilen; i++) {
                        var currentCount = nonMinMaxSets[i].count;
                        if (currentCount > currentMaxCount) {
                            currentMaxCount = currentCount;
                            maxIndex = i;
                        }
                    }
                    var setToSplit = nonMinMaxSets.splice(maxIndex, 1)[0];
                    if (setToSplit.count === 1) {
                        sorted.push(unsorted[setToSplit.startingIndex]);
                    }
                    else {
                        var splitIndex = (setToSplit.count >> 1) + setToSplit.startingIndex;
                        // Split the array in two, putting the split point into sorted, and creating two new sets by splitting the old set
                        sorted.push(unsorted[splitIndex]);
                        var leftCount = splitIndex - setToSplit.startingIndex;
                        if (leftCount > 0) {
                            nonMinMaxSets.push({
                                startingIndex: setToSplit.startingIndex,
                                count: leftCount,
                            });
                        }
                        var rightCount = setToSplit.startingIndex + setToSplit.count - splitIndex - 1;
                        if (rightCount > 0) {
                            nonMinMaxSets.push({
                                startingIndex: splitIndex + 1,
                                count: rightCount,
                            });
                        }
                    }
                    numberOfLabelsAdded++;
                }
            };
            MinMaxLabelDataPointSorter.prototype.getMinMaxType = function (index, scaledDataPoints) {
                var currentValue = scaledDataPoints[index];
                // Check to see if the point's value is null; these are not considered min/maxes
                if (scaledDataPoints[index] == null)
                    return MinMaxType.Neither;
                // If the array is of length one, return neither to exit early
                if (scaledDataPoints.length < 2)
                    return MinMaxType.Neither;
                // Check for cases at the very edge of the array
                if (scaledDataPoints[index - 1] == null) {
                    return scaledDataPoints[index + 1] > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
                }
                if (scaledDataPoints[index + 1] == null) {
                    return scaledDataPoints[index - 1] > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
                }
                var prevValue = scaledDataPoints[index - 1];
                var nextValue = scaledDataPoints[index + 1];
                // Check for cases next to nulls
                if (prevValue == null && nextValue == null) {
                    return MinMaxType.Neither;
                }
                if (prevValue == null) {
                    return nextValue > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
                }
                if (nextValue == null) {
                    return prevValue > currentValue ? MinMaxType.Minimum : MinMaxType.Maximum;
                }
                // Check for typical min/maxes
                if (prevValue > currentValue && currentValue < nextValue) {
                    return MinMaxType.Minimum;
                }
                if (prevValue < currentValue && currentValue > nextValue) {
                    return MinMaxType.Maximum;
                }
                return MinMaxType.Neither;
            };
            /** A rough estimate for how wide labels are for purposes of calculating density, window size, etc. */
            MinMaxLabelDataPointSorter.estimatedLabelWidth = 40;
            MinMaxLabelDataPointSorter.minimumWeightToConsiderMinMax = 0.015;
            MinMaxLabelDataPointSorter.maxNumberToSortFactor = 2; // Once we've sorted first/last/min/max and local max/mins, we limit ourselves to twice the maximum number of labels to render
            return MinMaxLabelDataPointSorter;
        }());
        visuals.MinMaxLabelDataPointSorter = MinMaxLabelDataPointSorter;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Applies inertia based on the tracking points it is given. It gives deltas that gradually
         * ease to a stop using the d3 "cubic-out" function.
         *
         * Usual usage is to:
         * 1. Call `addPoint` every time the item you want to apply inertia to is moving
         * 2. Call `start` when the item is released and you want to give it some inertia.
         */
        var Inertia = /** @class */ (function () {
            /**
             * Constructor
             * @param {function} callback Callback to execute for each "tick" of the inertia. The delta for X and Y is the change for each since the last tick.
             * @param {boolean} enabled Whether the inertia is enabled. If it's disabled, `start` won't do anything. Defaults to `true`
             * @param {number} distanceFactor A factor used in calculating the distance to move while applying inertia.
             * @param {number} timeFactor A factor used to calculate how long the inertia should last.
             * @param {number} sampleTime How long the window of what points are used to calculate the velocity is.
             */
            function Inertia(callback, enabled, distanceFactor, timeFactor, sampleTime) {
                if (enabled === void 0) { enabled = true; }
                if (distanceFactor === void 0) { distanceFactor = 250; }
                if (timeFactor === void 0) { timeFactor = 1700; }
                if (sampleTime === void 0) { sampleTime = 100; }
                this.callback = callback;
                this.enabled = enabled;
                this.distanceFactor = distanceFactor;
                this.timeFactor = timeFactor;
                this.sampleTime = sampleTime;
                this.points = [];
            }
            /**
             * Adds tracking points used to determine the velocity when the inertia is started. Existing points older than `sampleTime` ago are removed.
             */
            Inertia.prototype.addPoint = function (x, y) {
                var points = this.points;
                var now = Date.now();
                while (!_.isEmpty(points)) {
                    if (now - points[0].timestamp < this.sampleTime) {
                        break;
                    }
                    points.shift();
                }
                points.push({
                    x: x,
                    y: y,
                    timestamp: now
                });
            };
            Inertia.prototype.hasStarted = function () {
                return this.started;
            };
            Inertia.prototype.start = function () {
                var _this = this;
                if (!this.enabled || this.points.length <= 1) {
                    return;
                }
                if (this.started) {
                    this.stop();
                }
                // Get the points and figure out the velocity between the first and last point
                var easingFunction = d3.ease('cubic-out');
                var lastPoint = _.last(this.points);
                var firstPoint = _.first(this.points);
                var deltaX = lastPoint.x - firstPoint.x;
                var deltaY = lastPoint.y - firstPoint.y;
                var deltaT = lastPoint.timestamp - firstPoint.timestamp;
                var velocityX = deltaX / deltaT;
                var velocityY = deltaY / deltaT;
                // Apply the factors to the distance and time to determine how far the inertia will go and how long it will take
                var distanceFactor = window.distanceFactor || this.distanceFactor;
                var distanceX = velocityX * distanceFactor;
                var distanceY = velocityY * distanceFactor;
                var decayTime = Math.sqrt(Math.pow(velocityX, 2) + Math.pow(velocityY, 2)) * window.timeFactor || this.timeFactor;
                var totalDistanceX = 0;
                var totalDistanceY = 0;
                this.started = true;
                d3.timer((function (elapsed) {
                    if (_this.stopRequested) {
                        _this.clearState();
                        return true;
                    }
                    // Get the % of how far we are in applying the inertia
                    // Then figure out the delta since the previous tick and send that to the callback
                    var portion = easingFunction(elapsed * 1.0 / decayTime);
                    var newDeltaX = portion * distanceX - totalDistanceX;
                    var newDeltaY = portion * distanceY - totalDistanceY;
                    totalDistanceX += newDeltaX;
                    totalDistanceY += newDeltaY;
                    if (_this.callback) {
                        _this.callback(newDeltaX, newDeltaY);
                    }
                    var done = elapsed > decayTime;
                    if (done) {
                        _this.clearState();
                    }
                    return done;
                }));
            };
            Inertia.prototype.stop = function () {
                if (this.started) {
                    this.stopRequested = true;
                }
            };
            Inertia.prototype.clearState = function () {
                this.started = false;
                this.stopRequested = false;
            };
            return Inertia;
        }());
        visuals.Inertia = Inertia;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var InteractivityUtils;
        (function (InteractivityUtils) {
            function getPositionOfLastInputEvent() {
                return {
                    x: d3.event.clientX,
                    y: d3.event.clientY
                };
            }
            InteractivityUtils.getPositionOfLastInputEvent = getPositionOfLastInputEvent;
            function registerStandardInteractivityHandlers(selection, selectionHandler) {
                registerStandardSelectionHandler(selection, selectionHandler);
                registerStandardContextMenuHandler(selection, selectionHandler);
            }
            InteractivityUtils.registerStandardInteractivityHandlers = registerStandardInteractivityHandlers;
            function registerStandardSelectionHandler(selection, selectionHandler) {
                selection.on('click', (function (d) { return handleSelection(d, selectionHandler); }));
            }
            InteractivityUtils.registerStandardSelectionHandler = registerStandardSelectionHandler;
            function registerStandardContextMenuHandler(selection, selectionHandler) {
                selection.on('contextmenu', (function (d) { return handleContextMenu(d, selectionHandler); }));
            }
            InteractivityUtils.registerStandardContextMenuHandler = registerStandardContextMenuHandler;
            function registerGroupInteractivityHandlers(group, selectionHandler) {
                registerGroupSelectionHandler(group, selectionHandler);
                registerGroupContextMenuHandler(group, selectionHandler);
            }
            InteractivityUtils.registerGroupInteractivityHandlers = registerGroupInteractivityHandlers;
            function registerGroupSelectionHandler(group, selectionHandler) {
                group.on('click', (function () {
                    tryToSelectD3Target((function (d) { return handleSelection(d, selectionHandler); }));
                }));
            }
            InteractivityUtils.registerGroupSelectionHandler = registerGroupSelectionHandler;
            function registerGroupContextMenuHandler(group, selectionHandler) {
                group.on('contextmenu', (function () {
                    tryToSelectD3Target((function (d) { return handleContextMenu(d, selectionHandler); }));
                }));
            }
            InteractivityUtils.registerGroupContextMenuHandler = registerGroupContextMenuHandler;
            function tryToSelectD3Target(selectionEvent) {
                var target = d3.event.target;
                var d = d3.select(target).datum();
                // Sometimes d3's target doesn't have a datum.  In these cases, do not call the selectionEvent
                //   This happens when the target of a mouseDown and mouseUp are different, and the target of the
                //   click event becomes a parent element with no datum.
                if (d) {
                    selectionEvent(d);
                }
            }
            InteractivityUtils.tryToSelectD3Target = tryToSelectD3Target;
            function handleContextMenu(d, selectionHandler) {
                if (d3.event.ctrlKey)
                    return;
                d3.event.preventDefault();
                var position = InteractivityUtils.getPositionOfLastInputEvent();
                selectionHandler.handleContextMenu(d, position);
            }
            function handleSelection(d, selectionHandler) {
                var position = InteractivityUtils.getPositionOfLastInputEvent();
                selectionHandler.handleSelection(d, d3.event.ctrlKey, position);
            }
        })(InteractivityUtils = visuals.InteractivityUtils || (visuals.InteractivityUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataViewMatrixUtils = powerbi.data.DataViewMatrixUtils;
        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity, ignoreRoles, readMatrixDV) {
            var checker = new InvalidDataValuesChecker(supportsNaN /*supportsNaN*/, supportsNegativeInfinity /*supportsNegativeInfinity*/, supportsPositiveInfinity /*supportsPositiveInfinity*/, readMatrixDV, ignoreRoles);
            // Show a warning if necessary.
            return checker.getWarningMessages(dataViews);
        }
        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
        var InvalidDataValuesChecker = /** @class */ (function () {
            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity, readMatrixDV, ignoreRoles) {
                this.supportsNaN = supportsNaN;
                this.supportsNegativeInfinity = supportsNegativeInfinity;
                this.supportsPositiveInfinity = supportsPositiveInfinity;
                this.ignoreRoles = ignoreRoles;
                this.readMatrixDV = readMatrixDV;
            }
            InvalidDataValuesChecker.prototype.getWarningMessages = function (dataViews) {
                this.loadWarningStatus(dataViews);
                var warnings = [];
                if (this.hasNaN && !this.supportsNaN) {
                    warnings.push(new visuals.NaNNotSupportedWarning());
                }
                if ((this.hasNegativeInfinity && !this.supportsNegativeInfinity)
                    || (this.hasPositiveInfinity && !this.supportsPositiveInfinity)) {
                    warnings.push(new visuals.InfinityValuesNotSupportedWarning());
                }
                if (this.hasOutOfRange) {
                    warnings.push(new visuals.ValuesOutOfRangeWarning());
                }
                return warnings;
            };
            InvalidDataValuesChecker.prototype.loadWarningStatus = function (dataViews) {
                this.hasNaN = false;
                this.hasNegativeInfinity = false;
                this.hasOutOfRange = false;
                this.hasPositiveInfinity = false;
                for (var _i = 0, dataViews_1 = dataViews; _i < dataViews_1.length; _i++) {
                    var dataView = dataViews_1[_i];
                    if (this.readMatrixDV) {
                        this.readMatrix(dataView);
                    }
                    else {
                        this.readCategorical(dataView);
                    }
                }
            };
            InvalidDataValuesChecker.prototype.readCategorical = function (dataView) {
                var values = dataView && dataView.categorical && dataView.categorical.values
                    ? dataView.categorical.values
                    : null;
                if (!values)
                    return;
                var valuesIndicesToIgnore = this.valueIndicesToIgnore(_.map(values, (function (value) { return value.source; })));
                for (var index = 0, len = values.length; index < len; index++) {
                    if (_.contains(valuesIndicesToIgnore, index))
                        continue;
                    var valueColumn = values[index];
                    if (valueColumn.values) {
                        for (var _i = 0, _a = valueColumn.values; _i < _a.length; _i++) {
                            var v = _a[_i];
                            this.checkValue(v);
                        }
                    }
                }
            };
            InvalidDataValuesChecker.prototype.valueIndicesToIgnore = function (valueMetadataColumns) {
                var _this = this;
                var valueColumnIndicesToIgnore = [];
                if (!_.isEmpty(this.ignoreRoles)) {
                    for (var i = 0; i < valueMetadataColumns.length; i++) {
                        var col = valueMetadataColumns[i];
                        var columnRoles = col && col.roles && Object.keys(col.roles);
                        if (!_.isEmpty(columnRoles) && _.all(columnRoles, (function (role) { return _.contains(_this.ignoreRoles, role); }))) {
                            valueColumnIndicesToIgnore.push(i);
                        }
                    }
                }
                return valueColumnIndicesToIgnore;
            };
            InvalidDataValuesChecker.prototype.readMatrix = function (dataView) {
                var _this = this;
                if (!dataView || !dataView.matrix)
                    return;
                var valueSourceIndicesToIgnore = this.valueIndicesToIgnore(dataView.matrix.valueSources);
                // We only parse the rows as intersection values are currently only stored on rows, not columns
                powerbi.data.DataViewMatrixUtils.forEachNodeDepthFirst(dataView.matrix.rows.root, (function (node, path) {
                    if (DataViewMatrixUtils.isLeafNode(node)) {
                        if (!node.values)
                            return 1 /* continueToChildNodes */;
                        var ids = Object.keys(node.values);
                        for (var _i = 0, ids_1 = ids; _i < ids_1.length; _i++) {
                            var id = ids_1[_i];
                            var value = node.values[id];
                            if (_.contains(valueSourceIndicesToIgnore, value.valueSourceIndex)) {
                                continue;
                            }
                            _this.checkValue(value && value.value);
                        }
                        return 1 /* continueToChildNodes */;
                    }
                    else if (_this.hasNaN && _this.hasPositiveInfinity && _this.hasNegativeInfinity && _this.hasOutOfRange) {
                        return 0 /* stop */;
                    }
                    else {
                        return 1 /* continueToChildNodes */;
                    }
                }));
            };
            InvalidDataValuesChecker.prototype.checkValue = function (v) {
                if (isNaN(v))
                    this.hasNaN = true;
                else if (v === Number.POSITIVE_INFINITY)
                    this.hasPositiveInfinity = true;
                else if (v === Number.NEGATIVE_INFINITY)
                    this.hasNegativeInfinity = true;
                else if (v < -1e300 || v > 1e300)
                    this.hasOutOfRange = true;
            };
            return InvalidDataValuesChecker;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getCoordinates(rootNode, isPointerEvent) {
            var coordinates;
            if (isPointerEvent) {
                // DO NOT USE - WebKit bug in getScreenCTM with nested SVG results in slight negative coordinate shift
                // Also, IE will incorporate transform scale but WebKit does not, forcing us to detect browser and adjust appropriately.
                // Just use non-scaled coordinates for all browsers, and adjust for the transform scale later (see lineChart.findIndex)
                //coordinates = d3.mouse(rootNode);
                // copied from d3_eventSource (which is not exposed)
                var e = d3.event, s = void 0;
                while (s = e.sourceEvent)
                    e = s;
                var rect = rootNode.getBoundingClientRect();
                coordinates = [e.clientX - rect.left - rootNode.clientLeft, e.clientY - rect.top - rootNode.clientTop];
            }
            else {
                var touchCoordinates = d3.touches(rootNode);
                if (touchCoordinates && touchCoordinates.length > 0) {
                    coordinates = touchCoordinates[0];
                }
            }
            return coordinates;
        }
        visuals.getCoordinates = getCoordinates;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LassoManager = /** @class */ (function () {
            function LassoManager() {
            }
            LassoManager.prototype.init = function (surface) {
                this.surface = surface;
                this.initDragEvents(surface);
                this.enabled = true;
                this.behaviors = [];
            };
            LassoManager.prototype.enable = function (enabled) {
                this.enabled = enabled;
            };
            LassoManager.prototype.initDragEvents = function (svg) {
                var _this = this;
                svg.on('mousedown.lasso', (function () {
                    if (!_this.enabled)
                        return;
                    _this.startDrag(d3.event);
                }), true);
                svg.on('mousemove.lasso', (function () {
                    if (!_this.enabled)
                        return;
                    if (_this.dragging)
                        _this.drag(d3.event);
                }), true);
                svg.on('mouseup.lasso', (function () {
                    if (!_this.enabled)
                        return;
                    if (_this.dragging)
                        _this.endDrag(d3.event);
                }), true);
            };
            LassoManager.prototype.startDrag = function (e) {
                var _this = this;
                if (!this.onRectStart(e))
                    return;
                this.dragging = true;
                var point = visuals.getCoordinates(this.surface.node(), true);
                this.dragStart = {
                    x: point[0],
                    y: point[1],
                };
                this.dragRect = this.surface.append("rect")
                    .classed('lasso-select', true);
                this.updateDragRect(e, point);
                e.stopPropagation();
                d3.select('body')
                    .on('mousemove.lasso', (function () {
                    _this.drag(d3.event);
                }))
                    .on('mouseup.lasso', (function () {
                    _this.endDrag(d3.event);
                }));
            };
            LassoManager.prototype.endDrag = function (e) {
                var point = visuals.getCoordinates(this.surface.node(), true);
                var rect = {
                    left: Math.min(point[0], this.dragStart.x),
                    top: Math.min(point[1], this.dragStart.y),
                    right: Math.max(point[0], this.dragStart.x),
                    bottom: Math.max(point[1], this.dragStart.y),
                };
                this.onRectEnd(e, rect);
                this.dragging = false;
                if (this.dragRect) {
                    this.dragRect.remove();
                    this.dragRect = null;
                }
                // Remove all lasso event handlers
                d3.select('body').on('.lasso', null);
            };
            LassoManager.prototype.drag = function (e) {
                var point = visuals.getCoordinates(this.surface.node(), true);
                this.updateDragRect(e, point);
            };
            LassoManager.prototype.updateDragRect = function (e, point) {
                var rect = this.getDragRect(point);
                this.dragRect.attr({
                    x: rect.left,
                    y: rect.top,
                    width: rect.width,
                    height: rect.height,
                });
                this.onRectHover(e, {
                    left: rect.left,
                    top: rect.top,
                    right: rect.left + rect.width,
                    bottom: rect.top + rect.height,
                });
            };
            LassoManager.prototype.onRectHover = function (e, rect) {
                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    if (behavior.onRectHover)
                        behavior.onRectHover(e, rect);
                }
            };
            LassoManager.prototype.onRectEnd = function (e, rect) {
                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    if (behavior.onRectEnd)
                        behavior.onRectEnd(e, rect);
                }
            };
            LassoManager.prototype.onRectStart = function (e) {
                var valid = true;
                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    if (behavior.onDragStart)
                        valid = valid && behavior.onDragStart(e);
                }
                return valid;
            };
            LassoManager.prototype.getDragRect = function (point) {
                // TODO: clamp point to visual viewport
                var xDiff = point[0] - this.dragStart.x;
                var yDiff = point[1] - this.dragStart.y;
                return {
                    left: Math.min(this.dragStart.x, point[0]),
                    top: Math.min(this.dragStart.y, point[1]),
                    width: Math.abs(xDiff),
                    height: Math.abs(yDiff),
                };
            };
            return LassoManager;
        }());
        visuals.LassoManager = LassoManager;
        var CartesianPlotHelper;
        (function (CartesianPlotHelper) {
            function getScaledRegion(rect, axesLayout) {
                var left = rect.left - axesLayout.margin.left, top = rect.top - axesLayout.margin.top, right = rect.right - axesLayout.margin.left, bottom = rect.bottom - axesLayout.margin.top;
                return {
                    left: visuals.AxisHelper.invertScale(axesLayout.axes.x.scale, left),
                    top: visuals.AxisHelper.invertScale(axesLayout.axes.y1.scale, top),
                    right: visuals.AxisHelper.invertScale(axesLayout.axes.x.scale, right),
                    bottom: visuals.AxisHelper.invertScale(axesLayout.axes.y1.scale, bottom),
                };
            }
            CartesianPlotHelper.getScaledRegion = getScaledRegion;
        })(CartesianPlotHelper = visuals.CartesianPlotHelper || (visuals.CartesianPlotHelper = {}));
        var LassoSelectionBehavior = /** @class */ (function () {
            function LassoSelectionBehavior(behavior) {
                this.behavior = behavior;
            }
            LassoSelectionBehavior.prototype.update = function (axesLayout) {
                this.axesLayout = axesLayout;
            };
            LassoSelectionBehavior.prototype.onRectEnd = function (e, rect) {
                var scaledRegion = CartesianPlotHelper.getScaledRegion(rect, this.axesLayout);
                this.selectRegion(e, scaledRegion);
            };
            LassoSelectionBehavior.prototype.onRectHover = function (e, rect) {
                if (!this.behavior.hoverLassoRegion)
                    return;
                var scaledRegion = CartesianPlotHelper.getScaledRegion(rect, this.axesLayout);
                this.behavior.hoverLassoRegion(e, scaledRegion);
            };
            LassoSelectionBehavior.prototype.onDragStart = function (e) {
                if (e.button !== 0)
                    return false;
                return true;
            };
            LassoSelectionBehavior.prototype.selectRegion = function (e, rect) {
                if (this.behavior.lassoSelect)
                    this.behavior.lassoSelect(e, rect);
            };
            return LassoSelectionBehavior;
        }());
        visuals.LassoSelectionBehavior = LassoSelectionBehavior;
        var LassoZoomBehavior = /** @class */ (function () {
            function LassoZoomBehavior(hostServices) {
                this.hostServices = hostServices;
            }
            LassoZoomBehavior.prototype.update = function (axesLayout) {
                this.axesLayout = axesLayout;
            };
            LassoZoomBehavior.prototype.onRectEnd = function (e, rect) {
                if (e.button === 2) {
                    this.unzoomRegion();
                }
                else {
                    var scaledRegion = CartesianPlotHelper.getScaledRegion(rect, this.axesLayout);
                    this.zoomRegion(scaledRegion);
                }
            };
            LassoZoomBehavior.prototype.zoomRegion = function (rect) {
                this.hostServices.persistProperties({
                    replace: [
                        {
                            objectName: 'categoryAxis',
                            properties: {
                                start: rect.left,
                                end: rect.right,
                            },
                            selector: null,
                        }, {
                            objectName: 'valueAxis',
                            properties: {
                                start: rect.bottom,
                                end: rect.top,
                            },
                            selector: null,
                        }
                    ],
                });
            };
            LassoZoomBehavior.prototype.unzoomRegion = function () {
                this.hostServices.persistProperties({
                    remove: [
                        {
                            objectName: 'categoryAxis',
                            properties: {
                                start: null,
                                end: null,
                            },
                            selector: null,
                        }, {
                            objectName: 'valueAxis',
                            properties: {
                                start: null,
                                end: null,
                            },
                            selector: null,
                        }
                    ]
                });
            };
            return LassoZoomBehavior;
        }());
        visuals.LassoZoomBehavior = LassoZoomBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var normalizeSelector = powerbi.data.Selector.normalizeSelector;
        var LineStyle;
        (function (LineStyle) {
            var dashedStroke = '5, 5';
            var dottedStroke = '1, 5';
            var solidStroke = null;
            var dottedLineCap = 'round';
            var otherLineCap = null;
            function readFromStaticObjects(staticObjects, readMarkers) {
                return {
                    shadeArea: powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.shadeArea, false),
                    strokeWidth: powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.strokeWidth, visuals.CartesianHelper.defaultLineStrokeWidth),
                    lineJoin: powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.strokeLineJoin, visuals.strokeLineJoin.defaultValue),
                    style: powerbi.DataViewObjects.getValue(staticObjects, visuals.lineChartProps.lineStyles.lineStyle, visuals.lineStyle.solid),
                    markerProperties: readMarkers ? visuals.MarkerProperties.readFromStaticObjects(staticObjects) : visuals.MarkerProperties.getDefault(),
                };
            }
            LineStyle.readFromStaticObjects = readFromStaticObjects;
            function readFromSeriesObjects(reader, staticStyle, seriesIndex, readSeriesMarkers, showAllSeries) {
                var style = powerbi.Prototype.inherit(staticStyle);
                var markerProperties = visuals.MarkerProperties.readFromSeries(reader, staticStyle.markerProperties, seriesIndex, !readSeriesMarkers);
                style.markerProperties = markerProperties;
                if (!reader.data.hasSeries() || !showAllSeries) {
                    return style;
                }
                var objects = reader.objects.getSeriesDataObjects(seriesIndex);
                var strokeWidthFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.strokeWidth);
                if (strokeWidthFromObjects != null) {
                    style.strokeWidth = strokeWidthFromObjects;
                }
                var lineJoinFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.strokeLineJoin);
                if (lineJoinFromObjects != null) {
                    style.lineJoin = lineJoinFromObjects;
                }
                var styleFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.lineStyle);
                if (styleFromObjects != null) {
                    style.style = styleFromObjects;
                }
                var shadeFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.shadeArea);
                if (shadeFromObjects != null) {
                    style.shadeArea = shadeFromObjects;
                }
                return style;
            }
            LineStyle.readFromSeriesObjects = readFromSeriesObjects;
            function getDefault() {
                return {
                    strokeWidth: visuals.CartesianHelper.defaultLineStrokeWidth,
                    lineJoin: visuals.strokeLineJoin.defaultValue,
                    style: visuals.lineStyle.solid,
                    markerProperties: visuals.MarkerProperties.getDefault(),
                    shadeArea: false,
                };
            }
            LineStyle.getDefault = getDefault;
            function enumerate(options) {
                var style = options.style;
                var instance = {
                    selector: normalizeSelector(options.selector),
                    properties: {
                        shadeArea: style.shadeArea,
                        strokeWidth: style.strokeWidth,
                        strokeLineJoin: style.lineJoin,
                    },
                    objectName: visuals.lineChartProps.lineStyles.lineStyle.objectName
                };
                if (options.enumerateStyle) {
                    instance.properties[visuals.lineChartProps.lineStyles.lineStyle.propertyName] = style.style;
                }
                if (options.enumerateMarkers) {
                    visuals.MarkerProperties.populateInstance(instance, style.markerProperties);
                }
                var showSeries = options.showSeries;
                if (showSeries != null) {
                    instance.properties['showSeries'] = showSeries;
                }
                options.enumeration.pushInstance(instance);
            }
            LineStyle.enumerate = enumerate;
            function getStrokeDashArrayFromLineStyle(style) {
                switch (style) {
                    case visuals.lineStyle.dashed:
                        return dashedStroke;
                    case visuals.lineStyle.dotted:
                        return dottedStroke;
                    case visuals.lineStyle.solid:
                        return solidStroke;
                    default:
                        debug.assertFail('getStrokeDashArrayFromLineStyle received an unrecognized line style');
                        return solidStroke;
                }
            }
            LineStyle.getStrokeDashArrayFromLineStyle = getStrokeDashArrayFromLineStyle;
            function getSrokeDashArrayForLegend(style) {
                switch (style) {
                    case visuals.lineStyle.dashed:
                        return '7,5';
                    case visuals.lineStyle.dotted:
                        return '2.5,3.1';
                    case visuals.lineStyle.solid:
                        return solidStroke;
                    default:
                        debug.assertFail('getSrokeDashArrayForLegend received an unrecognized line style');
                        return solidStroke;
                }
            }
            LineStyle.getSrokeDashArrayForLegend = getSrokeDashArrayForLegend;
            function getStrokeLineCapFromLineStyle(style) {
                switch (style) {
                    case visuals.lineStyle.dashed:
                    case visuals.lineStyle.solid:
                        return otherLineCap;
                    case visuals.lineStyle.dotted:
                        return dottedLineCap;
                    default:
                        debug.assertFail('getStrokeDashArrayFromLineStyle received an unrecognized line style');
                        return otherLineCap;
                }
            }
            LineStyle.getStrokeLineCapFromLineStyle = getStrokeLineCapFromLineStyle;
        })(LineStyle = visuals.LineStyle || (visuals.LineStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ListViewFactory;
        (function (ListViewFactory) {
            function createListView(options) {
                return new ListView(options);
            }
            ListViewFactory.createListView = createListView;
        })(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
        /**
         * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
         * It can create lists containing either HTML or SVG elements.
         */
        var ListView = /** @class */ (function () {
            function ListView(options) {
                var _this = this;
                // make a copy of options so that it is not modified later by caller
                this.options = $.extend(true, {}, options);
                this.scrollbarInner = options.baseContainer
                    .append('div')
                    .classed('scrollbar-inner', true)
                    .on('scroll', (function () { return _this.renderImpl(_this.options.rowHeight); }));
                this.scrollContainer = this.scrollbarInner
                    .append('div')
                    .classed('scrollRegion', true)
                    .on('touchstart', (function () { return _this.stopTouchPropagation(); }))
                    .on('touchmove', (function () { return _this.stopTouchPropagation(); }));
                this.visibleGroupContainer = this.scrollContainer
                    .append('div')
                    .classed('visibleGroup', true);
                // Initialize jQuery Scrollbar
                var scrollInner = $(this.scrollbarInner.node());
                scrollInner.scrollbar({
                    ignoreOverlay: false,
                    ignoreMobile: false,
                    onDestroy: function () { return scrollInner.off('scroll'); },
                });
                $(options.baseContainer.node()).find('.scroll-element').attr('drag-resize-disabled', 'true');
                this.scrollToFrame = this.options.scrollToFrame || this.defaultScrollToFrame;
                ListView.SetDefaultOptions(options);
            }
            ListView.prototype.getContainerHeight = function () {
                return $(this.options.baseContainer.node()).outerHeight();
            };
            ListView.SetDefaultOptions = function (options) {
                options.rowHeight = options.rowHeight || ListView.defaultRowHeight;
            };
            ListView.prototype.rowHeight = function (rowHeight) {
                this.options.rowHeight = Math.ceil(rowHeight);
                return this;
            };
            ListView.prototype.data = function (data, getDatumIndex, dataReset) {
                if (dataReset === void 0) { dataReset = false; }
                this._data = data;
                this.getDatumIndex = getDatumIndex;
                this.setTotalRows();
                if (dataReset)
                    $(this.scrollbarInner.node()).scrollTop(0);
                this.render();
                return this;
            };
            /**
             * ToDo: we need to rename this method beacause it also calls render not only sets viewport.
             */
            ListView.prototype.viewport = function (viewport) {
                //debug.assertFail("Viewport is calculated internally based on options.baseContainer height");
                this.render();
                return this;
            };
            ListView.prototype.empty = function () {
                this._data = [];
                this.render();
            };
            ListView.prototype.render = function () {
                var _this = this;
                if (this.renderTimeoutId)
                    window.clearTimeout(this.renderTimeoutId);
                this.renderTimeoutId = window.setTimeout((function () {
                    _this.getRowHeight().then((function (rowHeight) {
                        _this.renderImpl(rowHeight);
                    }));
                    _this.renderTimeoutId = undefined;
                }), 0);
            };
            ListView.prototype.renderImpl = function (rowHeight) {
                var totalHeight = this.options.scrollEnabled ? Math.max(0, (this._totalRows * rowHeight)) : this.getContainerHeight();
                this.scrollContainer
                    .style('height', totalHeight + "px")
                    .attr('height', totalHeight);
                this.scrollToFrame(this, true /*loadMoreData*/, this.options.rowHeight || ListView.defaultRowHeight, this.scrollbarInner.node().scrollTop, this._totalRows, this.visibleGroupContainer, this.options.baseContainer);
            };
            /*
             *  This method is called in order to prevent a bug found in the Interact.js.
             *  The bug is caused when finishing a scroll outside the scroll area.
             *  In that case the Interact doesn't process a touchcancel event and thinks a touch point still exists.
             *  since the Interact listens on the visualContainer, by stoping the propagation we prevent the bug from taking place.
             */
            ListView.prototype.stopTouchPropagation = function () {
                //Stop the propagation only in read mode so the drag won't be affected.
                if (this.options.isReadMode()) {
                    if (d3.event.type === "touchstart") {
                        var event_1 = d3.event;
                        //If there is another touch point outside this visual than the event should be propagated.
                        //This way the pinch to zoom will not be affected.
                        if (event_1.touches && event_1.touches.length === 1) {
                            d3.event.stopPropagation();
                        }
                    }
                    if (d3.event.type === "touchmove") {
                        d3.event.stopPropagation();
                    }
                }
            };
            ListView.prototype.defaultScrollToFrame = function (listView, loadMoreData, rowHeight, scrollTop, totalElements, visibleGroupContainer, baseContainer) {
                var visibleRows = this.getVisibleRows();
                var scrollPosition = (scrollTop === 0) ? 0 : Math.floor(scrollTop / rowHeight);
                var transformAttr = visuals.SVGUtil.translateWithPixels(0, scrollPosition * rowHeight);
                visibleGroupContainer.style({
                    //order matters for proper overriding
                    'transform': function (d) { return transformAttr; },
                    '-webkit-transform': transformAttr
                });
                var position0 = Math.max(0, Math.min(scrollPosition, totalElements - visibleRows + 1)), position1 = position0 + visibleRows;
                this.performScrollToFrame(position0, position1, totalElements, visibleRows, loadMoreData);
            };
            ListView.prototype.performScrollToFrame = function (position0, position1, totalRows, visibleRows, loadMoreData) {
                var options = this.options;
                var visibleGroupContainer = this.visibleGroupContainer;
                var rowSelection = visibleGroupContainer.selectAll(".row")
                    .data(this._data.slice(position0, Math.min(position1, totalRows)), this.getDatumIndex);
                rowSelection
                    .enter()
                    .append('div')
                    .classed('row', true)
                    .call((function (d) { return options.enter(d); }));
                rowSelection.order();
                var rowUpdateSelection = visibleGroupContainer.selectAll('.row:not(.transitioning)');
                rowUpdateSelection.call((function (d) { return options.update(d); }));
                rowSelection
                    .exit()
                    .call((function (d) { return options.exit(d); }))
                    .remove();
                if (loadMoreData && visibleRows !== totalRows && position1 >= totalRows * ListView.loadMoreDataThreshold)
                    options.loadMoreData();
            };
            ListView.prototype.setTotalRows = function () {
                var data = this._data;
                this._totalRows = data ? data.length : 0;
            };
            ListView.prototype.getVisibleRows = function () {
                var minimumVisibleRows = 1;
                var options = this.options;
                var rowHeight = options.rowHeight;
                var containerHeight = this.getContainerHeight();
                if (!rowHeight || rowHeight < 1)
                    return minimumVisibleRows;
                // How many rows of space the viewport can hold (not the number of rows it can display).
                var viewportRowCount = containerHeight / rowHeight;
                if (this.options.scrollEnabled) {
                    // Ceiling the count since we can have items be partially displayed when scrolling.
                    // Add 1 to make sure we always render enough rows to cover the entire viewport (handles when rows are partially visible when scrolling).
                    // Ex. If you have a viewport that can show 280 (viewport height) / 100 (row height) = 2.8 rows, you need to have up to Math.ceil(2.8) + 1 = 4 rows of data to cover the viewport.
                    // If you only had Math.ceil(2.8) = 3 rows of data, and the top rows was 50% visible (scrolled up), you'd only be able to cover .5 + 1 + 1 = 2.5 rows of the viewport.
                    // This makes a gap at the bottom of the listview.
                    // Add an extra row of data and we can cover .5 + 1 + 1 + 1 = 3.5 rows of the viewport. 3.5 is enough to cover the entire viewport as only 2.8 is needed.
                    // 1 is always added, even if not needed, to keep logic simple. Advanced logic would figure out what % of the top row is visible and use that to add 1 if needed.
                    return Math.min(Math.ceil(viewportRowCount) + 1, this._totalRows) || minimumVisibleRows;
                }
                // Floor the count since that's the maximum number of entire rows we can display without scrolling.
                return Math.min(Math.floor(viewportRowCount), this._totalRows) || minimumVisibleRows;
            };
            ListView.prototype.getRowHeight = function () {
                var deferred = $.Deferred();
                var listView = this;
                var options = listView.options;
                if (this.cancelMeasurePass)
                    this.cancelMeasurePass();
                // if there is no data, resolve and return
                if (!(this._data && this._data.length && options)) {
                    listView.rowHeight(ListView.defaultRowHeight);
                    return deferred.resolve(options.rowHeight).promise();
                }
                //render the first item to calculate the row height
                this.scrollToFrame(this, false /*loadMoreData*/, this.options.rowHeight || ListView.defaultRowHeight, this.scrollbarInner.node().scrollTop, this._totalRows, this.visibleGroupContainer, this.options.baseContainer);
                var requestAnimationFrameId = window.requestAnimationFrame((function () {
                    // Measure row height. Take non empty rows to measure the row height because if the first row is empty, it returns incorrect height
                    // which causes scrolling issues. 
                    var rows = listView.visibleGroupContainer.selectAll(".row").filter((function () { return this.textContent !== ""; }));
                    // For image slicer, the text content will be empty. Hence just select the rows for that and then we use the first row height
                    if (rows.empty()) {
                        rows = listView.visibleGroupContainer.select(".row");
                    }
                    if (!rows.empty()) {
                        var firstRow = rows.node();
                        // If the container (child) has margins amd the row (parent) doesn't, the child's margins will collapse into the parent.
                        // outerHeight doesn't report the correct height for the parent in this case, but it does measure the child properly.
                        // Fix for #7497261 Measures both and take the max to work around this issue.
                        var rowHeight = Math.max($(firstRow).outerHeight(true), $(firstRow).children().first().outerHeight(true));
                        listView.rowHeight(rowHeight);
                        deferred.resolve(rowHeight);
                    }
                    listView.cancelMeasurePass = undefined;
                    window.cancelAnimationFrame(requestAnimationFrameId);
                }));
                this.cancelMeasurePass = function () {
                    window.cancelAnimationFrame(requestAnimationFrameId);
                    deferred.reject();
                };
                return deferred.promise();
            };
            /**
             * The value indicates the percentage of data already shown
             * in the list view that triggers a loadMoreData call.
             */
            ListView.loadMoreDataThreshold = 0.8;
            ListView.defaultRowHeight = 1;
            return ListView;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var defaultLevelOfDetail = 11;
        var MapUtil;
        (function (MapUtil) {
            function getBingMapsVersion() {
                var version;
                try {
                    if (Microsoft && Microsoft.Maps && Microsoft.Maps.Map && _.isFunction(Microsoft.Maps.Map.getVersion)) {
                        var v = Microsoft.Maps.Map.getVersion();
                        if (/^7\./.test(v))
                            version = 7 /* V7 */;
                        else
                            version = 8 /* V8 */;
                    }
                }
                catch (err) {
                    jsCommon.Trace.error('Error getting Bing maps version: ' + (err & (err.message || err.toString())));
                }
                return version;
            }
            MapUtil.getBingMapsVersion = getBingMapsVersion;
            // V7 compat
            function removeHillShading() {
                if (Microsoft.Maps.Globals && typeof Microsoft.Maps.Globals.roadUriFormat === 'string')
                    Microsoft.Maps.Globals.roadUriFormat = Microsoft.Maps.Globals.roadUriFormat.replace('&shading=hill', '');
            }
            MapUtil.removeHillShading = removeHillShading;
            // V7 compat
            function createPushPin(location, svgTemplate, width, height) {
                var options = {
                    draggable: false,
                };
                if (MapUtil.getBingMapsVersion() === 7 /* V7 */) {
                    options.htmlContent = svgTemplate;
                    options.height = height;
                    options.width = width;
                }
                else {
                    options.icon = svgTemplate;
                }
                return new Microsoft.Maps.Pushpin(location, options);
            }
            MapUtil.createPushPin = createPushPin;
            // V8 compat hack. Map is checking for resize on a 1 sec poll which is terribly slow
            // and makes our smooth data point animation look weird. They suggest this hack.
            function renderAfterResize(mapControl) {
                if (MapUtil.getBingMapsVersion() === 8 /* V8 */ && mapControl) {
                    var _sizeHelper = mapControl['_v8Map'] && mapControl['_v8Map']._sizeHelper;
                    if (!_sizeHelper || !_.isFunction(_sizeHelper.pollSize))
                        debug.assertFail('Smooth resize animation hack not working because V8 map control pollSize function not found');
                    else
                        _sizeHelper.pollSize();
                }
            }
            MapUtil.renderAfterResize = renderAfterResize;
            function mapTypeIdFromTheme(theme) {
                if (MapUtil.getBingMapsVersion() === 7 /* V7 */) {
                    switch (theme) {
                        case visuals.BingMapTheme.aerial: return Microsoft.Maps.MapTypeId.aerial;
                        default: return Microsoft.Maps.MapTypeId.road;
                    }
                }
                var typeId = Microsoft.Maps.MapTypeId[theme];
                debug.assertValue(typeId, 'Map theme did not select a MapTypeId');
                return typeId;
            }
            MapUtil.mapTypeIdFromTheme = mapTypeIdFromTheme;
            MapUtil.Settings = {
                /** Maximum Bing requests at once. The Bing have limit how many request at once you can do per socket. */
                MaxBingRequest: 6,
                /** Maximum cache size of cached geocode data. */
                MaxCacheSize: 3000,
                /** Maximum cache overflow of cached geocode data to kick the cache reducing. */
                MaxCacheSizeOverflow: 100,
                BingKey: "AoW85FdF-eTJavFmWhZjaQ970kwG1FuainbyVSlP5HglkbhVVIFOyNwlaQxAIj-S",
            };
            MapUtil.StreetsideModeManagerInterval = 16;
            var DefaultBingMapControlUrl = 'https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1';
            function mapControlFactory(promiseFactory, loader) {
                return {
                    ensureMap: function (locale) { return powerbi.ensureMap(promiseFactory, loader, DefaultBingMapControlUrl, locale); }
                };
            }
            MapUtil.mapControlFactory = mapControlFactory;
            // Bing map min/max boundaries
            MapUtil.MinAllowedLatitude = -85.05112878;
            MapUtil.MaxAllowedLatitude = 85.05112878;
            MapUtil.MinAllowedLongitude = -180;
            MapUtil.MaxAllowedLongitude = 180;
            MapUtil.TileSize = 256;
            MapUtil.MaxLevelOfDetail = 23;
            MapUtil.MinLevelOfDetail = 1;
            MapUtil.MaxAutoZoomLevel = 5;
            MapUtil.DefaultLevelOfDetail = 11;
            MapUtil.WorkerErrorName = "___error___";
            MapUtil.DefaultFillOpacity = 0.5;
            MapUtil.DefaultBackgroundColor = "#000000";
            MapUtil.LeaderLineColor = "#000000";
            MapUtil.CategoryTypes = {
                Address: "Address",
                City: "City",
                Continent: "Continent",
                CountryRegion: "Country",
                County: "County",
                Longitude: "Longitude",
                Latitude: "Latitude",
                Place: "Place",
                PostalCode: "PostalCode",
                StateOrProvince: "StateOrProvince"
            };
            var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            function clip(n, minValue, maxValue) {
                return Math.min(Math.max(n, minValue), maxValue);
            }
            MapUtil.clip = clip;
            function getMapSize(levelOfDetail) {
                if (levelOfDetail === 23)
                    return 2147483648; //256 << 23 overflow the integer and return a negative value
                if (Math.floor(levelOfDetail) === levelOfDetail)
                    return 256 << levelOfDetail;
                return 256 * Math.pow(2, levelOfDetail);
            }
            MapUtil.getMapSize = getMapSize;
            /**
             * pointArrayChunkLength Motivation:
             * When the number is too small (e.g. less than 1000) the tile is rendering but VERY SLOW,
             * when it's too high there is a risk to get "stack overflow" error on mobile (while joining).
             * this is the lowest number I managed to get without any noticeable slowness.
             */
            var pointArrayChunkLength = 15000;
            /**
             * @param latLongArray - is a Float64Array as [lt0, lon0, lat1, long1, lat2, long2,....]
             * @param buildString - optional, if true returns also a string as "x0 y0 x1 y1 x2 y2 ...."
             * @returns IPixelArrayResult with Float64Array as [x0, y0, x1, y1, x2, y2,....]
             */
            function latLongToPixelXYArray(latLongArray, levelOfDetail, buildString) {
                if (buildString === void 0) { buildString = false; }
                var helperArray = [];
                var result = {
                    array: new Float64Array(latLongArray.length),
                    arrayString: ""
                };
                for (var i = 0; i < latLongArray.length; i += 2) {
                    var latitude = clip(latLongArray[i], MapUtil.MinAllowedLatitude, MapUtil.MaxAllowedLatitude);
                    var longitude = clip(latLongArray[i + 1], MapUtil.MinAllowedLongitude, MapUtil.MaxAllowedLongitude);
                    var x = (longitude + 180) / 360;
                    var sinLatitude = Math.sin(latitude * Math.PI / 180);
                    var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
                    var mapSize = getMapSize(levelOfDetail);
                    result.array[i] = clip(x * mapSize + 0.5, 0.0, mapSize - 1);
                    result.array[i + 1] = clip(y * mapSize + 0.5, 0.0, mapSize - 1);
                    if (buildString) {
                        helperArray.push(result.array[i], result.array[i + 1]);
                        if (helperArray.length >= pointArrayChunkLength) {
                            result.arrayString += helperArray.join(" ") + " ";
                            helperArray = [];
                        }
                    }
                }
                if (buildString) {
                    result.arrayString += helperArray.join(" ") + " ";
                }
                return result;
            }
            MapUtil.latLongToPixelXYArray = latLongToPixelXYArray;
            function getLocationBoundaries(latLongArray) {
                var northWest = {
                    latitude: -90, longitude: 180
                };
                var southEast = {
                    latitude: 90, longitude: -180
                };
                for (var i = 0; i < latLongArray.length; i += 2) {
                    northWest.latitude = Math.max(latLongArray[i], northWest.latitude);
                    northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude);
                    southEast.latitude = Math.min(latLongArray[i], southEast.latitude);
                    southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                }
                northWest.longitude = clip(northWest.longitude, -180, 180);
                southEast.longitude = clip(southEast.longitude, -180, 180);
                return Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
            }
            MapUtil.getLocationBoundaries = getLocationBoundaries;
            /**
             * Note: this code is taken from Bing.
             *  see Point Compression Algorithm http://msdn.microsoft.com/en-us/library/jj158958.aspx
             *  see Decompression Algorithm in http://msdn.microsoft.com/en-us/library/dn306801.aspx
             */
            function parseEncodedSpatialValueArray(value) {
                var list = [];
                var index = 0;
                var xsum = 0;
                var ysum = 0;
                var max = 4294967296;
                while (index < value.length) {
                    var n = 0;
                    var k = 0;
                    while (1) {
                        if (index >= value.length) {
                            return null;
                        }
                        var b = safeCharacters.indexOf(value.charAt(index++));
                        if (b === -1) {
                            return null;
                        }
                        var tmp = ((b & 31) * (Math.pow(2, k)));
                        var ht = tmp / max;
                        var lt = tmp % max;
                        var hn = n / max;
                        var ln = n % max;
                        var nl = (lt | ln) >>> 0;
                        n = (ht | hn) * max + nl;
                        k += 5;
                        if (b < 32)
                            break;
                    }
                    var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                    n -= diagonal * (diagonal + 1) / 2;
                    var ny = Math.floor(n);
                    var nx = diagonal - ny;
                    nx = (nx >> 1) ^ -(nx & 1);
                    ny = (ny >> 1) ^ -(ny & 1);
                    xsum += nx;
                    ysum += ny;
                    var lat = ysum * 0.00001;
                    var lon = xsum * 0.00001;
                    list.push(lat);
                    list.push(lon);
                }
                return new Float64Array(list);
            }
            MapUtil.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray;
            function calcGeoData(data) {
                var locations = data.locations;
                for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
                    var location_1 = locations_1[_i];
                    if (!location_1.geographic) {
                        location_1.geographic = MapUtil.parseEncodedSpatialValueArray(location_1.nativeBing);
                    }
                    var polygon = location_1.geographic;
                    if (polygon) {
                        if (!location_1.absolute) {
                            var result = MapUtil.latLongToPixelXYArray(polygon, MapUtil.DefaultLevelOfDetail, true);
                            location_1.absolute = result.array;
                            location_1.absoluteString = result.arrayString;
                            var geographicBounds = MapUtil.getLocationBoundaries(polygon);
                            location_1.absoluteBounds = MapUtil.locationRectToRectXY(geographicBounds, MapUtil.DefaultLevelOfDetail);
                        }
                    }
                }
            }
            MapUtil.calcGeoData = calcGeoData;
            function locationToPixelXY(location, levelOfDetail) {
                return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
            }
            MapUtil.locationToPixelXY = locationToPixelXY;
            function locationRectToRectXY(locationRect, levelOfDetail) {
                var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail);
                var bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
            }
            MapUtil.locationRectToRectXY = locationRectToRectXY;
            function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                var array = latLongToPixelXYArray(new Float64Array([latitude, longitude]), levelOfDetail).array;
                return new powerbi.visuals.Point(array[0], array[1]);
            }
            MapUtil.latLongToPixelXY = latLongToPixelXY;
            function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                var mapSize = getMapSize(levelOfDetail);
                var x = (clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
                var y = 0.5 - (clip(pixelY, 0, mapSize - 1) / mapSize);
                var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
                var longitude = 360 * x;
                return new Microsoft.Maps.Location(latitude, longitude);
            }
            MapUtil.pixelXYToLocation = pixelXYToLocation;
            var CurrentLocation;
            (function (CurrentLocation) {
                function createPushpin(location) {
                    var template = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">'
                        + '<circle fill="#FF5F00" cx="12" cy="12" r="6"/>'
                        + '<circle fill="none" stroke="#FF5F00" stroke-width="2" cx="12" cy="12" r="10"/>'
                        + '</svg>';
                    return MapUtil.createPushPin(location, template, 24, 24);
                }
                CurrentLocation.createPushpin = createPushpin;
            })(CurrentLocation = MapUtil.CurrentLocation || (MapUtil.CurrentLocation = {}));
            function moveMap(mapControl, x, y) {
                var point = new Microsoft.Maps.Point(x, y);
                var location = mapControl.tryPixelToLocation(point, Microsoft.Maps.PixelReference.page);
                mapControl.setView({ center: location, });
            }
            MapUtil.moveMap = moveMap;
            function moveMapDelta(mapControl, deltaX, deltaY) {
                // Apply the deltas to the center, convert it to a location, then move to that location
                // Subtract the deltas since mouse movement is inverted. Moving the mouse down actually means to move the map (and center) up.
                var centerPixel = mapControl.tryLocationToPixel(mapControl.getCenter(), Microsoft.Maps.PixelReference.page);
                var newX = centerPixel.x - deltaX;
                var newY = centerPixel.y - deltaY;
                moveMap(mapControl, newX, newY);
            }
            MapUtil.moveMapDelta = moveMapDelta;
        })(MapUtil = visuals.MapUtil || (visuals.MapUtil = {}));
        var MapPolygonInfo = /** @class */ (function () {
            function MapPolygonInfo() {
                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
            }
            MapPolygonInfo.prototype.reCalc = function (mapControl, width, height) {
                var baseLocations = [this._locationRect.getNorthwest(), this._locationRect.getSoutheast()];
                width = width / 2.00;
                height = height / 2.00;
                if (!this._baseRect) {
                    var l0 = MapUtil.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail);
                    var l1 = MapUtil.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                    this._baseRect = new visuals.Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                }
                var l = mapControl.tryLocationToPixel(baseLocations);
                this._currentRect = new visuals.Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
            };
            Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                get: function () {
                    if (this._baseRect) {
                        return this._currentRect.width / this._baseRect.width;
                    }
                    return 1.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    transform.scale((current.width / base.width), (current.height / base.height));
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    var scale = Math.sqrt(current.width / base.width);
                    transform.scale(scale, scale);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    var scale = current.width / base.width;
                    transform.scale(scale, scale);
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.transformToString = function (transform) {
                var m = transform.matrix;
                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
            };
            return MapPolygonInfo;
        }());
        visuals.MapPolygonInfo = MapPolygonInfo;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MarkerProperties;
        (function (MarkerProperties) {
            var markerKeyBase = 'seriesMarker';
            function readFromStaticObjects(objects) {
                if (!objects) {
                    return getDefault();
                }
                var markerProperties = {
                    lineDashType: visuals.lineStyle.solid,
                    showMarker: powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.showMarker, false),
                    shape: powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.markerShape, visuals.markerShape.defaultValue),
                    size: powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.markerSize, Markers.defaultSize),
                    color: powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.lineStyles.markerColor),
                };
                return markerProperties;
            }
            MarkerProperties.readFromStaticObjects = readFromStaticObjects;
            function readFromSeries(reader, staticProps, seriesIndex, colorOnly) {
                var markerProps = powerbi.Prototype.inherit(staticProps);
                markerProps.key = markerKeyBase + seriesIndex;
                if (!reader.data.hasSeries() || colorOnly) {
                    markerProps.color = staticProps.color ? staticProps.color : reader.colors.createBySeries(seriesIndex);
                    return markerProps;
                }
                var objects = reader.objects.getSeriesDataObjects(seriesIndex);
                // TODO: add line dash type
                var showMarkerFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.showMarker);
                if (showMarkerFromObjects != null) {
                    markerProps.showMarker = showMarkerFromObjects;
                }
                var shapeFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.markerShape);
                if (shapeFromObjects != null) {
                    markerProps.shape = shapeFromObjects;
                }
                var sizeFromObjects = powerbi.DataViewObjects.getValue(objects, visuals.lineChartProps.lineStyles.markerSize);
                if (sizeFromObjects != null) {
                    markerProps.size = +sizeFromObjects;
                }
                // For colors, series object color > static object color > normal color by series
                var colorFromObjects = powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.lineStyles.markerColor);
                // Color based on marker series objects
                if (colorFromObjects != null) {
                    markerProps.color = colorFromObjects;
                }
                else if (!staticProps.color) {
                    markerProps.color = reader.colors.createBySeries(seriesIndex);
                }
                return markerProps;
            }
            MarkerProperties.readFromSeries = readFromSeries;
            function getDefault() {
                return {
                    lineDashType: visuals.lineStyle.solid,
                    showMarker: false,
                    shape: visuals.markerShape.defaultValue,
                    size: Markers.defaultSize,
                    color: undefined,
                };
            }
            MarkerProperties.getDefault = getDefault;
            function populateInstance(instance, markerProperties) {
                instance.properties[visuals.lineChartProps.lineStyles.showMarker.propertyName] = markerProperties.showMarker;
                if (markerProperties.showMarker) {
                    instance.properties[visuals.lineChartProps.lineStyles.markerShape.propertyName] = markerProperties.shape;
                    instance.properties[visuals.lineChartProps.lineStyles.markerSize.propertyName] = markerProperties.size;
                    instance.properties[visuals.lineChartProps.lineStyles.markerColor.propertyName] = markerProperties.color;
                }
            }
            MarkerProperties.populateInstance = populateInstance;
        })(MarkerProperties = visuals.MarkerProperties || (visuals.MarkerProperties = {}));
        var MarkerRenderer = /** @class */ (function () {
            function MarkerRenderer() {
                this.markerKeyModifier = '';
                this.shouldCycleKeyModifier = jsCommon.BrowserUtils.isInternetExplorerOrEdge();
                this.uniqueIdentifier = _.uniqueId();
            }
            MarkerRenderer.prototype.ensureMarkers = function (defs, markerProperties) {
                var _this = this;
                var modifiedMarkerProperties = this.modifyMarkersIfNeeded(markerProperties, this.shouldCycleKeyModifier);
                var markersData = defs.selectAll('marker').data(modifiedMarkerProperties.filter((function (markerProp) { return markerProp.showMarker; })), (function (markerProp) { return _this.getMarkerId(markerProp); }));
                var markersEnter = markersData.enter();
                var markers = markersEnter
                    .append('marker');
                markers
                    .append('path')
                    .classed('markerPaths', true);
                markersData
                    .attr({
                    id: function (d) { return _this.getMarkerId(d); },
                    markerUnits: 'strokeWidth',
                    orient: 0,
                    refX: 0,
                    refY: 0,
                    viewBox: '-6 -6 12 12',
                })
                    .transition()
                    .duration(1)
                    .attr({
                    markerHeight: function (d) { return d.size; },
                    markerWidth: function (d) { return d.size; },
                });
                markersData.exit()
                    .remove();
                var paths = defs.selectAll('.markerPaths').data(modifiedMarkerProperties.filter((function (markerProp) { return markerProp.showMarker; })), (function (markerProp) { return _this.getMarkerId(markerProp); }));
                paths
                    .attr('d', (function (d) { return Markers.getPath(d.shape); }))
                    .style('stroke-width', (function (d) { return Markers.getStrokeWidth(d.shape); }))
                    .style('stroke-opacity', 1)
                    .style('stroke', (function (d) { return d.color; }))
                    .style('fill', (function (d) { return d.color; }));
                paths.exit()
                    .remove();
            };
            MarkerRenderer.prototype.renderMarkers = function (markerPathTransition) {
                var _this = this;
                markerPathTransition
                    .attr('marker-start', (function (d, i) { return _this.getMarkerKey(d.lineStyle.markerProperties); }))
                    .attr('marker-mid', (function (d, i) { return _this.getMarkerKey(d.lineStyle.markerProperties); }))
                    .attr('marker-end', (function (d, i) { return _this.getMarkerKey(d.lineStyle.markerProperties); }));
            };
            MarkerRenderer.prototype.shouldDisableAnimations = function () {
                return this.shouldCycleKeyModifier;
            };
            /**
             * Obtains the key used for the marker defs, drawing the modifier from the
             * modified property so that both modifiers are included.
             */
            MarkerRenderer.prototype.getMarkerId = function (d) {
                return d.key + '-' + this.uniqueIdentifier + (d.modifier || '');
            };
            /**
             * Obtains the key used in the paths rendering the markers, drawing the modifier
             * from the Renderer's cycling key so that which of the two modifiers gets used
             * cycles between renders, working around an issue in IE.
             */
            MarkerRenderer.prototype.getMarkerKey = function (markerProperties) {
                var hrefAdjustment = window.location.href; // We need to adjust the URL paramter here to work around an issue in Safari TODO: adjust this to only be used in Safari
                return markerProperties.showMarker ? 'url(' + hrefAdjustment + '#' + markerProperties.key + '-' + this.uniqueIdentifier + this.markerKeyModifier + ')' : null;
            };
            MarkerRenderer.prototype.modifyMarkersIfNeeded = function (markerProperties, shouldCycleKeyModifier) {
                // For IE, we need to create two versions of each marker definition with different ids
                //   and cycle between them in order to ensure correct path rendering, since paths with
                //   markers only rerender correctly if the marker definition changes. We then switch
                //   between a and b in order to ensure the path updates.  The rendering and getMarkerKey
                //   already handle this.
                // TODO: This is rather hacky.  We should try to improve this.
                if (shouldCycleKeyModifier) {
                    var modifiedMarkerProperties = [];
                    this.cycleMarkerKeyModifier();
                    modifiedMarkerProperties = this.modifyMarkerProperties(markerProperties, 'a');
                    modifiedMarkerProperties.push.apply(modifiedMarkerProperties, this.modifyMarkerProperties(markerProperties, 'b'));
                    return modifiedMarkerProperties;
                }
                return markerProperties;
            };
            MarkerRenderer.prototype.cycleMarkerKeyModifier = function () {
                if (this.markerKeyModifier === 'a') {
                    this.markerKeyModifier = 'b';
                }
                else {
                    this.markerKeyModifier = 'a';
                }
            };
            MarkerRenderer.prototype.modifyMarkerProperties = function (markerProperties, modifier) {
                return _.map(markerProperties, (function (markerProp) {
                    var modifiedProp = powerbi.Prototype.inherit(markerProp);
                    modifiedProp.modifier = modifier;
                    return modifiedProp;
                }));
            };
            return MarkerRenderer;
        }());
        visuals.MarkerRenderer = MarkerRenderer;
        var Markers;
        (function (Markers) {
            Markers.defaultSize = 5;
            var circlePath = 'M 0 0 m -5 0 a 5 5 0 1 0 10 0 a 5 5 0 1 0 -10 0';
            var squarePath = 'M 0 0 m -5 -5 l 10 0 l 0 10 l -10 0 z';
            var diamondPath = 'M 0 0 m -5 0 l 5 -5 l 5 5 l -5 5 z';
            var trianglePath = 'M 0 0 m -5 5 l 5 -10 l 5 10 z';
            var xPath = 'M 0 0 m -5 -5 l 10 10 m -10 0 l 10 -10';
            var shortDashPath = 'M 0 0 l 5 0';
            var longDashPath = 'M 0 0 m -5 0 l 10 0';
            var plusPath = 'M 0 0 m -5 0 l 10 0 m -5 -5 l 0 10';
            var shapeStroke = 0;
            var thinStroke = 1;
            var thickStroke = 2;
            function getPath(shape) {
                switch (shape) {
                    case visuals.markerShape.circle:
                        return circlePath;
                    case visuals.markerShape.square:
                        return squarePath;
                    case visuals.markerShape.diamond:
                        return diamondPath;
                    case visuals.markerShape.triangle:
                        return trianglePath;
                    case visuals.markerShape.x:
                        return xPath;
                    case visuals.markerShape.shortDash:
                        return shortDashPath;
                    case visuals.markerShape.longDash:
                        return longDashPath;
                    case visuals.markerShape.plus:
                        return plusPath;
                    case visuals.markerShape.none:
                        return;
                    default:
                        debug.assertFail('Markers.getPath received an unknown MarkerShape');
                }
            }
            Markers.getPath = getPath;
            function getStrokeWidth(shape) {
                switch (shape) {
                    case visuals.markerShape.circle:
                    case visuals.markerShape.square:
                    case visuals.markerShape.diamond:
                    case visuals.markerShape.triangle:
                    case visuals.markerShape.none:
                        return shapeStroke;
                    case visuals.markerShape.x:
                    case visuals.markerShape.plus:
                        return thinStroke;
                    case visuals.markerShape.shortDash:
                    case visuals.markerShape.longDash:
                        return thickStroke;
                    default:
                        debug.assertFail('Markers.getStrokeWidth received an unknown MarkerShape');
                }
            }
            Markers.getStrokeWidth = getStrokeWidth;
            function resolveMarkerShape(markerProperties, renderingSetting, defaultShape) {
                var finalShape;
                // If we are set to marker only, render the marker if it's there and shown; otherwise, use the defaultMarkerShape
                if (renderingSetting === visuals.legendMarkerRendering.markerOnly) {
                    finalShape = markerProperties && markerProperties.showMarker ? markerProperties.shape : defaultShape;
                }
                else if (renderingSetting === visuals.legendMarkerRendering.lineAndMarker) {
                    finalShape = markerProperties && markerProperties.showMarker ? markerProperties.shape : visuals.markerShape.none;
                }
                else if (renderingSetting === visuals.legendMarkerRendering.lineOnly) {
                    finalShape = visuals.markerShape.none;
                }
                else {
                    finalShape = visuals.markerShape.circle;
                }
                return finalShape;
            }
            Markers.resolveMarkerShape = resolveMarkerShape;
            function resolveMarkerColor(markerProperties, seriesColor, renderingSetting, matchSeriesColor) {
                if (!markerProperties) {
                    return seriesColor;
                }
                if (renderingSetting === visuals.legendMarkerRendering.markerOnly) {
                    if (matchSeriesColor) {
                        return seriesColor;
                    }
                    else if (markerProperties.showMarker === false) {
                        return seriesColor;
                    }
                }
                return markerProperties.color || seriesColor;
            }
            Markers.resolveMarkerColor = resolveMarkerColor;
            function getPathWithRadius(shape, radius) {
                switch (shape) {
                    case visuals.markerShape.circle:
                        return "M 0 0 m " + (-radius) + " 0 a " + radius + " " + radius + " 0 1 0 " + (radius * 2) + " 0 a " + radius + " " + radius + " 0 1 0 " + (-2 * radius) + " 0";
                    case visuals.markerShape.square:
                        return "M 0 0 m " + (-radius) + " " + (-radius) + " l " + (radius * 2) + " 0 l 0 " + (radius * 2) + " l " + (-2 * radius) + " 0 z";
                    case visuals.markerShape.diamond:
                        return "M 0 0 m " + (-radius) + " 0 l " + radius + " " + (-radius) + " l " + radius + " " + radius + " l " + (-radius) + " " + radius + " z";
                    case visuals.markerShape.triangle:
                        return "M 0 0 m " + (-radius) + " " + radius + " l " + radius + " " + (-2 * radius) + " l " + radius + " " + (2 * radius) + " z";
                    case visuals.markerShape.x:
                    case visuals.markerShape.shortDash:
                    case visuals.markerShape.longDash:
                    case visuals.markerShape.plus:
                        debug.assertFail('Markers.getPathWithRadius does not support non-fillable marker shapes');
                    case visuals.markerShape.none:
                        return null;
                    default:
                        debug.assertFail('Markers.getPathWithRadius received an unknown MarkerShape');
                }
            }
            Markers.getPathWithRadius = getPathWithRadius;
        })(Markers = visuals.Markers || (visuals.Markers = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var ReferenceLineHelper;
        (function (ReferenceLineHelper) {
            var ReferenceLineProps;
            (function (ReferenceLineProps) {
                ReferenceLineProps.show = 'show';
                ReferenceLineProps.lineColor = 'lineColor';
                ReferenceLineProps.transparency = 'transparency';
                ReferenceLineProps.displayName = 'displayName';
                ReferenceLineProps.value = 'value';
                ReferenceLineProps.style = 'style';
                ReferenceLineProps.position = 'position';
                ReferenceLineProps.dataLabelShow = 'dataLabelShow';
                ReferenceLineProps.dataLabelColor = 'dataLabelColor';
                ReferenceLineProps.dataLabelText = 'dataLabelText';
                ReferenceLineProps.dataLabelDecimalPoints = 'dataLabelDecimalPoints';
                ReferenceLineProps.dataLabelHorizontalPosition = 'dataLabelHorizontalPosition';
                ReferenceLineProps.dataLabelVerticalPosition = 'dataLabelVerticalPosition';
                ReferenceLineProps.dataLabelDisplayUnits = 'dataLabelDisplayUnits';
            })(ReferenceLineProps = ReferenceLineHelper.ReferenceLineProps || (ReferenceLineHelper.ReferenceLineProps = {}));
            function isHorizontal(refLine, axes) {
                return (refLine.axis === 1 /* Y1 */) && !axes.y1.isCategoryAxis;
            }
            ReferenceLineHelper.isHorizontal = isHorizontal;
            function enumerateObjectInstances(enumeration, referenceLines, defaultColor, objectName, isValueAxisDisabled) {
                debug.assertValue(enumeration, 'enumeration');
                if (isValueAxisDisabled)
                    return;
                if (_.isEmpty(referenceLines)) {
                    // NOTE: We do not currently have support for object maps in the property pane. For now we will generate a single reference line 
                    // object that the format pane can handle.In the future we will need property pane support for multiple reference lines. Also, we're
                    // assuming that the user-defined IDs will be numeric strings, this may change in the future and will likley be controlled by the property pane.
                    var instance = {
                        selector: {
                            id: '0'
                        },
                        properties: {
                            show: false,
                            value: '',
                            lineColor: { solid: { color: defaultColor } },
                            transparency: 50,
                            style: visuals.lineStyle.dashed,
                            position: visuals.referenceLinePosition.front,
                            dataLabelShow: false,
                        },
                        objectName: objectName
                    };
                    enumeration.pushInstance(instance);
                    return;
                }
                for (var _i = 0, referenceLines_1 = referenceLines; _i < referenceLines_1.length; _i++) {
                    var referenceLine = referenceLines_1[_i];
                    var dataLabelShow = referenceLine.dataLabelProperties && referenceLine.dataLabelProperties.show;
                    var instance = {
                        selector: referenceLine.selector,
                        properties: {
                            show: referenceLine.show,
                            displayName: referenceLine.displayName,
                            value: referenceLine.value,
                            lineColor: referenceLine.color,
                            transparency: referenceLine.transparency,
                            style: referenceLine.style,
                            position: referenceLine.position,
                            dataLabelShow: dataLabelShow,
                        },
                        objectName: referenceLine.type
                    };
                    // Show the data label properties only if the user chose to show the data label
                    if (dataLabelShow) {
                        var dataLabelProperties = referenceLine.dataLabelProperties;
                        instance.properties[ReferenceLineProps.dataLabelColor] = dataLabelProperties.color;
                        instance.properties[ReferenceLineProps.dataLabelText] = dataLabelProperties.text;
                        instance.properties[ReferenceLineProps.dataLabelHorizontalPosition] = dataLabelProperties.horizontalPosition;
                        instance.properties[ReferenceLineProps.dataLabelVerticalPosition] = dataLabelProperties.verticalPosition;
                        instance.properties[ReferenceLineProps.dataLabelDisplayUnits] = dataLabelProperties.displayUnits;
                        instance.properties[ReferenceLineProps.dataLabelDecimalPoints] = dataLabelProperties.decimalPoints;
                    }
                    enumeration.pushInstance(instance);
                }
            }
            ReferenceLineHelper.enumerateObjectInstances = enumerateObjectInstances;
            function render(options) {
                var xScale = options.axes.x.scale;
                var yScale = options.axes.y1.scale;
                function setRefLineProperties(refLine) {
                    if (!refLine.show || !_.isNumber(refLine.value))
                        return;
                    var isHorizontal = ReferenceLineHelper.isHorizontal(refLine, options.axes);
                    var viewport = options.viewport;
                    var value = refLine.value;
                    var line = d3.select(this);
                    line.attr('x1', isHorizontal ? 0 : xScale(value));
                    line.attr('y1', isHorizontal ? yScale(value) : 0);
                    line.attr('x2', isHorizontal ? viewport.width : xScale(value));
                    line.attr('y2', isHorizontal ? yScale(value) : viewport.height);
                    var style = {};
                    style['stroke'] = refLine.color.solid.color;
                    var transparency = refLine.transparency;
                    style['stroke-opacity'] = (100 - transparency) / 100;
                    switch (refLine.style) {
                        case visuals.lineStyle.dotted:
                            {
                                style['stroke-dasharray'] = '1, 5';
                                style['stroke-linecap'] = 'round';
                            }
                            break;
                        case visuals.lineStyle.solid:
                            {
                                style['stroke-dasharray'] = null;
                                style['stroke-linecap'] = null;
                            }
                            break;
                        case visuals.lineStyle.dashed:
                        default:
                            {
                                style['stroke-dasharray'] = '5, 5';
                                style['stroke-linecap'] = null;
                            }
                            break;
                    }
                    line.style(style);
                }
                var graphicsContext = options.graphicContext;
                var frontClassAndSelector = createClassAndSelector('reference-line-front');
                var frontReferenceLines = _.filter(options.referenceLines, (function (line) { return line.position === visuals.referenceLinePosition.front && line.show; }));
                var frontLines = graphicsContext.selectAll(frontClassAndSelector.selector).data(frontReferenceLines);
                frontLines.enter().append('line').classed(frontClassAndSelector.class, true);
                frontLines.each(setRefLineProperties);
                frontLines.exit().remove();
                var backClassAndSelector = createClassAndSelector('reference-line-back');
                var backReferenceLines = _.filter(options.referenceLines, (function (line) { return line.position !== visuals.referenceLinePosition.front && line.show; }));
                var backLines = graphicsContext.selectAll(backClassAndSelector.selector).data(backReferenceLines);
                backLines.enter().insert('line', ':first-child').classed(backClassAndSelector.class, true);
                backLines.each(setRefLineProperties);
                backLines.exit().remove();
            }
            ReferenceLineHelper.render = render;
            function readDataView(objects, defaultColor, objectName, axis, metaDataColumn) {
                if (!objects)
                    return [];
                var referenceLines = [];
                for (var id in objects) {
                    var referenceLineObject = objects[id];
                    var show = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.show, false);
                    var displayName = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.displayName, undefined);
                    var value = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.value, 0);
                    var lineColor = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.lineColor, { solid: { color: defaultColor } });
                    var transparency = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.transparency, 50);
                    var style = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.style, visuals.lineStyle.dashed);
                    var position = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.position, visuals.referenceLinePosition.front);
                    var dataLabelShow = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelShow, false);
                    var dataLabelColor = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelColor, { solid: { color: defaultColor } });
                    var dataLabelText = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelText, visuals.labelText.value);
                    var dataLabelHorizontalPosition = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelHorizontalPosition, visuals.referenceLineDataLabelHorizontalPosition.left);
                    var dataLabelVerticalPosition = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelVerticalPosition, visuals.referenceLineDataLabelVerticalPosition.above);
                    var decimalPoints = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelDecimalPoints, undefined);
                    var dataLabelDecimalPoints = decimalPoints < 0 ? undefined : decimalPoints;
                    var dataLabelDisplayUnits = powerbi.DataViewObject.getValue(referenceLineObject, ReferenceLineProps.dataLabelDisplayUnits, 0);
                    var selector = { id: id, metadata: metaDataColumn };
                    referenceLines.push({
                        type: objectName,
                        selector: selector,
                        show: show,
                        displayName: displayName,
                        value: value,
                        color: lineColor,
                        transparency: transparency,
                        style: style,
                        position: position,
                        dataLabelProperties: {
                            show: dataLabelShow,
                            color: dataLabelColor,
                            text: dataLabelText,
                            horizontalPosition: dataLabelHorizontalPosition,
                            verticalPosition: dataLabelVerticalPosition,
                            decimalPoints: dataLabelDecimalPoints,
                            displayUnits: dataLabelDisplayUnits
                        },
                        axis: axis
                    });
                }
                return referenceLines;
            }
            ReferenceLineHelper.readDataView = readDataView;
            function createLabelDataPoint(options) {
                if (_.isEmpty(options.referenceLines)) {
                    return [];
                }
                var dataLabels = [];
                var offsetRefLine = 5;
                var axes = options.axes;
                var viewport = options.viewport;
                var xScale = axes.x.scale;
                var yScale = axes.y1.scale;
                for (var _i = 0, _a = options.referenceLines; _i < _a.length; _i++) {
                    var referenceLine = _a[_i];
                    if (!referenceLine.show || !_.isNumber(referenceLine.value) || !referenceLine.dataLabelProperties.show) {
                        continue;
                    }
                    // Format the reference line data label text according to the matching axis formatter
                    // When options is null default formatter is used either boolean, numeric, or text
                    var isHorizontal_1 = ReferenceLineHelper.isHorizontal(referenceLine, axes);
                    var axisFormatter = isHorizontal_1 ? axes.y1.formatter : axes.x.formatter;
                    var formatterForReferenceLineDataLabel = axisFormatter;
                    var refValue = referenceLine.value;
                    var dataLabelProperties = referenceLine.dataLabelProperties;
                    if (axisFormatter.options != null) {
                        var formatterOptions = powerbi.Prototype.inherit(axisFormatter.options);
                        formatterOptions.precision = dataLabelProperties.decimalPoints;
                        formatterOptions.value = dataLabelProperties.displayUnits;
                        formatterForReferenceLineDataLabel = visuals.valueFormatter.create(formatterOptions);
                    }
                    var text = '';
                    switch (dataLabelProperties.text) {
                        case visuals.labelText.name:
                            text = referenceLine.displayName;
                            break;
                        case visuals.labelText.nameAndValue:
                            {
                                if (!_.isNumber(refValue))
                                    continue;
                                var formatString = options.hostServices.getLocalizedString("Visual_LabelText_Name_Value_Format");
                                text = jsCommon.StringExtensions.format(formatString, referenceLine.displayName, visuals.LabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue)));
                            }
                            break;
                        case visuals.labelText.value:
                        default:
                            {
                                if (!_.isNumber(refValue))
                                    continue;
                                text = visuals.LabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue));
                            }
                    }
                    var fontProperties = visuals.FontProperties.inherit(visuals.LabelUtils.defaultFontProperties, { size: visuals.Units.FontSize.createFromPt(9) });
                    // Calculate text size
                    var properties = visuals.FontProperties.toTextProperties(fontProperties, text);
                    // Get the height and with of the text element that will be created in order to place it correctly
                    var rectWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var rectHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    var dataLabelX = void 0;
                    var dataLabelY = void 0;
                    var x1 = isHorizontal_1 ? 0 : xScale(refValue);
                    var y1 = isHorizontal_1 ? yScale(refValue) : 0;
                    var x2 = isHorizontal_1 ? viewport.width : xScale(refValue);
                    var y2 = isHorizontal_1 ? yScale(refValue) : viewport.height;
                    var validPositions = [1 /* Above */];
                    if (isHorizontal_1) {
                        // Horizontal line. y1 = y2
                        dataLabelX = (dataLabelProperties.horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? x1 + offsetRefLine : x2 - (rectWidth / 2) - offsetRefLine;
                        dataLabelY = y1;
                        validPositions = (dataLabelProperties.verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? [1 /* Above */] : [2 /* Below */];
                    }
                    else {
                        // Vertical line. x1 = x2 
                        dataLabelX = x1;
                        dataLabelY = (dataLabelProperties.verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? y1 + (rectHeight / 2) + offsetRefLine : y2 - (rectHeight / 2) - offsetRefLine;
                        validPositions = (dataLabelProperties.horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? [4 /* Left */] : [8 /* Right */];
                    }
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                    var parentShape = void 0;
                    parentShape = {
                        point: {
                            x: dataLabelX,
                            y: dataLabelY,
                        },
                        radius: 0,
                        validPositions: validPositions,
                    };
                    dataLabels.push({
                        isPreferred: true,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight,
                        },
                        outsideFill: dataLabelProperties.color.solid.color,
                        insideFill: null,
                        parentShape: parentShape,
                        parentType: 0 /* Point */,
                        fontProperties: fontProperties,
                        identity: null,
                        secondRowText: null,
                        key: JSON.stringify({
                            type: referenceLine.type,
                            id: referenceLine.selector.id,
                        }),
                    });
                }
                return dataLabels;
            }
            ReferenceLineHelper.createLabelDataPoint = createLabelDataPoint;
            function extractReferenceLineValue(referenceLineProperties) {
                var referenceLineValue = null;
                if (referenceLineProperties && powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineProps.show, false))
                    referenceLineValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineProps.value, null);
                return referenceLineValue;
            }
            ReferenceLineHelper.extractReferenceLineValue = extractReferenceLineValue;
            function gatherDomainExtents(referenceLines, xs, ys) {
                if (!_.isEmpty(referenceLines)) {
                    for (var _i = 0, referenceLines_2 = referenceLines; _i < referenceLines_2.length; _i++) {
                        var referenceLine = referenceLines_2[_i];
                        if (!referenceLine.show)
                            continue;
                        var value = referenceLine.value;
                        if (referenceLine.axis === 0 /* X */)
                            xs.push(value);
                        else
                            ys.push(value);
                    }
                }
            }
            ReferenceLineHelper.gatherDomainExtents = gatherDomainExtents;
        })(ReferenceLineHelper = visuals.ReferenceLineHelper || (visuals.ReferenceLineHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TextSizeDefaults = jsCommon.TextSizeDefaults;
        visuals.ResponsiveCartesianFontBreakpoints = {
            size: [
                { breakpoint: 240, maxSizePt: 9 },
                { breakpoint: 320, maxSizePt: 12 },
                { breakpoint: 460, maxSizePt: 16 },
                { breakpoint: 540, maxSizePt: 24 },
            ],
        };
        var ResponsiveCartesianFontHelper = /** @class */ (function () {
            function ResponsiveCartesianFontHelper() {
                this.lastViewportSeen = undefined;
                this.lastResolvedFontSizePt = undefined;
            }
            ResponsiveCartesianFontHelper.prototype.applyFontSizesChanges = function (viewport, originalFontProperties) {
                var maxFontSizePt = this.resolveMaxFontSizePtForViewport(viewport);
                if (maxFontSizePt >= originalFontProperties.size.pt) {
                    return originalFontProperties;
                }
                return this.copyWithNewFontSize(originalFontProperties, maxFontSizePt);
            };
            ResponsiveCartesianFontHelper.prototype.resolveMaxFontSizePtForViewport = function (viewport) {
                if (this.lastViewportSeen === viewport) {
                    return this.lastResolvedFontSizePt;
                }
                var maxFontSizePt = TextSizeDefaults.TextSizeMax;
                for (var _i = 0, _a = visuals.ResponsiveCartesianFontBreakpoints.size; _i < _a.length; _i++) {
                    var fontSizeBreakpoint = _a[_i];
                    if (viewport.height < fontSizeBreakpoint.breakpoint || viewport.width < fontSizeBreakpoint.breakpoint) {
                        maxFontSizePt = fontSizeBreakpoint.maxSizePt;
                        break; // once found, no need to keep looking
                    }
                }
                this.lastViewportSeen = viewport;
                this.lastResolvedFontSizePt = maxFontSizePt;
                return maxFontSizePt;
            };
            ResponsiveCartesianFontHelper.prototype.copyWithNewFontSize = function (originalFontProperties, newFontSizePt) {
                var newFontSize = visuals.Units.FontSize.createFromPt(newFontSizePt);
                return visuals.FontProperties.inherit(originalFontProperties, { size: newFontSize });
            };
            return ResponsiveCartesianFontHelper;
        }());
        visuals.ResponsiveCartesianFontHelper = ResponsiveCartesianFontHelper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
powerbi.define('PowerBIVisuals/visuals/common/ribbonChartUtils', (function (imports) {
    var CategoryLevelUtils = powerbi.visuals.CategoryLevelUtils;
    var columnRoleNames = powerbi.visuals.columnRoleNames;
    var converterHelper = powerbi.visuals.converterHelper;
    var DataViewObjects = powerbi.DataViewObjects;
    var valueFormatter = powerbi.visuals.valueFormatter;
    var defaultColorBands = true;
    var defaultShowBorder = false;
    var defaultSeriesGapRatio = 0;
    var defaultBandsTransparency = 30;
    var ribbonChartCurvature = 0.7;
    var ribbonChartFillColor = "#C8C8C8";
    var ribbonChartStrokeColor = "#777777";
    var ribbonChartStrokeWidth = 1;
    function getRibbonOptionsFromDataviewObjects(dataViewMetadata, columnChartProps) {
        var colorBands = defaultColorBands;
        var showBorder = defaultShowBorder;
        var seriesGapRatio = defaultSeriesGapRatio;
        var bandsTransparency = defaultBandsTransparency;
        if (dataViewMetadata && dataViewMetadata.objects) {
            var objects = dataViewMetadata.objects;
            colorBands = DataViewObjects.getValue(objects, columnChartProps.ribbonChart.colorBands, defaultColorBands);
            showBorder = DataViewObjects.getValue(objects, columnChartProps.dataPoint.showBorder, defaultShowBorder);
            seriesGapRatio = DataViewObjects.getValue(objects, columnChartProps.series.seriesGapRatio, defaultSeriesGapRatio);
            bandsTransparency = DataViewObjects.getValue(objects, columnChartProps.ribbonChart.bandsTransparency, defaultBandsTransparency);
        }
        return { seriesGapRatio: seriesGapRatio, colorBands: colorBands, bandsTransparency: bandsTransparency, showBorder: showBorder };
    }
    function enumerateRibbonChart(enumeration, ribbonChartData, ribbonChart) {
        if (ribbonChartData && ribbonChart) {
            enumeration.pushInstance({
                objectName: 'ribbonChart',
                selector: null,
                properties: {
                    seriesGapRatio: ribbonChartData.ribbonOptions.seriesGapRatio,
                    colorBands: ribbonChartData.ribbonOptions.colorBands,
                    bandsTransparency: ribbonChartData.ribbonOptions.bandsTransparency,
                    showBorder: ribbonChartData.ribbonOptions.showBorder,
                },
                validValues: {
                    seriesGapRatio: {
                        numberRange: {
                            min: 0,
                            max: 20,
                        },
                    },
                    bandsTransparency: {
                        numberRange: {
                            min: 0,
                            max: 100,
                        },
                    },
                },
            });
        }
    }
    function createRibbonChartDataPoints(options) {
        /**
         * Initialized the heightArray(with Positive/Negative values) with empty arrays that will be filled with SeriesIndexHeightInfo of each index with specific categoryIndex and seriesIndex.
         * SeriesIndexHeightInfo contains both the real seriesIndex and its height.
         * Noteworthy, real seriesIndex stored in SeriesIndexHeightInfo might be different from seriesIndex since some series might not appear in all categoryIndex (has value 0).
         */
        var heightMatrixPositive = [];
        var heightMatrixNegative = [];
        for (var categoryIndex = 0, len = options.categoryCount; categoryIndex < len; categoryIndex++) {
            /**
             * Keep two height arrays because since it is more understandable when we stack the positive values up and the negative values down in the column chart.
             * Also by this way, we could sort the values in opposite order, which is consistent with the opposite direction of stacking positive (up) and negative values (down).
             */
            heightMatrixPositive[categoryIndex] = [];
            heightMatrixNegative[categoryIndex] = [];
        }
        /**
         * Fill the heightMatrixPositive and heightMatrixNegative with SeriesIndexHeightInfo of specific seriesIndex and categoryIndex.
         * Noteworthy, the outer loop is over seriesIndex and inner loop is over categoryIndex, but the heightMatrixPositive's primary index is categoryIndex and secondary index is seriesIndex.
         * So this nested loops are constructing an inverted lists of data from original seriesIndex-based structure to categoryIndex-based structure.
         */
        var maxHeight = 0;
        for (var seriesIndex = 0, len = options.columnSeries.length; seriesIndex < len; seriesIndex++) {
            var series = options.columnSeries[seriesIndex].data;
            for (var dataPointIndex = 0, len_1 = series.length; dataPointIndex < len_1; dataPointIndex++) {
                var dataPoint = series[dataPointIndex];
                var seriesIndexHeightInfo = {
                    seriesIndex: seriesIndex,
                    height: dataPoint.value,
                    dataToChange: dataPoint,
                    dataToChangeHighlight: options.hasHighlights ? series[dataPointIndex + 1] : undefined,
                };
                var categoryIndex = dataPoint.categoryIndex;
                if (seriesIndexHeightInfo.height >= 0)
                    heightMatrixPositive[categoryIndex].push(seriesIndexHeightInfo);
                else
                    heightMatrixNegative[categoryIndex].push(seriesIndexHeightInfo);
                if (options.hasHighlights)
                    dataPointIndex++;
                if (dataPoint.valueAbsolute > maxHeight)
                    maxHeight = dataPoint.valueAbsolute;
            }
        }
        /**
         * Based on the sorted categoryIndex-based heightMatrixPositive, loop over each category and recalculate the position of each ColumnChartDataPoint.
         * Since the heightMatrixPositive is sorted by height, the position could be calculated by cumulating the height from 0.
         * Since the cumulation should be spreaded up and down from zero axis, we need to keep two totalCategoryHeight and two similar loops over the two height arrays.
         */
        var gapWidth = maxHeight * options.ribbonOptions.seriesGapRatio / 100;
        for (var categoryIndex = 0; categoryIndex < options.categoryCount; categoryIndex++) {
            var startRank = heightMatrixPositive[categoryIndex].length;
            var RankDataPointsOptions = {
                isPositive: true,
                heightMatrix: heightMatrixPositive,
                categoryIndex: categoryIndex,
                hasHighlights: options.hasHighlights,
                startRank: startRank,
                gapWidth: gapWidth,
            };
            rankDataPoints(RankDataPointsOptions);
            RankDataPointsOptions = {
                isPositive: false,
                heightMatrix: heightMatrixNegative,
                categoryIndex: categoryIndex,
                hasHighlights: options.hasHighlights,
                startRank: startRank,
                gapWidth: gapWidth,
            };
            rankDataPoints(RankDataPointsOptions);
        }
        /**
         * Pass the two ColumnChartDataPoint connected by the banding as RibbonChartDataPoint, will calculate the 4 corners of the banding as RibbonChartLayout in getLayout method.
         * Seperating the data point creation and corner points calculation is because the calculations of corner points of column chart and bar chart
         * are slightly different.
         */
        options.ribbonChartDataPoints = [];
        var columnSeries = options.columnSeries;
        for (var _i = 0, columnSeries_1 = columnSeries; _i < columnSeries_1.length; _i++) {
            var series = columnSeries_1[_i];
            var seriesData = series.data;
            if (options.hasHighlights) {
                seriesData = _.filter(seriesData, (function (columnChartDataPoint) { return columnChartDataPoint.highlight; }));
            }
            for (var categoryIndex = 0, numCategories = seriesData.length; categoryIndex < (numCategories - 1); categoryIndex++) {
                var d1 = seriesData[categoryIndex];
                var d2 = seriesData[categoryIndex + 1];
                if (!d1.value || !d2.value || d1.categoryIndex !== d2.categoryIndex - 1)
                    continue;
                // Add tooltips info for each ribbonChart data point.
                var tooltipInfo = [];
                /**
                 * There are two scenarios to draw rank change bandings: dynamic series (eg. Axis: Year, Legend: Quarter, Value: Sales)
                 * and static series (eg. Axis: Year, Value: Complete Volume & Category Volume).
                 */
                var valueColumnMetadata = options.reader.columns.getValueMetadataColumn(columnRoleNames.y, series.index);
                var startPointDisplayName = void 0;
                var endPointDisplayName = void 0;
                var categoryLevelsD1 = CategoryLevelUtils.getCategoryLevels(options.dataView.categorical.categories, d1.categoryIndex, options.formatStringProp);
                var categoryLevelsD2 = CategoryLevelUtils.getCategoryLevels(options.dataView.categorical.categories, d2.categoryIndex, options.formatStringProp);
                var concatenatedCategoryLevelD1 = CategoryLevelUtils.concatenateCategoryLevels(categoryLevelsD1);
                var concatenatedCategoryLevelD2 = CategoryLevelUtils.concatenateCategoryLevels(categoryLevelsD2);
                var categoryDisplayNameD1 = concatenatedCategoryLevelD1.value;
                var categoryDisplayNameD2 = concatenatedCategoryLevelD2.value;
                if (options.hasDynamicSeries) {
                    /**
                     * Dynamic series: we would like two tooltips about the start and ending column chart datapoints the bands connect.
                     * Eg. 2009 Q1 Sales $: $100,000, 2010 Q1 Sales $: 200,000.
                     * 2009 is categoryValue, Q1 is series' display name, "Sales $" and "$100,000" are consistent with the starting column chart datapoint's tooltip display name and value.
                     */
                    startPointDisplayName = categoryDisplayNameD1 + " " + series.displayName + " " + valueColumnMetadata.displayName;
                    endPointDisplayName = categoryDisplayNameD2 + " " + series.displayName + " " + valueColumnMetadata.displayName;
                }
                else {
                    /**
                     * Static series: we would like two tooltips about the start and ending column chart datapoints the bands connect.
                     * Eg. 2009 Category Volume: 100,000, 2010 Category Volume: 200,000. (Or 2009 Complete Volume: 100,000, 2010 Complete Volume: 200,000)
                     * Noteworthy, it is slightly different than the dynamic series.
                     * 2009 is categoryValue, "Category Volume" is series'display name and "100,000" is consistent with the starting column chart datapoint's tooltip value.
                     */
                    startPointDisplayName = categoryDisplayNameD1 + " " + series.displayName;
                    endPointDisplayName = categoryDisplayNameD2 + " " + series.displayName;
                }
                tooltipInfo.push({
                    displayName: startPointDisplayName,
                    value: converterHelper.formatFromMetadataColumn(d1.value, valueColumnMetadata, options.formatStringProp, /*suppressTypeFallback*/ false)
                });
                tooltipInfo.push({
                    displayName: endPointDisplayName,
                    value: converterHelper.formatFromMetadataColumn(d2.value, valueColumnMetadata, options.formatStringProp, /*suppressTypeFallback*/ false)
                });
                // Calculate the value difference of the bands: endpoint.value - startpoint.value
                var valueDiff = d2.value - d1.value;
                var formattedValueDiff = converterHelper.formatFromMetadataColumn(valueDiff, valueColumnMetadata, options.formatStringProp, /*suppressTypeFallback*/ false);
                var formatString = valueFormatter.getLocalizedString('Percentage');
                var percentValue = valueDiff / d1.value;
                var formattedPercentChange = valueFormatter.format(percentValue, formatString);
                tooltipInfo.push({
                    displayName: valueColumnMetadata.displayName + " " + options.hostServices.getLocalizedString('RibbonChart_TooltipChange'),
                    value: formattedValueDiff + " (" + formattedPercentChange + ")",
                });
                /**
                 * Add tooltip about ranks of the starting point and ending point. Eg. 2005 Q2 rank 1.
                 * 2005 is one of the column chart datapoint's categoryValue, Q2 is the series' display name, 1 is from column chart datapoint's rank field.
                 */
                tooltipInfo.push({
                    displayName: categoryDisplayNameD1 + " " + series.displayName + " " + options.hostServices.getLocalizedString('RibbonChart_TooltipRank'),
                    value: "" + (d1.rank)
                });
                tooltipInfo.push({
                    displayName: categoryDisplayNameD2 + " " + series.displayName + " " + options.hostServices.getLocalizedString('RibbonChart_TooltipRank'),
                    value: "" + (d2.rank)
                });
                /**
                 * Calculate the rank difference of starting and ending points. Eg. from rank 1 to rank 2 makes "rank change 1", from rank 2 to rank 1 makes "rank change 1"
                 * Using ASCII character  and  because rank change is sometimes confusing in words. Eg. rank increases by 1 is not clearly meaning rank goes from 1 to 2 or 2 to 1.
                 * Will not show the rank change if the rank remains the same.
                 */
                var rankDiff = d2.rank - d1.rank;
                if (rankDiff !== 0) {
                    var formattedRankDiff = rankDiff > 0 ? "\u25BC" + rankDiff : "\u25B2" + -rankDiff;
                    tooltipInfo.push({
                        displayName: options.hostServices.getLocalizedString('RibbonChart_TooltipRank') + " " + options.hostServices.getLocalizedString('RibbonChart_TooltipChange'),
                        value: formattedRankDiff
                    });
                }
                var newBanding = { d1: d1, d2: d2, tooltipInfo: tooltipInfo };
                options.ribbonChartDataPoints.push(newBanding);
            }
        }
        return options.ribbonChartDataPoints;
    }
    function rankDataPoints(options) {
        var totalCategoryHeight = 0;
        var heightArray = options.heightMatrix[options.categoryIndex];
        heightArray = _.sortBy(heightArray, (function (seriesIndexHeightInfo) { return options.isPositive ? seriesIndexHeightInfo.height : -seriesIndexHeightInfo.height; }));
        var gapWidth = (options.gapWidth && heightArray.length > 0) ? options.gapWidth : 0;
        for (var seriesIndex = 0, len = heightArray.length; seriesIndex < len; seriesIndex++) {
            var seriesIndexHeightInfo = heightArray[seriesIndex];
            var data = seriesIndexHeightInfo.dataToChange;
            // If the datapoints have highlights, change the highlighted datapoints accordingly
            if (options.hasHighlights) {
                var dataHighlight = seriesIndexHeightInfo.dataToChangeHighlight;
                if (options.isPositive)
                    dataHighlight.position = totalCategoryHeight + dataHighlight.value;
                else
                    // Noteworthy, this is different from positive highlight values, since when stacking negative values, the highlighted area is at the top of its parent column while stacking positvie values, it is at the bottom.
                    dataHighlight.position = totalCategoryHeight;
            }
            // Accumulate the heights and ensure only accumulating un-highlighted heights, since highlighted data points appear twice in the ColumnChartDataPoint array (one with highlight as true and one with false).
            var height = seriesIndexHeightInfo.height;
            if (options.isPositive) {
                totalCategoryHeight = totalCategoryHeight + height;
                data.position = totalCategoryHeight;
                totalCategoryHeight += (!data.value || data.value === 0) ? 0 : gapWidth;
                data.rank = (heightArray.length - seriesIndex);
            }
            else {
                // Noteworthy, this is different from positive values. Since the direction of stacking is opposite, we need to reverse these two steps: assign the position first and then update the cumulative height.
                data.position = totalCategoryHeight;
                totalCategoryHeight = totalCategoryHeight + height;
                totalCategoryHeight -= gapWidth;
                data.rank = (options.startRank + seriesIndex + 1);
            }
            if (options.hasHighlights)
                seriesIndexHeightInfo.dataToChangeHighlight.rank = data.rank;
        }
    }
    function getRibbonChartAreaLayout(layout, ribbonChartDataPoints, isColumn) {
        // Based on data.ribbonChartDataPoints generated from the converter, generate the ribbonChartAreaLayout by calculating the 4 corners of the curved banding area.
        var ribbonChartAreaLayout = [];
        for (var i = 0, len = ribbonChartDataPoints.length; i < len; i++) {
            // Calculate the x, y, width, height of d1 and d2 (the two ColumnChartDataPoint we want to connect by bands) in the same way as getLayout function above.
            var ribbonChartDataPoint = ribbonChartDataPoints[i];
            var d1 = ribbonChartDataPoint.d1;
            var d2 = ribbonChartDataPoint.d2;
            var shapeLayout = layout.shapeLayout;
            var x1 = shapeLayout.x(d1);
            var y1 = shapeLayout.y(d1);
            var width1 = shapeLayout.width(d1);
            var height1 = shapeLayout.height(d1);
            // Skip the data points that have zero values
            if (width1 === 0) {
                i--;
                continue;
            }
            var x2 = shapeLayout.x(d2);
            var y2 = shapeLayout.y(d2);
            var width2 = shapeLayout.width(d2);
            var height2 = shapeLayout.height(d2);
            // Calculate the 4 corners coordinates of the banding area based on the x, y, width, height of d1 and d2 (the two ColumnChartDataPoint we want to connect by bands).
            var bottomLeft = void 0;
            var topLeft = void 0;
            var bottomRight = void 0;
            var topRight = void 0;
            if (isColumn) {
                bottomLeft = { x: x1 + width1, y: y1 };
                topLeft = { x: x1 + width1, y: y1 + height1 };
                bottomRight = { x: x2, y: y2 };
                topRight = { x: x2, y: y2 + height2 };
            }
            else {
                bottomLeft = { x: x1, y: y1 };
                topLeft = { x: x1 + width1, y: y1 };
                bottomRight = { x: x2, y: y2 + height2 };
                topRight = { x: x2 + width2, y: y2 + height2 };
            }
            // Construct the RibbonChartArea based on the 4 corners and push it to the ribbonChartAreaLayout data structure which is an array of RibbonChartArea.
            var rankchangeBandingArea = {
                bottomLeft: bottomLeft,
                topLeft: topLeft,
                bottomRight: bottomRight,
                topRight: topRight,
                tooltipInfo: ribbonChartDataPoint.tooltipInfo,
                color: d1.color,
            };
            ribbonChartAreaLayout.push(rankchangeBandingArea);
        }
        return ribbonChartAreaLayout;
    }
    function drawRibbonChartAreaSmooth(options) {
        // Get the ribbonChartLayer and create one if the layer is empty.
        var layer = options.graphicsContext.select(options.ribbonChartGroupSelector.selector);
        if (layer.empty())
            layer = options.graphicsContext.append('g').classed(options.ribbonChartGroupSelector.class, true);
        // Create the d3 path based on the layout data generated.
        var shapeSelection = layer.selectAll(options.ribbonChartAreaSelector.selector);
        var shapes = shapeSelection.data(options.layout);
        shapes
            .enter()
            .append('path')
            .classed(options.ribbonChartAreaSelector.class, true);
        var bandsOpacity = (100 - options.bandsTransparency) / 100;
        if (options.colorBands) {
            // Generate gradient styles of specific opacity and color.
            shapes
                .style('fill', (function (ribbonChartArea) { return ribbonChartArea.color; }))
                .style('fill-opacity', bandsOpacity);
            if (options.showBorder)
                shapes.style("stroke", (function (ribbonChartArea) { return ribbonChartArea.color; }))
                    .style("stroke-width", ribbonChartStrokeWidth);
            else
                shapes.style("stroke-width", 0);
        }
        else {
            // Style the grey bands with stroke and specific opacity.
            shapes
                .style('fill', ribbonChartFillColor)
                .style('fill-opacity', bandsOpacity);
            if (options.showBorder)
                shapes.style("stroke", ribbonChartStrokeColor)
                    .style("stroke-width", ribbonChartStrokeWidth);
            else
                shapes.style("stroke-width", 0);
        }
        shapes
            .attr('d', (function (d) {
            // Create interpolater between bottomLeft and bottomRight corner of the banding area (two interpolators for x, y cordinates respectively)
            var xi = d3.interpolateNumber(d.bottomLeft.x, d.bottomRight.x);
            var yi = d3.interpolateNumber(d.bottomLeft.y, d.bottomRight.y);
            // Path begins from (moves to) bottomLeft corner firstly.
            var path = "M" + d.bottomLeft.x + "," + d.bottomLeft.y;
            /**
             * Construct the curved line connecting bottomLeft and bottomRight corner by using "C" and the interpolator feature of d3.
             * Noteworthy, the path is slightly different for columnChart and barChart. Since we want the banding look consistent in column and bar charts,
             * we need to interploating x for column charts and interpolating y for bar charts, which is intuitively symmetrical and consistent with how we draw column/bar charts.
             */
            if (options.isColumn)
                path += "C" + xi(ribbonChartCurvature) + "," + d.bottomLeft.y + " " + xi(1 - ribbonChartCurvature) + "," + d.bottomRight.y + " " + d.bottomRight.x + "," + d.bottomRight.y;
            else
                path += "C" + d.bottomLeft.x + "," + yi(ribbonChartCurvature) + " " + d.bottomRight.x + "," + yi(1 - ribbonChartCurvature) + " " + d.bottomRight.x + "," + d.bottomRight.y;
            // Draw straight line from bottomRight corner to topRight corner.
            path += "L" + d.topRight.x + "," + d.topRight.y;
            // Similar to above, draw another curved line connecting topRight and topLeft corner.
            xi = d3.interpolateNumber(d.topRight.x, d.topLeft.x);
            yi = d3.interpolateNumber(d.topRight.y, d.topLeft.y);
            if (options.isColumn)
                path += "C" + xi(ribbonChartCurvature) + "," + d.topRight.y + " " + xi(1 - ribbonChartCurvature) + "," + d.topLeft.y + " " + d.topLeft.x + "," + d.topLeft.y;
            else
                path += "C" + d.topRight.x + "," + yi(ribbonChartCurvature) + " " + d.topLeft.x + "," + yi(1 - ribbonChartCurvature) + " " + d.topLeft.x + "," + d.topLeft.y;
            // Similar to above, draw straight line from topLeft corner to bottomLeft corner. This finishes the 4 sides of the area and the whole path.
            path += "L" + d.bottomLeft.x + "," + d.bottomLeft.y + "Z";
            return path;
        }));
        shapes.exit().remove();
        return shapes;
    }
    return {
        getRibbonOptionsFromDataviewObjects: function (dataViewMetadata, columnChartProps) {
            return getRibbonOptionsFromDataviewObjects(dataViewMetadata, columnChartProps);
        },
        enumerateRibbonChart: function (enumeration, ribbonChartData, ribbonChart) {
            return enumerateRibbonChart(enumeration, ribbonChartData, ribbonChart);
        },
        createRibbonChartDataPoints: function (options) {
            return createRibbonChartDataPoints(options);
        },
        getRibbonChartAreaLayout: function (layout, ribbonChartDataPoints, isColumn) {
            return getRibbonChartAreaLayout(layout, ribbonChartDataPoints, isColumn);
        },
        drawRibbonChartAreaSmooth: function (options) {
            return drawRibbonChartAreaSmooth(options);
        },
    };
}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var utility;
        (function (utility) {
            var SelectionManager = /** @class */ (function () {
                function SelectionManager(options) {
                    this.dataPointObjectName = 'dataPoint';
                    this.hostServices = options.hostServices;
                    this.selectedIds = [];
                }
                SelectionManager.prototype.select = function (selectionId, multiSelect) {
                    if (multiSelect === void 0) { multiSelect = false; }
                    var deferred = $.Deferred();
                    if (this.hostServices.shouldRetainSelection()) {
                        this.sendSelectionToHost([selectionId]);
                    }
                    else {
                        this.selectInternal(selectionId, multiSelect);
                        this.sendSelectionToHost(this.selectedIds);
                    }
                    deferred.resolve(this.selectedIds);
                    return deferred;
                };
                SelectionManager.prototype.showContextMenu = function (selectionId, position) {
                    var deferred = $.Deferred();
                    position = position || visuals.InteractivityUtils.getPositionOfLastInputEvent();
                    this.sendContextMenuToHost(selectionId, position);
                    deferred.resolve();
                    return deferred;
                };
                SelectionManager.prototype.hasSelection = function () {
                    return this.selectedIds.length > 0;
                };
                SelectionManager.prototype.clear = function () {
                    var deferred = $.Deferred();
                    this.selectedIds = [];
                    this.sendSelectionToHost([]);
                    deferred.resolve();
                    return deferred;
                };
                SelectionManager.prototype.getSelectionIds = function () {
                    return this.selectedIds;
                };
                SelectionManager.prototype.sendSelectionToHost = function (ids) {
                    var dataPointObjectName = this.dataPointObjectName;
                    var selectArgs = {
                        visualObjects: _.chain(ids)
                            .filter((function (value) { return value.hasIdentity(); }))
                            .map((function (value) {
                            return { objectName: dataPointObjectName, selectorsByColumn: value.getSelectorsByColumn() };
                        }))
                            .value(),
                        selectors: undefined,
                    };
                    var shouldInsertSelectors = false;
                    if (!_.isEmpty(ids)) {
                        shouldInsertSelectors = ids[0].getSelector() && !ids[0].getSelectorsByColumn();
                    }
                    if (shouldInsertSelectors) {
                        selectArgs.selectors = _.chain(ids)
                            .filter((function (value) { return value.hasIdentity(); }))
                            .map((function (value) { return value.getSelector(); }))
                            .value();
                    }
                    this.hostServices.onSelect(selectArgs);
                };
                SelectionManager.prototype.sendContextMenuToHost = function (selectionId, position) {
                    var selectors = this.getSelectorsByColumn([selectionId]);
                    if (_.isEmpty(selectors))
                        return;
                    var args = {
                        data: selectors,
                        position: position
                    };
                    this.hostServices.onContextMenu(args);
                };
                SelectionManager.prototype.getSelectorsByColumn = function (selectionIds) {
                    return _(selectionIds)
                        .filter((function (value) { return value.hasIdentity; }))
                        .map((function (value) { return value.getSelectorsByColumn(); }))
                        .compact()
                        .value();
                };
                SelectionManager.prototype.selectInternal = function (selectionId, multiSelect) {
                    if (SelectionManager.containsSelection(this.selectedIds, selectionId)) {
                        this.selectedIds = multiSelect
                            ? this.selectedIds.filter((function (d) { return !powerbi.data.Selector.equals(d.getSelector(), selectionId.getSelector()); }))
                            : this.selectedIds.length > 1
                                ? [selectionId] : [];
                    }
                    else {
                        if (multiSelect)
                            this.selectedIds.push(selectionId);
                        else
                            this.selectedIds = [selectionId];
                    }
                };
                SelectionManager.containsSelection = function (list, id) {
                    return list.some((function (d) { return powerbi.data.Selector.equals(d.getSelector(), id.getSelector()); }));
                };
                return SelectionManager;
            }());
            utility.SelectionManager = SelectionManager;
        })(utility = visuals.utility || (visuals.utility = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var shapeUtil;
        (function (shapeUtil) {
            shapeUtil.MinBubbleMultiplier = 1;
            shapeUtil.MaxBubbleMultiplier = 3;
            function getBubbleSizeMultiplier(value) {
                return value != null ? shapeUtil.MinBubbleMultiplier + (value / 100) * shapeUtil.MaxBubbleMultiplier : shapeUtil.MinBubbleMultiplier;
            }
            shapeUtil.getBubbleSizeMultiplier = getBubbleSizeMultiplier;
            function invertBubbleSizeMultiplier(multiplier) {
                return Math.round(((multiplier - shapeUtil.MinBubbleMultiplier) / shapeUtil.MaxBubbleMultiplier) * 100).toString();
            }
            shapeUtil.invertBubbleSizeMultiplier = invertBubbleSizeMultiplier;
        })(shapeUtil = visuals.shapeUtil || (visuals.shapeUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.SlicerResponsiveBreakpoints = {
            rangeSlicer: {
                // Icon breakpoints will break only when the viewport is under the mentioned height AND width.
                // When one of the dimensions is not determined - it holds `Infinity` value so it will always returns true.
                iconBreakpoints: [
                    { height: Infinity, width: 75 },
                    { height: 35, width: Infinity },
                    { height: 65, width: 168 },
                ],
                hideHeaderHeight: 88,
            },
            horizontalSlicer: {
                // See comment above
                iconBreakpoints: [
                    { height: Infinity, width: 75 },
                    { height: 15, width: Infinity },
                ],
                hideHeaderHeight: 48,
                // See font breakpoints comment below.
                fontSize: [
                    { breakpoint: 360, applyWidth: true, applyHeight: false, maxFontSizePt: 9 },
                    { breakpoint: 540, applyWidth: true, applyHeight: false, maxFontSizePt: 16 },
                ]
            },
            slicerHeader: {
                // Font breakpoints are sorted ascending by the 'breakpoint' key, its value should be taken to comparison with width and/or height 
                // conditioned on the 'applyWidth', 'applyHeight' keys. e.g. { breakpoint: 320, applyWidth: true, applyHeight: false, maxFontSizePt: 24 }
                // since 'applyWidth' is true, if width < 320 the maximal font size is 24pt. Since 'applyHeight' is false we are not testing against it.
                fontSize: [
                    { breakpoint: 140, applyWidth: true, applyHeight: true, maxFontSizePt: 9 },
                    { breakpoint: 220, applyWidth: true, applyHeight: true, maxFontSizePt: 16 },
                    { breakpoint: 320, applyWidth: true, applyHeight: false, maxFontSizePt: 24 },
                    { breakpoint: 460, applyWidth: true, applyHeight: false, maxFontSizePt: 32 },
                ],
            },
        };
        var SlicerHelper;
        (function (SlicerHelper) {
            SlicerHelper.NumericSlicerEnabled = false;
            SlicerHelper.SingleValueSlicer = false;
            /**
             * Fixes the widget popup element position. Required to do because we are applying custom scale which breaks layout.
             * Because we dont have event which notifies visual about scale change we need to do it on every open
             */
            function fixWidgetPosition(widget, boundElement, padding, scaleWidget, position) {
                if (padding === void 0) { padding = null; }
                if (scaleWidget === void 0) { scaleWidget = false; }
                if (position === void 0) { position = null; }
                if (!widget || !boundElement) {
                    return;
                }
                var top = "";
                var right = "";
                var bottom = "";
                var left = "";
                var transform = "";
                var elementScale = SlicerHelper.getScale(boundElement);
                var widgetElement = boundElement.get(0);
                var parent = widget.offsetParent();
                var scale = SlicerHelper.getScale(parent);
                // Apply scale first in order to properly calculate position.
                if (scaleWidget) {
                    widget.css({
                        "transform": 'scale(' + elementScale + ')',
                    });
                }
                var rect = widgetElement.getBoundingClientRect();
                if (position == null) {
                    position = getWidgetPosition(rect);
                }
                if ((position & 1 /* bottom */) === 1 /* bottom */) {
                    var elementTop = rect.top + rect.height;
                    top = elementTop / scale;
                    transform = "top";
                }
                else {
                    var elementBottom = window.innerHeight - rect.top;
                    bottom = elementBottom / scale;
                    top = "auto";
                    transform = "bottom";
                }
                if ((position & 2 /* left */) === 2 /* left */) {
                    var elementLeft = rect.left;
                    left = elementLeft / scale;
                    if (SlicerHelper.isWidgetPositionExceedsBoundaries(widget, elementScale, left)) {
                        left = window.innerWidth - (widget.innerWidth() * elementScale);
                    }
                    transform = "left " + transform;
                }
                else {
                    var elementRight = window.innerWidth - rect.left - rect.width;
                    right = elementRight / scale;
                    left = "auto";
                    if (SlicerHelper.isWidgetPositionExceedsBoundaries(widget, elementScale, right)) {
                        right = window.innerWidth - (widget.innerWidth() * elementScale);
                    }
                    transform = "right " + transform;
                }
                var css = {
                    left: left,
                    top: top,
                    right: right,
                    bottom: bottom,
                    "transform-origin": transform
                };
                if (padding) {
                    if (css.top !== "auto") {
                        css.top += padding.top * elementScale;
                    }
                    else {
                        css.bottom += padding.top * elementScale;
                    }
                    if (css.left !== "auto") {
                        css.left += padding.left * elementScale;
                    }
                    else {
                        css.right += padding.left * elementScale;
                    }
                }
                widget.css(css);
            }
            SlicerHelper.fixWidgetPosition = fixWidgetPosition;
            function getScale(element) {
                if (!element) {
                    return 1;
                }
                var width = element.outerWidth();
                if (width === 0) {
                    return 1;
                }
                var scaledWidth = element.get(0).getBoundingClientRect().width;
                return scaledWidth / width;
            }
            SlicerHelper.getScale = getScale;
            // date-picker scaling should keep that it's width is smaller then the  screen width 
            // therefore it should never get pushed outside window bounderies after positioning fix
            function isWidgetPositionExceedsBoundaries(widget, elementScale, position) {
                return (widget.innerWidth() * elementScale) + position > window.innerWidth;
            }
            SlicerHelper.isWidgetPositionExceedsBoundaries = isWidgetPositionExceedsBoundaries;
            function getWidgetPosition(elementRect) {
                var position = 1 /* bottom */ | 2 /* left */;
                var availableHeight = window.innerHeight;
                var availableWidth = window.innerWidth;
                if ((availableHeight - elementRect.top) < availableHeight / 2) {
                    position &= ~1 /* bottom */;
                    position |= 0 /* top */;
                }
                if ((availableWidth - elementRect.left) < availableWidth / 2) {
                    position &= ~2 /* left */;
                    position |= 4 /* right */;
                }
                return position;
            }
        })(SlicerHelper = visuals.SlicerHelper || (visuals.SlicerHelper = {}));
        var SlicerViewModelAdapterUtils;
        (function (SlicerViewModelAdapterUtils) {
            // TODO: (t-urihai, 2017-09-11) move to responsiveCartesianFontHelpers.ts and merge logics
            function resolveMaxFontSizePtForViewport(viewport, fontSizeBreakpoints) {
                var maxFontSizePt = jsCommon.TextSizeDefaults.TextSizeMax;
                for (var _i = 0, fontSizeBreakpoints_1 = fontSizeBreakpoints; _i < fontSizeBreakpoints_1.length; _i++) {
                    var fontSizeBreakpoint = fontSizeBreakpoints_1[_i];
                    var hitWidthBreakpoint = (viewport.width < fontSizeBreakpoint.breakpoint) && fontSizeBreakpoint.applyWidth;
                    var hitHeightBreakpoint = (viewport.height < fontSizeBreakpoint.breakpoint) && fontSizeBreakpoint.applyHeight;
                    if (hitWidthBreakpoint || hitHeightBreakpoint) {
                        maxFontSizePt = fontSizeBreakpoint.maxFontSizePt;
                        break; // once found, no need to keep looking
                    }
                }
                return maxFontSizePt;
            }
            SlicerViewModelAdapterUtils.resolveMaxFontSizePtForViewport = resolveMaxFontSizePtForViewport;
        })(SlicerViewModelAdapterUtils = visuals.SlicerViewModelAdapterUtils || (visuals.SlicerViewModelAdapterUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
powerbi.define('Visuals/common/responsiveVisualUtil', (function (imports) {
    var ResponsiveVisibilityHelper = /** @class */ (function () {
        function ResponsiveVisibilityHelper(visualElement, iconClassName) {
            this.visualElement = visualElement;
            this.iconClassName = iconClassName;
            this.isVisualVisible = true;
        }
        ResponsiveVisibilityHelper.prototype.updateVisibility = function (options) {
            if (options.showIcon) {
                this.hideVisual();
                debug.assertValue(options.viewport, "viewport");
                this.renderResponsiveIcon(options.viewport);
            }
            else {
                this.removeResponsiveIcon();
                this.showVisual();
            }
        };
        ResponsiveVisibilityHelper.prototype.renderResponsiveIcon = function (viewport) {
            if (!this.responsiveIcon) {
                this.responsiveIcon = InJs.DomFactory.div().addClass(this.iconClassName).appendTo(this.visualElement);
            }
            this.responsiveIcon.css({
                'width': viewport.width,
                'height': viewport.height
            });
        };
        ResponsiveVisibilityHelper.prototype.removeResponsiveIcon = function () {
            if (this.responsiveIcon) {
                this.responsiveIcon.remove();
                this.responsiveIcon = undefined;
            }
        };
        ResponsiveVisibilityHelper.prototype.hideVisual = function () {
            if (this.isVisualVisible) {
                this.visualElement.children().hide();
                this.isVisualVisible = false;
            }
        };
        ResponsiveVisibilityHelper.prototype.showVisual = function () {
            if (!this.isVisualVisible) {
                this.visualElement.children().show();
                this.isVisualVisible = true;
            }
        };
        return ResponsiveVisibilityHelper;
    }());
    return {
        visibilityHelper: function (visualElement, iconClassName) {
            return new ResponsiveVisibilityHelper(visualElement, iconClassName);
        }
    };
}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in adding tooltips.
         */
        var tooltipUtils;
        (function (tooltipUtils) {
            function tooltipUpdate(selection, tooltips) {
                if (tooltips.length === 0)
                    return;
                debug.assert(selection.length === tooltips.length || selection[0].length === tooltips.length, 'data length should match dom element count');
                var titles = selection.selectAll('title');
                var titlesUpdate = titles.data((function (d, i) { return [tooltips[i]]; }));
                titlesUpdate.enter().append('title');
                titlesUpdate.exit().remove();
                titlesUpdate.text((function (d) { return d; }));
            }
            tooltipUtils.tooltipUpdate = tooltipUpdate;
        })(tooltipUtils = visuals.tooltipUtils || (visuals.tooltipUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in text manupilation.
         */
        var TextUtil;
        (function (TextUtil) {
            /**
             * Remove breaking spaces from given string and replace by none breaking space (&nbsp).
             */
            function removeBreakingSpaces(str) {
                return str.toString().replace(new RegExp(' ', 'g'), '&nbsp');
            }
            TextUtil.removeBreakingSpaces = removeBreakingSpaces;
            /**
             * Remove ellipses from a given string
             */
            function removeEllipses(str) {
                return str.replace(//g, '');
            }
            TextUtil.removeEllipses = removeEllipses;
            /**
            * Replace every whitespace (0x20) with Non-Breaking Space (0xA0)
             * @param {string} txt String to replace White spaces
             * @returns Text after replcing white spaces
             */
            function replaceSpaceWithNBSP(txt) {
                if (txt != null)
                    return txt.replace(/ /g, "\xA0");
            }
            TextUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;
            /**
             * Word break textContent of <text> SVG element into <tspan>s
             * Each tspan will be the height of a single line of text.
             * Different from powerbi.TextMeasurementService.wordBreak as the first <tspan> element is not shifted down.
             * @param textElement - the SVGTextElement containing the text to wrap
             * @param maxWidth - the maximum width available
             * @param maxHeight - the maximum height available (defaults to single line)
             * @param linePadding - (optional) padding to add to line height
             */
            function wordBreak(textElement, maxWidth, maxHeight, linePadding, preserveNewLines) {
                if (linePadding === void 0) { linePadding = 0; }
                if (preserveNewLines === void 0) { preserveNewLines = false; }
                debug.assertValue(textElement, 'textElement');
                var properties = powerbi.TextMeasurementService.getSvgMeasurementProperties(textElement);
                var height = powerbi.TextMeasurementService.estimateSvgTextHeight(properties) + linePadding;
                var maxNumLines = Math.max(1, Math.floor(maxHeight / height));
                var node = d3.select(textElement);
                // Store and clear text content
                var labelText = textElement.textContent;
                textElement.textContent = null;
                // Append a tspan for each word broken section
                var words = jsCommon.WordBreaker.splitByWidth(labelText, properties, powerbi.TextMeasurementService.measureSvgTextWidth, maxWidth, maxNumLines, /*truncator*/ null, /*splitLongWords*/ false, preserveNewLines);
                for (var i = 0, ilen = words.length; i < ilen; i++) {
                    properties.text = words[i];
                    node
                        .append('tspan')
                        .attr({
                        'x': 0,
                        'dy': i === 0 ? 0 : height,
                    })
                        .text(powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxWidth));
                }
            }
            TextUtil.wordBreak = wordBreak;
        })(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in text manupilation.
         */
        var TextboxUtil;
        (function (TextboxUtil) {
            TextboxUtil.loadQuillResources = true;
        })(TextboxUtil = visuals.TextboxUtil || (visuals.TextboxUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var GradientUtils;
        (function (GradientUtils) {
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var DefaultMidColor = "#ffffff";
            GradientUtils.DefaultNullColor = "#FF7F48";
            GradientUtils.DefaultNullStrategy = powerbi.NullStrategy.asZero;
            var DefaultColor = DefaultMidColor;
            var DataPointPropertyIdentifier = "dataPoint";
            var FillRulePropertyIdentifier = "fillRule";
            function getFillRuleDescriptor(objectDescs) {
                if (!objectDescs)
                    return;
                for (var objectName in objectDescs) {
                    var objectDesc = objectDescs[objectName];
                    for (var propertyName in objectDesc.properties) {
                        var propertyDesc = objectDesc.properties[propertyName];
                        if (propertyDesc.type && propertyDesc.type[FillRulePropertyIdentifier]) {
                            return propertyDesc.rule;
                        }
                    }
                }
            }
            GradientUtils.getFillRuleDescriptor = getFillRuleDescriptor;
            function getUpdatedGradientSettings(gradientObject) {
                var gradientSettings;
                if (gradientObject && !$.isEmptyObject(gradientObject)) {
                    gradientSettings = getDefaultGradientSettings();
                    for (var propertyName in gradientSettings) {
                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
                        if (hasProperty) {
                            var value = gradientObject[propertyName];
                            if (value && value.solid && value.solid.color) {
                                value = value.solid.color;
                            }
                            gradientSettings[propertyName] = value;
                        }
                    }
                }
                return gradientSettings;
            }
            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings;
            function getGradientMeasureIndex(dataViewCategorical) {
                if (dataViewCategorical && dataViewCategorical.values && dataViewCategorical.values.grouped) {
                    var grouped = dataViewCategorical.values.grouped();
                    return DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
                }
                return -1;
            }
            GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex;
            function getGradientValueColumn(dataViewCategorical) {
                if (dataViewCategorical == null)
                    return null;
                // check for gradient measure index
                var gradientMeasureIndex = GradientUtils.getGradientMeasureIndex(dataViewCategorical);
                var gradientValueColumn = gradientMeasureIndex === -1 ? null : dataViewCategorical.values[gradientMeasureIndex];
                return gradientValueColumn;
            }
            GradientUtils.getGradientValueColumn = getGradientValueColumn;
            function hasGradientRole(dataViewCategorical) {
                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                return gradientMeasureIndex >= 0;
            }
            GradientUtils.hasGradientRole = hasGradientRole;
            function hasGradientRoleInMatrix(dataViewMatrix) {
                var gradientMeasureIndex = _.findIndex(dataViewMatrix.valueSources, (function (valueSource) { return DataRoleHelper.hasRole(valueSource, 'Gradient'); }));
                return gradientMeasureIndex >= 0;
            }
            GradientUtils.hasGradientRoleInMatrix = hasGradientRoleInMatrix;
            function getDefaultGradientSettings() {
                var colors = getDefaultColors();
                var gradientSettings = {
                    diverging: false,
                    minColor: colors.minColor,
                    midColor: DefaultMidColor,
                    maxColor: colors.maxColor,
                    minValue: undefined,
                    midValue: undefined,
                    maxValue: undefined,
                    nullStrategy: GradientUtils.DefaultNullStrategy,
                    nullColor: GradientUtils.DefaultNullColor,
                };
                return gradientSettings;
            }
            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings;
            function getDefaultFillRuleDefinition() {
                return getLinearGradient2FillRuleDefinition();
            }
            GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition;
            function updateFillRule(propertyName, propertyValue, definitions) {
                var dataPointObjectDefinition = powerbi.data.DataViewObjectDefinitions.ensure(definitions, DataPointPropertyIdentifier, null);
                var fillRule = getFillRule(definitions);
                var numericValueExpr;
                var colorValueExpr;
                if (!fillRule) {
                    return;
                }
                if ($.isNumeric(propertyValue)) {
                    numericValueExpr = propertyValue !== undefined ? SQExprBuilder.double(+propertyValue) : undefined;
                }
                if (_.contains(["minColor", "midColor", "maxColor", "nullColor"], propertyName)) {
                    colorValueExpr = getColorExpressionValue(fillRule, propertyName, propertyValue);
                }
                switch (propertyName) {
                    case "minColor":
                        updateMinColor(fillRule, colorValueExpr);
                        break;
                    case "midColor":
                        updateMidColor(fillRule, colorValueExpr);
                        break;
                    case "maxColor":
                        updateMaxColor(fillRule, colorValueExpr);
                        break;
                    case "nullColor":
                        updateNullColor(fillRule, colorValueExpr);
                        break;
                    case "minValue":
                        updateMinValue(fillRule, numericValueExpr);
                        break;
                    case "midValue":
                        updateMidValue(fillRule, numericValueExpr);
                        break;
                    case "maxValue":
                        updateMaxValue(fillRule, numericValueExpr);
                        break;
                    case "nullStrategy":
                        updateNullStrategy(fillRule, propertyValue);
                        break;
                    case "diverging":
                        if (propertyValue) {
                            fillRule = getLinearGradient3FillRuleDefinition(fillRule);
                        }
                        else {
                            fillRule = getLinearGradient2FillRuleDefinition(fillRule);
                        }
                        dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
                        break;
                    case "revertToDefault":
                        fillRule = getDefaultFillRuleDefinition();
                        dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
                        break;
                    default:
                        debug.assertFail("updateFillRule - Unexpected propertyName: " + propertyName);
                        break;
                }
            }
            GradientUtils.updateFillRule = updateFillRule;
            function getGradientSettings(baseFillRule) {
                if (baseFillRule) {
                    return getGradientSettingsFromRule(baseFillRule);
                }
                else {
                    return getDefaultGradientSettings();
                }
            }
            GradientUtils.getGradientSettings = getGradientSettings;
            function getFillRule(objectDefinitions) {
                var fillRuleDefinition = powerbi.data.DataViewObjectDefinitions.getValue(objectDefinitions, { objectName: DataPointPropertyIdentifier, propertyName: FillRulePropertyIdentifier }, null);
                return fillRuleDefinition;
            }
            GradientUtils.getFillRule = getFillRule;
            function getDefaultColors() {
                var dataColors = new powerbi.visuals.DataColorPalette();
                var maxColorInfo = dataColors.getColorByIndex(0);
                var colors = d3.scale.linear()
                    .domain([0, 100])
                    .range(["#ffffff", maxColorInfo.value]);
                return {
                    minColor: colors(20),
                    midColor: DefaultMidColor,
                    maxColor: maxColorInfo.value,
                    nullColor: GradientUtils.DefaultNullColor,
                };
            }
            function getGradientSettingsFromRule(fillRule) {
                var maxColor;
                var minColor;
                var midColor = DefaultMidColor;
                var nullColor = GradientUtils.DefaultNullColor;
                var maxValue;
                var midValue;
                var minValue;
                var nullStrategy = GradientUtils.DefaultNullStrategy;
                var diverging = fillRule.linearGradient3 !== undefined;
                var rule2 = fillRule.linearGradient2;
                var rule3 = fillRule.linearGradient3;
                var nullStrategyExpr;
                if (rule2) {
                    maxColor = rule2.max.color.value;
                    minColor = rule2.min.color.value;
                    var maxValueExpr = rule2.max.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    var minValueExpr = rule2.min.value;
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                    nullStrategyExpr = rule2.nullColoringStrategy;
                }
                else if (rule3) {
                    maxColor = rule3.max.color.value;
                    midColor = rule3.mid.color.value;
                    minColor = rule3.min.color.value;
                    var maxValueExpr = rule3.max.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    var midValueExpr = rule3.mid.value;
                    if (midValueExpr) {
                        midValue = midValueExpr.value;
                    }
                    var minValueExpr = rule3.min.value;
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                    nullStrategyExpr = rule3.nullColoringStrategy;
                }
                if (nullStrategyExpr) {
                    nullStrategy = nullStrategyExpr.strategy.value;
                    var nullColorExpr = nullStrategyExpr.color;
                    if (nullColorExpr)
                        nullColor = nullColorExpr.value;
                }
                var output = {
                    diverging: diverging,
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                    nullStrategy: nullStrategy,
                };
                if (minValue != null)
                    output.minValue = minValue;
                if (midValue != null)
                    output.midValue = midValue;
                if (maxValue != null)
                    output.maxValue = maxValue;
                if (nullColor != null) {
                    output.nullColor = nullColor;
                }
                else {
                    // Setting the default null color so the dialog can show a proper color picker
                    // Note that this will not be present in the FillRuleDefinition unless the strategy === specificColor
                    output.nullColor = GradientUtils.DefaultNullColor;
                }
                return output;
            }
            GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
            /** Returns a string representing the gradient to be used for the GradientBar directive. */
            function getGradientBarColors(gradientSettings) {
                var colors = [];
                gradientSettings.minColor = gradientSettings.minColor || DefaultColor;
                colors.push(gradientSettings.minColor);
                if (gradientSettings.diverging) {
                    gradientSettings.midColor = gradientSettings.midColor || DefaultColor;
                    colors.push(gradientSettings.midColor || DefaultColor);
                }
                gradientSettings.maxColor = gradientSettings.maxColor || DefaultColor;
                colors.push(gradientSettings.maxColor || DefaultColor);
                return colors.join(",");
            }
            GradientUtils.getGradientBarColors = getGradientBarColors;
            /**
             * Gets Gradient2 FillRule Definition out of a base defintion, or the default defnition
             * @param {FillRuleDefinition} [baseFillRule] (Optional) Base Fill Rule to get the definition from. It can be LinearGradien2 or linearGradient3
             */
            function getLinearGradient2FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient2: {
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        nullColoringStrategy: {
                            strategy: SQExprBuilder.text(gradientSettings.nullStrategy),
                        },
                    }
                };
                var gradient = fillRuleDefinition.linearGradient2;
                if (gradientSettings.minValue != null)
                    gradient.min.value = SQExprBuilder.double(gradientSettings.minValue);
                if (gradientSettings.maxValue != null)
                    gradient.max.value = SQExprBuilder.double(gradientSettings.maxValue);
                if (gradientSettings.nullStrategy === powerbi.NullStrategy.specificColor && gradientSettings.nullColor)
                    gradient.nullColoringStrategy.color = SQExprBuilder.text(gradientSettings.nullColor);
                return fillRuleDefinition;
            }
            GradientUtils.getLinearGradient2FillRuleDefinition = getLinearGradient2FillRuleDefinition;
            /**
             * Gets Gradient3 FillRule Definition out of a base defintion, or the default defnition
             * @param {FillRuleDefinition} [baseFillRule] (Optional) Base Fill Rule to get the definition from. It can be LinearGradien2 or linearGradient3
             */
            function getLinearGradient3FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient3: {
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                        mid: { color: SQExprBuilder.text(gradientSettings.midColor) },
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        nullColoringStrategy: {
                            strategy: SQExprBuilder.text(gradientSettings.nullStrategy),
                        },
                    }
                };
                var gradient = fillRuleDefinition.linearGradient3;
                if (gradientSettings.minValue != null)
                    gradient.min.value = SQExprBuilder.double(gradientSettings.minValue);
                if (gradientSettings.midValue != null)
                    gradient.mid.value = SQExprBuilder.double(gradientSettings.midValue);
                if (gradientSettings.maxValue != null)
                    gradient.max.value = SQExprBuilder.double(gradientSettings.maxValue);
                if (gradientSettings.nullStrategy === powerbi.NullStrategy.specificColor && gradientSettings.nullColor)
                    gradient.nullColoringStrategy.color = SQExprBuilder.text(gradientSettings.nullColor);
                return fillRuleDefinition;
            }
            GradientUtils.getLinearGradient3FillRuleDefinition = getLinearGradient3FillRuleDefinition;
            function getDefaultColorExpression(fillRule, propertyName) {
                var defaultColor;
                if (fillRule.linearGradient3) {
                    var defaultGradient = getLinearGradient3FillRuleDefinition().linearGradient3;
                    switch (propertyName) {
                        case "minColor":
                            defaultColor = defaultGradient.min.color;
                            break;
                        case "midColor":
                            defaultColor = defaultGradient.mid.color;
                            break;
                        case "maxColor":
                            defaultColor = defaultGradient.max.color;
                            break;
                        case "nullColor":
                            defaultColor = defaultGradient.nullColoringStrategy.color;
                            break;
                        default:
                            debug.assertFail("updateFillRule - Unexpected propertyName: " + propertyName);
                            break;
                    }
                }
                else if (fillRule.linearGradient2) {
                    var defaultGradient = getLinearGradient2FillRuleDefinition().linearGradient2;
                    switch (propertyName) {
                        case "minColor":
                            defaultColor = defaultGradient.min.color;
                            break;
                        case "maxColor":
                            defaultColor = defaultGradient.max.color;
                            break;
                        case "nullColor":
                            defaultColor = defaultGradient.nullColoringStrategy.color;
                            break;
                        default:
                            debug.assertFail("updateFillRule - Unexpected propertyName: " + propertyName);
                            break;
                    }
                }
                return defaultColor;
            }
            function getColorExpressionValue(fillRule, propertyName, propertyValue) {
                var colorExpressionValue;
                if (propertyValue) {
                    colorExpressionValue = SQExprBuilder.text(propertyValue);
                }
                else {
                    colorExpressionValue = getDefaultColorExpression(fillRule, propertyName);
                }
                return colorExpressionValue;
            }
            function updateMinColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.color = colorExpressionValue;
                }
            }
            function updateMidColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.color = colorExpressionValue;
                }
            }
            function updateMaxColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.color = colorExpressionValue;
                }
            }
            function updateMinValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.value = value;
                }
            }
            function updateMidValue(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.value = value;
                }
            }
            function updateMaxValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.value = value;
                }
            }
            function updateNullStrategy(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.nullColoringStrategy.strategy = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.nullColoringStrategy.strategy = value;
                }
            }
            function updateNullColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.nullColoringStrategy.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.nullColoringStrategy.color = colorExpressionValue;
                }
            }
        })(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var HierarchyNodeType;
        (function (HierarchyNodeType) {
            HierarchyNodeType[HierarchyNodeType["Leaf"] = 0] = "Leaf";
            HierarchyNodeType[HierarchyNodeType["NonLeaf"] = 1] = "NonLeaf";
        })(HierarchyNodeType = visuals.HierarchyNodeType || (visuals.HierarchyNodeType = {}));
        var HierarchyNodeHelpers;
        (function (HierarchyNodeHelpers) {
            function isLeaf(node) {
                return HierarchyNodeHelpers.isKind(node, HierarchyNodeType.Leaf);
            }
            HierarchyNodeHelpers.isLeaf = isLeaf;
            function isNonLeaf(node) {
                return HierarchyNodeHelpers.isKind(node, HierarchyNodeType.NonLeaf);
            }
            HierarchyNodeHelpers.isNonLeaf = isNonLeaf;
            function isKind(node, kind) {
                return node && node.kind === kind;
            }
            HierarchyNodeHelpers.isKind = isKind;
            function getNodeAtCategoryIndexForDepth(rootNode, categoryIndex, depth) {
                debug.assert(depth >= 0, 'depth must be greater than or equal to 0');
                if (depth === 0) {
                    return rootNode;
                }
                debug.assert(HierarchyNodeHelpers.isNonLeaf(rootNode), 'rootNode must be non-leaf if depth > 0');
                var currentNode = rootNode;
                for (var currentDepth = 1; currentDepth <= depth; currentDepth++) {
                    var children = currentNode.children;
                    debug.assert(!_.isEmpty(children), 'currentNode has no children');
                    var levelNode = _.first(children);
                    currentNode = HierarchyNodeHelpers.getNodeAtCategoryIndex(levelNode, categoryIndex);
                }
                return currentNode;
            }
            HierarchyNodeHelpers.getNodeAtCategoryIndexForDepth = getNodeAtCategoryIndexForDepth;
            function getNodeAtCategoryIndex(node, categoryIndex) {
                debug.assertValue(node, 'node must not be null or undefined');
                debug.assert(!isVisited(node), 'Detected loop in previous/next references. node has already been visited.');
                var currentMaxIndex = getMaxIndex(node);
                if (currentMaxIndex === categoryIndex) {
                    return node;
                }
                if (currentMaxIndex < categoryIndex) {
                    var nextNode = node.next;
                    // Assert since the last node (has next == null) will have currentMaxIndex < categoryIndex.
                    // Since we're dealing with maximums, the last node only contains from the previous node's maxIndex to currentMaxIndex.
                    // Anything larger than that is out of range.
                    debug.assertValue(nextNode, 'categoryIndex is greater than the greatest maxCategoryIndex');
                    // Mark this node as visited before moving to the next one to detect loops
                    setVisited(node);
                    var returnNode = HierarchyNodeHelpers.getNodeAtCategoryIndex(nextNode, categoryIndex);
                    clearVisited(node);
                    return returnNode;
                }
                var previousNode = node.previous;
                // No assert here since the 1st node (has previous == null) will have currentMaxIndex > categoryIndex.
                // Since we're dealing with maximums, the 1st node contains everything from -Infinity to currentMaxIndex.
                if (previousNode && getMaxIndex(previousNode) >= categoryIndex) {
                    // Mark this node as visited before moving to the next one to detect loops
                    setVisited(node);
                    var returnNode = HierarchyNodeHelpers.getNodeAtCategoryIndex(previousNode, categoryIndex);
                    clearVisited(node);
                    return returnNode;
                }
                return node;
            }
            HierarchyNodeHelpers.getNodeAtCategoryIndex = getNodeAtCategoryIndex;
            function setVisited(item) {
                var visitedItem = item;
                visitedItem.visited = true;
            }
            function clearVisited(item) {
                var visitedItem = item;
                delete visitedItem.visited;
            }
            function isVisited(item) {
                var visitedItem = item;
                return !!visitedItem.visited;
            }
            function getMaxIndex(node) {
                if (HierarchyNodeHelpers.isLeaf(node)) {
                    return node.categoryIndex;
                }
                else if (HierarchyNodeHelpers.isNonLeaf(node)) {
                    return node.maxCategoryIndex;
                }
                debug.assertFail('Unhandled hierarchical node type');
            }
            /**
             * Gets the last node that has already been added on the same level as the given node.
             * Only works if the node (and its parents) have `parent` set, but the they haven't been added to the parent's `children` yet.
             */
            function getLastLevelNode(node) {
                if (node.parent) {
                    var parent_1 = node.parent;
                    if (!_.isEmpty(parent_1.children)) {
                        return _.last(parent_1.children);
                    }
                    var previousParent = getLastLevelNode(parent_1);
                    return previousParent && _.last(previousParent.children);
                }
                return undefined;
            }
            HierarchyNodeHelpers.getLastLevelNode = getLastLevelNode;
            var Builder;
            (function (Builder) {
                /**
                 * Converts the given categories into a tree of `HierarchyNode`s. Builds the tree depth-first, left to right.
                 */
                function build(categories) {
                    var categorySpan = _.first(categories).values.length;
                    var rootNode = {
                        categorySpan: categorySpan,
                        children: [],
                        kind: HierarchyNodeType.NonLeaf,
                        maxCategoryIndex: categorySpan,
                        parent: null,
                    };
                    var usedCategorySpan = 0;
                    while (usedCategorySpan < categorySpan) {
                        usedCategorySpan += buildSubtree(rootNode, categories, 0, usedCategorySpan);
                    }
                    return rootNode;
                }
                Builder.build = build;
                function buildSubtree(parent, categoryColumns, columnIndex, categoryIndex, identitySubsetExprs) {
                    if (!identitySubsetExprs) {
                        identitySubsetExprs = [];
                    }
                    var categoryColumn = categoryColumns[columnIndex];
                    var columnSubsetExprs = identitySubsetExprs[columnIndex];
                    var previousNode;
                    if (!columnSubsetExprs) {
                        // Add the current level so we'll get the identity that references the levels up to and including this one, but not the ones afterwards
                        // We don't need to do this for the leaf level since we use the entire identity
                        // This property is not present before SU09. We shouldn't be hitting this code if it's not set.
                        debug.assertValue(categoryColumn.source.identityExprs, 'levelCategory.source.identityExprs');
                        var newIdentityExprs = categoryColumn.source.identityExprs;
                        columnSubsetExprs = identitySubsetExprs[columnIndex] = columnIndex > 0 ? identitySubsetExprs[columnIndex - 1].slice() : [];
                        columnSubsetExprs.push.apply(columnSubsetExprs, newIdentityExprs);
                    }
                    var categorySpan = getCategorySpan(categoryColumn, categoryIndex, columnSubsetExprs);
                    var node = {
                        categorySpan: categorySpan,
                        children: [],
                        kind: HierarchyNodeType.NonLeaf,
                        maxCategoryIndex: null,
                        parent: parent
                    };
                    // 1st child node, get the previous node which may have different parents
                    if (previousNode === undefined) {
                        previousNode = getLastLevelNode(node);
                    }
                    if (previousNode) {
                        node.previous = previousNode;
                        previousNode.next = node;
                    }
                    var nextColumnIndex = columnIndex + 1;
                    if (nextColumnIndex >= categoryColumns.length - 1) {
                        buildLeaves(node, categoryColumns[nextColumnIndex], categoryIndex, categorySpan);
                    }
                    else {
                        var usedCategorySpan = 0;
                        while (usedCategorySpan < categorySpan) {
                            var startCategoryIndex = usedCategorySpan + categoryIndex;
                            usedCategorySpan += buildSubtree(node, categoryColumns, nextColumnIndex, startCategoryIndex, identitySubsetExprs);
                        }
                    }
                    var lastChild = _.last(node.children);
                    switch (lastChild.kind) {
                        case HierarchyNodeType.Leaf:
                            node.maxCategoryIndex = lastChild.categoryIndex;
                            break;
                        case HierarchyNodeType.NonLeaf:
                            node.maxCategoryIndex = lastChild.maxCategoryIndex;
                            break;
                        default:
                            debug.assertFail('Unhandled HierarchyNodeType');
                    }
                    parent.children.push(node);
                    return categorySpan;
                }
                function getCategorySpan(categoryColumn, startCategoryIndex, identitySubsetExprs) {
                    var categorySpan = 0;
                    var categoryValuesLength = categoryColumn.values.length;
                    var levelIdentity;
                    for (var categoryIndex = startCategoryIndex; categoryIndex < categoryValuesLength; categoryIndex++) {
                        var currentIdentity = getSpecificIdentityFromCompositeIdentity(categoryColumn, categoryIndex, identitySubsetExprs);
                        if (levelIdentity && !powerbi.DataViewScopeIdentity.equals(levelIdentity, currentIdentity)) {
                            break;
                        }
                        else if (!levelIdentity) {
                            levelIdentity = currentIdentity;
                        }
                        categorySpan++;
                    }
                    return categorySpan;
                }
                function buildLeaves(parent, categoryColumn, startCategoryIndex, categorySpan) {
                    var previousLeaf;
                    for (var categoryIndex = startCategoryIndex, endCategoryIndex = startCategoryIndex + categorySpan; categoryIndex < endCategoryIndex; categoryIndex++) {
                        var leaf = {
                            categoryIndex: categoryIndex,
                            kind: HierarchyNodeType.Leaf,
                            parent: parent,
                            previous: previousLeaf,
                        };
                        // 1st child leaf, get the previous leaf which may have different parents
                        if (previousLeaf === undefined) {
                            previousLeaf = getLastLevelNode(leaf);
                        }
                        if (previousLeaf) {
                            previousLeaf.next = leaf;
                            leaf.previous = previousLeaf;
                        }
                        previousLeaf = leaf;
                        parent.children.push(leaf);
                    }
                }
                /*
                 * Deconstructs the composite key to get an identity that uniquely represents the value for this column.
                 * Ex. The composite key for value1 references both columnA and columnB.
                 * If columnA is passed in, an identity for value1 that only references columnA will be returned.
                 * Mainly used for detecting unique values on each level of a hierarchy.
                 */
                function getSpecificIdentityFromCompositeIdentity(column, valueIndex, groupIdentityFields) {
                    var columnIdentities = column.identity;
                    debug.assertNonEmpty(columnIdentities, 'columnIdentities');
                    var identity = columnIdentities[valueIndex];
                    debug.assertValue(identity, 'identity');
                    var identitySubsetExpr = powerbi.data.ScopeIdentityExtractor.getSubset(identity.expr, groupIdentityFields);
                    var valueGroupIdentity = powerbi.data.createDataViewScopeIdentity(identitySubsetExpr);
                    return valueGroupIdentity;
                }
            })(Builder = HierarchyNodeHelpers.Builder || (HierarchyNodeHelpers.Builder = {}));
        })(HierarchyNodeHelpers = visuals.HierarchyNodeHelpers || (visuals.HierarchyNodeHelpers = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualBackgroundHelper;
        (function (visualBackgroundHelper) {
            function getDefaultColor() {
                return '#FFF';
            }
            visualBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultTransparency() {
                return 50;
            }
            visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency;
            function getDefaultShow() {
                return false;
            }
            visualBackgroundHelper.getDefaultShow = getDefaultShow;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                    transparency: getDefaultTransparency(),
                    show: getDefaultShow()
                };
            }
            visualBackgroundHelper.getDefaultValues = getDefaultValues;
            function enumeratePlot(enumeration, background) {
                var transparency = (background && background.transparency);
                if (transparency == null)
                    transparency = getDefaultTransparency();
                var backgroundObject = {
                    selector: null,
                    properties: {
                        transparency: transparency,
                        image: (background && background.image)
                    },
                    objectName: 'plotArea',
                };
                enumeration.pushInstance(backgroundObject);
            }
            visualBackgroundHelper.enumeratePlot = enumeratePlot;
            function renderBackgroundImage(background, visualElement, layout) {
                var image = background && background.image;
                var imageUrl = image && image.url;
                var imageFit = image && image.scaling;
                var imageTransparency = background && background.transparency;
                var backgroundImage = visualElement.children('.background-image');
                // If there were image and it was removed
                if (!imageUrl) {
                    if (backgroundImage.length !== 0)
                        backgroundImage.remove();
                    return;
                }
                // If this is the first edit of the image
                if (backgroundImage.length === 0) {
                    // Place the div only if the image exists in order to keep the html as clean as possible
                    visualElement.prepend('<div class="background-image"></div>');
                    backgroundImage = visualElement.children('.background-image');
                    // the div should be positioned absolute in order to get on top of the sibling svg
                    backgroundImage.css('position', 'absolute');
                }
                // Get the size and margins from the visual for the div will placed inside the plot area
                backgroundImage.css({
                    'width': layout.width,
                    'height': layout.height,
                    'margin-left': layout.left,
                    'margin-top': layout.top,
                });
                // Background properties
                backgroundImage.css({
                    'background-image': 'url(' + imageUrl + ')',
                    'background-repeat': 'no-repeat',
                    'opacity': (100 - imageTransparency) / 100,
                });
                switch (imageFit) {
                    // The image will be centered in its initial size
                    case visuals.imageScalingType.normal: {
                        backgroundImage.css({
                            'background-size': '',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                    // The image will be streched all over the background
                    case visuals.imageScalingType.fit: {
                        backgroundImage.css({
                            'background-size': '100% 100%',
                            'background-position': '',
                        });
                        break;
                    }
                    // The image will stretch on the width and the height will scale accordingly
                    case visuals.imageScalingType.fill: {
                        backgroundImage.css({
                            'background-size': '100%',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                    default: {
                        backgroundImage.css({
                            'background-size': '',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                }
            }
            visualBackgroundHelper.renderBackgroundImage = renderBackgroundImage;
        })(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Selector = powerbi.data.Selector;
        /**
         * A helper class for building a VisualObjectInstanceEnumerationObject:
         * - Allows call chaining (e.g., builder.pushInstance({...}).pushInstance({...})
         * - Allows creating of containers (via pushContainer/popContainer)
         */
        var ObjectEnumerationBuilder = /** @class */ (function () {
            function ObjectEnumerationBuilder() {
            }
            ObjectEnumerationBuilder.prototype.pushInstance = function (instance, mergeInstances) {
                if (mergeInstances === void 0) { mergeInstances = true; }
                debug.assertValue(instance, 'instance');
                var instances = this.instances;
                if (!instances) {
                    instances = this.instances = [];
                }
                var containerIdx = this.containerIdx;
                if (containerIdx != null) {
                    instance.containerIdx = containerIdx;
                }
                if (mergeInstances) {
                    // Attempt to merge with an existing item if possible.
                    for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
                        var existingInstance = instances_1[_i];
                        if (this.canMerge(existingInstance, instance)) {
                            this.extend(existingInstance, instance, 'properties');
                            this.extend(existingInstance, instance, 'validValues');
                            return this;
                        }
                    }
                }
                instances.push(instance);
                return this;
            };
            ObjectEnumerationBuilder.prototype.pushContainer = function (container) {
                debug.assertValue(container, 'container');
                var containers = this.containers;
                if (!containers) {
                    containers = this.containers = [];
                }
                var updatedLen = containers.push(container);
                this.containerIdx = updatedLen - 1;
                return this;
            };
            ObjectEnumerationBuilder.prototype.popContainer = function () {
                this.containerIdx = undefined;
                return this;
            };
            ObjectEnumerationBuilder.prototype.complete = function () {
                if (!this.instances)
                    return;
                var result = {
                    instances: this.instances,
                };
                var containers = this.containers;
                if (containers) {
                    result.containers = containers;
                }
                return result;
            };
            ObjectEnumerationBuilder.prototype.canMerge = function (x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return x.objectName === y.objectName &&
                    x.containerIdx === y.containerIdx &&
                    Selector.equals(x.selector, y.selector);
            };
            ObjectEnumerationBuilder.prototype.extend = function (target, source, propertyName) {
                debug.assertValue(target, 'target');
                debug.assertValue(source, 'source');
                debug.assertValue(propertyName, 'propertyName');
                var sourceValues = source[propertyName];
                if (!sourceValues)
                    return;
                var targetValues = target[propertyName];
                if (!targetValues)
                    targetValues = target[propertyName] = {};
                for (var valuePropertyName in sourceValues) {
                    if (targetValues[valuePropertyName]) {
                        // Properties have first-writer-wins semantics.
                        continue;
                    }
                    targetValues[valuePropertyName] = sourceValues[valuePropertyName];
                }
            };
            ObjectEnumerationBuilder.merge = function (x, y) {
                var xNormalized = ObjectEnumerationBuilder.normalize(x);
                var yNormalized = ObjectEnumerationBuilder.normalize(y);
                if (!xNormalized || !yNormalized)
                    return xNormalized || yNormalized;
                debug.assertValue(xNormalized, 'xNormalized');
                debug.assertValue(yNormalized, 'yNormalized');
                var xCategoryCount = xNormalized.containers ? xNormalized.containers.length : 0;
                for (var _i = 0, _a = yNormalized.instances; _i < _a.length; _i++) {
                    var yInstance = _a[_i];
                    xNormalized.instances.push(yInstance);
                    if (yInstance.containerIdx != null)
                        yInstance.containerIdx += xCategoryCount;
                }
                var yContainers = yNormalized.containers;
                if (!_.isEmpty(yContainers)) {
                    if (xNormalized.containers)
                        Array.prototype.push.apply(xNormalized.containers, yContainers);
                    else
                        xNormalized.containers = yContainers;
                }
                return xNormalized;
            };
            ObjectEnumerationBuilder.normalize = function (x) {
                debug.assertAnyValue(x, 'x');
                if (_.isArray(x)) {
                    return { instances: x };
                }
                return x;
            };
            ObjectEnumerationBuilder.getContainerForInstance = function (enumeration, instance) {
                debug.assertValue(enumeration, "enumeration");
                debug.assertValue(instance, "instance");
                debug.assertValue(enumeration.containers, "containers");
                debug.assert(enumeration.containers.length > instance.containerIdx, "no container found in containers collection");
                return enumeration.containers[instance.containerIdx];
            };
            return ObjectEnumerationBuilder;
        }());
        visuals.ObjectEnumerationBuilder = ObjectEnumerationBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Helper class for Visual border styles */
        var VisualBorderUtil;
        (function (VisualBorderUtil) {
            /**
             * Gets The Boder Width string (e.g. 0px 1px 2px 3px)
             * @param {OutlineType} string Type of the Outline, one of Visuals.outline.<XX> const strings
             * @param {number} outlineWeight Weight of the outline in pixels
             * @returns String representing the Border Width
             */
            function getBorderWidth(outlineType, outlineWeight) {
                switch (outlineType) {
                    case visuals.outline.none:
                        return '0px';
                    case visuals.outline.bottomOnly:
                        return '0px 0px ' + outlineWeight + 'px 0px';
                    case visuals.outline.topOnly:
                        return outlineWeight + 'px 0px 0px 0px';
                    case visuals.outline.leftOnly:
                        return '0px 0px 0px ' + outlineWeight + 'px';
                    case visuals.outline.rightOnly:
                        return '0px ' + outlineWeight + 'px 0px 0px';
                    case visuals.outline.topBottom:
                        return outlineWeight + 'px 0px';
                    case visuals.outline.leftRight:
                        return '0px ' + outlineWeight + 'px';
                    case visuals.outline.frame:
                        return outlineWeight + 'px';
                    default:
                        debug.assertFail('Unexpected OutlineType value: ' + outlineType);
                        return '0px';
                }
            }
            VisualBorderUtil.getBorderWidth = getBorderWidth;
        })(VisualBorderUtil = visuals.VisualBorderUtil || (visuals.VisualBorderUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Transformation matrix math wrapper */
        var Transform = /** @class */ (function () {
            // Constructor
            function Transform(m) {
                this.matrix = m || {
                    m00: 1, m01: 0, m02: 0,
                    m10: 0, m11: 1, m12: 0,
                };
            }
            // Methods
            Transform.prototype.applyToPoint = function (point) {
                if (!point) {
                    return point;
                }
                var m = this.matrix;
                return {
                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
                    y: m.m10 * point.x + m.m11 * point.y + m.m12,
                };
            };
            Transform.prototype.applyToRect = function (rect) {
                if (!rect) {
                    return rect;
                }
                var x0 = rect.left;
                var y0 = rect.top;
                var m = this.matrix;
                var isScaled = m.m00 !== 1 || m.m11 !== 1;
                var isRotated = m.m01 !== 0 || m.m10 !== 0;
                if (!isRotated && !isScaled) {
                    // Optimize for the translation only case
                    return { left: x0 + m.m02, top: y0 + m.m12, width: rect.width, height: rect.height };
                }
                var x1 = rect.left + rect.width;
                var y1 = rect.top + rect.height;
                var minX;
                var maxX;
                var minY;
                var maxY;
                if (isRotated) {
                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02;
                    var p0y = m.m10 * x0 + m.m11 * y0 + m.m12;
                    var p1x = m.m00 * x0 + m.m01 * y1 + m.m02;
                    var p1y = m.m10 * x0 + m.m11 * y1 + m.m12;
                    var p2x = m.m00 * x1 + m.m01 * y0 + m.m02;
                    var p2y = m.m10 * x1 + m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m01 * y1 + m.m02;
                    var p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p1x, p2x, p3x);
                    maxX = Math.max(p0x, p1x, p2x, p3x);
                    minY = Math.min(p0y, p1y, p2y, p3y);
                    maxY = Math.max(p0y, p1y, p2y, p3y);
                }
                else {
                    var p0x = m.m00 * x0 + m.m02;
                    var p0y = m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m02;
                    var p3y = m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p3x);
                    maxX = Math.max(p0x, p3x);
                    minY = Math.min(p0y, p3y);
                    maxY = Math.max(p0y, p3y);
                }
                return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
            };
            Transform.prototype.translate = function (xOffset, yOffset) {
                if (xOffset !== 0 || yOffset !== 0) {
                    var m = createTranslateMatrix(xOffset, yOffset);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.scale = function (xScale, yScale) {
                if (xScale !== 1 || yScale !== 1) {
                    var m = createScaleMatrix(xScale, yScale);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.rotate = function (angleInRadians) {
                if (angleInRadians !== 0) {
                    var m = createRotationMatrix(angleInRadians);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.add = function (other) {
                if (other) {
                    this.matrix = multiplyMatrices(this.matrix, other.matrix);
                    this._inverse = null;
                }
            };
            Transform.prototype.getInverse = function () {
                if (!this._inverse) {
                    this._inverse = new Transform(createInverseMatrix(this.matrix));
                }
                return this._inverse;
            };
            return Transform;
        }());
        visuals.Transform = Transform;
        function createTranslateMatrix(xOffset, yOffset) {
            return {
                m00: 1, m01: 0, m02: xOffset,
                m10: 0, m11: 1, m12: yOffset,
            };
        }
        visuals.createTranslateMatrix = createTranslateMatrix;
        function createScaleMatrix(xScale, yScale) {
            return {
                m00: xScale, m01: 0, m02: 0,
                m10: 0, m11: yScale, m12: 0
            };
        }
        visuals.createScaleMatrix = createScaleMatrix;
        function createRotationMatrix(angleInRads) {
            var a = angleInRads;
            var sinA = Math.sin(a);
            var cosA = Math.cos(a);
            return {
                m00: cosA, m01: -sinA, m02: 0,
                m10: sinA, m11: cosA, m12: 0,
            };
        }
        visuals.createRotationMatrix = createRotationMatrix;
        function createInverseMatrix(m) {
            var determinant = m.m00 * m.m11 - m.m01 * m.m10;
            var invdet = 1 / determinant;
            return {
                m00: m.m11 * invdet,
                m01: -m.m01 * invdet,
                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                m10: -m.m10 * invdet,
                m11: m.m00 * invdet,
                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
            };
        }
        visuals.createInverseMatrix = createInverseMatrix;
        function multiplyMatrices(a, b) {
            return {
                m00: a.m00 * b.m00 + a.m01 * b.m10,
                m01: a.m00 * b.m01 + a.m01 * b.m11,
                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                m10: a.m10 * b.m00 + a.m11 * b.m10,
                m11: a.m10 * b.m01 + a.m11 * b.m11,
                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12,
            };
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var TrendLineHelper;
        (function (TrendLineHelper) {
            var PropertyNames;
            (function (PropertyNames) {
                PropertyNames.show = 'show';
                PropertyNames.displayName = 'displayName';
                PropertyNames.lineColor = 'lineColor';
                PropertyNames.transparency = 'transparency';
                PropertyNames.style = 'style';
                PropertyNames.combineSeries = 'combineSeries';
                PropertyNames.useHighlightValues = 'useHighlightValues';
            })(PropertyNames || (PropertyNames = {}));
            var trendObjectName = 'trend';
            TrendLineHelper.defaults = {
                lineColor: { solid: { color: '#000' } },
                lineStyle: visuals.lineStyle.dashed,
                transparency: 0,
                combineSeries: true,
                useHighlightValues: true,
            };
            var TrendLineClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line');
            var TrendLineLayerClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line-layer');
            function enumerateObjectInstances(enumeration, trendLines) {
                debug.assertValue(enumeration, 'enumeration');
                if (_.isEmpty(trendLines)) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: false,
                            lineColor: TrendLineHelper.defaults.lineColor,
                            transparency: TrendLineHelper.defaults.transparency,
                            style: TrendLineHelper.defaults.lineStyle,
                            combineSeries: TrendLineHelper.defaults.combineSeries,
                        },
                        objectName: trendObjectName,
                    });
                    return;
                }
                var trendLine = trendLines[0];
                var properties = {};
                properties['show'] = trendLine.show;
                properties['displayName'] = trendLine.displayName;
                if (trendLine.combineSeries)
                    properties['lineColor'] = trendLine.lineColor;
                properties['transparency'] = trendLine.transparency;
                properties['style'] = trendLine.style;
                properties['combineSeries'] = trendLine.combineSeries;
                properties['useHighlightValues'] = trendLine.useHighlightValues;
                enumeration.pushInstance({
                    selector: null,
                    properties: properties,
                    objectName: trendObjectName,
                });
            }
            TrendLineHelper.enumerateObjectInstances = enumerateObjectInstances;
            function isDataViewForRegression(dataView) {
                return DataRoleHelper.hasRoleInDataView(dataView, 'regression.X');
            }
            TrendLineHelper.isDataViewForRegression = isDataViewForRegression;
            function readDataView(dataView, sourceDataView, y2, colors, readMatrix) {
                if (readMatrix) {
                    return powerbi.requireSync('visuals/trendlineHelper/matrix').read(dataView, sourceDataView, y2, colors);
                }
                else {
                    return powerbi.requireSync('visuals/trendlineHelper/categorical').read(dataView, sourceDataView, y2, colors);
                }
            }
            TrendLineHelper.readDataView = readDataView;
            function getTrendLineProperties(objects) {
                var trendProperties = powerbi.DataViewObjects.getObject(objects, trendObjectName, {});
                return {
                    show: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.show, false),
                    displayName: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.displayName),
                    lineColor: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.lineColor),
                    transparency: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.transparency, TrendLineHelper.defaults.transparency),
                    style: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.style, TrendLineHelper.defaults.lineStyle),
                    combineSeries: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.combineSeries, TrendLineHelper.defaults.combineSeries),
                    useHighlightValues: powerbi.DataViewObject.getValue(trendProperties, PropertyNames.useHighlightValues, TrendLineHelper.defaults.useHighlightValues),
                };
            }
            powerbi.define('visuals/trendlineHelper/matrix', (function (imports) {
                /**
                 * Expects to read matrix where the series is the outer row grouping while category is inner row grouping
                 * {
                 *     rows: {
                 *         levels: [ sources: [seriesCol, categoryCol]],
                 *         root: {
                 *             children: [ seriesValues (categoryValues are nested under their respective Series) ]
                 *         }
                 *     },
                 *     columns: {
                 *         levels: [],
                 *         root: {
                 *             children: []
                 *         }
                 *     },
                 *     valueSources: [XValuesCol, YValuesCol, SizeValuesCol]
                 * }
                 */
                function read(dataView, sourceDataView, y2, colors) {
                    if (!dataView || !dataView.matrix)
                        return;
                    var matrix = dataView.matrix;
                    var seriesNodes = matrix.rows && matrix.rows.root && matrix.rows.root.children;
                    if (_.isEmpty(seriesNodes))
                        return;
                    var trendlineProperties = getTrendLineProperties(dataView.metadata.objects);
                    // Trend lines generated by Insights will be putting line color here, we should convert the Insights code to create
                    // "trend" objects like above and write the upgrade code to handle pinned tiles with trend lines before removing any feature switch.
                    var legacyColor = powerbi.DataViewObjects.getValue(seriesNodes[0].children[0].objects, visuals.lineChartProps.dataPoint.fill);
                    if (legacyColor)
                        trendlineProperties.lineColor = legacyColor;
                    var objects = sourceDataView.metadata.objects;
                    var defaultColor = powerbi.DataViewObjects.getFillColor(objects, { objectName: 'dataPoint', propertyName: 'defaultColor' });
                    var colorHelper = new visuals.ColorHelper(colors, { objectName: 'dataPoint', propertyName: 'fill' }, defaultColor);
                    var sourceSeriesNodes = sourceDataView.matrix && sourceDataView.matrix.rows && sourceDataView.matrix.rows.root.children;
                    var trendLines = [];
                    for (var seriesIndex = 0; seriesIndex < seriesNodes.length; seriesIndex++) {
                        var series = seriesNodes[seriesIndex];
                        var points = [];
                        for (var _i = 0, _a = series.children; _i < _a.length; _i++) {
                            var category = _a[_i];
                            var x = visuals.AxisHelper.normalizeNonFiniteNumber(category.value);
                            // There is a assumption here that the group only has 1 set of values in it. Once we add more things like confidence bands,
                            // this assumption will not be true. This assumption comes from the way dataViewRegresion generates the dataView
                            var y = visuals.AxisHelper.normalizeNonFiniteNumber(category.values[0].value);
                            if (x != null && y != null) {
                                points.push({
                                    x: x,
                                    y: y,
                                });
                            }
                        }
                        var seriesLineColor = void 0;
                        if (trendlineProperties.combineSeries) {
                            seriesLineColor = trendlineProperties.lineColor || TrendLineHelper.defaults.lineColor;
                        }
                        else if (sourceDataView.matrix.rows.levels.length === 2) {
                            // TODO: This should likely be delegated to the layer which knows how to choose the correct color for any given situation.
                            var sourceSeriesNode = sourceSeriesNodes[seriesIndex];
                            var color = colorHelper.getColorForSeriesValue(sourceSeriesNode.objects, sourceSeriesNode.childIdentityFields, sourceSeriesNode.value);
                            color = darkenTrendLineColor(color);
                            seriesLineColor = { solid: { color: color } };
                        }
                        trendLines.push({
                            points: points,
                            show: trendlineProperties.show,
                            displayName: trendlineProperties.displayName,
                            lineColor: seriesLineColor,
                            transparency: trendlineProperties.transparency,
                            style: trendlineProperties.style,
                            combineSeries: trendlineProperties.combineSeries,
                            useHighlightValues: trendlineProperties.useHighlightValues,
                            y2Axis: y2,
                        });
                    }
                    return trendLines;
                }
                return {
                    read: function (dataView, sourceDataView, y2, colors) {
                        return read(dataView, sourceDataView, y2, colors);
                    },
                };
            }));
            powerbi.define('visuals/trendlineHelper/categorical', (function (imports) {
                function read(dataView, sourceDataView, y2, colors) {
                    if (!dataView || !dataView.categorical)
                        return;
                    var categorical = dataView.categorical;
                    if (_.isEmpty(categorical.categories) || _.isEmpty(categorical.values))
                        return;
                    var categories = categorical.categories[0].values;
                    var groups = categorical.values.grouped();
                    if (!categories || !groups)
                        return;
                    var trendlineProperties = getTrendLineProperties(dataView.metadata.objects);
                    // Trend lines generated by Insights will be putting line color here, we should convert the Insights code to create
                    // "trend" objects like above and write the upgrade code to handle pinned tiles with trend lines before removing any feature switch.
                    var legacyColor = powerbi.DataViewObjects.getValue(categorical.values[0].source.objects, visuals.lineChartProps.dataPoint.fill);
                    if (legacyColor)
                        trendlineProperties.lineColor = legacyColor;
                    var objects = sourceDataView.metadata.objects;
                    var defaultColor = powerbi.DataViewObjects.getFillColor(objects, { objectName: 'dataPoint', propertyName: 'defaultColor' });
                    var colorHelper = new visuals.ColorHelper(colors, { objectName: 'dataPoint', propertyName: 'fill' }, defaultColor);
                    var trendLines = [];
                    for (var groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                        var group = groups[groupIndex];
                        var points = [];
                        for (var i = 0; i < categories.length; i++) {
                            var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]);
                            // There is a assumption here that the group only has 1 set of values in it. Once we add more things like confidence bands,
                            // this assumption will not be true. This assumption comes from the way dataViewRegresion generates the dataView
                            var valueColumn = group.values[0];
                            var values = void 0;
                            if (trendlineProperties.useHighlightValues && valueColumn.highlights) {
                                values = valueColumn.highlights;
                            }
                            else {
                                values = valueColumn.values;
                            }
                            var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                            if (x != null && y != null) {
                                points.push({
                                    x: x,
                                    y: y,
                                });
                            }
                        }
                        var seriesLineColor = void 0;
                        if (trendlineProperties.combineSeries) {
                            seriesLineColor = trendlineProperties.lineColor || TrendLineHelper.defaults.lineColor;
                        }
                        else {
                            // TODO: This should likely be delegated to the layer which knows how to choose the correct color for any given situation.
                            var color = void 0;
                            if (sourceDataView.categorical.values.source) {
                                // Dynamic series
                                var sourceGroups = sourceDataView.categorical.values.grouped();
                                color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
                            }
                            else {
                                // Static series
                                var matchingMeasure = sourceDataView.categorical.values[groupIndex];
                                color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
                            }
                            color = darkenTrendLineColor(color);
                            seriesLineColor = { solid: { color: color } };
                        }
                        trendLines.push({
                            points: points,
                            show: trendlineProperties.show,
                            displayName: trendlineProperties.displayName,
                            lineColor: seriesLineColor,
                            transparency: trendlineProperties.transparency,
                            style: trendlineProperties.style,
                            combineSeries: trendlineProperties.combineSeries,
                            useHighlightValues: trendlineProperties.useHighlightValues,
                            y2Axis: y2,
                        });
                    }
                    return trendLines;
                }
                return {
                    read: function (dataView, sourceDataView, y2, colors) {
                        return read(dataView, sourceDataView, y2, colors);
                    },
                };
            }));
            function darkenTrendLineColor(color) {
                var rgb = Color.parseColorString(color);
                rgb = Color.darken(rgb, 20);
                return Color.rgbString(rgb);
            }
            TrendLineHelper.darkenTrendLineColor = darkenTrendLineColor;
            function render(trendLines, graphicsContext, axes, viewport) {
                var layer = graphicsContext.select(TrendLineLayerClassSelector.selector);
                if (layer.empty()) {
                    layer = graphicsContext.append('svg').classed(TrendLineLayerClassSelector.class, true);
                }
                layer.attr({
                    height: viewport.height,
                    width: viewport.width
                });
                var lines = layer.selectAll(TrendLineClassSelector.selector).data(trendLines || []);
                lines.enter().append('path').classed(TrendLineClassSelector.class, true);
                lines
                    .attr('d', (function (d) {
                    var xScale = axes.x.scale;
                    var yScale = (d.y2Axis && axes.y2) ? axes.y2.scale : axes.y1.scale;
                    var pathGen = d3.svg.line()
                        .x((function (point) { return xScale(point.x); }))
                        .y((function (point) { return yScale(point.y); }));
                    return pathGen(_.filter(d.points, (function (point) { return point.x != null && point.y != null; })));
                }));
                lines.each((function (data) {
                    var line = d3.select(this);
                    var style = {};
                    style.stroke = data.lineColor.solid.color;
                    if (data.transparency != null) {
                        style['stroke-opacity'] = (100 - data.transparency) / 100;
                    }
                    if (data.style === visuals.lineStyle.dashed) {
                        style['stroke-dasharray'] = "5, 5";
                    }
                    else if (data.style === visuals.lineStyle.dotted) {
                        style['stroke-dasharray'] = "1, 5";
                        style['stroke-linecap'] = "round";
                    }
                    else if (data.style === visuals.lineStyle.solid) {
                        style['stroke-dasharray'] = null;
                        style['stroke-linecap'] = null;
                    }
                    line.style(style);
                }));
                lines.exit().remove();
            }
            TrendLineHelper.render = render;
        })(TrendLineHelper = visuals.TrendLineHelper || (visuals.TrendLineHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visibilityHelper;
        (function (visibilityHelper) {
            /**  Helper method that uses jQuery :visible selector to determine if visual is visible.
                Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.
                Elements with visibility: hidden or opacity: 0 are considered visible, since they still consume space in the layout.
            */
            function partiallyVisible(element) {
                return element.is(":visible");
            }
            visibilityHelper.partiallyVisible = partiallyVisible;
        })(visibilityHelper = visuals.visibilityHelper || (visuals.visibilityHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
    var DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;
    var Selector = powerbi.data.Selector;
    var VisualObjectRepetition;
    (function (VisualObjectRepetition) {
        /** Determines whether two repetitions are equal. */
        function equals(x, y) {
            // Normalize falsy to null
            x = x || null;
            y = y || null;
            if (x === y)
                return true;
            if (!x !== !y)
                return false;
            debug.assertValue(x, 'x');
            debug.assertValue(y, 'y');
            if (!Selector.equals(x.selector, y.selector))
                return false;
            return _.isEqual(x.objects, y.objects);
        }
        VisualObjectRepetition.equals = equals;
        function getMetadata(objectRepetitions, objectDescriptors) {
            if (_.isEmpty(objectRepetitions))
                return [];
            debug.assertValue(objectDescriptors, 'objectDescriptors');
            var repetitionsMetadata = [];
            for (var _i = 0, objectRepetitions_1 = objectRepetitions; _i < objectRepetitions_1.length; _i++) {
                var repetition = objectRepetitions_1[_i];
                for (var objectName in repetition.objects) {
                    var properties = repetition.objects[objectName] && repetition.objects[objectName].formattingProperties;
                    if (_.isEmpty(properties))
                        continue;
                    for (var _a = 0, properties_1 = properties; _a < properties_1.length; _a++) {
                        var propertyName = properties_1[_a];
                        var propertyId = {
                            objectName: objectName,
                            propertyName: propertyName,
                        };
                        var propertyDescriptor = DataViewObjectDescriptors.findPropertyById(objectDescriptors, propertyId);
                        if (propertyDescriptor) {
                            repetitionsMetadata.push({
                                selector: repetition.selector,
                                propertyId: propertyId,
                                propertyDescriptor: propertyDescriptor,
                                containerName: repetition.containerName,
                            });
                        }
                    }
                }
            }
            return repetitionsMetadata;
        }
        VisualObjectRepetition.getMetadata = getMetadata;
        function metadataEquals(x, y) {
            if (x === y || (x == null && y == null))
                return true;
            if (!x !== !y)
                return false;
            return x.containerName === y.containerName
                && _.isEqual(x.propertyDescriptor, y.propertyDescriptor)
                && _.isEqual(x.propertyId, y.propertyId)
                && Selector.equals(x.selector, y.selector);
        }
        VisualObjectRepetition.metadataEquals = metadataEquals;
        function getDefinition(objectDefns, repetition) {
            return DataViewObjectDefinitions.getValue(objectDefns, repetition.propertyId, repetition.selector);
        }
        VisualObjectRepetition.getDefinition = getDefinition;
    })(VisualObjectRepetition = powerbi.VisualObjectRepetition || (powerbi.VisualObjectRepetition = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var FontProperties = powerbi.visuals.FontProperties;
    var shapes = powerbi.visuals.shapes;
    /**
    * Rectangle orientation. Rectangle orientation is used to define vertical or horizontal orientation
    * and starting/ending side of the rectangle.
    */
    var RectOrientation;
    (function (RectOrientation) {
        /** Rectangle with no specific orientation. */
        RectOrientation[RectOrientation["None"] = 0] = "None";
        /** Vertical rectangle with base at the bottom. */
        RectOrientation[RectOrientation["VerticalBottomTop"] = 1] = "VerticalBottomTop";
        /** Vertical rectangle with base at the top. */
        RectOrientation[RectOrientation["VerticalTopBottom"] = 2] = "VerticalTopBottom";
        /** Horizontal rectangle with base at the left. */
        RectOrientation[RectOrientation["HorizontalLeftRight"] = 3] = "HorizontalLeftRight";
        /** Horizontal rectangle with base at the right. */
        RectOrientation[RectOrientation["HorizontalRightLeft"] = 4] = "HorizontalRightLeft";
    })(RectOrientation = powerbi.RectOrientation || (powerbi.RectOrientation = {}));
    /**
    * Defines if panel elements are allowed to be positioned
    * outside of the panel boundaries.
    */
    var OutsidePlacement;
    (function (OutsidePlacement) {
        /** Elements can be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Allowed"] = 0] = "Allowed";
        /** Elements can not be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Disallowed"] = 1] = "Disallowed";
        /** Elements can be partially outside of the panel. */
        OutsidePlacement[OutsidePlacement["Partial"] = 2] = "Partial";
    })(OutsidePlacement = powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
    /**
    * Arranges label elements using the anchor point or rectangle. Collisions
    * between elements can be automatically detected and as a result elements
    * can be repositioned or get hidden.
    */
    var DataLabelManager = /** @class */ (function () {
        function DataLabelManager() {
            this.movingStep = 3;
            this.hideOverlapped = true;
            // The global settings for all labels. 
            // They can be oweridden by each label we add into the panel, because contains same properties.
            this.defaultDataLabelSettings = {
                anchorMargin: DataLabelManager.DefaultAnchorMargin,
                anchorRectOrientation: RectOrientation.None,
                contentPosition: 128 /* BottomCenter */,
                outsidePlacement: OutsidePlacement.Disallowed,
                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                validContentPositions: 128 /* BottomCenter */,
                opacity: 1
            };
        }
        Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
            get: function () {
                return this.defaultDataLabelSettings;
            },
            enumerable: true,
            configurable: true
        });
        /** Arranges the lables position and visibility*/
        DataLabelManager.prototype.hideCollidedLabels = function (viewport, data, layout, addTransform) {
            if (addTransform === void 0) { addTransform = false; }
            // Split size into a grid
            var arrangeGrid = new DataLabelArrangeGrid(viewport, data, layout);
            var filteredData = [];
            var transform = { x: 0, y: 0 };
            if (addTransform) {
                transform.x = viewport.width / 2;
                transform.y = viewport.height / 2;
            }
            for (var i = 0, len = data.length; i < len; i++) {
                // Filter unwanted data points
                if (!layout.filter(data[i]))
                    continue;
                // Set default values where properties values are undefined
                var info = this.getLabelInfo(data[i]);
                info.anchorPoint = {
                    x: layout.labelLayout.x(data[i]) + transform.x,
                    y: layout.labelLayout.y(data[i]) + transform.y,
                };
                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                if (DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, viewport)) {
                    data[i].labelX = position.left - transform.x;
                    data[i].labelY = position.top - transform.y;
                    // Keep track of all panel elements positions.
                    arrangeGrid.add(info, position);
                    // Save all data points to display
                    filteredData.push(data[i]);
                }
            }
            return filteredData;
        };
        /**
         * Merges the label element info with the panel element info and returns correct label info.
         * @param source The label info.
         */
        DataLabelManager.prototype.getLabelInfo = function (source) {
            var settings = this.defaultDataLabelSettings;
            source.anchorMargin = source.anchorMargin !== undefined ? source.anchorMargin : settings.anchorMargin;
            source.anchorRectOrientation = source.anchorRectOrientation !== undefined ? source.anchorRectOrientation : settings.anchorRectOrientation;
            source.contentPosition = source.contentPosition !== undefined ? source.contentPosition : settings.contentPosition;
            source.maximumMovingDistance = source.maximumMovingDistance !== undefined ? source.maximumMovingDistance : settings.maximumMovingDistance;
            source.minimumMovingDistance = source.minimumMovingDistance !== undefined ? source.minimumMovingDistance : settings.minimumMovingDistance;
            source.outsidePlacement = source.outsidePlacement !== undefined ? source.outsidePlacement : settings.outsidePlacement;
            source.validContentPositions = source.validContentPositions !== undefined ? source.validContentPositions : settings.validContentPositions;
            source.opacity = source.opacity !== undefined ? source.opacity : settings.opacity;
            source.maximumMovingDistance += source.anchorMargin;
            return source;
        };
        /**
        * (Private) Calculates element position using anchor point..
        */
        DataLabelManager.prototype.calculateContentPositionFromPoint = function (anchorPoint, contentPosition, contentSize, offset) {
            var position = { x: 0, y: 0 };
            if (anchorPoint) {
                if (anchorPoint.x !== undefined && isFinite(anchorPoint.x)) {
                    position.x = anchorPoint.x;
                    switch (contentPosition) {
                        // D3 positions the label in the middle by default.
                        // The algorithem asumed the label was positioned in right so this is why we add/substract half width
                        case 1 /* TopLeft */:
                        case 8 /* MiddleLeft */:
                        case 64 /* BottomLeft */:
                            position.x -= contentSize.width / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 32 /* MiddleRight */:
                        case 256 /* BottomRight */:
                            position.x += contentSize.width / 2.0;
                            break;
                    }
                }
                if (anchorPoint.y !== undefined && isFinite(anchorPoint.y)) {
                    position.y = anchorPoint.y;
                    switch (contentPosition) {
                        case 8 /* MiddleLeft */:
                        case 16 /* MiddleCenter */:
                        case 32 /* MiddleRight */:
                            position.y -= contentSize.height / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 1 /* TopLeft */:
                        case 2 /* TopCenter */:
                            position.y -= contentSize.height;
                            break;
                    }
                }
                if (offset !== undefined && isFinite(offset)) {
                    switch (contentPosition) {
                        case 1 /* TopLeft */:
                            position.x -= offset;
                            position.y -= offset;
                            break;
                        case 8 /* MiddleLeft */:
                            position.x -= offset;
                            break;
                        case 64 /* BottomLeft */:
                            position.x -= offset;
                            position.y += offset;
                            break;
                        case 2 /* TopCenter */:
                            position.y -= offset;
                            break;
                        case 16 /* MiddleCenter */:
                            // Offset is not applied
                            break;
                        case 128 /* BottomCenter */:
                            position.y += offset;
                            break;
                        case 4 /* TopRight */:
                            position.x += offset;
                            position.y -= offset;
                            break;
                        case 32 /* MiddleRight */:
                            position.x += offset;
                            break;
                        case 256 /* BottomRight */:
                            position.x += offset;
                            position.y += offset;
                            break;
                        default:
                            debug.assertFail("Unsupported content position.");
                            break;
                    }
                }
            }
            return { left: position.x, top: position.y, width: contentSize.width, height: contentSize.height };
        };
        /** (Private) Calculates element position using anchor rect. */
        DataLabelManager.prototype.calculateContentPositionFromRect = function (anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
            switch (contentPosition) {
                case 512 /* InsideCenter */:
                    return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 2048 /* InsideEnd */:
                    return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 1024 /* InsideBase */:
                    return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 8192 /* OutsideEnd */:
                    return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 4096 /* OutsideBase */:
                    return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                default:
                    debug.assertFail("Unsupported ContentPosition.");
            }
            return { left: 0, top: 0, width: -1, height: -1 };
        };
        /** (Private) Calculates element inside center position using anchor rect. */
        DataLabelManager.prototype.handleInsideCenterPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.middleVertical(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                case RectOrientation.HorizontalRightLeft:
                default:
                    return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside end position using anchor rect. */
        DataLabelManager.prototype.handleInsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside base position using anchor rect. */
        DataLabelManager.prototype.handleInsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside end position using anchor rect. */
        DataLabelManager.prototype.handleOutsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside base position using anchor rect. */
        DataLabelManager.prototype.handleOutsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
            }
        };
        /**  (Private) Calculates element position. */
        DataLabelManager.prototype.calculateContentPosition = function (anchoredElementInfo, contentPosition, contentSize, offset) {
            if (contentPosition !== 2048 /* InsideEnd */ &&
                contentPosition !== 512 /* InsideCenter */ &&
                contentPosition !== 1024 /* InsideBase */ &&
                contentPosition !== 4096 /* OutsideBase */ &&
                contentPosition !== 8192 /* OutsideEnd */) {
                // Determine position using anchor point.
                return this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset);
            }
            // Determine position using anchor rectangle.
            return this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
        };
        /** (Private) Check for collisions. */
        DataLabelManager.prototype.hasCollisions = function (arrangeGrid, info, position, size) {
            var rect = shapes.Rect;
            if (arrangeGrid.hasConflict(position)) {
                return true;
            }
            // Since we divide the height by 2 we add it back to the top of the view port so labels won't be cut off
            var intersection = { left: 0, top: position.height / 2, width: size.width, height: size.height };
            intersection = rect.inflate(intersection, { left: DataLabelManager.InflateAmount, top: 0, right: DataLabelManager.InflateAmount, bottom: 0 });
            intersection = rect.intersect(intersection, position);
            if (rect.isEmpty(intersection))
                // Empty rectangle means there is a collision
                return true;
            var lessWithPrecision = powerbi.Double.lessWithPrecision;
            switch (info.outsidePlacement) {
                // D3 positions the label in the middle by default.
                // The algorithem asumed the label was positioned in right so this is why we devide by 2 or 4
                case OutsidePlacement.Disallowed:
                    return lessWithPrecision(intersection.width, position.width) ||
                        lessWithPrecision(intersection.height, position.height / 2);
                case OutsidePlacement.Partial:
                    return lessWithPrecision(intersection.width, position.width / 2) ||
                        lessWithPrecision(intersection.height, position.height / 4);
            }
            return false;
        };
        DataLabelManager.isValid = function (rect) {
            return !shapes.Rect.isEmpty(rect) && (rect.width > 0 && rect.height > 0);
        };
        DataLabelManager.DefaultAnchorMargin = 0; // For future use
        DataLabelManager.DefaultMaximumMovingDistance = 12;
        DataLabelManager.DefaultMinimumMovingDistance = 3;
        DataLabelManager.InflateAmount = 5;
        return DataLabelManager;
    }());
    powerbi.DataLabelManager = DataLabelManager;
    /**
    * Utility class to speed up the conflict detection by collecting the arranged items in the DataLabelsPanel.
    */
    var DataLabelArrangeGrid = /** @class */ (function () {
        /**
         * Creates new ArrangeGrid.
         * @param size The available size
         */
        function DataLabelArrangeGrid(size, elements, layout) {
            this.grid = [];
            if (size.width === 0 || size.height === 0) {
                this.cellSize = size;
                this.rowCount = this.colCount = 0;
            }
            var baseProperties = FontProperties.toTextProperties(powerbi.visuals.LabelUtils.defaultFontProperties);
            var defaultFontSize = baseProperties.fontSize;
            //sets the cell size to be twice of the Max with and Max height of the elements 
            this.cellSize = { width: 0, height: 0 };
            for (var i = 0, len = elements.length; i < len; i++) {
                var child = elements[i];
                // Fill label field
                child.labeltext = layout.labelText(child);
                var properties = powerbi.Prototype.inherit(baseProperties);
                properties.text = child.labeltext;
                properties.fontSize = (child.data) ? child.data.labelFontSize :
                    child.labelFontSize ? child.labelFontSize : defaultFontSize;
                child.size = {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
                };
                var w = child.size.width * 2;
                var h = child.size.height * 2;
                if (w > this.cellSize.width)
                    this.cellSize.width = w;
                if (h > this.cellSize.height)
                    this.cellSize.height = h;
            }
            if (this.cellSize.width === 0)
                this.cellSize.width = size.width;
            if (this.cellSize.height === 0)
                this.cellSize.height = size.height;
            this.colCount = this.getGridRowColCount(this.cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this.rowCount = this.getGridRowColCount(this.cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this.cellSize.width = size.width / this.colCount;
            this.cellSize.height = size.height / this.rowCount;
            var grid = this.grid;
            for (var x = 0; x < this.colCount; x++) {
                grid[x] = [];
                for (var y = 0; y < this.rowCount; y++) {
                    grid[x][y] = [];
                }
            }
        }
        /**
         * Register a new label element.
         * @param element The label element to register.
         * @param rect The label element position rectangle.
         */
        DataLabelArrangeGrid.prototype.add = function (element, rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this.grid;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    grid[x][y].push({ element: element, rect: rect });
                }
            }
        };
        /**
         * Checks for conflict of given rectangle in registered elements.
         * @param rect The rectengle to check.
         * @return True if conflict is detected.
         */
        DataLabelArrangeGrid.prototype.hasConflict = function (rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this.grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var item = _a[_i];
                        if (isIntersecting(item.rect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * Calculates the number of rows or columns in a grid
         * @param step is the largest label size (width or height)
         * @param length is the grid size (width or height)
         * @param minCount is the minimum allowed size
         * @param maxCount is the maximum allowed size
         * @return the number of grid rows or columns
         */
        DataLabelArrangeGrid.prototype.getGridRowColCount = function (step, length, minCount, maxCount) {
            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
        };
        /**
         * Returns the grid index of a given recangle
         * @param rect The rectengle to check.
         * @return grid index as a thickness object.
         */
        DataLabelArrangeGrid.prototype.getGridIndexRect = function (rect) {
            var restrict = function (n, min, max) { return Math.min(Math.max(n, min), max); };
            return {
                left: restrict(Math.floor(rect.left / this.cellSize.width), 0, this.colCount),
                top: restrict(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                right: restrict(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.colCount),
                bottom: restrict(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
            };
        };
        DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1;
        DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100;
        return DataLabelArrangeGrid;
    }());
    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
    /**
    * (Private) Contains methods for calculating the top-left coordinate of rectangle based on content size and anchor rect.
    */
    var LocationConverter;
    (function (LocationConverter) {
        function topInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topInside = topInside;
        function bottomInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomInside = bottomInside;
        function rightInside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightInside = rightInside;
        function leftInside(size, rect, offset) {
            return {
                left: rect.left + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftInside = leftInside;
        function topOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topOutside = topOutside;
        function bottomOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomOutside = bottomOutside;
        function rightOutside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightOutside = rightOutside;
        function leftOutside(size, rect, offset) {
            return {
                left: rect.left - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftOutside = leftOutside;
        function middleHorizontal(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0 + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleHorizontal = middleHorizontal;
        function middleVertical(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + rect.height / 2.0 - size.height / 2.0 + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleVertical = middleVertical;
    })(LocationConverter || (LocationConverter = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var FontProperties = powerbi.visuals.FontProperties;
    var LabelUtils = powerbi.visuals.LabelUtils;
    var Rect = powerbi.visuals.shapes.Rect;
    var shapes = powerbi.visuals.shapes;
    var LabelArrangeGrid = /** @class */ (function () {
        function LabelArrangeGrid(labelDataPointGroups, viewport) {
            this.viewport = viewport;
            var maxLabelWidth = 0;
            var maxLabelHeight = 0;
            for (var _i = 0, labelDataPointGroups_1 = labelDataPointGroups; _i < labelDataPointGroups_1.length; _i++) {
                var labelDataPointsGroup = labelDataPointGroups_1[_i];
                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelDataPoint = _b[_a];
                    var dataLabelSize = labelDataPoint.labelSize;
                    if (dataLabelSize.width > maxLabelWidth) {
                        maxLabelWidth = dataLabelSize.width;
                    }
                    if (dataLabelSize.height > maxLabelHeight) {
                        maxLabelHeight = dataLabelSize.height;
                    }
                }
            }
            if (maxLabelWidth === 0) {
                maxLabelWidth = viewport.width;
            }
            if (maxLabelHeight === 0) {
                maxLabelHeight = viewport.height;
            }
            var cellSize = this.cellSize = { width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier, height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier };
            this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
            this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            var grid = [];
            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
                    grid[i][j] = [];
                }
            }
            this.grid = grid;
        }
        /**
         * Add a rectangle to check collision against
         */
        LabelArrangeGrid.prototype.add = function (rect) {
            var containingIndexRect = this.getContainingGridSubsection(rect);
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    this.grid[x][y].push(rect);
                }
            }
        };
        /**
         * Check whether the rect conflicts with the grid, either bleeding outside the
         * viewport or colliding with another rect added to the grid.
         */
        LabelArrangeGrid.prototype.hasConflict = function (rect) {
            if (!this.isWithinGridViewport(rect)) {
                return true;
            }
            return this.hasCollision(rect);
        };
        /**
         * Attempt to position the given rect within the viewport.  Returns
         * the adjusted rectangle or null if the rectangle couldn't fit,
         * conflicts with the viewport, or is too far outside the viewport
         */
        LabelArrangeGrid.prototype.tryPositionInViewport = function (rect) {
            // If it's too far outside the viewport, return null
            if (!this.isCloseToGridViewport(rect)) {
                return;
            }
            if (!this.isWithinGridViewport(rect)) {
                rect = this.tryMoveInsideViewport(rect);
            }
            if (rect && !this.hasCollision(rect)) {
                return rect;
            }
        };
        /**
         * Checks for a collision between the given rect and others in the grid.
         * Returns true if there is a collision.
         */
        LabelArrangeGrid.prototype.hasCollision = function (rect) {
            var containingIndexRect = this.getContainingGridSubsection(rect);
            var grid = this.grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var currentGridRect = _a[_i];
                        if (isIntersecting(currentGridRect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * Check to see if the given rect is inside the grid's viewport
         */
        LabelArrangeGrid.prototype.isWithinGridViewport = function (rect) {
            return rect.left >= 0 &&
                rect.top >= 0 &&
                rect.left + rect.width <= this.viewport.width &&
                rect.top + rect.height <= this.viewport.height;
        };
        /**
         * Checks to see if the rect is close enough to the viewport to be moved inside.
         * "Close" here is determined by the distance between the edge of the viewport
         * and the closest edge of the rect; if that distance is less than the appropriate
         * dimension of the rect, we will reposition the rect.
         */
        LabelArrangeGrid.prototype.isCloseToGridViewport = function (rect) {
            return rect.left + rect.width >= 0 - rect.width &&
                rect.top + rect.height >= -rect.height &&
                rect.left <= this.viewport.width + rect.width &&
                rect.top <= this.viewport.height + rect.height;
        };
        /**
         * Attempt to move the rect inside the grid's viewport.  Returns the resulting
         * rectangle with the same width/height adjusted to be inside the viewport or
         * null if it couldn't fit regardless.
         */
        LabelArrangeGrid.prototype.tryMoveInsideViewport = function (rect) {
            var result = Rect.clone(rect);
            var viewport = this.viewport;
            // Return null if it's too big to fit regardless of positioning
            if (rect.width > viewport.width || rect.height > viewport.height) {
                return;
            }
            // Only one movement should be made in each direction, because we are only moving it inside enough for it to fit; there should be no overshooting.
            // Outside to the left
            if (rect.left < 0) {
                result.left = 0;
            }
            else if (rect.left + rect.width > viewport.width) {
                result.left -= (rect.left + rect.width) - viewport.width;
            }
            // Outside above
            if (rect.top < 0) {
                result.top = 0;
            }
            else if (rect.top + rect.height > viewport.height) {
                result.top -= (rect.top + rect.height) - viewport.height;
            }
            return result;
        };
        LabelArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
            return {
                xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
            };
        };
        LabelArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
            return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        };
        LabelArrangeGrid.bound = function (value, min, max) {
            return Math.max(Math.min(value, max), min);
        };
        /**
         * A multiplier applied to the largest width height to attempt to balance # of
         * labels in each cell and number of cells each label belongs to
         */
        LabelArrangeGrid.cellSizeMultiplier = 2;
        return LabelArrangeGrid;
    }());
    powerbi.LabelArrangeGrid = LabelArrangeGrid;
    var LabelLayout = /** @class */ (function () {
        function LabelLayout(options) {
            this.startingOffset = options.startingOffset;
            this.maximumOffset = options.maximumOffset;
            if (options.offsetIterationDelta != null) {
                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
                this.offsetIterationDelta = options.offsetIterationDelta;
            }
            else {
                this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta;
            }
            if (options.horizontalPadding != null) {
                this.horizontalPadding = options.horizontalPadding;
            }
            else {
                this.horizontalPadding = LabelLayout.defaultHorizontalPadding;
            }
            if (options.verticalPadding != null) {
                this.verticalPadding = options.verticalPadding;
            }
            else {
                this.verticalPadding = LabelLayout.defaultVerticalPadding;
            }
            this.allowLeaderLines = !!options.allowLeaderLines;
            this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
        }
        LabelLayout.prototype.layout = function (arg0, viewport) {
            var labelDataPointsGroups;
            if (this.isOldLabelDataPointGroups(arg0)) {
                labelDataPointsGroups = this.upgradeToNewLabelDataPointsGroups(arg0);
            }
            else {
                labelDataPointsGroups = arg0;
            }
            // Clear data labels for a new layout
            var labelDataPointsGroupsLayoutInfo = [];
            for (var _i = 0, labelDataPointsGroups_1 = labelDataPointsGroups; _i < labelDataPointsGroups_1.length; _i++) {
                var labelDataPointsGroup = labelDataPointsGroups_1[_i];
                var labelDataPointsLayoutInfo = _.map(labelDataPointsGroup.labelDataPoints, (function (labelDataPoint) { return ({ labelDataPoint: labelDataPoint }); }));
                var labelGroupOrientation = labelDataPointsGroup.labelOrientation;
                for (var _a = 0, labelDataPointsLayoutInfo_1 = labelDataPointsLayoutInfo; _a < labelDataPointsLayoutInfo_1.length; _a++) {
                    var labelDataPointLayoutInfo = labelDataPointsLayoutInfo_1[_a];
                    var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
                    labelDataPointLayoutInfo.hasBeenRendered = false;
                    var textWidth = labelDataPoint.textSize.width;
                    var textHeight = labelDataPoint.textSize.height;
                    if (labelGroupOrientation === 0 /* Vertical */) {
                        textWidth = labelDataPoint.textSize.height;
                        textHeight = labelDataPoint.textSize.width;
                    }
                    if (labelDataPoint.hasBackground) {
                        labelDataPointLayoutInfo.labelSize = {
                            width: textWidth + 2 * LabelUtils.horizontalLabelBackgroundPadding,
                            height: textHeight + 2 * LabelUtils.verticalLabelBackgroundPadding,
                        };
                    }
                    else {
                        labelDataPointLayoutInfo.labelSize = {
                            width: textWidth,
                            height: textHeight,
                        };
                    }
                }
                labelDataPointsGroupsLayoutInfo.push({
                    labelDataPoints: labelDataPointsLayoutInfo,
                    maxNumberOfLabels: labelDataPointsGroup.maxNumberOfLabels,
                    labelOrientation: labelDataPointsGroup.labelOrientation,
                });
            }
            var resultingDataLabels = [];
            var grid = new LabelArrangeGrid(labelDataPointsGroupsLayoutInfo, viewport);
            // Iterates on every series
            for (var _b = 0, labelDataPointsGroupsLayoutInfo_1 = labelDataPointsGroupsLayoutInfo; _b < labelDataPointsGroupsLayoutInfo_1.length; _b++) {
                var labelDataPointsGroupLayoutInfo = labelDataPointsGroupsLayoutInfo_1[_b];
                var maxLabelsToRender = labelDataPointsGroupLayoutInfo.maxNumberOfLabels;
                // NOTE: we create a copy and modify the copy to keep track of preferred vs. non-preferred labels.
                var labelDataPointsLayoutInfo = _.clone(labelDataPointsGroupLayoutInfo.labelDataPoints);
                var preferredLabels = [];
                var labelGroupOrientation = labelDataPointsGroupLayoutInfo.labelOrientation;
                // Exclude preferred labels
                for (var j = labelDataPointsLayoutInfo.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
                    var labelDataPoint = labelDataPointsLayoutInfo[j].labelDataPoint;
                    if (labelDataPoint.isPreferred) {
                        preferredLabels.unshift(labelDataPointsLayoutInfo.splice(j, 1)[0]);
                        localMax--;
                    }
                }
                // First iterate all the preferred labels
                if (preferredLabels.length > 0) {
                    var positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender, labelGroupOrientation);
                    maxLabelsToRender -= positionedLabels.length;
                    resultingDataLabels = resultingDataLabels.concat(positionedLabels);
                }
                // While there are invisible not preferred labels and label distance is less than the max
                // allowed distance
                if (labelDataPointsLayoutInfo.length > 0) {
                    var labels = this.positionDataLabels(labelDataPointsLayoutInfo, viewport, grid, maxLabelsToRender, labelGroupOrientation);
                    resultingDataLabels = resultingDataLabels.concat(labels);
                }
                // TODO: Add reference lines if we want them
            }
            var filtedResultingDataLabels = _.filter(resultingDataLabels, (function (d) { return d.isVisible; }));
            return this.isOldLabelDataPointGroups(arg0) ? LabelUtils.downgradeToOldLabels(filtedResultingDataLabels) : filtedResultingDataLabels;
        };
        LabelLayout.prototype.positionDataLabels = function (labelDataPointsLayoutInfo, viewport, grid, maxLabelsToRender, labelOrientation) {
            var resultingDataLabels = [];
            var offsetDelta = this.offsetIterationDelta;
            var currentOffset = this.startingOffset;
            var currentCenteredOffset = 0;
            var drawLeaderLinesOnIteration;
            var labelsRendered = 0;
            while (currentOffset <= this.maximumOffset && labelsRendered < maxLabelsToRender) {
                drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
                for (var _i = 0, labelDataPointsLayoutInfo_2 = labelDataPointsLayoutInfo; _i < labelDataPointsLayoutInfo_2.length; _i++) {
                    var labelDataPointLayoutInfo = labelDataPointsLayoutInfo_2[_i];
                    var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
                    if (labelDataPointLayoutInfo.hasBeenRendered) {
                        continue;
                    }
                    var dataLabel = void 0;
                    if (labelDataPoint.parentType === 1 /* Rectangle */) {
                        dataLabel = this.tryPositionForRectPositions(labelDataPointLayoutInfo, grid, currentOffset, currentCenteredOffset, labelOrientation);
                    }
                    else {
                        dataLabel = this.tryPositionForPointPositions(labelDataPointLayoutInfo, grid, currentOffset, drawLeaderLinesOnIteration, labelOrientation);
                    }
                    if (dataLabel) {
                        resultingDataLabels.push(dataLabel);
                        labelsRendered++;
                    }
                    if (!(labelsRendered < maxLabelsToRender)) {
                        break;
                    }
                }
                currentOffset += offsetDelta;
                currentCenteredOffset += offsetDelta;
            }
            return resultingDataLabels;
        };
        LabelLayout.prototype.tryPositionForRectPositions = function (labelDataPointLayoutInfo, grid, currentLabelOffset, currentCenteredLabelOffset, labelOrientation) {
            var _this = this;
            // Function declared and reused to reduce code duplication
            var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
            var tryPosition = function (position, adjustForViewport) {
                var isPositionInside = position & 7 /* InsideAll */;
                if (isPositionInside && !DataLabelRectPositioner.canFitWithinParent(labelDataPointLayoutInfo, _this.horizontalPadding, _this.verticalPadding)) {
                    return;
                }
                var resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelDataPointLayoutInfo, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
                if (resultingBoundingBox) {
                    if (isPositionInside && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelDataPoint, _this.horizontalPadding, _this.verticalPadding)) {
                        return;
                    }
                    grid.add(resultingBoundingBox);
                    labelDataPointLayoutInfo.hasBeenRendered = true;
                    return {
                        boundingBox: resultingBoundingBox,
                        text: labelDataPoint.text,
                        tooltip: labelDataPoint.tooltip,
                        isVisible: true,
                        identity: labelDataPoint.identity,
                        key: labelDataPoint.key,
                        fontProperties: FontProperties.inherit(labelDataPoint.fontProperties, { color: isPositionInside ? labelDataPoint.insideFill : labelDataPoint.outsideFill }),
                        selected: false,
                        hasBackground: !!labelDataPoint.hasBackground,
                        labelOrientation: labelOrientation,
                    };
                }
            };
            // Iterate over all positions that are valid for the data point
            for (var _i = 0, _a = labelDataPoint.parentShape.validPositions; _i < _a.length; _i++) {
                var position = _a[_i];
                var label = tryPosition(position, false /* adjustForViewport */);
                if (label)
                    return label;
            }
            // If no position has been found and the option is enabled, try any outside positions while moving the label inside the viewport
            if (this.attemptToMoveLabelsIntoViewport) {
                for (var _b = 0, _c = labelDataPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    var label = tryPosition(position, true /* adjustForViewport */);
                    if (label)
                        return label;
                }
            }
            return null;
        };
        /**
         * Tests a particular position/offset combination for the given data label.
         * If the label can be placed, returns the resulting bounding box for the data
         * label.  If not, returns null.
         */
        LabelLayout.tryPositionRect = function (grid, position, labelDataPointLayoutInfo, offset, centerOffset, adjustForViewport) {
            var offsetForPosition = offset;
            if (position & 1 /* InsideCenter */) {
                offsetForPosition = centerOffset;
            }
            var labelRect = DataLabelRectPositioner.getLabelRect(labelDataPointLayoutInfo, position, offsetForPosition);
            var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
            if (position !== 1 /* InsideCenter */ || labelDataPoint.parentShape.orientation === 0 /* None */) {
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
                if (adjustForViewport) {
                    return grid.tryPositionInViewport(labelRect);
                }
            }
            else {
                // If the position is centered, attempt to offset in both a positive and negative direction
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
                labelRect = DataLabelRectPositioner.getLabelRect(labelDataPointLayoutInfo, position, -offsetForPosition);
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
            }
            return null;
        };
        LabelLayout.prototype.tryPositionForPointPositions = function (labelDataPointLayoutInfo, grid, currentLabelOffset, drawLeaderLines, labelOrientation) {
            // Function declared and reused to reduce code duplication
            var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
            var tryPosition = function (position, parentShape, adjustForViewport) {
                var resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelDataPointLayoutInfo, currentLabelOffset, adjustForViewport);
                if (resultingBoundingBox) {
                    grid.add(resultingBoundingBox);
                    labelDataPointLayoutInfo.hasBeenRendered = true;
                    return {
                        boundingBox: resultingBoundingBox,
                        text: labelDataPoint.text,
                        tooltip: labelDataPoint.tooltip,
                        isVisible: true,
                        isInsideParent: position === 256 /* Center */,
                        identity: labelDataPoint.identity,
                        key: labelDataPoint.key,
                        fontProperties: FontProperties.inherit(labelDataPoint.fontProperties, 
                        // If we ever support "inside" for point-based labels, this needs to be updated
                        { color: position === 256 /* Center */ ? labelDataPoint.insideFill : labelDataPoint.outsideFill }),
                        selected: false,
                        leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
                        hasBackground: !!labelDataPoint.hasBackground,
                        labelOrientation: labelOrientation,
                    };
                }
            };
            // Iterate over all positions that are valid for the data point
            var parentShape = labelDataPoint.parentShape;
            var validPositions = parentShape.validPositions;
            for (var _i = 0, validPositions_1 = validPositions; _i < validPositions_1.length; _i++) {
                var position = validPositions_1[_i];
                var label = tryPosition(position, parentShape, false /* adjustForViewport */);
                if (label)
                    return label;
            }
            // Attempt to position at the most preferred position by simply moving it inside the viewport
            if (this.attemptToMoveLabelsIntoViewport && !_.isEmpty(validPositions)) {
                var label = tryPosition(validPositions[0], parentShape, true /* adjustForViewport */);
                if (label)
                    return label;
            }
            return null;
        };
        LabelLayout.tryPositionPoint = function (grid, position, labelDataPointLayoutInfo, offset, adjustForViewport) {
            var labelRect = DataLabelPointPositioner.getLabelRect(labelDataPointLayoutInfo.labelSize, labelDataPointLayoutInfo.labelDataPoint.parentShape, position, offset);
            if (!grid.hasConflict(labelRect)) {
                return labelRect;
            }
            if (adjustForViewport) {
                return grid.tryPositionInViewport(labelRect);
            }
            return null;
        };
        LabelLayout.prototype.isOldLabelDataPoint = function (labelDataPoint) {
            var newLabelDataPoint = labelDataPoint;
            return !newLabelDataPoint.fontProperties;
        };
        LabelLayout.prototype.isOldLabelDataPointGroups = function (labelDataPointGroups) {
            var newLabelDataPointGroups = labelDataPointGroups;
            if (newLabelDataPointGroups.length !== 0) {
                var labelDataPointGroup = _.find(newLabelDataPointGroups, (function (labelDataPointGroup) { return !_.isEmpty(labelDataPointGroup.labelDataPoints); }));
                if (labelDataPointGroup) {
                    var labelDataPoint = labelDataPointGroup.labelDataPoints[0];
                    return this.isOldLabelDataPoint(labelDataPoint);
                }
            }
            return false;
        };
        LabelLayout.prototype.upgradeToNewLabelDataPointsGroups = function (labelDataPointsGroups) {
            var newLabelDataPointsGroups = [];
            var _loop_3 = function (labelDataPointsGroup) {
                var newLabelDataPointsGroup;
                newLabelDataPointsGroup = {
                    labelOrientation: labelDataPointsGroup.labelOrientation,
                    maxNumberOfLabels: labelDataPointsGroup.maxNumberOfLabels,
                    labelDataPoints: []
                };
                _.map(labelDataPointsGroup.labelDataPoints, (function (labelDataPoint) {
                    newLabelDataPointsGroup.labelDataPoints.push({
                        textSize: labelDataPoint.textSize,
                        isPreferred: labelDataPoint.isPreferred,
                        parentType: labelDataPoint.parentType,
                        parentShape: labelDataPoint.parentShape,
                        hasBackground: labelDataPoint.hasBackground,
                        text: labelDataPoint.text,
                        tooltip: labelDataPoint.tooltip,
                        insideFill: labelDataPoint.insideFill,
                        outsideFill: labelDataPoint.outsideFill,
                        identity: labelDataPoint.identity,
                        key: labelDataPoint.key,
                        fontProperties: FontProperties.inherit(LabelUtils.defaultFontProperties, { size: labelDataPoint.fontSize ? powerbi.visuals.Units.FontSize.createFromPt(labelDataPoint.fontSize) : undefined }),
                        secondRowText: labelDataPoint.secondRowText,
                        weight: labelDataPoint.weight,
                    });
                }));
                newLabelDataPointsGroups.push(newLabelDataPointsGroup);
            };
            for (var _i = 0, labelDataPointsGroups_2 = labelDataPointsGroups; _i < labelDataPointsGroups_2.length; _i++) {
                var labelDataPointsGroup = labelDataPointsGroups_2[_i];
                _loop_3(labelDataPointsGroup);
            }
            return newLabelDataPointsGroups;
        };
        // Default values
        LabelLayout.defaultOffsetIterationDelta = 2;
        LabelLayout.defaultHorizontalPadding = 2;
        LabelLayout.defaultVerticalPadding = 2;
        return LabelLayout;
    }());
    powerbi.LabelLayout = LabelLayout;
    /**
     * (Private) Contains methods for calculating the bounding box of a data label
     */
    var DataLabelRectPositioner;
    (function (DataLabelRectPositioner) {
        function getLabelRect(labelDataPointLayoutInfo, position, offset) {
            var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
            var parentRect = labelDataPoint.parentShape;
            if (parentRect != null) {
                // Each combination of position and orientation results in a different actual positioning, which is then called.
                switch (position) {
                    case 1 /* InsideCenter */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.middleVertical(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.middleHorizontal(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 2 /* InsideBase */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.bottomInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.topInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.leftInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.rightInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 4 /* InsideEnd */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.topInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.bottomInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.rightInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.leftInside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 8 /* OutsideBase */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.bottomOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.topOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.leftOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.rightOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 16 /* OutsideEnd */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.topOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.bottomOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.rightOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.leftOutside(labelDataPointLayoutInfo.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    default:
                        debug.assertFail("Unsupported label position");
                }
            }
            else {
                // TODO: Data labels for non-rectangular visuals (line chart)
            }
            return null;
        }
        DataLabelRectPositioner.getLabelRect = getLabelRect;
        function canFitWithinParent(labelDataPointLayoutInfo, horizontalPadding, verticalPadding) {
            var labelDataPoint = labelDataPointLayoutInfo.labelDataPoint;
            return (labelDataPointLayoutInfo.labelSize.width + 2 * horizontalPadding < labelDataPoint.parentShape.rect.width) ||
                (labelDataPointLayoutInfo.labelSize.height + 2 * verticalPadding < labelDataPoint.parentShape.rect.height);
        }
        DataLabelRectPositioner.canFitWithinParent = canFitWithinParent;
        function isLabelWithinParent(labelRect, labelPoint, horizontalPadding, verticalPadding) {
            var parentRect = labelPoint.parentShape.rect;
            var labelRectWithPadding = shapes.Rect.inflate(labelRect, { left: horizontalPadding, right: horizontalPadding, top: verticalPadding, bottom: verticalPadding });
            return shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left,
                y: labelRectWithPadding.top,
            }) && shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left + labelRectWithPadding.width,
                y: labelRectWithPadding.top + labelRectWithPadding.height,
            });
        }
        DataLabelRectPositioner.isLabelWithinParent = isLabelWithinParent;
        function topInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.topInside = topInside;
        function bottomInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: (parentRect.top + parentRect.height) - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.bottomInside = bottomInside;
        function rightInside(labelSize, parentRect, offset) {
            return {
                left: (parentRect.left + parentRect.width) - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.rightInside = rightInside;
        function leftInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.leftInside = leftInside;
        function topOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top - labelSize.height - offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.topOutside = topOutside;
        function bottomOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: (parentRect.top + parentRect.height) + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.bottomOutside = bottomOutside;
        function rightOutside(labelSize, parentRect, offset) {
            return {
                left: (parentRect.left + parentRect.width) + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.rightOutside = rightOutside;
        function leftOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.leftOutside = leftOutside;
        function middleHorizontal(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0 + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.middleHorizontal = middleHorizontal;
        function middleVertical(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0 + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.middleVertical = middleVertical;
    })(DataLabelRectPositioner = powerbi.DataLabelRectPositioner || (powerbi.DataLabelRectPositioner = {}));
    var DataLabelPointPositioner;
    (function (DataLabelPointPositioner) {
        DataLabelPointPositioner.cos45 = Math.cos(45);
        DataLabelPointPositioner.sin45 = Math.sin(45);
        function getLabelRect(labelSize, parentPoint, position, offset) {
            switch (position) {
                case 1 /* Above */: {
                    return DataLabelPointPositioner.above(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 2 /* Below */: {
                    return DataLabelPointPositioner.below(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 4 /* Left */: {
                    return DataLabelPointPositioner.left(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 8 /* Right */: {
                    return DataLabelPointPositioner.right(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 32 /* BelowLeft */: {
                    return DataLabelPointPositioner.belowLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 16 /* BelowRight */: {
                    return DataLabelPointPositioner.belowRight(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 128 /* AboveLeft */: {
                    return DataLabelPointPositioner.aboveLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 64 /* AboveRight */: {
                    return DataLabelPointPositioner.aboveRight(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 256 /* Center */: {
                    return DataLabelPointPositioner.center(labelSize, parentPoint.point);
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return null;
        }
        DataLabelPointPositioner.getLabelRect = getLabelRect;
        function above(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.above = above;
        function below(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.below = below;
        function left(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - offset - labelSize.width,
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.left = left;
        function right(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + offset,
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.right = right;
        function belowLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.belowLeft = belowLeft;
        function belowRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.belowRight = belowRight;
        function aboveLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.aboveLeft = aboveLeft;
        function aboveRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.aboveRight = aboveRight;
        function center(labelSize, parentPoint) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.center = center;
        function getLabelLeaderLineEndingPoint(boundingBox, position, parentShape) {
            var x = boundingBox.left;
            var y = boundingBox.top;
            switch (position) {
                case 1 /* Above */:
                    x += (boundingBox.width / 2);
                    y += boundingBox.height;
                    break;
                case 2 /* Below */:
                    x += (boundingBox.width / 2);
                    break;
                case 4 /* Left */:
                    x += boundingBox.width;
                    y += ((boundingBox.height * 2) / 3);
                    break;
                case 8 /* Right */:
                    y += ((boundingBox.height * 2) / 3);
                    break;
                case 32 /* BelowLeft */:
                    x += boundingBox.width;
                    y += (boundingBox.height / 2);
                    break;
                case 16 /* BelowRight */:
                    y += (boundingBox.height / 2);
                    break;
                case 128 /* AboveLeft */:
                    x += boundingBox.width;
                    y += boundingBox.height;
                    break;
                case 64 /* AboveRight */:
                    y += boundingBox.height;
                    break;
            }
            return [[parentShape.point.x, parentShape.point.y], [x, y]];
        }
        DataLabelPointPositioner.getLabelLeaderLineEndingPoint = getLabelLeaderLineEndingPoint;
    })(DataLabelPointPositioner = powerbi.DataLabelPointPositioner || (powerbi.DataLabelPointPositioner = {}));
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var LabelUtils = powerbi.visuals.LabelUtils;
    var DefaultCentroidOffset = 5;
    var OffsetDelta = 10;
    var MaximumOffset = 60;
    var stemExtension = 5;
    var FilledMapLabelLayout = /** @class */ (function () {
        function FilledMapLabelLayout() {
        }
        FilledMapLabelLayout.prototype.layout = function (labelDataPoints, viewport, polygonInfoTransform, redrawDataLabels) {
            var labelDataPointsLayoutInfo = _.map(labelDataPoints, (function (labelDataPoint) { return ({ labelDataPoint: labelDataPoint }); }));
            if (redrawDataLabels || this.labels === undefined) {
                var labelDataPointsGroup = {
                    labelDataPoints: labelDataPointsLayoutInfo,
                    maxNumberOfLabels: labelDataPointsLayoutInfo.length
                };
                for (var _i = 0, labelDataPointsLayoutInfo_3 = labelDataPointsLayoutInfo; _i < labelDataPointsLayoutInfo_3.length; _i++) {
                    var labelDataPointLayoutInfo = labelDataPointsLayoutInfo_3[_i];
                    var labelPoint = labelDataPointLayoutInfo.labelDataPoint;
                    labelDataPointLayoutInfo.labelSize = {
                        width: labelPoint.textSize.width + 2 * LabelUtils.horizontalLabelBackgroundPadding,
                        height: labelPoint.textSize.height + 2 * LabelUtils.verticalLabelBackgroundPadding,
                    };
                }
                var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
                var resultingDataLabels = [];
                var allPolygons = [];
                for (var _a = 0, labelDataPoints_3 = labelDataPoints; _a < labelDataPoints_3.length; _a++) {
                    var labelPoint = labelDataPoints_3[_a];
                    var polygon = labelPoint.parentShape.polygon;
                    allPolygons.push(polygon);
                    polygon.pixelBoundingRect = polygonInfoTransform.applyToRect(polygon.absoluteBoundingRect());
                }
                var shapesgrid = new LabelPolygonArrangeGrid(allPolygons, viewport);
                for (var _b = 0, labelDataPoints_4 = labelDataPoints; _b < labelDataPoints_4.length; _b++) {
                    var labelPoint = labelDataPoints_4[_b];
                    var dataLabel = this.getLabelByPolygonPositions(labelPoint, polygonInfoTransform, grid, shapesgrid);
                    if (dataLabel != null) {
                        resultingDataLabels.push(dataLabel);
                    }
                }
                this.labels = resultingDataLabels;
            }
            else {
                this.updateLabelOffsets(polygonInfoTransform);
            }
            return _.filter(this.labels, (function (d) { return d.isVisible; }));
        };
        FilledMapLabelLayout.prototype.getLabelPolygon = function (mapDataPoint, position, pointPosition, offset) {
            var dataPointSize = {
                width: mapDataPoint.textSize.width,
                height: (mapDataPoint.textSize.height)
            };
            return this.getLabelBoundingBox(dataPointSize, position, pointPosition, offset);
        };
        FilledMapLabelLayout.prototype.getLabelBoundingBox = function (dataPointSize, position, pointPosition, offset) {
            switch (position) {
                case 1 /* Above */: {
                    return powerbi.DataLabelPointPositioner.above(dataPointSize, pointPosition, offset);
                }
                case 2 /* Below */: {
                    return powerbi.DataLabelPointPositioner.below(dataPointSize, pointPosition, offset);
                }
                case 4 /* Left */: {
                    return powerbi.DataLabelPointPositioner.left(dataPointSize, pointPosition, offset);
                }
                case 8 /* Right */: {
                    return powerbi.DataLabelPointPositioner.right(dataPointSize, pointPosition, offset);
                }
                case 128 /* AboveLeft */: {
                    return powerbi.DataLabelPointPositioner.aboveLeft(dataPointSize, pointPosition, offset);
                }
                case 64 /* AboveRight */: {
                    return powerbi.DataLabelPointPositioner.aboveRight(dataPointSize, pointPosition, offset);
                }
                case 32 /* BelowLeft */: {
                    return powerbi.DataLabelPointPositioner.belowLeft(dataPointSize, pointPosition, offset);
                }
                case 16 /* BelowRight */: {
                    return powerbi.DataLabelPointPositioner.belowRight(dataPointSize, pointPosition, offset);
                }
                case 256 /* Center */: {
                    return powerbi.DataLabelPointPositioner.center(dataPointSize, pointPosition);
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return null;
        };
        FilledMapLabelLayout.prototype.getLabelByPolygonPositions = function (labelPoint, polygonInfoTransform, grid, shapesGrid) {
            var offset = 0;
            var inverseTransorm = polygonInfoTransform.getInverse();
            for (var i = 0; i < 2; i++) {
                if (i === 1) {
                    offset = DefaultCentroidOffset;
                }
                for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                    var position = _a[_i];
                    var resultingAbsoluteBoundingBox = this.tryPositionForPolygonPosition(position, labelPoint, polygonInfoTransform, offset, inverseTransorm);
                    if (position === 256 /* Center */ && i !== 0) {
                        continue;
                    }
                    if (resultingAbsoluteBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsoluteBoundingBox);
                        var dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: true,
                            fontProperties: { color: labelPoint.insideFill },
                            identity: null,
                            selected: false,
                            hasBackground: true,
                            textAnchor: "middle",
                            originalPixelOffset: offset,
                            isPlacedInsidePolygon: true,
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsoluteBoundingBox.left + resultingAbsoluteBoundingBox.width / 2,
                                y: resultingAbsoluteBoundingBox.top + resultingAbsoluteBoundingBox.height / 2
                            }
                        };
                        return dataLabel;
                    }
                }
            }
            var currentOffset = 6;
            while (currentOffset <= MaximumOffset) {
                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    if (position === 256 /* Center */) {
                        continue;
                    }
                    var polygon = labelPoint.parentShape.polygon;
                    var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
                    var resultingAbsolutBoundingBox = this.tryPlaceLabelOutsidePolygon(grid, position, labelPoint, currentOffset, pixelCentroid, shapesGrid, inverseTransorm);
                    if (resultingAbsolutBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsolutBoundingBox);
                        var dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: true,
                            fontProperties: { color: labelPoint.insideFill },
                            identity: null,
                            selected: false,
                            hasBackground: true,
                            isPlacedInsidePolygon: false,
                            textAnchor: "middle",
                            originalPixelOffset: currentOffset,
                            originalPosition: position,
                            originalAbsoluteCentroid: polygon.absoluteCentroid(),
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsolutBoundingBox.left + resultingAbsolutBoundingBox.width / 2,
                                y: resultingAbsolutBoundingBox.top + resultingAbsolutBoundingBox.height / 2
                            }
                        };
                        var pixelStemSource = this.calculateStemSource(polygonInfoTransform, inverseTransorm, polygon, resultingBoundingBox, position, pixelCentroid);
                        dataLabel.leaderLinePoints = this.setLeaderLinePoints(pixelStemSource, this.calculateStemDestination(resultingBoundingBox, position));
                        dataLabel.absoluteStemSource = inverseTransorm.applyToPoint(pixelStemSource);
                        grid.add(resultingBoundingBox);
                        return dataLabel;
                    }
                }
                currentOffset += OffsetDelta;
            }
            return null;
        };
        FilledMapLabelLayout.prototype.setLeaderLinePoints = function (stemSource, stemDestination) {
            return [[stemSource.x, stemSource.y], [stemDestination.x, stemDestination.y]];
        };
        FilledMapLabelLayout.prototype.calculateStemSource = function (polygonInfoTransform, inverseTransorm, polygon, labelBoundingBox, position, pixelCentroid) {
            var absoluteStemSource = polygon.lineIntersectionPoint(polygon.absoluteCentroid(), inverseTransorm.applyToPoint({ x: labelBoundingBox.left + labelBoundingBox.width / 2, y: labelBoundingBox.top + labelBoundingBox.height / 2 }));
            if (absoluteStemSource == null) {
                return pixelCentroid;
            }
            var stemSource = polygonInfoTransform.applyToPoint(absoluteStemSource);
            switch (position) {
                case 1 /* Above */: {
                    stemSource.y += stemExtension;
                    break;
                }
                case 2 /* Below */: {
                    stemSource.y -= stemExtension;
                    break;
                }
                case 4 /* Left */: {
                    stemSource.x += stemExtension;
                    break;
                }
                case 8 /* Right */: {
                    stemSource.x -= stemExtension;
                    break;
                }
                case 128 /* AboveLeft */: {
                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 64 /* AboveRight */: {
                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 32 /* BelowLeft */: {
                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 16 /* BelowRight */: {
                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 256 /* Center */: {
                    break;
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return stemSource;
        };
        FilledMapLabelLayout.prototype.calculateStemDestination = function (labelBoundingBox, position) {
            var x;
            var y;
            switch (position) {
                case 1 /* Above */: {
                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 2 /* Below */: {
                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
                    y = labelBoundingBox.top;
                    break;
                }
                case 4 /* Left */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;
                }
                case 8 /* Right */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;
                }
                case 128 /* AboveLeft */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 64 /* AboveRight */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 32 /* BelowLeft */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top;
                    break;
                }
                case 16 /* BelowRight */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top;
                    break;
                }
                case 256 /* Center */: {
                    break;
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return { x: x, y: y };
        };
        FilledMapLabelLayout.prototype.tryPositionForPolygonPosition = function (position, labelDataPoint, polygonInfoTransform, offset, inverseTransorm) {
            var polygon = labelDataPoint.parentShape.polygon;
            var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offset);
            var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransorm, labelRect);
            return polygon.contains(absoluteLabelRect) ? absoluteLabelRect : null;
        };
        /**
        * Tests a particular position/offset combination for the given data label.
        * If the label can be placed, returns the resulting bounding box for the data
        * label.  If not, returns null.
        */
        FilledMapLabelLayout.prototype.tryPlaceLabelOutsidePolygon = function (grid, position, labelDataPoint, offset, pixelCentroid, shapesGrid, inverseTransform) {
            var offsetForPosition = offset;
            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offsetForPosition);
            var otherLabelsConflict = grid.hasConflict(labelRect);
            if (!otherLabelsConflict) {
                var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransform, labelRect);
                if (!shapesGrid.hasConflict(absoluteLabelRect, labelRect))
                    return absoluteLabelRect;
            }
            return null;
        };
        FilledMapLabelLayout.prototype.updateLabelOffsets = function (polygonInfoTransform) {
            for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                if (!label.isVisible)
                    continue;
                if (label.isPlacedInsidePolygon) {
                    var newOffset = polygonInfoTransform.applyToPoint(label.absoluteBoundingBoxCenter);
                    var xDelta = (label.boundingBox.left + label.boundingBox.width / 2) - newOffset.x;
                    var yDelta = (label.boundingBox.top + label.boundingBox.height / 2) - newOffset.y;
                    label.boundingBox.top -= yDelta;
                    label.boundingBox.left -= xDelta;
                }
                else {
                    var stemSourcePoint = polygonInfoTransform.applyToPoint(label.absoluteStemSource);
                    var pixelCentroid = polygonInfoTransform.applyToPoint(label.originalAbsoluteCentroid);
                    label.boundingBox = this.getLabelBoundingBox({ width: label.boundingBox.width, height: label.boundingBox.height }, label.originalPosition, pixelCentroid, label.originalPixelOffset);
                    if (label.leaderLinePoints !== undefined)
                        label.leaderLinePoints = this.setLeaderLinePoints(stemSourcePoint, this.calculateStemDestination(label.boundingBox, label.originalPosition));
                }
            }
        };
        FilledMapLabelLayout.prototype.getAbsoluteRectangle = function (inverseTransorm, rect) {
            return inverseTransorm.applyToRect(rect);
        };
        return FilledMapLabelLayout;
    }());
    powerbi.FilledMapLabelLayout = FilledMapLabelLayout;
    var LabelPolygonArrangeGrid = /** @class */ (function () {
        function LabelPolygonArrangeGrid(polygons, viewport) {
            this.viewport = viewport;
            var maxPolygonWidth = 0;
            var maxPolygonHeight = 0;
            for (var _i = 0, polygons_1 = polygons; _i < polygons_1.length; _i++) {
                var polygon = polygons_1[_i];
                var polygonSize = polygon.pixelBoundingRect;
                if (polygonSize.width > maxPolygonWidth) {
                    maxPolygonWidth = polygonSize.width;
                }
                if (polygonSize.height > maxPolygonHeight) {
                    maxPolygonHeight = polygonSize.height;
                }
            }
            if (maxPolygonWidth === 0) {
                maxPolygonWidth = viewport.width;
            }
            if (maxPolygonHeight === 0) {
                maxPolygonHeight = viewport.height;
            }
            var cellSize = this.cellSize = { width: maxPolygonWidth * LabelPolygonArrangeGrid.cellSizeMultiplier, height: maxPolygonHeight * LabelPolygonArrangeGrid.cellSizeMultiplier };
            this.columnCount = LabelPolygonArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
            this.rowCount = LabelPolygonArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            var grid = [];
            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
                    grid[i][j] = [];
                }
            }
            this.grid = grid;
            for (var _a = 0, polygons_2 = polygons; _a < polygons_2.length; _a++) {
                var polygon = polygons_2[_a];
                this.add(polygon);
            }
        }
        LabelPolygonArrangeGrid.prototype.hasConflict = function (absolutLabelRect, pixelLabelRect) {
            var containingIndexRect = this.getContainingGridSubsection(pixelLabelRect);
            var grid = this.grid;
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var currentPolygon = _a[_i];
                        if (currentPolygon.conflicts(absolutLabelRect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        LabelPolygonArrangeGrid.prototype.add = function (polygon) {
            var containingIndexRect = this.getContainingGridSubsection(polygon.pixelBoundingRect);
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    this.grid[x][y].push(polygon);
                }
            }
        };
        LabelPolygonArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
            return {
                xMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
            };
        };
        LabelPolygonArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
            return LabelPolygonArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        };
        LabelPolygonArrangeGrid.bound = function (value, min, max) {
            return Math.max(Math.min(value, max), min);
        };
        /**
         * A multiplier applied to the largest width height to attempt to balance # of
         * polygons in each cell and number of cells each polygon belongs to
         */
        LabelPolygonArrangeGrid.cellSizeMultiplier = 2;
        return LabelPolygonArrangeGrid;
    }());
    powerbi.LabelPolygonArrangeGrid = LabelPolygonArrangeGrid;
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var FormattingStrategies;
        (function (FormattingStrategies) {
            function defaultFormatter(formatStringProp) {
                return function (value, source) { return visuals.converterHelper.formatFromMetadataColumn(value, source, formatStringProp, /* suppressTypeFallback */ true); };
            }
            FormattingStrategies.defaultFormatter = defaultFormatter;
            function fallbackBasedOnType(formatStringProp) {
                return function (value, source) { return visuals.converterHelper.formatFromMetadataColumn(value, source, formatStringProp, /* suppressTypeFallback */ false); };
            }
            FormattingStrategies.fallbackBasedOnType = fallbackBasedOnType;
        })(FormattingStrategies = visuals.FormattingStrategies || (visuals.FormattingStrategies = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataViewTransform = powerbi.data.DataViewTransform;
        var BeautifiedFormat = {
            '0.00 %;-0.00 %;0.00 %': 'Percentage',
            '0.0 %;-0.0 %;0.0 %': 'Percentage1',
        };
        var defaultLocalizedStrings = {
            'NullValue': '(Blank)',
            'BooleanTrue': 'True',
            'BooleanFalse': 'False',
            'NaNValue': 'NaN',
            'InfinityValue': '+Infinity',
            'NegativeInfinityValue': '-Infinity',
            'Restatement_Comma': '{0}, {1}',
            'Restatement_CompoundAnd': '{0} and {1}',
            'DisplayUnitSystem_EAuto_Title': 'Auto',
            'DisplayUnitSystem_E0_Title': 'None',
            'DisplayUnitSystem_E3_LabelFormat': '{0}K',
            'DisplayUnitSystem_E3_Title': 'Thousands',
            'DisplayUnitSystem_E6_LabelFormat': '{0}M',
            'DisplayUnitSystem_E6_Title': 'Millions',
            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
            'DisplayUnitSystem_E9_Title': 'Billions',
            'DisplayUnitSystem_E12_LabelFormat': '{0}T',
            'DisplayUnitSystem_E12_Title': 'Trillions',
            'Percentage': '#,0.##%',
            'Percentage1': '#,0.#%',
            'RichTextbox_Link_DefaultText': 'Link',
            'RichTextbox_Link_ToolTip': 'Insert link',
            'TableTotalLabel': 'Total',
            'ListJoin_Separator': ', ',
            'Tooltip_HighlightedValueDisplayName': 'Highlighted',
            'Funnel_PercentOfFirst': 'Percent of first',
            'Funnel_PercentOfPrevious': 'Percent of previous',
            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',
            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',
            'Waterfall_BreakdownDifferenceTooltip': 'Difference in {0}',
            'Waterfall_OtherLabel': 'Other',
            // Geotagging strings
            'GeotaggingString_Continent': 'continent',
            'GeotaggingString_Continents': 'continents',
            'GeotaggingString_Country': 'country',
            'GeotaggingString_Countries': 'countries',
            'GeotaggingString_State': 'state',
            'GeotaggingString_States': 'states',
            'GeotaggingString_City': 'city',
            'GeotaggingString_Cities': 'cities',
            'GeotaggingString_Town': 'town',
            'GeotaggingString_Towns': 'towns',
            'GeotaggingString_Province': 'province',
            'GeotaggingString_Provinces': 'provinces',
            'GeotaggingString_County': 'county',
            'GeotaggingString_Counties': 'counties',
            'GeotaggingString_Village': 'village',
            'GeotaggingString_Villages': 'villages',
            'GeotaggingString_Post': 'post',
            'GeotaggingString_Zip': 'zip',
            'GeotaggingString_Code': 'code',
            'GeotaggingString_Place': 'place',
            'GeotaggingString_Places': 'places',
            'GeotaggingString_Address': 'address',
            'GeotaggingString_Addresses': 'addresses',
            'GeotaggingString_Street': 'street',
            'GeotaggingString_Streets': 'streets',
            'GeotaggingString_Longitude': 'longitude',
            'GeotaggingString_Longitude_Short': 'lon',
            'GeotaggingString_Longitude_Short2': 'long',
            'GeotaggingString_Latitude': 'latitude',
            'GeotaggingString_Latitude_Short': 'lat',
            'GeotaggingString_PostalCode': 'postal code',
            'GeotaggingString_PostalCodes': 'postal codes',
            'GeotaggingString_ZipCode': 'zip code',
            'GeotaggingString_ZipCodes': 'zip codes',
            'GeotaggingString_Territory': 'territory',
            'GeotaggingString_Territories': 'territories',
            'Waterfall_IncreaseLabel': 'Increase',
            'Waterfall_DecreaseLabel': 'Decrease',
            'Waterfall_TotalLabel': 'Total',
            'Slicer_SelectAll': 'Select All',
            'Visual_Quarter_Abbreviated': 'Qtr {0}',
        };
        var DefaultVisualHostServices = /** @class */ (function () {
            function DefaultVisualHostServices() {
                this.instanceId = undefined;
            }
            // TODO: Add locale-awareness to this host service. Currently default/english functionality only.
            DefaultVisualHostServices.initialize = function () {
                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions());
                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
                DataViewTransform.setLocalizationOptions(DefaultVisualHostServices.createDataViewTransformLocalizationOptions());
            };
            /**
             * Create locale options.
             *
             * Note: Public for testability.
             */
            DefaultVisualHostServices.createLocaleOptions = function () {
                return {
                    null: defaultLocalizedStrings['NullValue'],
                    true: defaultLocalizedStrings['BooleanTrue'],
                    false: defaultLocalizedStrings['BooleanFalse'],
                    NaN: defaultLocalizedStrings['NaNValue'],
                    infinity: defaultLocalizedStrings['InfinityValue'],
                    negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                    beautify: function (format) { return DefaultVisualHostServices.beautify(format); },
                    describe: function (exponent) { return DefaultVisualHostServices.describeUnit(exponent); },
                    restatementComma: defaultLocalizedStrings['Restatement_Comma'],
                    restatementCompoundAnd: defaultLocalizedStrings['Restatement_CompoundAnd'],
                    restatementCompoundOr: defaultLocalizedStrings['Restatement_CompoundOr']
                };
            };
            DefaultVisualHostServices.createTooltipLocaleOptions = function () {
                return {
                    highlightedValueDisplayName: defaultLocalizedStrings['Tooltip_HighlightedValueDisplayName']
                };
            };
            DefaultVisualHostServices.createDataViewTransformLocalizationOptions = function () {
                return {
                    quarterPrefix: defaultLocalizedStrings['Visual_Quarter_Abbreviated']
                };
            };
            DefaultVisualHostServices.prototype.getLocalizedString = function (stringId) {
                return defaultLocalizedStrings[stringId];
            };
            // NO-OP IHostServices methods
            DefaultVisualHostServices.prototype.onDragStart = function () { };
            DefaultVisualHostServices.prototype.canSelect = function () { return false; };
            DefaultVisualHostServices.prototype.onSelecting = function (args) { args.action = 0 /* Selection */; };
            DefaultVisualHostServices.prototype.onSelect = function () { };
            DefaultVisualHostServices.prototype.onContextMenu = function () { };
            DefaultVisualHostServices.prototype.loadMoreData = function () { };
            DefaultVisualHostServices.prototype.persistProperties = function (changes) { };
            DefaultVisualHostServices.prototype.onCustomSort = function (args) { };
            DefaultVisualHostServices.prototype.getViewMode = function () { return 0 /* View */; };
            DefaultVisualHostServices.prototype.getEditMode = function () { return 0 /* Default */; };
            DefaultVisualHostServices.prototype.setWarnings = function (warnings) { };
            DefaultVisualHostServices.prototype.setToolbar = function ($toolbar) { };
            DefaultVisualHostServices.prototype.shouldRetainSelection = function () { return false; };
            DefaultVisualHostServices.prototype.geocoder = function () { return visuals.services.createGeocoder(); };
            DefaultVisualHostServices.prototype.geolocation = function () { return visuals.services.createGeolocation(); };
            DefaultVisualHostServices.prototype.promiseFactory = function () { return powerbi.createJQueryPromiseFactory(); };
            DefaultVisualHostServices.prototype.visualCapabilitiesChanged = function () { };
            DefaultVisualHostServices.prototype.analyzeFilter = function (options) {
                return {
                    isNotFilter: false,
                    selectedIdentities: [],
                    filter: undefined,
                    defaultValue: undefined,
                };
            };
            DefaultVisualHostServices.prototype.getIdentityDisplayNames = function (dentities) { return; };
            DefaultVisualHostServices.prototype.setIdentityDisplayNames = function (displayNamesIdentityPairs) { };
            DefaultVisualHostServices.prototype.tooltips = function () { return; };
            DefaultVisualHostServices.prototype.telemetry = function () { return; };
            DefaultVisualHostServices.prototype.authenticationService = function () { return; };
            DefaultVisualHostServices.prototype.locale = function () { return navigator.language; };
            DefaultVisualHostServices.prototype.allowInteractions = function () { return true; };
            DefaultVisualHostServices.prototype.loader = function () { return powerbi.createModuleLoader(this.promiseFactory(), _.noop, /*config*/ null); };
            DefaultVisualHostServices.prototype.getUIComponentFactory = function () { return null; };
            DefaultVisualHostServices.prototype.applyJsonFilter = function (filter, objectName, propertyName, action) { return; };
            DefaultVisualHostServices.prototype.launchUrl = function (url) { return; };
            DefaultVisualHostServices.prototype.refreshHostData = function () { };
            DefaultVisualHostServices.beautify = function (format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            };
            DefaultVisualHostServices.describeUnit = function (exponent) {
                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            };
            return DefaultVisualHostServices;
        }());
        visuals.DefaultVisualHostServices = DefaultVisualHostServices;
        visuals.defaultVisualHostServices = new DefaultVisualHostServices();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var SemanticFilter = powerbi.data.SemanticFilter;
        /**
         * Factory method to create an IInteractivityService instance.
         */
        function createInteractivityService(hostServices) {
            return new InteractivityService(hostServices);
        }
        visuals.createInteractivityService = createInteractivityService;
        /**
         * Creates a clear an svg rect to catch clear clicks.
         */
        function appendClearCatcher(selection) {
            return selection
                .append("rect")
                .classed("clearCatcher", true)
                .attr({ width: "100%", height: "100%" });
        }
        visuals.appendClearCatcher = appendClearCatcher;
        function isCategoryColumnSelected(propertyId, categories, idx) {
            return categories.objects != null
                && categories.objects[idx]
                && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
        }
        visuals.isCategoryColumnSelected = isCategoryColumnSelected;
        function dataHasSelection(data) {
            for (var i = 0, ilen = data.length; i < ilen; i++) {
                if (data[i].selected)
                    return true;
            }
            return false;
        }
        visuals.dataHasSelection = dataHasSelection;
        var InteractivityService = /** @class */ (function () {
            function InteractivityService(hostServices) {
                this.renderSelectionInVisual = _.noop;
                this.renderSelectionInLegend = _.noop;
                this.renderSelectionInLabels = _.noop;
                // Selection state
                this.selectedIds = [];
                this.isInvertedSelectionMode = false;
                this.dataPointObjectName = 'dataPoint';
                debug.assertValue(hostServices, 'hostServices');
                this.hostService = hostServices;
            }
            // IInteractivityService Implementation
            /** Binds the vsiual to the interactivityService */
            InteractivityService.prototype.bind = function (dataPoints, behavior, behaviorOptions, options) {
                var _this = this;
                // Bind the data
                if (options && options.overrideSelectionFromData) {
                    // Override selection state from data points if needed
                    this.takeSelectionStateFromDataPoints(dataPoints);
                }
                if (options) {
                    if (options.isLegend) {
                        // Bind to legend data instead of normal data if isLegend
                        this.selectableLegendDataPoints = dataPoints;
                        this.renderSelectionInLegend = function () { return behavior.renderSelection(_this.legendHasSelection()); };
                    }
                    else if (options.isLabels) {
                        //Bind to label data instead of normal data if isLabels
                        this.selectableLabelsDataPoints = dataPoints;
                        this.renderSelectionInLabels = function () { return behavior.renderSelection(_this.labelsHasSelection()); };
                    }
                    else {
                        this.selectableDataPoints = dataPoints;
                        this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
                    }
                    if (options.hasSelectionOverride != null)
                        this.hasSelectionOverride = options.hasSelectionOverride;
                    if (options.slicerValueHandler)
                        this.slicerValueHandler = options.slicerValueHandler;
                }
                else {
                    this.selectableDataPoints = dataPoints;
                    this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
                }
                // Bind to the behavior
                this.behavior = behavior;
                behavior.bindEvents(behaviorOptions, this);
                // Sync data points with current selection state
                this.syncSelectionState();
            };
            /**
             * Sets the selected state of all selectable data points to false, clears any inverted selection mode,
             * and re-renders selection.
             */
            InteractivityService.prototype.clearSelection = function () {
                this.clearSelectionInternal();
                this.renderAll();
            };
            /**
             * Clears the selected state of all selectable data points to false and clears any inverted selection mode
             * (does not re-render)
             */
            InteractivityService.prototype.clearSelectionInternal = function () {
                // if default value is already applied, don't clear the default selection
                if (this.slicerValueHandler && this.slicerValueHandler.getDefaultValue() && this.useDefaultValue) {
                    this.isInvertedSelectionMode = false;
                    return;
                }
                this.hasSelectionOverride = undefined;
                ArrayExtensions.clear(this.selectedIds);
                this.isInvertedSelectionMode = false;
                this.applyToAllSelectableDataPoints((function (dataPoint) { return dataPoint.selected = false; }));
            };
            InteractivityService.prototype.applySelectionStateToData = function (dataPoints) {
                for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var dataPoint = dataPoints_2[_i];
                    dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
                }
                return this.hasSelection();
            };
            /**
             * Checks whether there is at least one item selected.
             */
            InteractivityService.prototype.hasSelection = function () {
                return this.selectedIds.length > 0;
            };
            InteractivityService.prototype.legendHasSelection = function () {
                return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : false;
            };
            InteractivityService.prototype.labelsHasSelection = function () {
                return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : false;
            };
            InteractivityService.prototype.isSelectionModeInverted = function () {
                return this.isInvertedSelectionMode;
            };
            InteractivityService.prototype.setSelectionModeInverted = function (inverted) {
                this.isInvertedSelectionMode = inverted;
            };
            // ISelectionHandler Implementation
            InteractivityService.prototype.handleSelection = function (dataPoint, multiSelect, position) {
                // defect 7067397: should not happen so assert but also don't continue as it's
                // causing a lot of error telemetry in desktop.
                debug.assertValue(dataPoint, 'dataPoint');
                if (!dataPoint)
                    return;
                var selectingSelectorsByColumn;
                if (dataPoint.specificIdentity) {
                    selectingSelectorsByColumn = dataPoint.specificIdentity.getSelectorsByColumn();
                }
                else if (dataPoint.identity) {
                    selectingSelectorsByColumn = dataPoint.identity.getSelectorsByColumn();
                }
                var selectingArgs = {
                    visualObjects: [{
                            objectName: this.dataPointObjectName,
                            selectorsByColumn: selectingSelectorsByColumn,
                        }],
                    position: position
                };
                if (!_.isEmpty(selectingSelectorsByColumn)) {
                    this.hostService.onSelecting(selectingArgs);
                }
                if (selectingArgs.action === 0 /* Selection */ || selectingArgs.action == null) {
                    if (!dataPoint.identity) {
                        this.handleClearSelection();
                    }
                    else {
                        this.useDefaultValue = false;
                        this.select(dataPoint, multiSelect);
                        this.sendSelectionToHost();
                        this.renderAll();
                    }
                }
            };
            InteractivityService.prototype.handleMultipleSelection = function (dataPoints, mode) {
                this.useDefaultValue = false;
                this.selectMultiple(dataPoints, mode);
                this.sendSelectionToHost();
                this.renderAll();
            };
            InteractivityService.prototype.handleContextMenu = function (dataPoint, point) {
                this.sendContextMenuToHost(dataPoint, point);
            };
            InteractivityService.prototype.handleClearSelection = function () {
                this.useDefaultValue = true;
                this.clearSelection();
                this.sendSelectionToHost();
            };
            InteractivityService.prototype.toggleSelectionModeInversion = function () {
                this.useDefaultValue = false;
                this.isInvertedSelectionMode = !this.isInvertedSelectionMode;
                ArrayExtensions.clear(this.selectedIds);
                this.applyToAllSelectableDataPoints((function (dataPoint) { return dataPoint.selected = false; }));
                this.sendSelectionToHost();
                this.isInvertedSelectionMode ? this.syncSelectionStateInverted() : this.syncSelectionState();
                this.renderAll();
                return this.isInvertedSelectionMode;
            };
            InteractivityService.prototype.persistSelectionFilter = function (filterPropertyIdentifier) {
                this.hostService.persistProperties(InteractivityService.createChangeForFilterProperty(filterPropertyIdentifier, this.getFilterFromSelectors()));
            };
            InteractivityService.prototype.persistSelfFilter = function (filterPropertyIdentifier, selfFilter) {
                this.hostService.persistProperties(InteractivityService.createChangeForFilterProperty(filterPropertyIdentifier, selfFilter));
            };
            InteractivityService.prototype.setDefaultValueMode = function (useDefaultValue) {
                this.useDefaultValue = useDefaultValue;
            };
            InteractivityService.prototype.isDefaultValueEnabled = function () {
                return this.useDefaultValue;
            };
            InteractivityService.prototype.restoreSelection = function (selectorsByColumn) {
                this.clearSelection();
                this.selectedIds = _.map(selectorsByColumn, (function (selectorbyColumn) { return visuals.SelectionId.fromSelectorsByColumn(selectorbyColumn); }));
                this.syncSelectionState();
                this.renderAll();
                return this.selectedIds.length > 0;
            };
            // Private utility methods
            InteractivityService.prototype.renderAll = function () {
                this.renderSelectionInVisual();
                this.renderSelectionInLegend();
                this.renderSelectionInLabels();
            };
            InteractivityService.prototype.selectMultiple = function (dataPoints, mode) {
                debug.assert(!this.isInvertedSelectionMode, 'Inverted multi-select not supported.');
                if (mode === 0 /* Normal */ || mode === 2 /* Intersection */)
                    this.selectedIds = [];
                for (var _i = 0, dataPoints_3 = dataPoints; _i < dataPoints_3.length; _i++) {
                    var dataPoint = dataPoints_3[_i];
                    var id = dataPoint.identity;
                    if (id.highlight)
                        continue;
                    if (mode === 1 /* Union */ || mode === 0 /* Normal */) {
                        dataPoint.selected = true;
                        this.selectedIds.push(id);
                    }
                    else if (mode === 3 /* Difference */) {
                        dataPoint.selected = false;
                        this.removeId(id);
                    }
                    else if (mode === 2 /* Intersection */) {
                        if (dataPoint.selected)
                            this.selectedIds.push(id);
                    }
                }
                if (mode === 2 /* Intersection */) {
                    for (var _a = 0, _b = this.selectableDataPoints; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if (!_.contains(this.selectedIds, dataPoint.identity))
                            dataPoint.selected = false;
                    }
                }
                this.syncSelectionState();
            };
            /** Marks a data point as selected and syncs selection with the host. */
            InteractivityService.prototype.select = function (d, multiSelect) {
                // If we're in inverted mode, use the invertedSelect instead
                if (this.isInvertedSelectionMode) {
                    return this.selectInverted(d, multiSelect);
                }
                // For highlight data points we actually want to select the non-highlight data point
                if (d.identity && d.identity.highlight) {
                    d = _.find(this.selectableDataPoints, (function (dp) { return !dp.identity.highlight && d.identity.includes(dp.identity, /* ignoreHighlight */ true); }));
                    debug.assertValue(d, 'Expected to find a non-highlight data point');
                }
                var id = d.identity;
                if (!id)
                    return;
                var selected = !d.selected || (!multiSelect && this.selectedIds.length > 1);
                // If we have a multiselect flag, we attempt a multiselect
                if (multiSelect) {
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                        if (id.hasIdentity()) {
                            this.removeSelectionIdsWithOnlyMeasures();
                        }
                        else {
                            this.removeSelectionIdsExceptOnlyMeasures();
                        }
                    }
                    else {
                        d.selected = false;
                        this.removeId(id);
                    }
                }
                // We do a single select if we didn't do a multiselect or if we find out that the multiselect is invalid.
                if (!multiSelect || !this.hostService.canSelect(this.createSelectEventArgs(this.selectedIds))) {
                    this.clearSelectionInternal();
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                }
                this.syncSelectionState();
            };
            InteractivityService.prototype.selectInverted = function (d, multiSelect) {
                var wasSelected = d.selected;
                var id = d.identity;
                debug.assert(!!multiSelect, "inverted selections are only supported in multiselect mode");
                // the current datapoint state has to be inverted
                d.selected = !wasSelected;
                if (wasSelected) {
                    this.removeId(id);
                }
                else {
                    this.selectedIds.push(id);
                    if (id.hasIdentity()) {
                        this.removeSelectionIdsWithOnlyMeasures();
                    }
                    else {
                        this.removeSelectionIdsExceptOnlyMeasures();
                    }
                }
                this.syncSelectionStateInverted();
            };
            InteractivityService.prototype.removeId = function (toRemove) {
                var selectedIds = this.selectedIds;
                for (var i = selectedIds.length - 1; i > -1; i--) {
                    var currentId = selectedIds[i];
                    if (toRemove.includes(currentId))
                        selectedIds.splice(i, 1);
                }
            };
            InteractivityService.prototype.getFilterFromSelectors = function () {
                var selectors = [];
                if (this.selectedIds.length > 0) {
                    selectors = _.chain(this.selectedIds)
                        .filter((function (value) { return value.hasIdentity(); }))
                        .map((function (value) { return value.getSelector(); }))
                        .value();
                }
                var filter = powerbi.data.Selector.filterFromSelector(selectors, this.isInvertedSelectionMode);
                if (this.slicerValueHandler && this.slicerValueHandler.getDefaultValue()) {
                    // we explicitly check for true/false because undefine means no default value
                    if (this.useDefaultValue === true)
                        filter = SemanticFilter.getDefaultValueFilter(this.slicerValueHandler.getIdentityFields());
                    else if (_.isEmpty(selectors))
                        filter = SemanticFilter.getAnyValueFilter(this.slicerValueHandler.getIdentityFields());
                }
                return filter;
            };
            InteractivityService.createChangeForFilterProperty = function (filterPropertyIdentifier, filter) {
                var properties = {};
                var instance = {
                    objectName: filterPropertyIdentifier.objectName,
                    selector: undefined,
                    properties: properties
                };
                if (filter == null) {
                    properties[filterPropertyIdentifier.propertyName] = {};
                    return {
                        remove: [instance]
                    };
                }
                else {
                    properties[filterPropertyIdentifier.propertyName] = filter;
                    return {
                        merge: [instance]
                    };
                }
            };
            InteractivityService.prototype.sendContextMenuToHost = function (dataPoint, position) {
                var host = this.hostService;
                if (!host.onContextMenu)
                    return;
                var dataPointIdentity;
                if (dataPoint.specificIdentity) {
                    dataPointIdentity = dataPoint.specificIdentity;
                }
                else if (dataPoint.identity) {
                    dataPointIdentity = dataPoint.identity;
                }
                // If the user right-clicks one of multiple selected data points we want to use the identities of all the selected data points.
                var identities;
                if (!dataPointIdentity || (_.size(this.selectedIds) > 1 && _.any(this.selectedIds, (function (selectedId) { return selectedId.equals(dataPointIdentity); })))) {
                    identities = this.selectedIds;
                }
                else {
                    identities = [dataPointIdentity];
                }
                var selectorsByColumn = [];
                for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {
                    var identity = identities_1[_i];
                    var selectors = identity.getSelectorsByColumn();
                    if (_.isEmpty(selectors))
                        continue;
                    selectorsByColumn.push(selectors);
                }
                if (_.isEmpty(selectorsByColumn))
                    return;
                var args = {
                    data: selectorsByColumn,
                    position: position
                };
                host.onContextMenu(args);
            };
            InteractivityService.prototype.sendSelectionToHost = function () {
                var host = this.hostService;
                if (!this.slicerValueHandler && host.onSelect) {
                    var selectArgs = this.createSelectEventArgs(this.selectedIds);
                    host.onSelect(selectArgs);
                }
            };
            InteractivityService.prototype.createSelectEventArgs = function (selectedIds) {
                var shouldInsertSelectors = false;
                var dataPointObjectName = this.dataPointObjectName;
                if (!_.isEmpty(selectedIds)) {
                    shouldInsertSelectors = selectedIds[0].getSelector() && !selectedIds[0].getSelectorsByColumn();
                }
                var selectedIdsWithIdentities = _.chain(selectedIds)
                    .filter((function (value) { return value.hasIdentity(); }));
                var selectEventArgs = {
                    visualObjects: selectedIdsWithIdentities
                        .map((function (value) { return { objectName: dataPointObjectName, selectorsByColumn: value.getSelectorsByColumn() }; }))
                        .value(),
                };
                if (shouldInsertSelectors) {
                    selectEventArgs.selectors = selectedIdsWithIdentities
                        .map((function (value) { return value.getSelector(); }))
                        .value();
                }
                return selectEventArgs;
            };
            InteractivityService.prototype.takeSelectionStateFromDataPoints = function (dataPoints) {
                debug.assertValue(dataPoints, "dataPoints");
                var selectedIds = this.selectedIds;
                // Replace the existing selectedIds rather than merging.
                ArrayExtensions.clear(selectedIds);
                for (var _i = 0, dataPoints_4 = dataPoints; _i < dataPoints_4.length; _i++) {
                    var dataPoint = dataPoints_4[_i];
                    if (dataPoint.selected)
                        selectedIds.push(dataPoint.identity);
                }
            };
            /**
             * Syncs the selection state for all data points that have the same category. Returns
             * true if the selection state was out of sync and corrections were made; false if
             * the data is already in sync with the service.
             *
             * If the data is not compatible with the current service's current selection state,
             * the state is cleared and the cleared selection is sent to the host.
             *
             * Ignores series for now, since we don't support series selection at the moment.
             */
            InteractivityService.prototype.syncSelectionState = function () {
                if (this.isInvertedSelectionMode) {
                    return this.syncSelectionStateInverted();
                }
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                var foundMatchingId = false; // Checked only against the visual's data points; it's possible to have stuff selected in the visual that's not in the legend, but not vice-verse
                if (!selectableDataPoints && !selectableLegendDataPoints)
                    return;
                if (selectableDataPoints) {
                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds))
                        foundMatchingId = true;
                }
                if (selectableLegendDataPoints) {
                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableLegendDataPoints, selectedIds))
                        foundMatchingId = true;
                }
                if (selectableLabelsDataPoints) {
                    var labelsDataPoint_1;
                    for (var i = 0, ilen = selectableLabelsDataPoints.length; i < ilen; i++) {
                        labelsDataPoint_1 = selectableLabelsDataPoints[i];
                        if (selectedIds.some((function (value) { return value.includes(labelsDataPoint_1.identity); })))
                            labelsDataPoint_1.selected = true;
                        else
                            labelsDataPoint_1.selected = false;
                    }
                }
                if (!foundMatchingId && selectedIds.length > 0) {
                    this.clearSelection();
                    this.sendSelectionToHost();
                }
            };
            InteractivityService.prototype.syncSelectionStateInverted = function () {
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                if (!selectableDataPoints)
                    return;
                if (selectedIds.length === 0) {
                    for (var _i = 0, selectableDataPoints_1 = selectableDataPoints; _i < selectableDataPoints_1.length; _i++) {
                        var dataPoint_1 = selectableDataPoints_1[_i];
                        dataPoint_1.selected = false;
                    }
                }
                else {
                    for (var _a = 0, selectableDataPoints_2 = selectableDataPoints; _a < selectableDataPoints_2.length; _a++) {
                        var dataPoint = selectableDataPoints_2[_a];
                        if (selectedIds.some((function (value) { return value.includes(dataPoint.identity); })))
                            dataPoint.selected = true;
                        else if (dataPoint.selected)
                            dataPoint.selected = false;
                    }
                }
            };
            InteractivityService.prototype.applyToAllSelectableDataPoints = function (action) {
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                if (selectableDataPoints) {
                    for (var _i = 0, selectableDataPoints_3 = selectableDataPoints; _i < selectableDataPoints_3.length; _i++) {
                        var dataPoint = selectableDataPoints_3[_i];
                        action(dataPoint);
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var _a = 0, selectableLegendDataPoints_1 = selectableLegendDataPoints; _a < selectableLegendDataPoints_1.length; _a++) {
                        var dataPoint = selectableLegendDataPoints_1[_a];
                        action(dataPoint);
                    }
                }
                if (selectableLabelsDataPoints) {
                    for (var _b = 0, selectableLabelsDataPoints_1 = selectableLabelsDataPoints; _b < selectableLabelsDataPoints_1.length; _b++) {
                        var dataPoint = selectableLabelsDataPoints_1[_b];
                        action(dataPoint);
                    }
                }
            };
            InteractivityService.updateSelectableDataPointsBySelectedIds = function (selectableDataPoints, selectedIds) {
                var foundMatchingId = false;
                for (var _i = 0, selectableDataPoints_4 = selectableDataPoints; _i < selectableDataPoints_4.length; _i++) {
                    var dataPoint = selectableDataPoints_4[_i];
                    dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, selectedIds);
                    if (dataPoint.selected)
                        foundMatchingId = true;
                }
                return foundMatchingId;
            };
            InteractivityService.checkDatapointAgainstSelectedIds = function (datapoint, selectedIds) {
                return selectedIds.some((function (value) { return value.includes(datapoint.identity); }));
            };
            InteractivityService.prototype.removeSelectionIdsWithOnlyMeasures = function () {
                this.selectedIds = _.filter(this.selectedIds, (function (identity) { return identity.hasIdentity(); }));
            };
            InteractivityService.prototype.removeSelectionIdsExceptOnlyMeasures = function () {
                this.selectedIds = _.filter(this.selectedIds, (function (identity) { return !identity.hasIdentity(); }));
            };
            return InteractivityService;
        }());
        visuals.InteractivityService = InteractivityService;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            var CategoryTypes = visuals.MapUtil.CategoryTypes;
            var JQueryPromiseState = powerbi.JQueryPromiseState;
            var Settings = visuals.MapUtil.Settings;
            function createGeocoder() {
                return new DefaultGeocoder();
            }
            services.createGeocoder = createGeocoder;
            function isNotUpHierarchyMatchCode(matchCodes) {
                return !_.any(matchCodes, (function (code) { return code === "UpHierarchy"; }));
            }
            var BingMapsGeocoder = /** @class */ (function () {
                function BingMapsGeocoder() {
                }
                BingMapsGeocoder.prototype.geocode = function (location, options) {
                    return this.geocodeCore("geocode", new GeocodeQuery(this.bingGeocodingUrl(), this.bingSpatialDataUrl(), location), options);
                };
                BingMapsGeocoder.prototype.geocodeBoundary = function (latitude, longitude, category, levelOfDetail, maxGeoData, options) {
                    if (category === void 0) { category = ''; }
                    if (levelOfDetail === void 0) { levelOfDetail = 2; }
                    if (maxGeoData === void 0) { maxGeoData = 3; }
                    return this.geocodeCore("geocodeBoundary", new GeocodeBoundaryQuery(this.bingGeocodingUrl(), this.bingSpatialDataUrl(), latitude, longitude, category, levelOfDetail, maxGeoData, options && options.entityType), options);
                };
                BingMapsGeocoder.prototype.geocodePoint = function (latitude, longitude, entities, options) {
                    return this.geocodeCore("geocodePoint", new GeocodePointQuery(this.bingGeocodingUrl(), this.bingSpatialDataUrl(), latitude, longitude, entities), options);
                };
                BingMapsGeocoder.prototype.tryGeocodeImmediate = function (location) {
                    return GeocodeCacheManager.getCoordinates(new GeocodeQuery(this.bingGeocodingUrl(), this.bingSpatialDataUrl(), location).key);
                };
                BingMapsGeocoder.prototype.tryGeocodeBoundaryImmediate = function (latitude, longitude, category, levelOfDetail, maxGeoData, entityType) {
                    if (maxGeoData === void 0) { maxGeoData = 3; }
                    var result = GeocodeCacheManager.getCoordinates(new GeocodeBoundaryQuery(this.bingGeocodingUrl(), this.bingSpatialDataUrl(), latitude, longitude, category, levelOfDetail, maxGeoData, entityType).key);
                    return result;
                };
                BingMapsGeocoder.prototype.geocodeCore = function (queueName, geocodeQuery, options) {
                    var result = GeocodeCacheManager.getCoordinates(geocodeQuery.getKey());
                    var deferred = $.Deferred();
                    if (result) {
                        deferred.resolve(result);
                    }
                    else {
                        var item_1 = { query: geocodeQuery, deferred: deferred };
                        GeocodeQueueManager.enqueue(queueName, item_1);
                        if (options && options.timeout) {
                            options.timeout.finally((function () {
                                if (item_1.deferred.state() === JQueryPromiseState[JQueryPromiseState.pending])
                                    item_1.deferred.reject();
                            }));
                        }
                    }
                    return deferred;
                };
                return BingMapsGeocoder;
            }());
            services.BingMapsGeocoder = BingMapsGeocoder;
            var DefaultGeocoder = /** @class */ (function (_super) {
                __extends(DefaultGeocoder, _super);
                function DefaultGeocoder() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                DefaultGeocoder.prototype.bingSpatialDataUrl = function () {
                    return 'https://platform.bing.com/geo/spatial/v1/public/Geodata';
                };
                DefaultGeocoder.prototype.bingGeocodingUrl = function () {
                    return 'https://dev.virtualearth.net/REST/v1/Locations';
                };
                return DefaultGeocoder;
            }(BingMapsGeocoder));
            services.DefaultGeocoder = DefaultGeocoder;
            services.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            /** Note: Used for test mockup */
            services.BingAjaxCall = $.ajax;
            services.CategoryTypeArray = [
                CategoryTypes.Address,
                CategoryTypes.City,
                CategoryTypes.Continent,
                CategoryTypes.CountryRegion,
                CategoryTypes.County,
                CategoryTypes.Longitude,
                CategoryTypes.Latitude,
                CategoryTypes.Place,
                CategoryTypes.PostalCode,
                CategoryTypes.StateOrProvince,
            ];
            function isCategoryType(value) {
                return services.CategoryTypeArray.indexOf(value) > -1;
            }
            services.isCategoryType = isCategoryType;
            services.BingEntities = {
                Continent: "Continent",
                Sovereign: "Sovereign",
                CountryRegion: "CountryRegion",
                AdminDivision1: "AdminDivision1",
                AdminDivision2: "AdminDivision2",
                PopulatedPlace: "PopulatedPlace",
                Postcode: "Postcode",
                Postcode1: "Postcode1",
                Neighborhood: "Neighborhood",
                Address: "Address",
            };
            // map Bing Entities to unstructured geocode request parameters
            var BingEntitiesToRequestParameter = {
                "Sovereign": "countryRegion",
                "CountryRegion": "countryRegion",
                "AdminDivision1": "adminDistrict",
                "AdminDivision2": "adminDistrict",
                "PopulatedPlace": "locality",
                "Postcode": "postalCode",
                "Postcode1": "postalCode",
                "Neighborhood": "locality",
                "Address": "addressLine",
            };
            var CategoryToBingEntity;
            (function (CategoryToBingEntity) {
                var categoryToBingEntity;
                function reset() {
                    categoryToBingEntity = undefined;
                }
                CategoryToBingEntity.reset = reset;
                function find(category) {
                    if (!categoryToBingEntity) {
                        categoryToBingEntity = {};
                        categoryToBingEntity[CategoryTypes.Continent.toLowerCase()] = services.BingEntities.Continent;
                        categoryToBingEntity[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.Sovereign;
                        categoryToBingEntity[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
                        categoryToBingEntity[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
                        categoryToBingEntity[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
                        categoryToBingEntity[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode;
                        categoryToBingEntity[CategoryTypes.Address.toLowerCase()] = services.BingEntities.Address;
                    }
                    return category && categoryToBingEntity[category.toLowerCase()] || "";
                }
                CategoryToBingEntity.find = find;
            })(CategoryToBingEntity || (CategoryToBingEntity = {}));
            var CategoryToBingEntityGeodata;
            (function (CategoryToBingEntityGeodata) {
                var categoryToBingEntityGeodata;
                function reset() {
                    categoryToBingEntityGeodata = undefined;
                }
                CategoryToBingEntityGeodata.reset = reset;
                function find(category) {
                    if (!categoryToBingEntityGeodata) {
                        categoryToBingEntityGeodata = {};
                        categoryToBingEntityGeodata[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.CountryRegion;
                        categoryToBingEntityGeodata[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
                        categoryToBingEntityGeodata[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
                        categoryToBingEntityGeodata[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
                        categoryToBingEntityGeodata[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode1;
                    }
                    return category && categoryToBingEntityGeodata[category.toLowerCase()] || "";
                }
                CategoryToBingEntityGeodata.find = find;
            })(CategoryToBingEntityGeodata || (CategoryToBingEntityGeodata = {}));
            var GeocodeQueryBase = /** @class */ (function () {
                function GeocodeQueryBase(bingGeocodingUrl, bingSpatialDataUrl, location, version) {
                    this.bingGeocodingUrl = bingGeocodingUrl;
                    this.bingSpatialDataUrl = bingSpatialDataUrl;
                    this.location = location;
                    debug.assertValue(bingGeocodingUrl, 'bingGeocodingUrl');
                    debug.assertValue(bingSpatialDataUrl, 'bingSpatialDataUrl');
                    this.makeKey(version);
                }
                GeocodeQueryBase.prototype.makeKey = function (version) {
                    var locationKey = _.map(this.location.components, (function (component) { return (component.query || "") + '/' + (component.category || ""); })).join('&');
                    this.key = ("G:" + this.bingGeocodingUrl + "; S:" + this.bingSpatialDataUrl + ";" + locationKey).toLowerCase();
                    if (version)
                        this.key = "V:" + version + '-' + this.key;
                };
                GeocodeQueryBase.prototype.getKey = function () {
                    return this.key;
                };
                return GeocodeQueryBase;
            }());
            services.GeocodeQueryBase = GeocodeQueryBase;
            var GeocodeQuery = /** @class */ (function (_super) {
                __extends(GeocodeQuery, _super);
                function GeocodeQuery(bingGeocodingUrl, bingSpatialDataUrl, location) {
                    return _super.call(this, bingGeocodingUrl, bingSpatialDataUrl, location, GeocodeQuery.CacheKeyVersion) || this;
                }
                GeocodeQuery.prototype.getBingEntity = function () {
                    return CategoryToBingEntity.find(_.last(this.location.components).category);
                };
                GeocodeQuery.prototype.getUrl = function () {
                    var parameters = {
                        key: Settings.BingKey,
                    };
                    var components = this.getGeocodingParameters();
                    if (_.any(components, (function (component) { return !component.key; }))) {
                        // When query includes an uncategorized value (or one categorized as Place or Continent which don't have a structured fetch representation),
                        // build a general query that composes all the values
                        parameters["q"] = _.chain(components)
                            .map((function (component) { return component.value; }))
                            .filter((function (value) { return value; }))
                            .reverse()
                            .value()
                            .join(", ");
                    }
                    else {
                        for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                            var component = components_1[_i];
                            var value = component.value;
                            if (!value)
                                // Bing treats empty values as if they're not given. That's a problem if the
                                // empty value is the deepest in the hierarchy as Bing will give the outer
                                // level but without UpHierarchy indication so we won't know to skip it.
                                return;
                            var key = component.key;
                            // we allow two levels of administrative district (e.g. state and county). if user gives both
                            // and drills, the lower level admin division may be ambiguous. for example Decatur County is
                            // ambiguous because Indiana, Georgia, Tennessee and Kansas all have a Decatur County. we remove
                            // the ambiguity by composing the two levels. examples,
                            //      Decatur County, GA
                            //      Gemeente Hoogeveen, Drenthe
                            //      Albacete, Castile-La Mancha
                            //      Calvados, Lower Normandy
                            if (key === "adminDistrict" && parameters[key])
                                parameters[key] = component.value + ", " + parameters[key];
                            else
                                parameters[key] = component.value;
                        }
                    }
                    var cultureName = navigator["userLanguage"] || navigator["language"];
                    cultureName = mapLocalesForBing(cultureName);
                    if (cultureName) {
                        parameters["c"] = cultureName;
                    }
                    parameters["maxRes"] = "10";
                    return jsCommon.UrlUtils.setQueryParameters(this.bingGeocodingUrl, parameters, /*keepExisting*/ true);
                };
                GeocodeQuery.prototype.getGeocodingParameters = function () {
                    // Continent needs special consideration. You'd hope countryRegion=Europe would work
                    // but Bing geocoder doesn't support it. Therefore we have to use a general query
                    // q=Europe instead. Essentially this treats Continent as uncategoried (or as Place).
                    // But if you're drilled we can't compose general query with a structured request
                    // so we have to use one or the other. For example we could use q=United States, North America
                    // or countryRegion=United States and the latter is more precise. But if the next level
                    // is City the choices are q=Paris, North America or locality=Paris. The former at least
                    // gives some context and indeed gives a better result. So the rule is that
                    // if the top level is continent and the next drilled level is country, drop the
                    // continent altogether. Otherwise continent will become uncategorized and a general
                    // query will be created with all components composed.
                    var locationComponents = this.location.components;
                    if (locationComponents.length >= 2 && locationComponents[0].category === CategoryTypes.Continent && locationComponents[1].category === CategoryTypes.CountryRegion) {
                        locationComponents = _.rest(locationComponents);
                    }
                    // convert component keys: PBI category -> Bing entity -> geocoding parameter
                    var components = _.map(locationComponents, (function (component) {
                        var entityType = CategoryToBingEntity.find(component.category);
                        var key = entityType && BingEntitiesToRequestParameter[entityType] || "";
                        var value = component.query;
                        // hack for certain ISO country codes
                        if (entityType === services.BingEntities.Sovereign && value)
                            value = GeocodeQuery.Iso3166Substitutions[value] || value;
                        return { key: key, value: value, };
                    }));
                    return components;
                };
                GeocodeQuery.prototype.isGeneralQuery = function () {
                    return _.any(this.getGeocodingParameters(), (function (component) { return !component.key; }));
                };
                GeocodeQuery.prototype.getResult = function (data) {
                    var _this = this;
                    var isGeneralQuery = this.isGeneralQuery();
                    var location = getBestLocation(data, (function (location) { return _this.locationQuality(location, isGeneralQuery); }));
                    if (location) {
                        var pointData = location.point.coordinates;
                        var coordinates = {
                            latitude: pointData && pointData[0],
                            longitude: pointData && pointData[1],
                            entityType: location.entityType,
                        };
                        return { coordinates: coordinates };
                    }
                    return { error: new Error("Geocode result is empty.") };
                };
                GeocodeQuery.prototype.locationQuality = function (location, isGeneralQuery) {
                    if (!isGeneralQuery && location.matchCodes && !isNotUpHierarchyMatchCode(location.matchCodes))
                        return -1;
                    var quality = 0;
                    // two letter ISO country query is most important
                    if (this.location.components.length === 1 && this.location.components[0].category === CategoryTypes.CountryRegion) {
                        var iso2 = location.address && location.address.countryRegionIso2;
                        if (iso2) {
                            var queryString = this.location.components[0].query.toLowerCase();
                            if (queryString.length === 2 && queryString === iso2.toLowerCase()) {
                                quality += 2;
                            }
                        }
                    }
                    // matching the entity type is also important
                    if (location.entityType && location.entityType.toLowerCase() === this.getBingEntity().toLowerCase()) {
                        quality += 1;
                    }
                    return quality;
                };
                GeocodeQuery.CacheKeyVersion = "2";
                // Bing does not return correct data for these ISO 3166 country codes. Use an alternative name.
                GeocodeQuery.Iso3166Substitutions = {
                    BI: "Burundi",
                    BQ: "Bonaire",
                    SJ: "Svalbard",
                    BES: "Bonaire",
                    NGA: "Nigeria",
                    NAM: "Namibia",
                    SJM: "Svalbard",
                    // MAF is giving back Isle of Man but should be Saint Martin (French Part)
                    MAF: "MF",
                };
                return GeocodeQuery;
            }(GeocodeQueryBase));
            services.GeocodeQuery = GeocodeQuery;
            function getBestLocation(data, quality) {
                var resources = data && !_.isEmpty(data.resourceSets) && data.resourceSets[0].resources;
                if (Array.isArray(resources)) {
                    var bestLocation = _.chain(resources)
                        .map((function (location) { return ({ location: location, value: quality(location) }); }))
                        .filter((function (locationValue) { return locationValue.value >= 0; }))
                        .max((function (locationValue) { return locationValue.value; }))
                        .value()
                        .location;
                    return bestLocation;
                }
            }
            var GeocodePointQuery = /** @class */ (function (_super) {
                __extends(GeocodePointQuery, _super);
                function GeocodePointQuery(bingGeocodingUrl, bingSpatialDataUrl, latitude, longitude, entities) {
                    var _this = _super.call(this, bingGeocodingUrl, bingSpatialDataUrl, { components: [{ query: [latitude, longitude].join(), category: "Point" }] }) || this;
                    _this.latitude = latitude;
                    _this.longitude = longitude;
                    _this.entities = entities;
                    return _this;
                }
                // Point queries are used for user real-time location data so do not cache
                GeocodePointQuery.prototype.getKey = function () {
                    return null;
                };
                GeocodePointQuery.prototype.getUrl = function () {
                    debug.assert(this.entities.every((function (e) { return !!_.findKey(services.BingEntities, (function (be) { return be === e; })); })), "All entities should match one of the allowed BingEntities");
                    var urlAndQuery = jsCommon.UrlUtils.splitUrlAndQuery(this.bingGeocodingUrl);
                    // add backlash if it's missing
                    var url = !_.endsWith(urlAndQuery.baseUrl, '/') ? urlAndQuery.baseUrl + '/' : urlAndQuery.baseUrl;
                    url += [this.latitude, this.longitude].join();
                    var parameters = {
                        key: Settings.BingKey,
                        include: 'ciso2'
                    };
                    if (!_.isEmpty(this.entities))
                        parameters['includeEntityTypes'] = this.entities.join();
                    return jsCommon.UrlUtils.setQueryParameters(url, parameters, /*keepExisting*/ true);
                };
                GeocodePointQuery.prototype.getResult = function (data) {
                    var _this = this;
                    var location = getBestLocation(data, (function (location) { return _this.entities.indexOf(location.entityType) === -1 ? 0 : 1; }));
                    if (location) {
                        var pointData = location.point.coordinates;
                        var addressData = location.address || {};
                        var name_1 = location.name;
                        var coordinates = {
                            latitude: pointData[0],
                            longitude: pointData[1],
                            addressLine: addressData.addressLine,
                            locality: addressData.locality,
                            neighborhood: addressData.neighborhood,
                            adminDistrict: addressData.adminDistrict,
                            adminDistrict2: addressData.adminDistrict2,
                            formattedAddress: addressData.formattedAddress,
                            postalCode: addressData.postalCode,
                            countryRegionIso2: addressData.countryRegionIso2,
                            countryRegion: addressData.countryRegion,
                            landmark: addressData.landmark,
                            name: name_1,
                        };
                        return { coordinates: coordinates };
                    }
                    // NOTE: GeoLocationHostFiltersService.resolveGeoResource is coded to require a completion with empty coordinates
                    return { coordinates: null };
                };
                return GeocodePointQuery;
            }(GeocodeQueryBase));
            services.GeocodePointQuery = GeocodePointQuery;
            var GeocodeBoundaryQuery = /** @class */ (function (_super) {
                __extends(GeocodeBoundaryQuery, _super);
                function GeocodeBoundaryQuery(bingGeocodingUrl, bingSpatialDataUrl, latitude, longitude, category, levelOfDetail, maxGeoData, entityType) {
                    if (maxGeoData === void 0) { maxGeoData = 3; }
                    var _this = _super.call(this, bingGeocodingUrl, bingSpatialDataUrl, {
                        components: [{
                                query: [latitude, longitude, levelOfDetail, maxGeoData].join(",") + (entityType !== CategoryToBingEntityGeodata.find(category) ? "," + entityType : ""),
                                category: category
                            }]
                    }) || this;
                    _this.latitude = latitude;
                    _this.longitude = longitude;
                    _this.levelOfDetail = levelOfDetail;
                    _this.maxGeoData = maxGeoData;
                    _this.entityType = entityType;
                    return _this;
                }
                GeocodeBoundaryQuery.prototype.getBingEntity = function () {
                    return CategoryToBingEntityGeodata.find(_.last(this.location.components).category);
                };
                GeocodeBoundaryQuery.prototype.getUrl = function () {
                    var parameters = {
                        key: Settings.BingKey,
                        $format: "json",
                    };
                    var entityType = this.entityType || this.getBingEntity();
                    if (!entityType) {
                        return null;
                    }
                    var cultureName = navigator["userLanguage"] || navigator["language"];
                    cultureName = mapLocalesForBing(cultureName) || '';
                    var cultures = cultureName.split("-");
                    // always giving a userRegion param, even if blank, fixes the 404 errors we were getting by omitting this "optional" param
                    var userRegion = cultures.length > 1 ? cultures[1] : '';
                    var data = [this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'", "'" + userRegion + "'"];
                    parameters["SpatialFilter"] = "GetBoundary(" + data.join(", ") + ")";
                    return jsCommon.UrlUtils.setQueryParameters(this.bingSpatialDataUrl, parameters, /*keepExisting*/ true);
                };
                GeocodeBoundaryQuery.prototype.getResult = function (data) {
                    var result = data;
                    if (result && result.d && Array.isArray(result.d.results) && result.d.results.length > 0) {
                        var entity = result.d.results[0];
                        var primitives = entity.Primitives;
                        if (primitives && primitives.length > 0) {
                            var coordinates = {
                                latitude: this.latitude,
                                longitude: this.longitude,
                                locations: []
                            };
                            primitives.sort((function (a, b) {
                                if (a.Shape.length < b.Shape.length) {
                                    return 1;
                                }
                                if (a.Shape.length > b.Shape.length) {
                                    return -1;
                                }
                                return 0;
                            }));
                            var maxGeoData = Math.min(primitives.length, this.maxGeoData);
                            for (var i = 0; i < maxGeoData; i++) {
                                var ringStr = primitives[i].Shape;
                                var ringArray = ringStr.split(",");
                                for (var j = 1; j < ringArray.length; j++) {
                                    coordinates.locations.push({ nativeBing: ringArray[j] });
                                }
                            }
                            return { coordinates: coordinates };
                        }
                    }
                    return { error: new Error("Geocode result is empty.") };
                };
                return GeocodeBoundaryQuery;
            }(GeocodeQueryBase));
            services.GeocodeBoundaryQuery = GeocodeBoundaryQuery;
            /**
             * Map locales that cause failures to similar locales that work
             */
            function mapLocalesForBing(locale) {
                switch (locale.toLowerCase()) {
                    case 'fr':// Bing gives a 404 error when this language code is used (fr is only obtained from Chrome).  Use fr-FR for a near-identical version that works. Defect # 255717 opened with Bing.
                        return 'fr-FR';
                    case 'de':
                        return 'de-DE';
                    case 'da':
                        return 'da-DK';
                    case 'es':
                        return 'es-ES';
                    case 'it':
                        return 'it-IT';
                    case 'nl':
                        return 'nl-BE';
                    // Screen for supported locale strings, https://msdn.microsoft.com/en-us/library/hh441729.aspx
                    // Sending unsupported locale (e.g. fr-CH for French-Swiss) causes zero results to be returned. CRI fix.
                    case 'af':
                    case 'am':
                    case 'ar-sa':
                    case 'as':
                    case 'az-atn':
                    case 'be':
                    case 'bg':
                    case 'bn-bd':
                    case 'bn-in':
                    case 'bs':
                    case 'ca':
                    case 'ca-es-valencia':
                    case 'cs':
                    case 'cy':
                    //case 'da':
                    //case 'de':
                    case 'de-de':
                    case 'el':
                    case 'en-gb':
                    case 'en-us':
                    //case 'es':
                    case 'es-es':
                    case 'es-us':
                    case 'es-mx':
                    case 'et':
                    case 'eu':
                    case 'fa':
                    case 'fi':
                    case 'fil-latn':
                    //case 'fr':
                    case 'fr-fr':
                    case 'fr-ca':
                    case 'ga':
                    case 'gd-latn':
                    case 'gl':
                    case 'gu':
                    case 'ha-latn':
                    case 'he':
                    case 'hi':
                    case 'hr':
                    case 'hu':
                    case 'hy':
                    case 'id':
                    case 'ig-latn':
                    case 'is':
                    //case 'it':
                    case 'it-it':
                    case 'ja':
                    case 'ka':
                    case 'kk':
                    case 'km':
                    case 'kn':
                    case 'ko':
                    case 'kok':
                    case 'ku-arab':
                    case 'ky-cyrl':
                    case 'lb':
                    case 'lt':
                    case 'lv':
                    case 'mi-latn':
                    case 'mk':
                    case 'ml':
                    case 'mn-cyrl':
                    case 'mr':
                    case 'ms':
                    case 'mt':
                    case 'nb':
                    case 'ne':
                    //case 'nl':
                    case 'nl-be':
                    case 'nn':
                    case 'nso':
                    case 'or':
                    case 'pa':
                    case 'pa-arab':
                    case 'pl':
                    case 'prs-arab':
                    case 'pt-br':
                    case 'pt-pt':
                    case 'qut-latn':
                    case 'quz':
                    case 'ro':
                    case 'ru':
                    case 'rw':
                    case 'sd-arab':
                    case 'si':
                    case 'sk':
                    case 'sl':
                    case 'sq':
                    case 'sr-cryl-ba':
                    case 'sr-cryl-rs':
                    case 'sr-latn-rs':
                    case 'sv':
                    case 'sw':
                    case 'ta':
                    case 'te':
                    case 'tg-cyrl':
                    case 'th':
                    case 'ti':
                    case 'tk-latn':
                    case 'tn':
                    case 'tr':
                    case 'tt-cyrl':
                    case 'ug-arab':
                    case 'uk':
                    case 'ur':
                    case 'uz-latn':
                    case 'vi':
                    case 'wo':
                    case 'xh':
                    case 'yo-latn':
                    case 'zh-hans':
                    case 'zh-hant':
                    case 'zu':
                        return locale;
                    default:
                        return null;
                }
            }
            var GeocodeQueueManager;
            (function (GeocodeQueueManager) {
                var queues = {};
                function ensureQueue(queueName) {
                    var queue = queues[queueName];
                    if (!queue)
                        queues[queueName] = queue = new GeocodeQueue();
                    return queue;
                }
                function enqueue(queueName, item) {
                    ensureQueue(queueName).enqueue(item);
                }
                GeocodeQueueManager.enqueue = enqueue;
                function reset() {
                    for (var queueName in queues)
                        queues[queueName].reset();
                    queues = {};
                }
                GeocodeQueueManager.reset = reset;
            })(GeocodeQueueManager || (GeocodeQueueManager = {}));
            var GeocodeQueue = /** @class */ (function () {
                function GeocodeQueue() {
                    this.entries = [];
                    this.activeEntries = [];
                    this.inDequeue = false;
                }
                GeocodeQueue.prototype.reset = function () {
                    var timeout = this.dequeueTimeout;
                    if (timeout) {
                        this.dequeueTimeout = undefined;
                        clearTimeout(timeout);
                    }
                    for (var _i = 0, _a = this.entries.concat(this.activeEntries); _i < _a.length; _i++) {
                        var entry = _a[_i];
                        this.cancel(entry);
                    }
                    this.entries = [];
                    this.activeEntries = [];
                };
                GeocodeQueue.prototype.enqueue = function (item) {
                    var _this = this;
                    var entry = { item: item };
                    this.entries.push(entry);
                    item.deferred.always((function () {
                        _this.cancel(entry);
                    }));
                    this.dequeue();
                };
                GeocodeQueue.prototype.dequeue = function () {
                    if (this.inDequeue || this.dequeueTimeout)
                        return;
                    try {
                        this.inDequeue = true;
                        while (this.entries.length !== 0 && this.activeEntries.length < Settings.MaxBingRequest) {
                            var entry = this.entries.shift();
                            if (!entry.isCompleted)
                                this.makeRequest(entry);
                        }
                    }
                    finally {
                        this.inDequeue = false;
                    }
                };
                GeocodeQueue.prototype.scheduleDequeue = function () {
                    var _this = this;
                    if (!this.dequeueTimeout && this.entries.length !== 0) {
                        this.dequeueTimeout = setTimeout((function () {
                            _this.dequeueTimeout = undefined;
                            _this.dequeue();
                        }));
                    }
                };
                GeocodeQueue.prototype.cancel = function (entry) {
                    if (!entry.jsonp) {
                        var request = entry.request;
                        if (request) {
                            entry.request = null;
                            request.abort();
                        }
                    }
                    this.complete(entry, { error: new Error('cancelled') });
                };
                GeocodeQueue.prototype.complete = function (entry, result) {
                    if (!entry.isCompleted) {
                        entry.isCompleted = true;
                        if (entry.item.deferred.state() === JQueryPromiseState[JQueryPromiseState.pending]) {
                            if (!result || result.error) {
                                entry.item.deferred.reject(result && result.error || new Error('cancelled'));
                            }
                            else {
                                if (result.coordinates)
                                    GeocodeCacheManager.registerCoordinates(entry.item.query.getKey(), result.coordinates);
                                entry.item.deferred.resolve(result.coordinates);
                            }
                        }
                    }
                    this.scheduleDequeue();
                };
                GeocodeQueue.prototype.makeRequest = function (entry) {
                    var _this = this;
                    var result = GeocodeCacheManager.getCoordinates(entry.item.query.getKey());
                    if (result) {
                        this.complete(entry, { coordinates: result });
                        return;
                    }
                    // Unfortunately the Bing service doesn't support CORS, only jsonp. This issue must be raised and revised.
                    // VSTS: 1396088 - Tracking: Ask: Bing geocoding to support CORS
                    var config = {
                        type: "GET",
                        dataType: "jsonp",
                        jsonp: "jsonp"
                    };
                    entry.jsonp = true;
                    var url = entry.item.query.getUrl();
                    if (!url) {
                        this.complete(entry, { error: new Error("Unsupported query.") });
                        return;
                    }
                    this.activeEntries.push(entry);
                    entry.request = services.BingAjaxCall(url, config);
                    entry.request.always((function () {
                        _.pull(_this.activeEntries, entry);
                    }));
                    entry.request.then((function (data) {
                        entry.request = null;
                        try {
                            _this.complete(entry, entry.item.query.getResult(data));
                        }
                        catch (error) {
                            _this.complete(entry, { error: error });
                        }
                    }), (function (error) {
                        entry.request = null;
                        _this.complete(entry, { error: new Error(error && error.statusText || 'cancelled') });
                    }));
                };
                return GeocodeQueue;
            }());
            services.GeocodeQueue = GeocodeQueue;
            var GeocodeCacheManager;
            (function (GeocodeCacheManager) {
                var geocodingCache;
                function ensureCache() {
                    if (!geocodingCache)
                        geocodingCache = services.createGeocodingCache(Settings.MaxCacheSize, Settings.MaxCacheSizeOverflow);
                    return geocodingCache;
                }
                function getCoordinates(key) {
                    if (key)
                        return ensureCache().getCoordinates(key);
                }
                GeocodeCacheManager.getCoordinates = getCoordinates;
                function registerCoordinates(key, coordinates) {
                    if (key)
                        return ensureCache().registerCoordinates(key, coordinates);
                }
                GeocodeCacheManager.registerCoordinates = registerCoordinates;
                function reset(cache) {
                    geocodingCache = cache;
                }
                GeocodeCacheManager.reset = reset;
            })(GeocodeCacheManager || (GeocodeCacheManager = {}));
            function resetStaticGeocoderState(cache) {
                if (cache !== undefined)
                    GeocodeCacheManager.reset(cache);
                GeocodeQueueManager.reset();
                CategoryToBingEntity.reset();
                CategoryToBingEntityGeodata.reset();
            }
            services.resetStaticGeocoderState = resetStaticGeocoderState;
            resetStaticGeocoderState();
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService) {
                if (!localStorageService)
                    localStorageService = powerbi.localStorageService;
                return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService);
            }
            services.createGeocodingCache = createGeocodingCache;
            var GeocodingCache = /** @class */ (function () {
                function GeocodingCache(maxCacheSize, maxCacheSizeOverflow, localStorageService) {
                    this.geocodeCache = {};
                    this.geocodeCacheCount = 0;
                    this.maxCacheSize = maxCacheSize;
                    this.maxCacheSizeOverflow = maxCacheSizeOverflow;
                    this.localStorageService = localStorageService;
                }
                /**
                 * Retrieves the coordinate for the key from the cache, returning undefined on a cache miss.
                 */
                GeocodingCache.prototype.getCoordinates = function (key) {
                    // Check in-memory cache
                    var pair = this.geocodeCache[key];
                    if (pair) {
                        ++pair.hitCount;
                        return pair.coordinate;
                    }
                    // Check local storage cache
                    pair = this.localStorageService.getData(key);
                    if (pair) {
                        this.registerInMemory(key, pair.coordinate);
                        return pair.coordinate;
                    }
                    return undefined;
                };
                /**
                 * Registers the query and coordinate to the cache.
                 */
                GeocodingCache.prototype.registerCoordinates = function (key, coordinate) {
                    this.registerInMemory(key, coordinate);
                    this.registerInStorage(key, coordinate);
                };
                GeocodingCache.prototype.registerInMemory = function (key, coordinate) {
                    var geocodeCache = this.geocodeCache;
                    var maxCacheSize = this.maxCacheSize;
                    var maxCacheCount = maxCacheSize + this.maxCacheSizeOverflow;
                    // are we about to exceed the maximum?
                    if (this.geocodeCacheCount >= maxCacheCount) {
                        var keys = Object.keys(geocodeCache);
                        var cacheSize = keys.length;
                        // sort keys in *descending* hitCount order
                        keys.sort((function (a, b) {
                            var cachedA = geocodeCache[a];
                            var cachedB = geocodeCache[b];
                            var ca = cachedA ? cachedA.hitCount : 0;
                            var cb = cachedB ? cachedB.hitCount : 0;
                            return ca < cb ? 1 : (ca > cb ? -1 : 0);
                        }));
                        // whack ones with the lower hitCounts.
                        // - while # whacked keys is small, do a quick wipe
                        // - after awhile we get lots of keys whose cached value is undefined. 
                        //   when there are "too many," make a whole new memory cache.
                        if (cacheSize < 2 * maxCacheCount) {
                            for (var i = maxCacheSize; i < cacheSize; i++)
                                geocodeCache[keys[i]] = undefined;
                        }
                        else {
                            var newGeocodeCache = {};
                            for (var i = 0; i < maxCacheSize; ++i)
                                newGeocodeCache[keys[i]] = geocodeCache[keys[i]];
                            geocodeCache = this.geocodeCache = newGeocodeCache;
                        }
                        this.geocodeCacheCount = maxCacheSize;
                    }
                    geocodeCache[key] = { coordinate: coordinate, hitCount: 1 };
                    ++this.geocodeCacheCount;
                };
                GeocodingCache.prototype.registerInStorage = function (key, coordinate) {
                    this.localStorageService.setData(key, { coordinate: coordinate });
                };
                return GeocodingCache;
            }());
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            function createGeolocation() {
                return new GeolocationService();
            }
            services.createGeolocation = createGeolocation;
            /**
             * HTML5 Implementation of IGeolocation
             */
            var GeolocationService = /** @class */ (function () {
                function GeolocationService() {
                    this.webGeolocation = navigator.geolocation;
                }
                GeolocationService.prototype.watchPosition = function (successCallback, errorCallback) {
                    return this.webGeolocation.watchPosition((function (position) {
                        successCallback(position);
                    }), (function (error) {
                        if (errorCallback != null) {
                            errorCallback(error);
                        }
                    }));
                };
                GeolocationService.prototype.clearWatch = function (watchId) {
                    this.webGeolocation.clearWatch(watchId);
                };
                GeolocationService.prototype.getCurrentPosition = function (successCallback, errorCallback) {
                    this.webGeolocation.getCurrentPosition((function (position) {
                        successCallback(position);
                    }), (function (error) {
                        if (errorCallback != null) {
                            errorCallback(error);
                        }
                    }));
                };
                return GeolocationService;
            }());
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
powerbi.define('PowerBIVisuals/visuals/services/tooltipEventsRegistrator', (function (imports) {
    var TouchUtils = powerbi.visuals.TouchUtils;
    var TooltipsNamespace = ".tooltip";
    var MouseOverEventName = "mouseover" + TooltipsNamespace;
    var MouseOutEventName = "mouseout" + TooltipsNamespace;
    var MouseMoveEventName = "mousemove" + TooltipsNamespace;
    var TouchStartEventName = TouchUtils.touchStartEventName() + TooltipsNamespace;
    var TouchEndEventName = TouchUtils.touchEndEventName() + TooltipsNamespace;
    var TouchMoveEventName = TouchUtils.touchMoveEventName() + TooltipsNamespace;
    var TooltipServiceDelegate = /** @class */ (function () {
        function TooltipServiceDelegate(visualHostTooltipService, handleTouchDelay) {
            this.visualHostTooltipService = visualHostTooltipService;
            this.handleTouchDelay = handleTouchDelay;
            this.rootNode = this.visualHostTooltipService.container();
        }
        TooltipServiceDelegate.prototype.showTooltip = function (isTouchEvent, isPointerEvent, getTooltipInfo, getDataPointIdentity, loadTooltipData, hideBeforeShowAttempt, hideTooltipOnNoData) {
            if (hideBeforeShowAttempt) {
                this.visualHostTooltipService.hide({
                    isTouchEvent: isTouchEvent,
                    immediately: true,
                });
            }
            var tooltipEventArgs = this.makeTooltipEventArgs(isPointerEvent, isTouchEvent);
            if (!tooltipEventArgs)
                return;
            var tooltipInfo;
            if (loadTooltipData) {
                tooltipInfo = getTooltipInfo(tooltipEventArgs);
                if (tooltipInfo == null) {
                    if (hideTooltipOnNoData) {
                        this.visualHostTooltipService.hide({
                            isTouchEvent: false,
                            immediately: false,
                        });
                    }
                    return;
                }
            }
            var selectionId = getDataPointIdentity(tooltipEventArgs);
            var identity = selectionId && selectionId.getSelectorsByColumn();
            this.visualHostTooltipService.show({
                coordinates: tooltipEventArgs.coordinates,
                isTouchEvent: isTouchEvent,
                dataItems: tooltipInfo,
                identities: identity ? [identity] : [],
            });
        };
        TooltipServiceDelegate.prototype.hideTooltip = function (isTouchEvent) {
            this.visualHostTooltipService.hide({
                isTouchEvent: isTouchEvent,
                immediately: false,
            });
        };
        TooltipServiceDelegate.prototype.getCoordinates = function (node, isPointerEvent) {
            var coordinates;
            if (isPointerEvent) {
                // DO NOT USE - WebKit bug in getScreenCTM with nested SVG results in slight negative coordinate shift
                // Also, IE will incorporate transform scale but WebKit does not, forcing us to detect browser and adjust appropriately.
                // Just use non-scaled coordinates for all browsers, and adjust for the transform scale later (see lineChart.findIndex)
                //coordinates = d3.mouse(rootNode);
                // copied from d3_eventSource (which is not exposed)
                var e = d3.event, s = void 0;
                while (s = e.sourceEvent)
                    e = s;
                var rect = node.getBoundingClientRect();
                coordinates = [e.clientX - rect.left - node.clientLeft, e.clientY - rect.top - node.clientTop];
            }
            else {
                var touchCoordinates = d3.touches(node);
                if (touchCoordinates && touchCoordinates.length > 0) {
                    coordinates = touchCoordinates[0];
                }
            }
            return coordinates;
        };
        TooltipServiceDelegate.prototype.makeTooltipEventArgs = function (isPointerEvent, isTouchEvent) {
            var eventCoordinates = this.getCoordinates(this.rootNode, isPointerEvent);
            var target = isTouchEvent
                ? document.elementFromPoint(eventCoordinates[0], eventCoordinates[1])
                : d3.event.target;
            var data = d3.select(target).datum();
            var elementCoordinates = this.getCoordinates(target, isPointerEvent);
            var tooltipEventArgs = {
                data: data,
                coordinates: eventCoordinates,
                elementCoordinates: elementCoordinates,
                context: target,
                isTouchEvent: isTouchEvent
            };
            return tooltipEventArgs;
        };
        TooltipServiceDelegate.prototype.startTimeout = function () {
            var _this = this;
            if (this.handleTouchTimeoutId)
                clearTimeout(this.handleTouchTimeoutId);
            // At the end of touch action, set a timeout that will let us ignore the incoming mouse events for a small amount of time
            // TODO: any better way to do this?
            this.handleTouchTimeoutId = setTimeout((function () {
                _this.handleTouchTimeoutId = undefined;
            }), this.handleTouchDelay);
        };
        TooltipServiceDelegate.prototype.canDisplayTooltip = function (d3Event) {
            var canDisplay = true;
            var mouseEvent = d3Event;
            if (mouseEvent.buttons !== undefined) {
                // Check mouse buttons state
                var hasMouseButtonPressed = mouseEvent.buttons !== 0;
                canDisplay = !hasMouseButtonPressed;
            }
            // Make sure we are not ignoring mouse events immediately after touch end.
            canDisplay = canDisplay && (this.handleTouchTimeoutId == null);
            return canDisplay;
        };
        return TooltipServiceDelegate;
    }());
    /**
     * DefaultTooltipEventsRegistrator behavior:
     *
     * Mouse behavior:
     * 1. On hover show tooltip
     * 2. On mouse out hide tooltip
     * 3. When moving inside the visual, the tooltip will update its position and data according to the mouse pointer's position and the data point it's on
     *
     * Touch behavior:
     * 1. On tap show tooltip
     * 2. On leave hide tooltip (show tooltip only when finger is on the data point)
     */
    var DefaultTooltipEventsRegistrator = /** @class */ (function () {
        function DefaultTooltipEventsRegistrator(tooltipServiceDelegate) {
            this.tooltipServiceDelegate = tooltipServiceDelegate;
        }
        DefaultTooltipEventsRegistrator.prototype.unregisterEvents = function (selection) {
            selection.on(TooltipsNamespace, null);
        };
        DefaultTooltipEventsRegistrator.prototype.registerEvents = function (selection, getTooltipInfo, getDataPointIdentity, reloadTooltipDataOnMouseMove) {
            this.registerMouseEvents(selection, getTooltipInfo, getDataPointIdentity, reloadTooltipDataOnMouseMove);
            this.registerTouchEvents(selection, getTooltipInfo, getDataPointIdentity);
        };
        DefaultTooltipEventsRegistrator.prototype.registerMouseEvents = function (selection, getTooltipInfo, getDataPointIdentity, reloadTooltipDataOnMouseMove) {
            var _this = this;
            selection.on(MouseOverEventName, (function () {
                // Ignore mouseover while handling touch events
                if (!_this.tooltipServiceDelegate.canDisplayTooltip(d3.event))
                    return;
                _this.tooltipServiceDelegate.showTooltip(
                /* isTouchEvent */ false, 
                /* isPointerEvent */ true, getTooltipInfo, getDataPointIdentity, 
                /* loadTooltipData */ true, 
                /* hideBeforeShowAttempt */ true, 
                /* hideTooltipOnNoData */ false);
            }));
            selection.on(MouseOutEventName, (function () {
                _this.tooltipServiceDelegate.hideTooltip(/* isTouchEvent */ false);
            }));
            selection.on(MouseMoveEventName, (function () {
                // Ignore mousemove while handling touch events
                if (!_this.tooltipServiceDelegate.canDisplayTooltip(d3.event))
                    return;
                // NOTE: The initial show event (mouseover) may not have had any data associated with it, so we need to ensure
                // the tooltip is visible here.
                _this.tooltipServiceDelegate.showTooltip(
                /* isTouchEvent*/ false, 
                /* isPointerEvent */ true, getTooltipInfo, getDataPointIdentity, reloadTooltipDataOnMouseMove, 
                /* hideBeforeShowAttempt */ false, 
                /* hideTooltipOnNoData */ true);
            }));
        };
        DefaultTooltipEventsRegistrator.prototype.registerTouchEvents = function (selection, getTooltipInfo, getDataPointIdentity) {
            var _this = this;
            var isPointerEvent = TouchUtils.usePointerEvents();
            selection.on(TouchStartEventName, (function () {
                _this.tooltipServiceDelegate.showTooltip(
                /* isTouchEvent */ true, isPointerEvent, getTooltipInfo, getDataPointIdentity, 
                /* loadTooltipData */ true, 
                /* hideBeforeShowAttempt */ true, 
                /* hideTooltipOnNoData */ false);
            }));
            selection.on(TouchEndEventName, (function () {
                _this.tooltipServiceDelegate.hideTooltip(/* isTouchEvent */ true);
                _this.tooltipServiceDelegate.startTimeout();
            }));
        };
        return DefaultTooltipEventsRegistrator;
    }());
    /**
     * TouchScreenOptimizedTooltipEventsRegistrator behavior:
     *
     * Mouse behavior:
     * See DefaultTooltipEventsRegistrator's mouse behavior
     *
     * Touch behavior:
     * 1. On long tap show tooltip (on single tap do not show tooltip)
     * 2. On leave do nothing (leave tooltip open, if visible)
     * 3. When moving inside the visual, the tooltip will update its position and data according to the finger's position and the data point it's on
     */
    var TouchScreenOptimizedTooltipEventsRegistrator = /** @class */ (function (_super) {
        __extends(TouchScreenOptimizedTooltipEventsRegistrator, _super);
        function TouchScreenOptimizedTooltipEventsRegistrator(tooltipServiceDelegate, visualHostTooltipService) {
            var _this = _super.call(this, tooltipServiceDelegate) || this;
            _this.visualHostTooltipService = visualHostTooltipService;
            return _this;
        }
        TouchScreenOptimizedTooltipEventsRegistrator.prototype.unregisterEvents = function (selection) {
            selection.on(TooltipsNamespace, null);
        };
        TouchScreenOptimizedTooltipEventsRegistrator.prototype.registerEvents = function (selection, getTooltipInfo, getDataPointIdentity, reloadTooltipDataOnMouseMove) {
            this.registerMouseEvents(selection, getTooltipInfo, getDataPointIdentity, reloadTooltipDataOnMouseMove);
            this.registerTouchEvents(selection, getTooltipInfo, getDataPointIdentity);
        };
        TouchScreenOptimizedTooltipEventsRegistrator.prototype.registerTouchEvents = function (selection, getTooltipInfo, getDataPointIdentity) {
            var _this = this;
            var isPointerEvent = TouchUtils.usePointerEvents();
            selection.on(TouchStartEventName, (function () {
                // The tooltip may be currently visible since it's a sticky tooltip. If it is visible and touchstart was received
                // we want the tooltip to immediately move to the new data point without any delay, so we do not hide the tooltip before moving it (hideBeforeShowAttempt = false).
                // (no delay before show if tooltip is currently open, see visualHostTooltipService.show implementation)
                _this.tooltipServiceDelegate.showTooltip(
                /* isTouchEvent */ true, isPointerEvent, getTooltipInfo, getDataPointIdentity, 
                /* loadTooltipData */ true, 
                /* hideBeforeShowAttempt */ false, 
                /* hideTooltipOnNoData */ false);
            }));
            selection.on(TouchEndEventName, (function () {
                // If the tooltip is not visible, ensure it is not about to be shown (disable long tap for showing tooltips).
                // If the tooltip is visible, then leave it open on touchend
                if (!_this.visualHostTooltipService.visible()) {
                    _this.visualHostTooltipService.hide({
                        isTouchEvent: true,
                        immediately: true
                    });
                }
                _this.tooltipServiceDelegate.startTimeout();
            }));
            selection.on(TouchMoveEventName, (function () {
                // NOTE: The initial show event (touchstart) may not have had any data associated with it, so we need to ensure
                // the tooltip is visible here.
                _this.tooltipServiceDelegate.showTooltip(
                /* isTouchEvent */ true, isPointerEvent, getTooltipInfo, getDataPointIdentity, 
                /* loadTooltipData */ true, 
                /* hideBeforeShowAttempt */ false, 
                /* hideTooltipOnNoData */ false);
            }));
        };
        return TouchScreenOptimizedTooltipEventsRegistrator;
    }(DefaultTooltipEventsRegistrator));
    return {
        create: function (options) {
            var tooltipServiceDelegate = new TooltipServiceDelegate(options.visualHostTooltipService, options.handleTouchDelay);
            return options.touchScreenOptimizedTooltips
                ? new TouchScreenOptimizedTooltipEventsRegistrator(tooltipServiceDelegate, options.visualHostTooltipService)
                : new DefaultTooltipEventsRegistrator(tooltipServiceDelegate);
        }
    };
}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function createTooltipService(hostServices, touchScreenOptimizedTooltips) {
            var visualHostTooltipService = hostServices.tooltips();
            if (visualHostTooltipService)
                return new TooltipService(visualHostTooltipService, touchScreenOptimizedTooltips);
            return new LegacyTooltipService();
        }
        visuals.createTooltipService = createTooltipService;
        var DefaultHandleTouchDelay = 1000;
        var TooltipService = /** @class */ (function () {
            function TooltipService(visualHostTooltipService, touchScreenOptimizedTooltips, handleTouchDelay) {
                if (handleTouchDelay === void 0) { handleTouchDelay = DefaultHandleTouchDelay; }
                this.visualHostTooltipService = visualHostTooltipService;
                this.tooltipEventsRegistrator = powerbi.requireSync('PowerBIVisuals/visuals/services/tooltipEventsRegistrator').create({
                    touchScreenOptimizedTooltips: touchScreenOptimizedTooltips,
                    visualHostTooltipService: this.visualHostTooltipService,
                    handleTouchDelay: handleTouchDelay
                });
            }
            TooltipService.prototype.addTooltip = function (selection, getTooltipInfoDelegate, getDataPointIdentity, reloadTooltipDataOnMouseMove) {
                debug.assertValue(selection, "selection");
                if (this.visualHostTooltipService.enabled()) {
                    this.tooltipEventsRegistrator.registerEvents(selection, getTooltipInfoDelegate, getDataPointIdentity, reloadTooltipDataOnMouseMove);
                }
            };
            TooltipService.prototype.removeTooltips = function (selection) {
                this.tooltipEventsRegistrator.unregisterEvents(selection);
            };
            TooltipService.prototype.hide = function () {
                this.visualHostTooltipService.hide({ immediately: true, isTouchEvent: false });
            };
            return TooltipService;
        }());
        visuals.TooltipService = TooltipService;
        var LegacyTooltipService = /** @class */ (function () {
            function LegacyTooltipService() {
            }
            LegacyTooltipService.prototype.addTooltip = function (selection, getTooltipInfoDelegate, getDataPointIdentity, reloadTooltipDataOnMouseMove) {
                // Default to the old tooltip system if the host does not support tooltips.
                visuals.TooltipManager.addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
            };
            LegacyTooltipService.prototype.removeTooltips = function (selection) {
            };
            LegacyTooltipService.prototype.hide = function () {
                visuals.TooltipManager.ToolTipInstance.hide();
            };
            return LegacyTooltipService;
        }());
        visuals.LegacyTooltipService = LegacyTooltipService;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CardUtil;
        (function (CardUtil) {
            CardUtil.DefaultStyle = {
                card: {
                    maxFontSize: 200
                },
                label: {
                    textSize: 12,
                    fontFamily: visuals.LabelUtils.StandardFontFamily,
                    color: '#a6a6a6',
                    paddingTop: 8
                },
                value: {
                    textSize: 27,
                    color: '#333333',
                    fontFamily: visuals.Font.Family.regularSecondary.css
                }
            };
        })(CardUtil = visuals.CardUtil || (visuals.CardUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var UNSELECTABLE_CLASS_NAME = "unselectable";
            function fire(eventHandlers, eventArgs) {
                if (eventHandlers) {
                    for (var _i = 0, eventHandlers_1 = eventHandlers; _i < eventHandlers_1.length; _i++) {
                        var h = eventHandlers_1[_i];
                        h(eventArgs);
                    }
                }
            }
            controls.fire = fire;
            var ScrollbarButton = /** @class */ (function () {
                // Constructor
                function ScrollbarButton(owner, direction) {
                    this._owner = owner;
                    this._direction = direction;
                    this._timerHandle = undefined;
                    this.createView();
                    var that = this;
                    this._element.addEventListener("mousedown", (function (e) { that.onMouseDown(e); }));
                    $(this._element).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._svg).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Object.defineProperty(ScrollbarButton.prototype, "element", {
                    // Properties
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                // Methods
                ScrollbarButton.prototype.createView = function () {
                    var svgns = "http://www.w3.org/2000/svg";
                    this._polygon = document.createElementNS(svgns, "polygon");
                    this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8");
                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR);
                    this._svg = document.createElementNS(svgns, "svg");
                    var svgStyle = this._svg.style;
                    svgStyle.position = "absolute";
                    svgStyle.left = "0px";
                    svgStyle.top = "0px";
                    this._svg.appendChild(this._polygon);
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.arrowClassName;
                    this._element.appendChild(this._svg);
                    this._owner.element.appendChild(this._element);
                };
                ScrollbarButton.prototype.onMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._mouseUpWrapper) {
                        event.cancelBubble = true;
                        var that_1 = this;
                        this._mouseUpWrapper = function (event) { that_1.onMouseUp(event); };
                        Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                    }
                    this._owner._scrollSmallIncrement(this._direction);
                    this._owner.refresh();
                    this._timerHandle = setTimeout((function () { that.onMouseDown(event); }), 100);
                    if (event.preventDefault) {
                        event.preventDefault(); // prevent dragging
                    }
                };
                ScrollbarButton.prototype.onMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper);
                    this._mouseUpWrapper = undefined;
                };
                ScrollbarButton.prototype.arrange = function (width, height, angle) {
                    var size = Math.min(width, height);
                    var scale = size / 16;
                    var x = (width - size) / 2;
                    var y = (height - size) / 2;
                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)");
                    this._svg.setAttributeNS(null, "width", width + "px");
                    this._svg.setAttributeNS(null, "height", height + "px");
                    controls.HTMLElementUtils.setElementWidth(this._element, width);
                    controls.HTMLElementUtils.setElementHeight(this._element, height);
                };
                // Const
                // TODO: Move to style
                ScrollbarButton.MIN_WIDTH = 26;
                ScrollbarButton.ARROW_COLOR = "#404040";
                return ScrollbarButton;
            }());
            controls.ScrollbarButton = ScrollbarButton;
            /** Scrollbar base class */
            var Scrollbar = /** @class */ (function () {
                function Scrollbar(parentElement, layoutKind) {
                    this.MIN_BAR_SIZE = 10;
                    this.min = 0;
                    this.max = 10;
                    this.viewMin = 0;
                    this.viewSize = 2;
                    this.smallIncrement = 1;
                    this._onscroll = [];
                    this._screenToOffsetScale = 1.0;
                    this.createView(parentElement, layoutKind);
                    var that = this;
                    this._element.addEventListener("mousedown", (function (e) { that.onBackgroundMouseDown(e); }));
                    this._middleBar.addEventListener("mousedown", (function (e) { that.onMiddleBarMouseDown(e); }));
                    this._timerHandle = undefined;
                    this._visible = true;
                    this.element["winControl"] = this;
                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Scrollbar.prototype.scrollBy = function (delta) {
                    this.scrollTo(this.viewMin + delta);
                };
                Scrollbar.prototype.scrollUp = function () {
                    this.scrollBy(-this.smallIncrement);
                };
                Scrollbar.prototype.scrollDown = function () {
                    this.scrollBy(this.smallIncrement);
                };
                Scrollbar.prototype.scrollPageUp = function () {
                    this.scrollBy(-this.viewSize);
                };
                Scrollbar.prototype.scrollPageDown = function () {
                    this.scrollBy(this.viewSize);
                };
                Object.defineProperty(Scrollbar.prototype, "width", {
                    get: function () {
                        return this._width;
                    },
                    set: function (value) {
                        this._width = value;
                        this._element.style.width = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "height", {
                    get: function () {
                        return this._height;
                    },
                    set: function (value) {
                        this._height = value;
                        this._element.style.height = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.refresh = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar.refresh()");
                };
                Object.defineProperty(Scrollbar.prototype, "element", {
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "maxButton", {
                    get: function () {
                        return this._maxButton;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "middleBar", {
                    get: function () {
                        return this._middleBar;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype._scrollSmallIncrement = function (direction) {
                    this.scrollBy(this.smallIncrement * direction);
                };
                Object.defineProperty(Scrollbar.prototype, "visible", {
                    get: function () {
                        return this._visible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                    get: function () {
                        return this._timerHandle !== undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.show = function (value) {
                    this._visible = value;
                    this.element.style.visibility = value ? "visible" : "hidden";
                    this.invalidateArrange();
                };
                Scrollbar.prototype._getMouseOffset = function (event) {
                    if (event.offsetX !== undefined)
                        return { x: event.offsetX, y: event.offsetY };
                    if (event.layerX !== undefined)
                        return { x: event.layerX, y: event.layerY };
                    return { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype._getOffsetXDelta = function (event) {
                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetYDelta = function (event) {
                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetXTouchDelta = function (event) {
                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                };
                Scrollbar.prototype._getOffsetYTouchDelta = function (event) {
                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                };
                Scrollbar.prototype.initTouch = function (panel, allowMouseDrag) {
                    var _this = this;
                    this._touchPanel = panel;
                    this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                    if ("ontouchmove" in panel) {
                        panel.addEventListener("touchstart", (function (e) { return _this.onTouchStart(e); }));
                        panel.addEventListener("touchmove", (function (e) { return _this.onTouchMove(e); }));
                        panel.addEventListener("touchend", (function (e) { return _this.onTouchEnd(e); }));
                    }
                    else {
                        panel.addEventListener("mousedown", (function (e) { return _this.onTouchMouseDown(e); }));
                        panel.addEventListener("mousemove", (function (e) { return _this.onTouchMouseMove(e); }));
                        panel.addEventListener("mouseup", (function (e) { return _this.onTouchMouseUp(e); }));
                    }
                };
                Scrollbar.prototype.onTouchStart = function (e) {
                    if (e.touches.length === 1) {
                        this.onTouchMouseDown(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchMove = function (e) {
                    if (e.touches.length === 1) {
                        if (e.preventDefault)
                            e.preventDefault();
                        this.onTouchMouseMove(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchEnd = function (e) {
                    this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                };
                Scrollbar.prototype.onTouchMouseDown = function (e) {
                    // except IE touch cancels mouse so not need for detection. For IE touch and mouse difference is detected by a flag.
                    if (!this._allowMouseDrag &&
                        e["pointerType"] === MSPointerEvent.MSPOINTER_TYPE_MOUSE) {
                        return;
                    }
                    if ("setCapture" in this._touchPanel) {
                        this._touchPanel.setCapture(true);
                    }
                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null;
                    this._touchStarted = true;
                };
                Scrollbar.prototype._getOffsetTouchDelta = function (e) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetTouchDelta()");
                    return null;
                };
                Scrollbar.prototype.onTouchMouseMove = function (e) {
                    if (this._touchStarted) {
                        if (!this._offsetTouchStartPos) {
                            this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e);
                        }
                        var delta = this._getOffsetTouchDelta(e);
                        if (delta !== 0) {
                            this.scrollBy(-delta / this._getRunningSize(false) * this.viewSize);
                            this._offsetTouchPrevPos = this._getMouseOffset(e);
                        }
                        if (e.preventDefault)
                            e.preventDefault();
                        e.cancelBubble = true;
                    }
                };
                Scrollbar.prototype.onTouchMouseUp = function (e, bubble) {
                    if (this._touchStarted) {
                        if (this._offsetTouchStartPos) {
                            var end = this._getMouseOffset(e);
                            if (!bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3)) {
                                if (e.preventDefault)
                                    e.preventDefault();
                                e.cancelBubble = true;
                            }
                        }
                    }
                    if ("releaseCapture" in this._touchPanel) {
                        this._touchPanel.releaseCapture();
                    }
                    this._touchStarted = false;
                };
                Scrollbar.prototype.createView = function (parentElement, layoutKind) {
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.className;
                    this._element.setAttribute("drag-resize-disabled", "true");
                    if (layoutKind === 0 /* Canvas */)
                        parentElement.appendChild(this._element);
                    this._minButton = new ScrollbarButton(this, -1);
                    this._maxButton = new ScrollbarButton(this, 1);
                    this._middleBar = document.createElement("div");
                    this._middleBar.className = Scrollbar.barClassName;
                    this._element.appendChild(this._middleBar);
                };
                Scrollbar.prototype.scrollTo = function (pos) {
                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                    if (viewMin !== this.viewMin) {
                        this.viewMin = viewMin;
                        fire(this._onscroll, null);
                    }
                };
                Scrollbar.prototype._scrollByPage = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._scrollByPage()");
                };
                Scrollbar.prototype._getRunningSize = function (net) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getRunningSize()");
                    return null;
                };
                Scrollbar.prototype._getOffsetDelta = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetDelta()");
                    return null;
                };
                Scrollbar.prototype.scroll = function (event) {
                    var delta = this._getOffsetDelta(event) / this._getRunningSize(true) * (this.max - this.min);
                    if (delta < 0) {
                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) {
                            return;
                        }
                    }
                    else if (delta > 0) {
                        if (this._getScreenMousePos(event) <= this._screenMinMousePos) {
                            return;
                        }
                    }
                    this.scrollBy(delta);
                };
                Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                    get: function () {
                        if (this._actualWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                    get: function () {
                        if (!this._actualHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                    get: function () {
                        if (!this._actualButtonWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                    get: function () {
                        if (!this._actualButtonHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.arrange = function () {
                    if (!this._actualWidth) {
                        this._actualWidth = this._element.offsetWidth;
                        this._actualHeight = this._element.offsetHeight;
                        this._actualButtonWidth = this._calculateButtonWidth();
                        this._actualButtonHeight = this._calculateButtonHeight();
                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle());
                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle());
                        this._setMaxButtonPosition();
                    }
                };
                Scrollbar.prototype._calculateButtonWidth = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonWidth()");
                    return null;
                };
                Scrollbar.prototype._calculateButtonHeight = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonHeight()");
                    return null;
                };
                Scrollbar.prototype._getMinButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMinButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._getMaxButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMaxButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._setMaxButtonPosition = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._setMaxButtonPosition()");
                };
                Scrollbar.prototype.invalidateArrange = function () {
                    this._actualWidth = undefined;
                    this._actualHeight = undefined;
                    this._actualButtonWidth = undefined;
                    this._actualButtonHeight = undefined;
                };
                Scrollbar.prototype.onHoldBackgroundMouseDown = function (event) {
                    var _this = this;
                    var holdDelay = this._timerHandle ?
                        Scrollbar.ScrollbarBackgroundMousedownHoldDelay :
                        Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                    this._timerHandle = setTimeout((function () {
                        _this.onBackgroundMouseDown(event);
                    }), holdDelay);
                };
                Scrollbar.prototype.onBackgroundMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._backgroundMouseUpWrapper) {
                        event.cancelBubble = true;
                        this._backgroundMouseUpWrapper = function (event) { that.onBackgroundMouseUp(event); };
                        Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    }
                    this._scrollByPage(event);
                    this.refresh();
                    this.onHoldBackgroundMouseDown(event);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onBackgroundMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    this._timerHandle = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    this._backgroundMouseUpWrapper = undefined;
                };
                Scrollbar.prototype.getPinchZoomY = function () {
                    return document.documentElement.clientHeight / window.innerHeight;
                };
                Scrollbar.prototype.onMiddleBarMouseDown = function (event) {
                    event.cancelBubble = true;
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                    this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element));
                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar));
                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                    var that = this;
                    this._middleBarMouseMoveWrapper = function (e) { that.onMiddleBarMouseMove(e); };
                    Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseUpWrapper = function (e) { that.onMiddleBarMouseUp(e); };
                    Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onMiddleBarMouseMove = function (event) {
                    if (!this._screenPrevMousePos) {
                        return;
                    }
                    this.scroll(event);
                    this.refresh();
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype.onMiddleBarMouseUp = function (event) {
                    this._screenPrevMousePos = undefined;
                    Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseMoveWrapper = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    this._middleBarMouseUpWrapper = undefined;
                    if (event.preventDefault)
                        event.preventDefault(); // prevent other events
                };
                Scrollbar.prototype._getScreenContextualLeft = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualLeft()");
                    return null;
                };
                Scrollbar.prototype._getScreenContextualRight = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualRight()");
                    return null;
                };
                Scrollbar.prototype.onMouseWheel = function (delta) {
                    if (delta) {
                        this.mouseWheel(delta);
                    }
                };
                Scrollbar.prototype.mouseWheel = function (delta) {
                    if (this.visible) {
                        if (delta < 0) {
                            delta = Math.min(-Scrollbar.MouseWheelRange, delta);
                        }
                        else if (delta > 0) {
                            delta = Math.max(Scrollbar.MouseWheelRange, delta);
                        }
                        this.scrollBy(-delta / Scrollbar.MouseWheelRange * this.smallIncrement);
                    }
                };
                Scrollbar.prototype._getScreenMousePos = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenMousePos()");
                    return null;
                };
                Scrollbar.addDocumentMouseUpEvent = function (func) {
                    document.addEventListener("mouseup", func);
                };
                Scrollbar.removeDocumentMouseUpEvent = function (func) {
                    document.removeEventListener("mouseup", func);
                };
                Scrollbar.addDocumentMouseMoveEvent = function (func) {
                    document.addEventListener("mousemove", func);
                };
                Scrollbar.removeDocumentMouseMoveEvent = function (func) {
                    document.removeEventListener("mousemove", func);
                };
                Scrollbar.DefaultScrollbarWidth = "15px"; // protected
                Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500;
                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50;
                Scrollbar.MouseWheelRange = 120;
                Scrollbar.className = "scroll-bar-div";
                Scrollbar.barClassName = "scroll-bar-part-bar";
                Scrollbar.arrowClassName = "scroll-bar-part-arrow";
                return Scrollbar;
            }());
            controls.Scrollbar = Scrollbar;
            /** Horizontal Scrollbar */
            var HorizontalScrollbar = /** @class */ (function (_super) {
                __extends(HorizontalScrollbar, _super);
                function HorizontalScrollbar(parentElement, layoutKind) {
                    var _this = _super.call(this, parentElement, layoutKind) || this;
                    _this.height = Scrollbar.DefaultScrollbarWidth;
                    return _this;
                }
                HorizontalScrollbar.prototype._calculateButtonWidth = function () {
                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                };
                HorizontalScrollbar.prototype._calculateButtonHeight = function () {
                    return this.actualHeight;
                };
                HorizontalScrollbar.prototype._getMinButtonAngle = function () {
                    return -180;
                };
                HorizontalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 0;
                };
                HorizontalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                };
                HorizontalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualWidth - this.actualButtonWidth * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    barSize = Math.min(barSize, runningSize);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight);
                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                };
                HorizontalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.height = this.height;
                    }
                    else {
                        controls.HTMLElementUtils.setElementHeight(this.element, 0);
                    }
                };
                HorizontalScrollbar.prototype._scrollByPage = function (event) {
                    var left = this.middleBar.offsetLeft;
                    var right = left + this.middleBar.offsetWidth;
                    var x = (event.offsetX === undefined) ? event.layerX : event.offsetX;
                    if (x > right) {
                        this.scrollPageDown();
                    }
                    else if (x < left) {
                        this.scrollPageUp();
                    }
                };
                HorizontalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualWidth;
                    if (net) {
                        var barMinPos = this.actualButtonWidth + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                HorizontalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetXDelta(event);
                };
                HorizontalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetXTouchDelta(e);
                };
                HorizontalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().left;
                };
                HorizontalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().right;
                };
                HorizontalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenX;
                };
                return HorizontalScrollbar;
            }(Scrollbar));
            controls.HorizontalScrollbar = HorizontalScrollbar;
            /** Vertical Scrollbar */
            var VerticalScrollbar = /** @class */ (function (_super) {
                __extends(VerticalScrollbar, _super);
                function VerticalScrollbar(parentElement, layoutKind) {
                    var _this = _super.call(this, parentElement, layoutKind) || this;
                    _this.width = Scrollbar.DefaultScrollbarWidth;
                    return _this;
                }
                VerticalScrollbar.prototype._calculateButtonWidth = function () {
                    return this.actualWidth;
                };
                VerticalScrollbar.prototype._calculateButtonHeight = function () {
                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                };
                VerticalScrollbar.prototype._getMinButtonAngle = function () {
                    return -90;
                };
                VerticalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 90;
                };
                VerticalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                };
                VerticalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualHeight - this.actualButtonHeight * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                };
                VerticalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.width = this.width;
                    }
                    else {
                        controls.HTMLElementUtils.setElementWidth(this.element, 0);
                    }
                };
                VerticalScrollbar.prototype._scrollByPage = function (event) {
                    var top = this.middleBar.offsetTop;
                    var bottom = top + this.middleBar.offsetHeight;
                    var y = (event.offsetY === undefined) ? event.layerY : event.offsetY;
                    if (y > bottom) {
                        this.scrollPageDown();
                    }
                    else if (y < top) {
                        this.scrollPageUp();
                    }
                };
                VerticalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualHeight;
                    if (net) {
                        var barMinPos = this.actualButtonHeight + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                VerticalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetYDelta(event);
                };
                VerticalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetYTouchDelta(e);
                };
                VerticalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().top;
                };
                VerticalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().bottom;
                };
                VerticalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenY;
                };
                return VerticalScrollbar;
            }(Scrollbar));
            controls.VerticalScrollbar = VerticalScrollbar;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var SlicerHelper = powerbi.visuals.SlicerHelper;
            var DisableDragAttribute = "drag-resize-disabled";
            var DefaultPaddingTop = 0;
            var DefaultPaddingLeft = 0;
            var SelectMenu = /** @class */ (function () {
                function SelectMenu(settings) {
                    debug.assertValue(settings.container, "container");
                    this.settings = settings;
                    this.init();
                    this.applyStyles();
                    this.setValue(this.settings.selectedValue);
                }
                /**
                 * Update styles and selected value for the select menu.
                 */
                SelectMenu.prototype.update = function (settings) {
                    _.extend(this.settings, settings);
                    SelectMenu.populateOptions(this.select, this.settings.options);
                    if (this.settings.selectedValue != null) {
                        this.setValue(this.settings.selectedValue);
                    }
                    this.select.selectmenu("refresh");
                    this.applyStyles();
                    this.applyState();
                };
                SelectMenu.prototype.disableOption = function (value) {
                    var options = this.select.find('option');
                    /* tslint:disable:prefer-for-of (JQuery rather than array) */
                    for (var i = 0; i < options.length; i++) {
                        var option = options[i];
                        var val = option.getAttribute("value");
                        if (val === value) {
                            option.setAttribute("disabled", "true");
                        }
                    }
                    this.select.selectmenu("refresh");
                };
                SelectMenu.prototype.enableOption = function (value) {
                    var options = this.select.find('option');
                    for (var i = 0; i < options.length; i++) {
                        var option = options[i];
                        var val = option.getAttribute("value");
                        if (val === value) {
                            option.setAttribute("disabled", "false");
                        }
                    }
                    this.select.selectmenu("refresh");
                };
                SelectMenu.prototype.close = function () {
                    this.select.selectmenu("close");
                };
                /**
                 * Sets selected value.
                 */
                SelectMenu.prototype.setValue = function (value) {
                    this.select.val(value);
                };
                SelectMenu.prototype.init = function () {
                    var _this = this;
                    this.select = InJs.DomFactory.select();
                    this.select
                        .attr(DisableDragAttribute, "true")
                        .appendTo(this.settings.container);
                    SelectMenu.populateOptions(this.select, this.settings.options);
                    this.select.selectmenu({
                        open: function () {
                            SlicerHelper.fixWidgetPosition(_this.menuWidget, _this.widget, { left: -DefaultPaddingLeft, top: DefaultPaddingTop }, true);
                        },
                        select: function (event) {
                            event.stopPropagation();
                        },
                        width: 'auto'
                    });
                    if (this.settings.onChange) {
                        this.select.on("selectmenuchange", (function (event, element) {
                            var value = element.item.value;
                            _this.settings.onChange(value);
                        }));
                    }
                    this.applyState();
                    this.widget = this.select.selectmenu("widget");
                    this.menuWidget = this.select.selectmenu("menuWidget").parent();
                    this.menuWidget.addClass(this.settings.className);
                };
                SelectMenu.prototype.applyState = function () {
                    if (this.settings.disabled)
                        this.select.selectmenu("disable");
                    else
                        this.select.selectmenu("enable");
                };
                SelectMenu.prototype.applyStyles = function () {
                    if (this.settings.css) {
                        this.widget.css(this.settings.css);
                    }
                };
                SelectMenu.populateOptions = function (select, options) {
                    select.find('option').remove();
                    for (var _i = 0, options_2 = options; _i < options_2.length; _i++) {
                        var option = options_2[_i];
                        $("<option />")
                            .attr("value", option.value)
                            .text(option.text)
                            .appendTo(select);
                    }
                };
                return SelectMenu;
            }());
            controls.SelectMenu = SelectMenu;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var UNSELECTABLE_CLASS_NAME = "unselectable";
                /** This class is responsible for tablix header resizing */
                var TablixResizer = /** @class */ (function () {
                    function TablixResizer(element, handler) {
                        this._element = element;
                        this._handler = handler;
                        this._elementMouseDownWrapper = null;
                        this._elementMouseMoveWrapper = null;
                        this._elementMouseOutWrapper = null;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                        this._startMousePosition = null;
                        this._originalCursor = null;
                    }
                    TablixResizer.addDocumentMouseUpEvent = function (listener) {
                        document.addEventListener("mouseup", listener);
                    };
                    TablixResizer.removeDocumentMouseUpEvent = function (listener) {
                        document.removeEventListener("mouseup", listener);
                    };
                    TablixResizer.addDocumentMouseMoveEvent = function (listener) {
                        document.addEventListener("mousemove", listener);
                    };
                    TablixResizer.removeDocumentMouseMoveEvent = function (listener) {
                        document.removeEventListener("mousemove", listener);
                    };
                    TablixResizer.getMouseCoordinates = function (event) {
                        return { x: event.pageX, y: event.pageY };
                    };
                    TablixResizer.getMouseCoordinateDelta = function (previous, current) {
                        return { x: current.x - previous.x, y: current.y - previous.y };
                    };
                    TablixResizer.prototype.initialize = function () {
                        var _this = this;
                        this._elementMouseDownWrapper = function (e) { return _this.onElementMouseDown(e); };
                        this._element.addEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseMoveWrapper = function (e) { return _this.onElementMouseMove(e); };
                        this._element.addEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseOutWrapper = function (e) { return _this.onElementMouseOut(e); };
                        this._element.addEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = function (e) { return _this.onElementMouseDoubleClick(e); };
                        this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                    };
                    TablixResizer.prototype.uninitialize = function () {
                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseDownWrapper = null;
                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseMoveWrapper = null;
                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseOutWrapper = null;
                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = null;
                    };
                    Object.defineProperty(TablixResizer.prototype, "cell", {
                        get: function () {
                            // abstract
                            debug.assertFail("PureVirtualMethod: TablixResizer.cell");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixResizer.prototype, "element", {
                        get: function () {
                            return this._element;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixResizer.prototype._hotSpot = function (position) {
                        // abstract
                        debug.assertFail("PureVirtualMethod: TablixResizer._hotSpot");
                        return false;
                    };
                    TablixResizer.prototype.onElementMouseDown = function (event) {
                        var _this = this;
                        var position = TablixResizer.getMouseCoordinates(event);
                        if (!this._hotSpot(position))
                            return;
                        if ("setCapture" in this._element) {
                            this._element.setCapture();
                        }
                        event.cancelBubble = true;
                        this._startMousePosition = position;
                        this._documentMouseMoveWrapper = function (e) { return _this.onDocumentMouseMove(e); };
                        TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseUpWrapper = function (e) { return _this.onDocumentMouseUp(e); };
                        TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        if (document.documentElement) {
                            this._originalCursor = document.documentElement.style.cursor;
                            document.documentElement.style.cursor = TablixResizer.resizeCursor;
                        }
                        this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y);
                    };
                    TablixResizer.prototype.onElementMouseMove = function (event) {
                        if (!this._startMousePosition) {
                            if (this._hotSpot(TablixResizer.getMouseCoordinates(event))) {
                                if (this._originalCursor === null) {
                                    this._originalCursor = this._element.style.cursor;
                                    this._element.style.cursor = TablixResizer.resizeCursor;
                                }
                            }
                            else {
                                if (this._originalCursor !== null) {
                                    this._element.style.cursor = this._originalCursor;
                                    this._originalCursor = null;
                                }
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseOut = function (event) {
                        if (!this._startMousePosition) {
                            if (this._originalCursor !== null) {
                                this._element.style.cursor = this._originalCursor;
                                this._originalCursor = null;
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseDoubleClick = function (event) {
                        if (!this._hotSpot(TablixResizer.getMouseCoordinates(event)))
                            return;
                        this._handler.onReset(this.cell);
                    };
                    TablixResizer.prototype.onDocumentMouseMove = function (event) {
                        if (!this._startMousePosition)
                            return;
                        var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                        this._handler.onResize(this.cell, delta.x, delta.y);
                        // Need to prevent default to prevent mouse move from triggering other effects (VSTS 6720639)
                        event.preventDefault();
                    };
                    TablixResizer.prototype.onDocumentMouseUp = function (event) {
                        this._startMousePosition = null;
                        if ("releaseCapture" in this._element) {
                            this._element.releaseCapture();
                        }
                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseMoveWrapper = null;
                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        this._documentMouseUpWrapper = null;
                        if (document.documentElement)
                            document.documentElement.style.cursor = this._originalCursor;
                        if (event.preventDefault)
                            event.preventDefault(); // prevent other events
                        this._handler.onEndResize(this.cell);
                    };
                    TablixResizer.resizeHandleSize = 4;
                    TablixResizer.resizeCursor = "e-resize";
                    return TablixResizer;
                }());
                internal.TablixResizer = TablixResizer;
                var TablixDomResizer = /** @class */ (function (_super) {
                    __extends(TablixDomResizer, _super);
                    function TablixDomResizer(cell, element, handler) {
                        var _this = _super.call(this, element, handler) || this;
                        _this._cell = cell;
                        return _this;
                    }
                    Object.defineProperty(TablixDomResizer.prototype, "cell", {
                        get: function () {
                            return this._cell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixDomResizer.prototype._hotSpot = function (position) {
                        return position.x >= this.element.getBoundingClientRect().right - TablixResizer.resizeHandleSize;
                    };
                    return TablixDomResizer;
                }(TablixResizer));
                internal.TablixDomResizer = TablixDomResizer;
                var TablixCellPresenter = /** @class */ (function () {
                    function TablixCellPresenter(fitProportionally, layoutKind) {
                        // Table cell will be created once needed
                        this._tableCell = null;
                        // Content element
                        this._contentElement = internal.TablixUtils.createDiv();
                        // Content Host
                        this._contentHost = internal.TablixUtils.createDiv();
                        this.layoutKind = layoutKind;
                        this._contentElement.appendChild(this._contentHost);
                        this._resizer = null;
                    }
                    TablixCellPresenter.prototype.initialize = function (owner) {
                        this._owner = owner;
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerTableCell = function (tableCell) {
                        this._tableCell = tableCell;
                        tableCell.appendChild(this._contentElement);
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                        get: function () {
                            return this._tableCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                        /**
                         * Outer DIV
                         */
                        get: function () {
                            return this._contentElement;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                        /**
                        * Inner DIV
                        */
                        get: function () {
                            return this._contentHost;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerClickHandler = function (handler) {
                        this._contentElement.onclick = handler;
                    };
                    TablixCellPresenter.prototype.unregisterClickHandler = function () {
                        this._contentElement.onclick = null;
                    };
                    TablixCellPresenter.prototype.onContainerWidthChanged = function (value) {
                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                    };
                    TablixCellPresenter.prototype.onContinerHeightChanged = function (height) {
                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                    };
                    TablixCellPresenter.prototype.onColumnSpanChanged = function (value) {
                        this._tableCell.colSpan = value;
                    };
                    TablixCellPresenter.prototype.onRowSpanChanged = function (value) {
                        this._tableCell.rowSpan = value;
                    };
                    TablixCellPresenter.prototype.onTextAlignChanged = function (value) {
                        this._tableCell.style.textAlign = value;
                    };
                    TablixCellPresenter.prototype.onClear = function () {
                        this._contentHost.className = "";
                        this._tableCell.className = "";
                    };
                    TablixCellPresenter.prototype.onHorizontalScroll = function (width, offset) {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                    };
                    TablixCellPresenter.prototype.onVerticalScroll = function (height, offset) {
                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                    };
                    TablixCellPresenter.prototype.onInitializeScrolling = function () {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementTop(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                    };
                    TablixCellPresenter.prototype.enableHorizontalResize = function (enable, handler) {
                        if (enable === (this._resizer !== null))
                            return;
                        if (enable) {
                            this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler);
                            this._resizer.initialize();
                        }
                        else {
                            this._resizer.uninitialize();
                            this._resizer = null;
                        }
                    };
                    /**
                     * In order to allow dragging of the tableCell we need to
                     * disable dragging of the container of the cell in IE.
                     */
                    TablixCellPresenter.prototype.disableDragResize = function () {
                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                    };
                    // Attribute used to disable dragging in order to have cell resizing work.
                    TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled";
                    return TablixCellPresenter;
                }());
                internal.TablixCellPresenter = TablixCellPresenter;
                var TablixRowPresenter = /** @class */ (function () {
                    function TablixRowPresenter(fitProportionally) {
                        // Table row will be created once needed
                        this._tableRow = null;
                        this._fitProportionally = fitProportionally;
                    }
                    TablixRowPresenter.prototype.initialize = function (row) {
                        this._row = row;
                    };
                    TablixRowPresenter.prototype.createCellPresenter = function (layoutKind) {
                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
                    };
                    TablixRowPresenter.prototype.registerRow = function (tableRow) {
                        this._tableRow = tableRow;
                    };
                    TablixRowPresenter.prototype.onAppendCell = function (cell) {
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reason we use InsertCell() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableCell = this._tableRow.insertCell(-1);
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.appendChild(presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onInsertCellBefore = function (cell, refCell) {
                        debug.assertValue(refCell._presenter.tableCell, 'refTableCell');
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reasons we use InsertCell() to create new table cells instead of AppendChild()
                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onRemoveCell = function (cell) {
                        this._tableRow.removeChild(cell._presenter.tableCell);
                    };
                    TablixRowPresenter.prototype.getHeight = function () {
                        return this.getCellHeight(this._row.getTablixCell());
                    };
                    TablixRowPresenter.prototype.getCellHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    TablixRowPresenter.prototype.getCellContentHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                        get: function () {
                            return this._tableRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TablixRowPresenter;
                }());
                internal.TablixRowPresenter = TablixRowPresenter;
                var DashboardRowPresenter = /** @class */ (function (_super) {
                    __extends(DashboardRowPresenter, _super);
                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
                        var _this = _super.call(this, fitProportionally) || this;
                        _this._gridPresenter = gridPresenter;
                        return _this;
                    }
                    DashboardRowPresenter.prototype.getCellHeight = function (cell) {
                        return cell.containerHeight;
                    };
                    DashboardRowPresenter.prototype.getCellContentHeight = function (cell) {
                        return cell.contentHeight;
                    };
                    return DashboardRowPresenter;
                }(TablixRowPresenter));
                internal.DashboardRowPresenter = DashboardRowPresenter;
                var CanvasRowPresenter = /** @class */ (function (_super) {
                    __extends(CanvasRowPresenter, _super);
                    function CanvasRowPresenter() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    CanvasRowPresenter.prototype.getCellHeight = function (cell) {
                        return cell.containerHeight;
                    };
                    CanvasRowPresenter.prototype.getCellContentHeight = function (cell) {
                        return cell.contentHeight;
                    };
                    return CanvasRowPresenter;
                }(TablixRowPresenter));
                internal.CanvasRowPresenter = CanvasRowPresenter;
                var TablixColumnPresenter = /** @class */ (function () {
                    function TablixColumnPresenter() {
                    }
                    TablixColumnPresenter.prototype.initialize = function (column) {
                        this._column = column;
                    };
                    TablixColumnPresenter.prototype.getWidth = function () {
                        var width = this.getPersistedWidth();
                        if (width == null)
                            width = this.getCellWidth(this._column.getTablixCell());
                        return width;
                    };
                    TablixColumnPresenter.prototype.getPersistedWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getPersistedWidth");
                        return -1;
                    };
                    TablixColumnPresenter.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellWidth");
                        return -1;
                    };
                    return TablixColumnPresenter;
                }());
                internal.TablixColumnPresenter = TablixColumnPresenter;
                var DashboardColumnPresenter = /** @class */ (function (_super) {
                    __extends(DashboardColumnPresenter, _super);
                    function DashboardColumnPresenter(gridPresenter) {
                        var _this = _super.call(this) || this;
                        _this._gridPresenter = gridPresenter;
                        return _this;
                    }
                    DashboardColumnPresenter.prototype.getPersistedWidth = function () {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    };
                    DashboardColumnPresenter.prototype.getCellWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    };
                    return DashboardColumnPresenter;
                }(TablixColumnPresenter));
                internal.DashboardColumnPresenter = DashboardColumnPresenter;
                var CanvasColumnPresenter = /** @class */ (function (_super) {
                    __extends(CanvasColumnPresenter, _super);
                    function CanvasColumnPresenter(gridPresenter, index) {
                        var _this = _super.call(this) || this;
                        _this._gridPresenter = gridPresenter;
                        _this._columnIndex = index;
                        return _this;
                    }
                    CanvasColumnPresenter.prototype.getPersistedWidth = function () {
                        return this._gridPresenter.getPersistedColumnWidth(this._column);
                    };
                    CanvasColumnPresenter.prototype.getCellWidth = function (cell) {
                        var tablixCell = cell;
                        if (!tablixCell._presenter)
                            return 0;
                        return cell.contentWidth;
                    };
                    return CanvasColumnPresenter;
                }(TablixColumnPresenter));
                internal.CanvasColumnPresenter = CanvasColumnPresenter;
                var TablixGridPresenter = /** @class */ (function () {
                    function TablixGridPresenter(columnWidthManager) {
                        // Main Table
                        this._table = internal.TablixUtils.createTable();
                        this._table.className = UNSELECTABLE_CLASS_NAME;
                        // Footer Table
                        this._footerTable = internal.TablixUtils.createTable();
                        this._footerTable.className = UNSELECTABLE_CLASS_NAME;
                        // ColumnWidthManager
                        this._columnWidthManager = columnWidthManager;
                    }
                    TablixGridPresenter.prototype.initialize = function (owner, gridHost, footerHost, control) {
                        this._owner = owner;
                        gridHost.appendChild(this._table);
                        footerHost.appendChild(this._footerTable);
                    };
                    TablixGridPresenter.prototype.getWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getWidth");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getHeight");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioX = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioY = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.createRowPresenter = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createRowPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createColumnPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.onAppendRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._table.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onInsertRowBefore = function (row, refRow) {
                        debug.assertValue(refRow.presenter.tableRow, 'refTableRow');
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onRemoveRow = function (row) {
                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
                    };
                    TablixGridPresenter.prototype.onAddFooterRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._footerTable.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onClear = function () {
                        controls.HTMLElementUtils.clearChildren(this._table);
                        controls.HTMLElementUtils.clearChildren(this._footerTable);
                    };
                    TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function (value) {
                        if (value) {
                            this._table.style.width = "100%";
                            this._footerTable.style.width = "100%";
                        }
                        else {
                            this._table.style.width = "auto";
                            this._footerTable.style.width = "auto";
                        }
                    };
                    TablixGridPresenter.prototype.invokeColumnResizeEndCallback = function (column, width) {
                        if (this._columnWidthManager)
                            this._columnWidthManager.onColumnWidthChanged(controls.TablixColumnWidthManager.getColumnQueryName(column), width);
                    };
                    TablixGridPresenter.prototype.getPersistedColumnWidth = function (column) {
                        if (this._columnWidthManager) {
                            return this._columnWidthManager.getPersistedColumnWidth(controls.TablixColumnWidthManager.getColumnQueryName(column));
                        }
                    };
                    return TablixGridPresenter;
                }());
                internal.TablixGridPresenter = TablixGridPresenter;
                var DashboardTablixGridPresenter = /** @class */ (function (_super) {
                    __extends(DashboardTablixGridPresenter, _super);
                    function DashboardTablixGridPresenter(sizeComputationManager) {
                        var _this = _super.call(this) || this;
                        _this._sizeComputationManager = sizeComputationManager;
                        return _this;
                    }
                    DashboardTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                    };
                    DashboardTablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        return new DashboardColumnPresenter(this);
                    };
                    Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                        get: function () {
                            return this._sizeComputationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DashboardTablixGridPresenter.prototype.getWidth = function () {
                        return this._sizeComputationManager.gridWidth;
                    };
                    DashboardTablixGridPresenter.prototype.getHeight = function () {
                        return this._sizeComputationManager.gridHeight;
                    };
                    return DashboardTablixGridPresenter;
                }(TablixGridPresenter));
                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                var CanvasTablixGridPresenter = /** @class */ (function (_super) {
                    __extends(CanvasTablixGridPresenter, _super);
                    function CanvasTablixGridPresenter(columnWidthManager) {
                        return _super.call(this, columnWidthManager) || this;
                    }
                    CanvasTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                    };
                    CanvasTablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        return new CanvasColumnPresenter(this, index);
                    };
                    CanvasTablixGridPresenter.prototype.getWidth = function () {
                        return controls.HTMLElementUtils.getElementWidth(this._table);
                    };
                    CanvasTablixGridPresenter.prototype.getHeight = function () {
                        return controls.HTMLElementUtils.getElementHeight(this._table);
                    };
                    return CanvasTablixGridPresenter;
                }(TablixGridPresenter));
                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                /**
                 * Base class for Tablix realization manager.
                 */
                var TablixDimensionRealizationManager = /** @class */ (function () {
                    function TablixDimensionRealizationManager(binder) {
                        this._binder = binder;
                        this._adjustmentFactor = 1;
                    }
                    TablixDimensionRealizationManager.prototype._getOwner = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getOwner");
                        return null;
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                        get: function () {
                            return this._adjustmentFactor;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                        get: function () {
                            return this._itemsToRealizeCount;
                        },
                        set: function (count) {
                            this._itemsToRealizeCount = count;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                        get: function () {
                            return this._itemsEstimatedContextualWidth;
                        },
                        set: function (contextualWidth) {
                            this._itemsEstimatedContextualWidth = contextualWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function () {
                        var owner = this._getOwner();
                        if (owner.measureEnabled && !owner.done) {
                            this._getEstimatedItemsToRealizeCount();
                        }
                        this._realizedLeavesCount = 0;
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function (gridContextualWidth, filled) {
                        if (!filled && !this._getOwner().allItemsRealized)
                            this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth);
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingSession = function () {
                        this._adjustmentFactor = 1;
                    };
                    TablixDimensionRealizationManager.prototype.onCornerCellRealized = function (item, cell) {
                    };
                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        if (leaf) {
                            this._realizedLeavesCount++;
                        }
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizedLeavesCount < this._itemsToRealizeCount;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._calculateItemsToRealize");
                    };
                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._getSizeAdjustment");
                        return 1;
                    };
                    return TablixDimensionRealizationManager;
                }());
                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                /**
                 * DOM implementation for Row Tablix realization manager.
                 */
                var RowRealizationManager = /** @class */ (function (_super) {
                    __extends(RowRealizationManager, _super);
                    function RowRealizationManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Object.defineProperty(RowRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateRowsToRealizeCount();
                    };
                    RowRealizationManager.prototype.estimateRowsToRealizeCount = function () {
                        debug.assertValue(this._owner, '_owner');
                        if (!this._owner.dimension.model) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        if (this._owner.alignToEnd)
                            this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1;
                        else
                            this.itemsToRealizeCount = Math.ceil((this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor)) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1;
                    };
                    RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (!this._owner.dimension.model || this._owner.dimension.getItemsCount() === 0)
                            return 0;
                        var levels = new RowWidths();
                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                        var levelsArray = levels.items;
                        var levelCount = levelsArray.length;
                        var width = 0;
                        for (var i = 0; i < levelCount; i++) {
                            var level = levelsArray[i];
                            if (level.maxNonLeafWidth !== 0)
                                width += level.maxNonLeafWidth;
                            else
                                width += level.maxLeafWidth;
                        }
                        return width;
                    };
                    RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function (items, firstVisibleIndex, levels) {
                        if (firstVisibleIndex < 0)
                            return;
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var binder = this.binder;
                        var length = hierarchyNavigator.getCount(items);
                        for (var i = firstVisibleIndex; i < length; i++) {
                            if (levels.leafCount === this.itemsToRealizeCount)
                                return;
                            var item = hierarchyNavigator.getAt(items, i);
                            var label = binder.getHeaderLabel(item);
                            var itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex);
                            var isLeaf = hierarchyNavigator.isLeaf(item);
                            var l = hierarchyNavigator.getLevel(item);
                            var level = levels.items[l];
                            if (!level) {
                                level = new RowWidth();
                                levels.items[l] = level;
                            }
                            if (isLeaf) {
                                level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth);
                                levels.leafCount = levels.leafCount + 1;
                            }
                            else {
                                level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth);
                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels);
                            }
                        }
                    };
                    RowRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                    };
                    return RowRealizationManager;
                }(TablixDimensionRealizationManager));
                internal.RowRealizationManager = RowRealizationManager;
                /**
                 * DOM implementation for Column Tablix realization manager.
                 */
                var ColumnRealizationManager = /** @class */ (function (_super) {
                    __extends(ColumnRealizationManager, _super);
                    function ColumnRealizationManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                    };
                    Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                        get: function () {
                            return this._owner.otherLayoutManager.realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (this._owner.otherLayoutManager.done)
                            return this._owner.getOtherHierarchyContextualHeight();
                        return this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                    };
                    ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function (rowHierarchyWidth) {
                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        var binder = this.binder;
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var startColumnIndex = this._owner.dimension.getIntegerScrollOffset();
                        var endColumnIndex = this._owner.dimension.getItemsCount();
                        var columnCount = endColumnIndex - startColumnIndex;
                        var startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset();
                        var endRowIndex = this._owner.otherLayoutManager.dimension.getItemsCount();
                        this.itemsEstimatedContextualWidth = 0;
                        if (this._owner.alignToEnd) {
                            this.itemsToRealizeCount = columnCount;
                            return;
                        }
                        for (var i = startColumnIndex; i < endColumnIndex; i++) {
                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) {
                                this.itemsToRealizeCount = i - startColumnIndex;
                                return;
                            }
                            var maxWidth = 0;
                            var visibleSizeRatio = void 0;
                            if (i === startColumnIndex) {
                                visibleSizeRatio = this._owner.getVisibleSizeRatio();
                            }
                            else {
                                visibleSizeRatio = 1;
                            }
                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i);
                            var label = binder.getHeaderLabel(columnMember);
                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                            for (var j = startRowIndex; j < endRowIndex; j++) {
                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                label = binder.getCellContent(intersection);
                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                            }
                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                        }
                        this.itemsToRealizeCount = columnCount;
                    };
                    ColumnRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                    };
                    return ColumnRealizationManager;
                }(TablixDimensionRealizationManager));
                internal.ColumnRealizationManager = ColumnRealizationManager;
                var RowWidths = /** @class */ (function () {
                    function RowWidths() {
                        this.items = [];
                        this.leafCount = 0;
                    }
                    return RowWidths;
                }());
                internal.RowWidths = RowWidths;
                var RowWidth = /** @class */ (function () {
                    function RowWidth() {
                        this.maxLeafWidth = 0;
                        this.maxNonLeafWidth = 0;
                    }
                    return RowWidth;
                }());
                internal.RowWidth = RowWidth;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var TablixCell = /** @class */ (function () {
                    function TablixCell(presenter, extension, row) {
                        this._scrollable = false;
                        this._presenter = presenter;
                        this.extension = extension;
                        this._presenter.initialize(this);
                        this._row = row;
                        this.item = null;
                        this.type = null;
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this._colSpan = 1;
                        this._rowSpan = 1;
                        this._containerWidth = -1;
                        this._containerHeight = -1;
                        this.contentHeight = this.contentWidth = 0;
                        this.position = new internal.TablixUtils.CellPosition();
                    }
                    TablixCell.prototype.unfixRowHeight = function () {
                        this._row.unfixSize();
                    };
                    Object.defineProperty(TablixCell.prototype, "colSpan", {
                        get: function () {
                            return this._colSpan;
                        },
                        set: function (value) {
                            if (this._colSpan !== value) {
                                this._presenter.onColumnSpanChanged(value);
                                this._colSpan = value;
                                this._presenter.onContainerWidthChanged(-1);
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "rowSpan", {
                        get: function () {
                            return this._rowSpan;
                        },
                        set: function (value) {
                            if (this._rowSpan !== value) {
                                this._presenter.onRowSpanChanged(value);
                                this._rowSpan = value;
                                this._row.unfixSize();
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.getCellSpanningHeight = function () {
                        return this._row.getCellSpanningHeight(this);
                    };
                    Object.defineProperty(TablixCell.prototype, "textAlign", {
                        get: function () {
                            return this._textAlign;
                        },
                        set: function (value) {
                            if (value !== this._textAlign) {
                                this._presenter.onTextAlignChanged(value);
                                this._textAlign = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                        get: function () {
                            return this._horizontalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                        get: function () {
                            return this._verticalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.isScrollable = function () {
                        return this._scrollable;
                    };
                    TablixCell.prototype.clear = function () {
                        if (this.isScrollable()) {
                            this.initializeScrolling();
                        }
                        this._presenter.onClear();
                        this.setContainerWidth(-1);
                        this.setContainerHeight(-1);
                        this.contentHeight = this.contentWidth = 0;
                    };
                    TablixCell.prototype.initializeScrolling = function () {
                        this._presenter.onInitializeScrolling();
                        this._horizontalOffset = 0;
                        if (this._verticalOffset !== 0) {
                            this._verticalOffset = 0;
                        }
                        if (this.colSpan === 1)
                            this.setContainerWidth(-1);
                        if (this.rowSpan === 1)
                            this.setContainerHeight(-1);
                    };
                    TablixCell.prototype.prepare = function (scrollable) {
                        if (this.isScrollable())
                            this.initializeScrolling();
                        this._scrollable = scrollable;
                    };
                    TablixCell.prototype.scrollVertically = function (height, offset) {
                        // Ceiling the offset because setting a fraction Width on the TD will ceil it
                        // We need to let the TD and the OuterDiv to align in order for Borders to touch
                        var offsetInPixels = Math.ceil(-height * offset);
                        this._verticalOffset = offsetInPixels;
                        if (this.isScrollable()) {
                            this._presenter.onVerticalScroll(height, offsetInPixels);
                            this.setContainerHeight(height + offsetInPixels);
                        }
                        else {
                            this.setContainerHeight(this._row.getCellSpanningHeight(this) + offsetInPixels);
                        }
                    };
                    TablixCell.prototype.scrollHorizontally = function (width, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        this._presenter.onHorizontalScroll(width, offset);
                        this.setContainerWidth(width + offset);
                    };
                    TablixCell.prototype.setContainerWidth = function (value) {
                        if (value === this._containerWidth)
                            return;
                        this._containerWidth = value;
                        this._presenter.onContainerWidthChanged(value);
                    };
                    Object.defineProperty(TablixCell.prototype, "containerWidth", {
                        get: function () {
                            return this._containerWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.setContainerHeight = function (value) {
                        if (value < 0)
                            value = -1;
                        if (value === this._containerHeight)
                            return;
                        this._containerHeight = value;
                        // Apply word wrapping if needed
                        var tablix = this._row.owner.owner;
                        var binder = tablix.getBinder();
                        if (tablix.wordWrapRowHeaders
                            && binder.applyWordWrapping != null
                            && value !== -1
                            && this.type === 1 /* RowHeader */
                            && !this.position.column.isLast)
                            binder.applyWordWrapping(this.item, this);
                        this._presenter.onContinerHeightChanged(value);
                    };
                    Object.defineProperty(TablixCell.prototype, "containerHeight", {
                        get: function () {
                            return this._containerHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.applyStyle = function (style) {
                        if (style) {
                            style.applyStyle(this);
                            this.contentHeight += style.getExtraBottom() + style.getExtraTop();
                            this.contentWidth += style.getExtraLeft() + style.getExtraRight();
                        }
                    };
                    TablixCell.prototype.enableHorizontalResize = function (enable, handler) {
                        this._presenter.enableHorizontalResize(enable, handler);
                    };
                    TablixCell.prototype.isColumnResizing = function () {
                        return this._column && this._column.isResizing();
                    };
                    return TablixCell;
                }());
                internal.TablixCell = TablixCell;
                var TablixColumn = /** @class */ (function () {
                    function TablixColumn(presenter, columnIndex) {
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._containerWidth = -1;
                        this._width = -1;
                        this._sizeFixed = false;
                        this._aligningWidth = -1;
                        this._fixedToAligningWidth = false;
                        this._items = [];
                        this._itemType = null;
                        this._footerCell = null;
                        this._columnIndex = columnIndex;
                        this.isColumnResizing = false;
                    }
                    TablixColumn.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCornerCells = [];
                        this._realizedBodyCells = [];
                    };
                    Object.defineProperty(TablixColumn.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getType = function () {
                        if (this._realizedCornerCells.length > 0)
                            return 0 /* CornerCell */;
                        return 2 /* ColumnHeader */;
                    };
                    TablixColumn.prototype.getColumnHeadersOrCorners = function () {
                        if (this._realizedCornerCells.length > 0)
                            return this._realizedCornerCells;
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.columnHeadersOrCornersEqual = function (newType, headers, hierarchyNavigator) {
                        if (this._items.length !== headers.length)
                            return false;
                        var count = this._items.length;
                        for (var i = 0; i < count; i++) {
                            if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator))
                                return false;
                        }
                        return true;
                    };
                    Object.defineProperty(TablixColumn.prototype, "itemType", {
                        get: function () {
                            return this._itemType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getLeafItem = function () {
                        if (this._items.length === 0)
                            return null;
                        return this._items[this._items.length - 1];
                    };
                    TablixColumn.prototype.columnHeaderOrCornerEquals = function (type1, item1, type2, item2, hierarchyNavigator) {
                        if (type1 !== type2)
                            return false;
                        if (type1 === 0 /* CornerCell */) {
                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2))
                                return false;
                        }
                        else {
                            if (!hierarchyNavigator.headerItemEquals(item1, item2))
                                return false;
                        }
                        return true;
                    };
                    TablixColumn.prototype.OnLeafRealized = function (hierarchyNavigator) {
                        // if the headers/corner have changed we should clear the column size to accomodate for the new content
                        var type = this.getType();
                        var columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) {
                            this.clearSpanningCellsWidth(this._realizedColumnHeaders);
                        }
                        else {
                            var count = columnHeadersOrCorners.length;
                            this._items = [];
                            for (var i = 0; i < count; i++) {
                                this._items.push(columnHeadersOrCorners[i].item);
                            }
                            this._itemType = type;
                            this.clearSize();
                        }
                    };
                    TablixColumn.prototype.clearSpanningCellsWidth = function (cells) {
                        for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {
                            var cell = cells_1[_i];
                            if (cell.colSpan > 1) {
                                cell.setContainerWidth(-1);
                            }
                        }
                    };
                    TablixColumn.prototype.addCornerCell = function (cell) {
                        cell._column = this;
                        this._realizedCornerCells.push(cell);
                        cell.setContainerWidth(this._containerWidth);
                    };
                    TablixColumn.prototype.addRowHeader = function (cell) {
                        cell._column = this;
                        this._realizedRowHeaders.push(cell);
                        cell.setContainerWidth(this._containerWidth);
                    };
                    TablixColumn.prototype.addColumnHeader = function (cell, isLeaf) {
                        cell._column = this;
                        this._realizedColumnHeaders.push(cell);
                        if (isLeaf) {
                            cell.setContainerWidth(this._containerWidth);
                        }
                    };
                    TablixColumn.prototype.addBodyCell = function (cell) {
                        cell._column = this;
                        this._realizedBodyCells.push(cell);
                        cell.setContainerWidth(this._containerWidth);
                    };
                    Object.defineProperty(TablixColumn.prototype, "footer", {
                        get: function () {
                            return this._footerCell;
                        },
                        set: function (footerCell) {
                            this._footerCell = footerCell;
                            footerCell._column = this;
                            footerCell.setContainerWidth(this._containerWidth);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.isResizing = function () {
                        return this.isColumnResizing;
                    };
                    TablixColumn.prototype.onResize = function (width) {
                        this.isColumnResizing = true;
                        if (width === this.getContentContextualWidth())
                            return;
                        this._containerWidth = width;
                        this.setContainerWidth(this._containerWidth);
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = false;
                        this._aligningWidth = -1;
                    };
                    TablixColumn.prototype.onResizeEnd = function (width) {
                        this.isColumnResizing = false;
                        // Invoke resize callback
                        var gridPresenter = this.owner._presenter;
                        if (gridPresenter)
                            gridPresenter.invokeColumnResizeEndCallback(this, width);
                    };
                    TablixColumn.prototype.fixSize = function () {
                        var shouldAlign = this._aligningWidth !== -1;
                        var switched = shouldAlign !== this._fixedToAligningWidth;
                        if ((this._sizeFixed && !switched && !shouldAlign))
                            return;
                        if (this._aligningWidth === -1) {
                            this.setContainerWidth(this._containerWidth);
                        }
                        else {
                            this.setContainerWidth(this._aligningWidth);
                        }
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = this._aligningWidth !== -1;
                    };
                    TablixColumn.prototype.clearSize = function () {
                        this._containerWidth = -1;
                        this.setContainerWidth(this._containerWidth);
                        this._sizeFixed = false;
                    };
                    TablixColumn.prototype.getContentContextualWidth = function () {
                        return this._containerWidth;
                    };
                    TablixColumn.prototype.getCellIContentContextualWidth = function (cell) {
                        return this._presenter.getCellWidth(cell);
                    };
                    TablixColumn.prototype.getContextualWidth = function () {
                        if (this._width === -1 || this._containerWidth === -1)
                            this._width = this._presenter.getWidth();
                        return this._width;
                    };
                    TablixColumn.prototype.calculateSize = function () {
                        if (this._sizeFixed)
                            return this._containerWidth;
                        var contentWidth = 0;
                        // Check for persisted width
                        var persistedWidth = this._presenter.getPersistedWidth();
                        if (persistedWidth != null) {
                            // If yes, Set the width to the persisted width
                            contentWidth = persistedWidth;
                            // Handle special case of a single-child non-leaf column header, we need to show that wholly
                            for (var i = 0, len = this._realizedColumnHeaders.length; i < len - 1; i++) {
                                var cell = this._realizedColumnHeaders[i];
                                if (cell.colSpan === 1)
                                    contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                            }
                            return this._containerWidth = contentWidth;
                        }
                        // If no persisted width, we get the maximum width of the visible cells
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(cell));
                        }
                        if (this._footerCell !== null && this._footerCell.colSpan === 1)
                            contentWidth = Math.max(contentWidth, this._presenter.getCellWidth(this._footerCell));
                        return this._containerWidth = contentWidth;
                    };
                    TablixColumn.prototype.setAligningContextualWidth = function (size) {
                        this._aligningWidth = size;
                    };
                    TablixColumn.prototype.getAligningContextualWidth = function () {
                        return this._aligningWidth;
                    };
                    TablixColumn.prototype.setContainerWidth = function (value) {
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.colSpan === 1)
                                cell.setContainerWidth(value);
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.colSpan === 1)
                                cell.setContainerWidth(value);
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            cell.setContainerWidth(value);
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            cell.setContainerWidth(value);
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                this._footerCell.setContainerWidth(value);
                        }
                        this._width = value; // set cell width to new value
                    };
                    TablixColumn.prototype.getTablixCell = function () {
                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixColumn.prototype.getIndex = function (grid) {
                        return grid.realizedColumns.indexOf(this);
                    };
                    TablixColumn.prototype.getHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixColumn.prototype.getCellContextualSpan = function (cell) {
                        return cell.colSpan;
                    };
                    TablixColumn.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._row;
                    };
                    return TablixColumn;
                }());
                internal.TablixColumn = TablixColumn;
                var TablixRow = /** @class */ (function () {
                    function TablixRow(presenter) {
                        this._containerHeight = -1;
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._allocatedCells = [];
                        this._heightFixed = false;
                        this._containerHeight = -1;
                        this._height = -1;
                    }
                    TablixRow.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedBodyCells = [];
                        this._realizedCornerCells = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCellsCount = 0;
                    };
                    Object.defineProperty(TablixRow.prototype, "presenter", {
                        get: function () {
                            return this._presenter;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixRow.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixRow.prototype.releaseUnusedCells = function (owner) {
                        this.releaseCells(owner, this._realizedCellsCount);
                    };
                    TablixRow.prototype.releaseAllCells = function (owner) {
                        this.releaseCells(owner, 0);
                    };
                    TablixRow.prototype.releaseCells = function (owner, startIndex) {
                        var cells = this._allocatedCells;
                        var length = cells.length;
                        for (var i = startIndex; i < length; i++) {
                            var cell = cells[i];
                            owner._unbindCell(cell);
                            cell.clear();
                        }
                    };
                    TablixRow.prototype.moveScrollableCellsToEnd = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells[i];
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onAppendCell(cell);
                            this._allocatedCells.push(cell);
                        }
                        this._allocatedCells.splice(frontIndex, count);
                    };
                    TablixRow.prototype.moveScrollableCellsToStart = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells.pop();
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]);
                            this._allocatedCells.splice(frontIndex, 0, cell);
                        }
                    };
                    TablixRow.prototype.getOrCreateCornerCell = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.addCornerCell(cell);
                        this._realizedCornerCells.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateRowHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addRowHeader(cell);
                        this._realizedRowHeaders.push(cell);
                        if (leaf)
                            cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateColumnHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addColumnHeader(cell, leaf);
                        this._realizedColumnHeaders.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addBodyCell(cell);
                        this._realizedBodyCells.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterRowHeader = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.footer = cell;
                        this._realizedRowHeaders.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.footer = cell;
                        this._realizedBodyCells.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getRowHeaderLeafIndex = function () {
                        var index = -1;
                        var count = this._allocatedCells.length;
                        for (var i = 0; i < count; i++) {
                            if (this._allocatedCells[i].type !== 1 /* RowHeader */)
                                break;
                            index++;
                        }
                        return index;
                    };
                    TablixRow.prototype.getAllocatedCellAt = function (index) {
                        return this._allocatedCells[index];
                    };
                    TablixRow.prototype.moveCellsBy = function (delta) {
                        if (this._allocatedCells.length === 0)
                            return;
                        if (delta > 0) {
                            var refCell = this._allocatedCells[0];
                            for (var i = 0; i < delta; i++) {
                                var cell = this.createCell(this);
                                this._presenter.onInsertCellBefore(cell, refCell);
                                this._allocatedCells.unshift(cell);
                                refCell = cell;
                            }
                        }
                        else {
                            delta = -delta;
                            for (var i = 0; i < delta; i++) {
                                this._presenter.onRemoveCell(this._allocatedCells[i]);
                            }
                            this._allocatedCells.splice(0, delta);
                        }
                    };
                    TablixRow.prototype.getRealizedCellCount = function () {
                        return this._realizedCellsCount;
                    };
                    TablixRow.prototype.getRealizedHeadersCount = function () {
                        return this._realizedRowHeaders.length;
                    };
                    TablixRow.prototype.getRealizedHeaderAt = function (index) {
                        return this._realizedRowHeaders[index];
                    };
                    TablixRow.prototype.getTablixCell = function () {
                        var realizedCells;
                        if (this._realizedRowHeaders.length > 0) {
                            realizedCells = this._realizedRowHeaders;
                        }
                        else if (this._realizedCornerCells.length > 0) {
                            realizedCells = this._realizedCornerCells;
                        }
                        else {
                            realizedCells = this._realizedColumnHeaders;
                        }
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixRow.prototype.getOrCreateEmptySpaceCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        return cell;
                    };
                    TablixRow.prototype.createCell = function (row) {
                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                        return new TablixCell(presenter, presenter, this);
                    };
                    TablixRow.prototype.getOrCreateCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        else {
                            cell.colSpan = 1;
                            cell.rowSpan = 1;
                        }
                        this._realizedCellsCount = this._realizedCellsCount + 1;
                        return cell;
                    };
                    TablixRow.prototype.isResizing = function () {
                        return false;
                    };
                    TablixRow.prototype.onResize = function (height) {
                        if (height === this.getContentContextualWidth())
                            return;
                        this._containerHeight = height;
                        this.setContentHeight();
                        this._heightFixed = true;
                        this.setAligningContextualWidth(-1);
                    };
                    TablixRow.prototype.onResizeEnd = function (height) { };
                    TablixRow.prototype.fixSize = function () {
                        this.setContentHeight();
                        this._heightFixed = true;
                    };
                    TablixRow.prototype.unfixSize = function () {
                        this._heightFixed = false;
                        this._height = -1;
                    };
                    TablixRow.prototype.getContentContextualWidth = function () {
                        return this._containerHeight;
                    };
                    TablixRow.prototype.getCellIContentContextualWidth = function (cell) {
                        return this.presenter.getCellContentHeight(cell);
                    };
                    TablixRow.prototype.getCellSpanningHeight = function (cell) {
                        var height = this.getContextualWidth();
                        if (cell.rowSpan > 1) {
                            var index = this.getIndex(this.owner);
                            var rows = this.owner.realizedRows;
                            for (var i = 1; i < cell.rowSpan; i++)
                                height += rows[i + index].getContextualWidth();
                        }
                        return height;
                    };
                    TablixRow.prototype.getContextualWidth = function () {
                        if (this._height === -1 || this._containerHeight === -1)
                            this._height = this._presenter.getHeight();
                        return this._height;
                    };
                    TablixRow.prototype.sizeFixed = function () {
                        return this._heightFixed;
                    };
                    TablixRow.prototype.calculateSize = function () {
                        if (this._heightFixed)
                            return this._containerHeight;
                        var contentHeight = 0;
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                        }
                        return this._containerHeight = contentHeight;
                    };
                    TablixRow.prototype.setAligningContextualWidth = function (size) {
                        // TODO should be implemented when we support variable row heights
                    };
                    TablixRow.prototype.getAligningContextualWidth = function () {
                        // TODO should be implemented when we support variable row heights
                        return -1;
                    };
                    TablixRow.prototype.setContentHeight = function () {
                        var count = this._realizedRowHeaders.length;
                        // Need to do them in reverse order so that leaf headers are set first
                        for (var i = count - 1; i >= 0; i--) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.containerHeight !== -1 && cell._row.sizeFixed())
                                continue;
                            cell.setContainerHeight(this._containerHeight);
                            if (cell.rowSpan > 1)
                                cell.setContainerHeight(this.getCellSpanningHeight(cell));
                        }
                        for (var _i = 0, _a = this._realizedCornerCells; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.containerHeight !== -1 && cell._row.sizeFixed())
                                continue;
                            cell.setContainerHeight(this._containerHeight);
                        }
                        for (var _b = 0, _c = this._realizedColumnHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.containerHeight !== -1 && cell._row.sizeFixed())
                                continue;
                            cell.setContainerHeight(this._containerHeight);
                            if (cell.rowSpan > 1)
                                cell.setContainerHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var _d = 0, _e = this._realizedBodyCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            if (cell.containerHeight !== -1 && cell._row.sizeFixed())
                                continue;
                            cell.setContainerHeight(this._containerHeight);
                        }
                        this._height = -1;
                    };
                    TablixRow.prototype.getIndex = function (grid) {
                        return grid.realizedRows.indexOf(this);
                    };
                    TablixRow.prototype.getHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixRow.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixRow.prototype.getCellContextualSpan = function (cell) {
                        return cell.rowSpan;
                    };
                    TablixRow.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._column;
                    };
                    return TablixRow;
                }());
                internal.TablixRow = TablixRow;
                var TablixGrid = /** @class */ (function () {
                    function TablixGrid(presenter) {
                        this._presenter = presenter;
                        this._footerRow = null;
                    }
                    TablixGrid.prototype.initialize = function (owner, gridHost, footerHost) {
                        this._owner = owner;
                        this._presenter.initialize(this, gridHost, footerHost, owner);
                        this.fillColumnsProportionally = false;
                        this._realizedRows = [];
                        this._realizedColumns = [];
                        this._emptySpaceHeaderCell = null;
                        this._emptyFooterSpaceCell = null;
                    };
                    Object.defineProperty(TablixGrid.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                        get: function () {
                            return this._fillColumnsProportionally;
                        },
                        set: function (value) {
                            if (this._fillColumnsProportionally === value)
                                return;
                            this._fillColumnsProportionally = value;
                            this._presenter.onFillColumnsProportionallyChanged(value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                        get: function () {
                            return this._realizedColumns;
                        },
                        set: function (columns) {
                            this._realizedColumns = columns;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                        get: function () {
                            return this._realizedRows;
                        },
                        set: function (rows) {
                            this._realizedRows = rows;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "footerRow", {
                        get: function () {
                            return this._footerRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                        get: function () {
                            return this._emptySpaceHeaderCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                        get: function () {
                            return this._emptyFooterSpaceCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixGrid.prototype.ShowEmptySpaceCells = function (rowSpan, width) {
                        if (this._realizedRows.length === 0)
                            return;
                        if (this._realizedRows.length !== 0 && !this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell();
                            this._emptySpaceHeaderCell.rowSpan = rowSpan;
                            this._emptySpaceHeaderCell.colSpan = 1;
                            this._emptySpaceHeaderCell.setContainerWidth(width);
                        }
                        if (this._footerRow && (this._emptyFooterSpaceCell === null)) {
                            this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell();
                            this._emptyFooterSpaceCell.rowSpan = 1;
                            this._emptyFooterSpaceCell.colSpan = 1;
                            this._emptyFooterSpaceCell.setContainerWidth(width);
                        }
                    };
                    TablixGrid.prototype.HideEmptySpaceCells = function () {
                        if (this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell.clear();
                            this._emptySpaceHeaderCell = null;
                        }
                        if (this._emptyFooterSpaceCell) {
                            this._emptyFooterSpaceCell.clear();
                            this._emptyFooterSpaceCell = null;
                        }
                    };
                    TablixGrid.prototype.onStartRenderingSession = function (clear) {
                        if (clear) {
                            this.clearRows();
                            this.clearColumns();
                        }
                    };
                    TablixGrid.prototype.onStartRenderingIteration = function () {
                        this.initializeRows();
                        this.initializeColumns();
                    };
                    TablixGrid.prototype.onEndRenderingIteration = function () {
                        var rows = this._rows;
                        if (rows !== undefined) {
                            var rowCount = rows.length;
                            for (var i = 0; i < rowCount; i++) {
                                rows[i].releaseUnusedCells(this._owner);
                            }
                        }
                        if (this._footerRow) {
                            this._footerRow.releaseUnusedCells(this._owner);
                        }
                    };
                    TablixGrid.prototype.getOrCreateRow = function (rowIndex) {
                        var currentRow = this._rows[rowIndex];
                        if (currentRow === undefined) {
                            currentRow = new TablixRow(this._presenter.createRowPresenter());
                            currentRow.initialize(this);
                            this._presenter.onAppendRow(currentRow);
                            this._rows[rowIndex] = currentRow;
                        }
                        if (this._realizedRows[rowIndex] === undefined) {
                            this._realizedRows[rowIndex] = currentRow;
                        }
                        return currentRow;
                    };
                    TablixGrid.prototype.getOrCreateFootersRow = function () {
                        if (this._footerRow === null) {
                            this._footerRow = new TablixRow(this._presenter.createRowPresenter());
                            this._footerRow.initialize(this);
                            this._presenter.onAddFooterRow(this._footerRow);
                        }
                        return this._footerRow;
                    };
                    TablixGrid.prototype.moveRowsToEnd = function (moveFromIndex, count) {
                        for (var i = 0; i < count; i++) {
                            var row = this._rows[i + moveFromIndex];
                            debug.assertValue(row, "Invalid Row Index");
                            row.unfixSize();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onAppendRow(row);
                            this._rows.push(row);
                        }
                        this._rows.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveRowsToStart = function (moveToIndex, count) {
                        var refRow = this._rows[moveToIndex];
                        debug.assertValue(refRow, "Invalid Row Index");
                        for (var i = 0; i < count; i++) {
                            var row = this._rows.pop();
                            row.unfixSize();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onInsertRowBefore(row, refRow);
                            this._rows.splice(moveToIndex + i, 0, row);
                        }
                    };
                    TablixGrid.prototype.moveColumnsToEnd = function (moveFromIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToEnd(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns[i + moveFromIndex];
                            //Debug.assertValue(column, "Invalid Column Index");
                            this._columns.push(column);
                        }
                        this._columns.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveColumnsToStart = function (moveToIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToStart(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns.pop();
                            this._columns.splice(moveToIndex + i, 0, column);
                        }
                    };
                    TablixGrid.prototype.getOrCreateColumn = function (columnIndex) {
                        var currentColumn = this._columns[columnIndex];
                        if (currentColumn === undefined) {
                            currentColumn = new TablixColumn(this._presenter.createColumnPresenter(columnIndex), columnIndex);
                            currentColumn.initialize(this);
                            this._columns[columnIndex] = currentColumn;
                        }
                        if (this._realizedColumns[columnIndex] === undefined) {
                            this._realizedColumns[columnIndex] = currentColumn;
                        }
                        return currentColumn;
                    };
                    TablixGrid.prototype.initializeColumns = function () {
                        if (!this._columns)
                            this._columns = [];
                        var length = this._columns.length;
                        for (var i = 0; i < length; i++) {
                            this._columns[i].initialize(this);
                        }
                        this._realizedColumns = [];
                    };
                    TablixGrid.prototype.clearColumns = function () {
                        this._columns = null;
                        this._realizedColumns = null;
                    };
                    TablixGrid.prototype.initializeRows = function () {
                        // make sure rowDimension confirms it and it's not null in the grid
                        var hasFooter = this._owner.rowDimension.hasFooter() && (this._footerRow !== null);
                        this._realizedRows = [];
                        if (!this._rows) {
                            this._rows = [];
                        }
                        var rows = this._rows;
                        var length = rows.length;
                        for (var i = 0; i < length; i++) {
                            rows[i].initialize(this);
                        }
                        if (hasFooter) {
                            if (!this._footerRow) {
                                this.getOrCreateFootersRow();
                            }
                            this._footerRow.initialize(this);
                        }
                    };
                    TablixGrid.prototype.clearRows = function () {
                        var rows = this._rows;
                        if (rows) {
                            var length_1 = rows.length;
                            for (var i = 0; i < length_1; i++) {
                                rows[i].releaseAllCells(this._owner);
                            }
                            if (this._footerRow)
                                this._footerRow.releaseAllCells(this._owner);
                            this._presenter.onClear();
                            this._footerRow = null;
                            this._rows = null;
                            this._realizedRows = null;
                        }
                    };
                    TablixGrid.prototype.getWidth = function () {
                        return this._presenter.getWidth();
                    };
                    TablixGrid.prototype.getHeight = function () {
                        return this._presenter.getHeight();
                    };
                    return TablixGrid;
                }());
                internal.TablixGrid = TablixGrid;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var PixelConverter = jsCommon.PixelConverter;
                /**
                 * This class is used for layouts that don't or cannot
                 * rely on DOM measurements.  Instead they compute all required
                 * widths and heights and store it in this structure.
                 */
                var SizeComputationManager = /** @class */ (function () {
                    function SizeComputationManager() {
                    }
                    Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                        get: function () {
                            return this._viewport ? this._viewport.width : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                        get: function () {
                            return this._viewport ? this._viewport.height : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                        get: function () {
                            return this.visibleWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                        get: function () {
                            return this.visibleHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SizeComputationManager.prototype.updateColumnCount = function (columnCount) {
                        this._columnCount = columnCount;
                    };
                    SizeComputationManager.prototype.updateRowHeight = function (rowHeight) {
                        this._cellHeight = rowHeight;
                    };
                    SizeComputationManager.prototype.updateScalingFactor = function (scalingFactor) {
                        this._scalingFactor = scalingFactor;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                    };
                    SizeComputationManager.prototype.updateViewport = function (viewport) {
                        this._viewport = viewport;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                        this._cellHeight = this.computeColumnHeight();
                    };
                    SizeComputationManager.prototype.computeColumnWidth = function (totalColumnCount) {
                        var scalingFactor = this._scalingFactor;
                        if (!scalingFactor)
                            scalingFactor = 1;
                        var minimumColumnWidth = scalingFactor * SizeComputationManager.TablixMinimumColumnWidth;
                        var maxAllowedColumns = Math.floor(this._viewport.width / minimumColumnWidth);
                        return this.fitToColumnCount(maxAllowedColumns, totalColumnCount);
                    };
                    SizeComputationManager.prototype.computeColumnHeight = function () {
                        if (!this.hasImageContent)
                            return this._cellHeight;
                        var width = this._viewport.width;
                        if (width <= 250) {
                            // Small
                            return 20;
                        }
                        else if (width <= 510) {
                            // Medium
                            return 51;
                        }
                        else if (width <= 770) {
                            // Large
                            return 52;
                        }
                        debug.assertFail("Fixed size is only for viewport up to 770px width.");
                    };
                    SizeComputationManager.prototype.fitToColumnCount = function (maxAllowedColumnCount, totalColumnCount) {
                        var columnsToFit = Math.min(maxAllowedColumnCount, totalColumnCount);
                        return Math.floor(this._viewport.width / columnsToFit);
                    };
                    // Minimum size for a column, used to calculate layout
                    SizeComputationManager.TablixMinimumColumnWidth = 75;
                    return SizeComputationManager;
                }());
                internal.SizeComputationManager = SizeComputationManager;
                var DimensionLayoutManager = /** @class */ (function () {
                    function DimensionLayoutManager(owner, grid, realizationManager) {
                        //debug.assertValue(realizationManager, "Realization Manager must be defined");
                        this._owner = owner;
                        this._grid = grid;
                        this._lastScrollOffset = null;
                        this._isScrolling = false;
                        this._fixedSizeEnabled = true;
                        this._done = false;
                        this._realizationManager = realizationManager;
                    }
                    Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                        get: function () {
                            return this._realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                        get: function () {
                            return this._fixedSizeEnabled;
                        },
                        set: function (enable) {
                            this._fixedSizeEnabled = enable;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onCornerCellRealized = function (item, cell, leaf) {
                        this._realizationManager.onCornerCellRealized(item, cell);
                    };
                    DimensionLayoutManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        this._realizationManager.onHeaderRealized(item, cell, leaf);
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizationManager.needsToRealize;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getVisibleSizeRatio = function () {
                        return 1 - this.dimension.getFractionScrollOffset();
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                        get: function () {
                            return this._alignToEnd;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                        get: function () {
                            return this._done;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype._requiresMeasure = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._requiresMeasure");
                        return true;
                    };
                    DimensionLayoutManager.prototype.startScrollingSession = function () {
                        this._isScrolling = true;
                    };
                    DimensionLayoutManager.prototype.endScrollingSession = function () {
                        this._isScrolling = false;
                    };
                    DimensionLayoutManager.prototype.isScrolling = function () {
                        return this._isScrolling;
                    };
                    DimensionLayoutManager.prototype.isResizing = function () {
                        return false;
                    };
                    DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function () {
                        var otherDimension = this.dimension.otherDimension;
                        var count = otherDimension.getDepth();
                        var contextualHeight = 0;
                        var items = this._getRealizedItems();
                        if (items.length > 0) {
                            for (var i = 0; i < count; i++) {
                                contextualHeight += items[i].getContextualWidth();
                            }
                        }
                        return contextualHeight;
                    };
                    DimensionLayoutManager.prototype._isAutoSized = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._isAutoSized");
                        return false;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingSession = function () {
                        this._measureEnabled = this._requiresMeasure();
                        this._gridOffset = this.dimension.otherDimension.getDepth();
                    };
                    DimensionLayoutManager.prototype.onEndRenderingSession = function () {
                        this._realizationManager.onEndRenderingSession();
                        this._alignToEnd = false;
                        this._done = false;
                        this._measureEnabled = true;
                        this._sendDimensionsToControl();
                    };
                    /**
                     * Implementing classes must override this to send dimentions to TablixControl.
                     */
                    DimensionLayoutManager.prototype._sendDimensionsToControl = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._sendDimensionsToControl");
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                        get: function () {
                            return this._measureEnabled;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getFooterContextualWidth = function () {
                        return 0;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingIteration = function (clear, contextualWidth) {
                        if (this._measureEnabled && !this._done) {
                            this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth();
                        }
                        this._realizationManager.onStartRenderingIteration();
                        if (clear) {
                            this._lastScrollOffset = null;
                        }
                        else if (this._lastScrollOffset !== null) {
                            this.swapElements();
                        }
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                        get: function () {
                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || this.dimension.getItemsCount() === 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onEndRenderingIteration = function () {
                        if (this._done) {
                            return;
                        }
                        if (!this._measureEnabled) {
                            this._lastScrollOffset = this.dimension.scrollOffset;
                            this._done = true;
                            return;
                        }
                        var gridContextualWidth = this.getGridContextualWidth();
                        var filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        var allRealized = this.allItemsRealized;
                        var newScrollOffset;
                        if (filled) {
                            newScrollOffset = this.scrollForwardToAlignEnd(gridContextualWidth);
                        }
                        else {
                            newScrollOffset = this.scrollBackwardToFill(gridContextualWidth);
                        }
                        this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                        var originalScrollbarVisible = this.dimension.scrollbar.visible;
                        this.updateScrollbar(gridContextualWidth);
                        this._done = (filled || allRealized) &&
                            this.dimension.scrollbar.visible === originalScrollbarVisible &&
                            powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        this.dimension.scrollOffset = newScrollOffset;
                        this._lastScrollOffset = this.dimension.scrollOffset;
                    };
                    DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function () {
                        if (this._lastScrollOffset !== null) {
                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) {
                                return delta;
                            }
                        }
                        return null;
                    };
                    DimensionLayoutManager.prototype.swapElements = function () {
                        var delta = this.getScrollDeltaWithinPage();
                        if (delta !== null) {
                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                            if (Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth) {
                                if (delta > 0) {
                                    this._moveElementsToBottom(otherHierarchyDepth, delta);
                                }
                                else if (delta < 0) {
                                    this._moveElementsToTop(otherHierarchyDepth, -delta);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype._getRealizedItems = function () {
                        // abstract
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._getRealizedItems");
                        return null;
                    };
                    DimensionLayoutManager.prototype.getRealizedItemsCount = function () {
                        var realizedItems = this._getRealizedItems();
                        return realizedItems.length;
                    };
                    DimensionLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToBottom");
                    };
                    DimensionLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToTop");
                    };
                    DimensionLayoutManager.prototype.isScrollingWithinPage = function () {
                        return this.getScrollDeltaWithinPage() !== null;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidth = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridContextualWidth");
                        return 0;
                    };
                    DimensionLayoutManager.prototype.updateScrollbar = function (gridContextualWidth) {
                        var scrollbar = this.dimension.scrollbar;
                        scrollbar.viewMin = this.dimension.scrollOffset;
                        scrollbar.min = 0;
                        scrollbar.max = this.dimension.getItemsCount();
                        scrollbar.viewSize = this.getViewSize(gridContextualWidth);
                        this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                    };
                    DimensionLayoutManager.prototype.getViewSize = function (gridContextualWidth) {
                        var count = this.getRealizedItemsCount();
                        if (count === 0)
                            return 0;
                        var startIndex = this._gridOffset;
                        var sizeInItems = 0;
                        var sizeInPixels = 0;
                        var widthToFill = this._contextualWidthToFill;
                        var scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight();
                        var error = this.getMeaurementError(gridContextualWidth);
                        for (var i = startIndex; i < count; i++) {
                            var visibleRatio = void 0;
                            if (i === startIndex) {
                                visibleRatio = this.getVisibleSizeRatio();
                            }
                            else
                                visibleRatio = 1;
                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                            sizeInPixels += itemContextualWidth;
                            sizeInItems += visibleRatio;
                            if (powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                sizeInItems -= ((sizeInPixels - scrollableArea) / itemContextualWidth) * visibleRatio;
                                break;
                            }
                        }
                        return sizeInItems;
                    };
                    DimensionLayoutManager.prototype.isScrollableHeader = function (item, items, index) {
                        if (index !== 0 || this.dimension.getFractionScrollOffset() === 0) {
                            return false;
                        }
                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
                        if (hierarchyNavigator.isLeaf(item)) {
                            return true;
                        }
                        var currentItem = item;
                        var currentItems = items;
                        do {
                            currentItems = hierarchyNavigator.getChildren(currentItem);
                            currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1);
                            if (currentItem === undefined) {
                                break;
                            }
                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) {
                                return false;
                            }
                        } while (!hierarchyNavigator.isLeaf(currentItem));
                        return true;
                    };
                    DimensionLayoutManager.prototype.reachedEnd = function () {
                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    };
                    DimensionLayoutManager.prototype.scrollBackwardToFill = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this.reachedEnd()) {
                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                            if (this.dimension.getItemsCount() > 0) {
                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - (widthToFill / averageColumnwidth)));
                            }
                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision); // this is an aproximate scrolling back, we have to ensure it is aligned to the end of the control
                        }
                        return newScrollOffset;
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidth = function (index) {
                        var realizedItems = this._getRealizedItems();
                        if (index >= realizedItems.length)
                            return null;
                        return realizedItems[index].getContextualWidth();
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function (index) {
                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                    };
                    DimensionLayoutManager.prototype.getSizeWithScrolling = function (size, index) {
                        var ratio;
                        if (this._gridOffset === index) {
                            ratio = this.getVisibleSizeRatio();
                        }
                        else {
                            ratio = 1;
                        }
                        return size * ratio;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function () {
                        var count = this.getRealizedItemsCount();
                        var contextualWidth = 0;
                        for (var i = 0; i < count; i++) {
                            contextualWidth += this.getItemContextualWidthWithScrolling(i);
                        }
                        return contextualWidth;
                    };
                    DimensionLayoutManager.prototype.getMeaurementError = function (gridContextualWidth) {
                        return gridContextualWidth / this.getGridContextualWidthFromItems();
                    };
                    DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this._alignToEnd) {
                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                            if (!withinThreshold) {
                                var count = this.getRealizedItemsCount();
                                var startIndex = this._gridOffset;
                                var widthToScroll = gridContextualWidth - this._contextualWidthToFill;
                                var error = this.getMeaurementError(gridContextualWidth);
                                for (var i = startIndex; i < count; i++) {
                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                    if (powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                        widthToScroll -= itemContextualWidth;
                                    }
                                    else {
                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + (widthToScroll * visibleRatio / itemContextualWidth));
                                        break;
                                    }
                                }
                            }
                            this._alignToEnd = !withinThreshold;
                        }
                        return newScrollOffset;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.dimension");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                        get: function () {
                            return this.dimension.otherDimension.layoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                        get: function () {
                            return this._contextualWidthToFill;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getGridScale = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridScale");
                        return 0;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.otherScrollbarContextualWidth");
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getActualContextualWidth = function (gridContextualWidth) {
                        if (this._isAutoSized() && !this.canScroll(gridContextualWidth))
                            return gridContextualWidth;
                        return this._contextualWidthToFill;
                    };
                    DimensionLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.canScroll");
                        return false;
                    };
                    DimensionLayoutManager.prototype.calculateSizes = function () {
                        if (this.fixedSizeEnabled) {
                            this.calculateContextualWidths();
                            this.calculateSpans();
                        }
                    };
                    DimensionLayoutManager.prototype._calculateSize = function (item) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._calculateSize");
                        return null;
                    };
                    DimensionLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var count = items.length;
                        for (var i = 0; i < count; i++) {
                            var item = items[i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            this._calculateSize(item);
                        }
                    };
                    DimensionLayoutManager.prototype.calculateSpans = function () {
                        if (this.measureEnabled) {
                            this.updateNonScrollableItemsSpans();
                            this.updateScrollableItemsSpans();
                        }
                        // TODO override in row layout manager to add footer to calculation, this is required for Matrix
                    };
                    DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function () {
                        var otherDimensionItems = this.otherLayoutManager._getRealizedItems();
                        var otherDimensionItemsCount = otherDimensionItems.length;
                        var startIndex = this.dimension.getDepth();
                        for (var i = startIndex; i < otherDimensionItemsCount; i++) {
                            var otherDimensionItem = otherDimensionItems[i];
                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders(), false);
                        }
                    };
                    DimensionLayoutManager.prototype.updateScrollableItemsSpans = function () {
                        var otherRealizedItems = this.otherLayoutManager._getRealizedItems();
                        var otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length);
                        for (var i = 0; i < otherRealizedItemsCount; i++) {
                            var otherRealizedItem = otherRealizedItems[i];
                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders(), true);
                        }
                    };
                    DimensionLayoutManager.prototype.fixSizes = function () {
                        if (this.fixedSizeEnabled) {
                            var items = this._getRealizedItems();
                            var count = items.length;
                            for (var i = count - 1; i >= 0; i--) {
                                items[i].fixSize();
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateSpans = function (otherRealizedItem, cells, considerScrolling) {
                        var realizedItems = this._getRealizedItems();
                        var cellCount = cells.length;
                        for (var j = 0; j < cellCount; j++) {
                            var cell = cells[j];
                            var owner = otherRealizedItem.getOtherDimensionOwner(cell);
                            var span = owner.getCellContextualSpan(cell);
                            if (span > 1) {
                                var totalSizeInSpan = 0;
                                var startIndex = owner.getIndex(this._grid);
                                for (var k = 0; k < span; k++) {
                                    var item = realizedItems[k + startIndex];
                                    var childWidth = item.getContentContextualWidth();
                                    // Considering scroll offset for first column only, as scroll has not been applied to the cells
                                    if (considerScrolling && j === 0 && k === 0) {
                                        childWidth = Math.floor((1 - this.dimension.getFractionScrollOffset()) * childWidth);
                                    }
                                    totalSizeInSpan += childWidth;
                                    if (k === span - 1)
                                        this.updateLastChildSize(cell, item, totalSizeInSpan);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateLastChildSize = function (spanningCell, item, totalSpanSize) {
                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                        if (delta > 0)
                            item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                    };
                    DimensionLayoutManager._pixelPrecision = 1.0001;
                    DimensionLayoutManager._scrollOffsetPrecision = 0.01;
                    return DimensionLayoutManager;
                }());
                internal.DimensionLayoutManager = DimensionLayoutManager;
                var ResizeState = /** @class */ (function () {
                    function ResizeState(column, width, scale) {
                        this.column = column;
                        this.item = column.getLeafItem();
                        this.itemType = column.itemType;
                        this.startColumnWidth = width;
                        this.resizingDelta = 0;
                        this.animationFrame = null;
                        this.scale = scale;
                    }
                    ResizeState.prototype.getNewSize = function () {
                        return this.startColumnWidth + this.resizingDelta;
                    };
                    return ResizeState;
                }());
                internal.ResizeState = ResizeState;
                var ColumnLayoutManager = /** @class */ (function (_super) {
                    __extends(ColumnLayoutManager, _super);
                    function ColumnLayoutManager(owner, grid, realizationManager) {
                        var _this = _super.call(this, owner, grid, realizationManager) || this;
                        realizationManager.owner = _this;
                        _this.fillProportionally = false;
                        _this._resizeState = null;
                        return _this;
                    }
                    Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.columnDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.isResizing = function () {
                        return this._resizeState !== null;
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                        get: function () {
                            return this._grid.fillColumnsProportionally;
                        },
                        set: function (value) {
                            this._grid.fillColumnsProportionally = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioX();
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype._getRealizedItems = function () {
                        if (!this._grid.realizedColumns) {
                            this._grid.realizedColumns = [];
                        }
                        return this._grid.realizedColumns;
                    };
                    ColumnLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveColumnsToEnd(moveFromIndex, count);
                    };
                    ColumnLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveColumnsToStart(moveToIndex, count);
                    };
                    ColumnLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension or is scrolling or is resizing
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling()) || this.isScrolling() || this.isResizing();
                    };
                    ColumnLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getWidth();
                    };
                    ColumnLayoutManager.prototype.getFirstVisibleColumn = function () {
                        return this._grid.realizedColumns[this._gridOffset];
                    };
                    ColumnLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeWidth;
                    };
                    ColumnLayoutManager.prototype.applyScrolling = function () {
                        var columnOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleColumnWidth = 0;
                        var firstVisibleColumn = this.getFirstVisibleColumn();
                        if (firstVisibleColumn !== undefined) {
                            firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
                            // Ceiling the offset because setting a fraction Width on the TD will ceil it
                            // We need to let the TD and the OuterDiv to align in order for Borders to touch
                            var offsetInPixels = Math.ceil(-firstVisibleColumnWidth * columnOffset);
                            this.scroll(firstVisibleColumn, firstVisibleColumnWidth, offsetInPixels);
                        }
                    };
                    ColumnLayoutManager.prototype.scroll = function (firstVisibleColumn, width, offset) {
                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset);
                        this.scrollBodyCells(this._grid.realizedRows, width, offset);
                        if (firstVisibleColumn.footer !== null) {
                            firstVisibleColumn.footer.scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollCells = function (cells, width, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollBodyCells = function (rows, width, offset) {
                        var length = rows.length;
                        var cells;
                        var cell;
                        for (var i = 0; i < length; i++) {
                            cells = rows[i]._realizedBodyCells;
                            if (cells !== undefined) {
                                cell = cells[0];
                                if (cell !== undefined) {
                                    cell.scrollHorizontally(width, offset);
                                }
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.onStartResize = function (cell, currentX, currentY) {
                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                    };
                    ColumnLayoutManager.prototype.onResize = function (cell, deltaX, deltaY) {
                        var _this = this;
                        if (this.isResizing()) {
                            // Need to recalculate row height in case we have word wrapping
                            if (this.owner.owner.wordWrapColumnHeaders)
                                cell.unfixRowHeight();
                            this._resizeState.resizingDelta = Math.round(Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth));
                            if (this._resizeState.animationFrame === null)
                                this._resizeState.animationFrame = requestAnimationFrame((function () { return _this.performResizing(); }));
                        }
                    };
                    ColumnLayoutManager.prototype.onEndResize = function (cell) {
                        if (this.isResizing() && this._resizeState.animationFrame !== null) {
                            this.performResizing(); // if we reached the end and we are still waiting for the last animation frame, perform the pending resizing and clear the state 
                        }
                        this.endResizing();
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.onReset = function (cell) {
                        // Need to recalculate row height in case we have word wrapping
                        if (this.owner.owner.wordWrapColumnHeaders)
                            cell.unfixRowHeight();
                        this._resizeState = new ResizeState(cell._column, -1, 1);
                        cell._column.clearSize();
                        this.endResizing();
                        this.owner.owner.refresh(false);
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.updateItemToResizeState = function (realizedColumns) {
                        if (this._resizeState === null)
                            return;
                        var columnCount = realizedColumns.length;
                        var hierarchyNavigator = this.owner.owner.hierarchyNavigator;
                        // Only iterate over the columns that belong to column hierachy (i.e. skip the row hierarchy rows)
                        // as this post-rendering adjustment only applies to them.
                        var startIndex = this.otherLayoutManager.dimension.getDepth();
                        for (var i = startIndex; i < columnCount; i++) {
                            var column = realizedColumns[i];
                            if (!column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator))
                                continue;
                            if (column !== this._resizeState.column) {
                                this._resizeState.column = column;
                                column.onResize(this._resizeState.getNewSize());
                                break;
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.performResizing = function () {
                        if (this._resizeState === null)
                            return;
                        this._resizeState.animationFrame = null;
                        var newSize = this._resizeState.getNewSize();
                        this._resizeState.column.onResize(newSize);
                        this.owner.owner.refresh(false);
                    };
                    ColumnLayoutManager.prototype.endResizing = function () {
                        if (this._resizeState === null)
                            return;
                        var newSize = this._resizeState.getNewSize();
                        this._resizeState.column.onResizeEnd(newSize);
                    };
                    /**
                     * Sends column related data (pixel size, column count, etc) to TablixControl.
                     */
                    ColumnLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale(); // in case of canvas we have to convert the size from device pixel to css pixel
                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                    };
                    ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedBodyCellWidth");
                        return -1;
                    };
                    ColumnLayoutManager.minColumnWidth = 10;
                    return ColumnLayoutManager;
                }(DimensionLayoutManager));
                internal.ColumnLayoutManager = ColumnLayoutManager;
                var DashboardColumnLayoutManager = /** @class */ (function (_super) {
                    __extends(DashboardColumnLayoutManager, _super);
                    function DashboardColumnLayoutManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        if (this.ignoreColumn(headerIndex))
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardColumnLayoutManager.prototype._calculateSize = function (item) {
                        var headerIndex = item.getIndex(this._grid);
                        var computedSize = 0;
                        if (!this.ignoreColumn(headerIndex)) {
                            // for dashboard layout it does not matter whether we pass an actual cell or not
                            computedSize = this.owner.getContentWidth(undefined);
                        }
                        item.onResize(computedSize);
                        item.onResizeEnd(computedSize);
                        return computedSize;
                    };
                    DashboardColumnLayoutManager.prototype.ignoreColumn = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        return headerIndex === 0 && !this.owner.binder.hasRowGroups();
                    };
                    return DashboardColumnLayoutManager;
                }(ColumnLayoutManager));
                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                var CanvasColumnLayoutManager = /** @class */ (function (_super) {
                    __extends(CanvasColumnLayoutManager, _super);
                    function CanvasColumnLayoutManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        return this.owner.getEstimatedTextWidth(content);
                    };
                    CanvasColumnLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var columnWidths = [];
                        for (var i = 0, len = items.length; i < len; i++) {
                            var item = items[i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            var queryName = controls.TablixColumnWidthManager.getColumnQueryName(item);
                            if (queryName != null) {
                                columnWidths.push({
                                    queryName: queryName,
                                    width: this._calculateSize(item),
                                    isFixed: false // Unused
                                });
                            }
                        }
                        // Save all column widths. Needed when user turns off auto-sizing for column widths.
                        this.owner.columnWidthsToPersist = columnWidths;
                    };
                    CanvasColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasColumnLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    return CanvasColumnLayoutManager;
                }(ColumnLayoutManager));
                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                var RowLayoutManager = /** @class */ (function (_super) {
                    __extends(RowLayoutManager, _super);
                    function RowLayoutManager(owner, grid, realizationManager) {
                        var _this = _super.call(this, owner, grid, realizationManager) || this;
                        realizationManager.owner = _this;
                        return _this;
                    }
                    Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.rowDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioY();
                    };
                    Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.startScrollingSession = function () {
                        _super.prototype.startScrollingSession.call(this);
                    };
                    RowLayoutManager.prototype._getRealizedItems = function () {
                        if (!this._grid.realizedRows) {
                            this._grid.realizedRows = [];
                        }
                        return this._grid.realizedRows;
                    };
                    RowLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveRowsToEnd(moveFromIndex, count);
                    };
                    RowLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveRowsToStart(moveToIndex, count);
                    };
                    RowLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension and the column dimension is not resizing or row dimension is scrolling and reaching the end while scrolling 
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing())
                            || (this.isScrolling() && (this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount()));
                    };
                    RowLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getHeight();
                    };
                    RowLayoutManager.prototype.getFirstVisibleRow = function () {
                        return this._grid.realizedRows[this._gridOffset];
                    };
                    RowLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeHeight;
                    };
                    RowLayoutManager.prototype.applyScrolling = function () {
                        var rowOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleRowHeight = 0;
                        var firstVisibleRow = this.getFirstVisibleRow();
                        if (firstVisibleRow) {
                            firstVisibleRowHeight = firstVisibleRow.getContextualWidth();
                            this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset);
                        }
                    };
                    RowLayoutManager.prototype.scroll = function (firstVisibleRow, height, offset) {
                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset);
                        this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                    };
                    RowLayoutManager.prototype.scrollCells = function (cells, height, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollVertically(height, offset);
                        }
                    };
                    RowLayoutManager.prototype.getFooterContextualWidth = function () {
                        if (this.owner.owner.rowDimension.hasFooter()) {
                            if (this.owner.grid.footerRow) {
                                return this.owner.grid.footerRow.getContextualWidth();
                            }
                        }
                        return 0;
                    };
                    RowLayoutManager.prototype.calculateContextualWidths = function () {
                        _super.prototype.calculateContextualWidths.call(this);
                        if (this.fixedSizeEnabled) {
                            var footerRow = this._grid.footerRow;
                            if (footerRow) {
                                this._calculateSize(footerRow);
                            }
                        }
                    };
                    RowLayoutManager.prototype.fixSizes = function () {
                        _super.prototype.fixSizes.call(this);
                        if (this.fixedSizeEnabled) {
                            if (this._grid.footerRow) {
                                this._grid.footerRow.fixSize();
                            }
                        }
                    };
                    /**
                     * Sends row related data (pixel size, column count, etc) to TablixControl.
                     */
                    RowLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale();
                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), (this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0));
                    };
                    RowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: RowLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    return RowLayoutManager;
                }(DimensionLayoutManager));
                internal.RowLayoutManager = RowLayoutManager;
                var DashboardRowLayoutManager = /** @class */ (function (_super) {
                    __extends(DashboardRowLayoutManager, _super);
                    function DashboardRowLayoutManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        return this.getHeaderWidth(headerIndex);
                    };
                    DashboardRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardRowLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    DashboardRowLayoutManager.prototype.getHeaderWidth = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        if (headerIndex === 0 && !this.owner.binder.hasRowGroups())
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual text or not
                        return this.owner.getEstimatedTextWidth(undefined);
                    };
                    return DashboardRowLayoutManager;
                }(RowLayoutManager));
                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                var CanvasRowLayoutManager = /** @class */ (function (_super) {
                    __extends(CanvasRowLayoutManager, _super);
                    function CanvasRowLayoutManager() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasRowLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    return CanvasRowLayoutManager;
                }(RowLayoutManager));
                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                var TablixLayoutManager = /** @class */ (function () {
                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                        this._allowHeaderResize = true;
                        this._binder = binder;
                        this._grid = grid;
                        this._columnLayoutManager = columnLayoutManager;
                        this._rowLayoutManager = rowLayoutManager;
                        this._columnWidthsToPersist = [];
                    }
                    TablixLayoutManager.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._container = owner.container;
                        this._gridHost = owner.contentHost;
                        this._footersHost = owner.footerHost;
                        this._grid.initialize(owner, this._gridHost, this._footersHost);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnWidthsToPersist", {
                        get: function () {
                            return this._columnWidthsToPersist;
                        },
                        set: function (columnWidths) {
                            this._columnWidthsToPersist = columnWidths;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.getTablixClassName = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getTablixClassName");
                        return null;
                    };
                    TablixLayoutManager.prototype.getLayoutKind = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getLayoutKind");
                        // TODO ckerer: this method should not be necessary when we are done refactoring!
                        return null;
                    };
                    TablixLayoutManager.prototype.getOrCreateColumnHeader = function (item, items, rowIndex, columnIndex) {
                        var hierarchyNav = this.owner.hierarchyNavigator;
                        var row = this._grid.getOrCreateRow(rowIndex);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        var isLeaf = hierarchyNav.isLeaf(item);
                        var cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf);
                        var rowIdx = hierarchyNav.getLevel(item);
                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
                        cell.position.row.isFirst = rowIdx === 0;
                        cell.position.row.isLast = isLeaf;
                        var colIdx = hierarchyNav.getIndex(item);
                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
                        cell.position.column.isFirst = hierarchyNav.areAllParentsFirst(item, items);
                        cell.position.column.isLast = hierarchyNav.areAllParentsLast(item, items);
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateRowHeader = function (item, items, rowIndex, columnIndex) {
                        var hierarchyNav = this.owner.hierarchyNavigator;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex);
                        var isLeaf = hierarchyNav.isLeaf(item);
                        var scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                        if (row.getRealizedCellCount() === 0) {
                            this.alignRowHeaderCells(item, row);
                        }
                        var cell = row.getOrCreateRowHeader(column, scrollable, hierarchyNav.isLeaf(item));
                        var rowIdx = hierarchyNav.getIndex(item);
                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
                        cell.position.row.isFirst = hierarchyNav.areAllParentsFirst(item, items);
                        cell.position.row.isLast = hierarchyNav.areAllParentsLast(item, items);
                        var colIdx = hierarchyNav.getLevel(item);
                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
                        cell.position.column.isFirst = colIdx === 0;
                        cell.position.column.isLast = isLeaf;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateCornerCell = function (item, rowLevel, columnLevel) {
                        var row = this._grid.getOrCreateRow(columnLevel);
                        var column = this._grid.getOrCreateColumn(rowLevel);
                        var columnDepth = this._columnLayoutManager.dimension.getDepth();
                        var isLeaf = columnLevel === (columnDepth - 1);
                        var cell = row.getOrCreateCornerCell(column);
                        var rowIdx = columnLevel;
                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
                        cell.position.row.isFirst = rowIdx === 0;
                        cell.position.row.isLast = isLeaf;
                        var colIdx = rowLevel;
                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
                        cell.position.column.isFirst = colIdx === 0;
                        cell.position.column.isLast = colIdx === this._rowLayoutManager.dimension.getDepth() - 1;
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateBodyCell = function (cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        if (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0) {
                            scrollable = true;
                        }
                        else {
                            scrollable = this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                        }
                        var cell = row.getOrCreateBodyCell(column, scrollable);
                        cell.position = cellItem.position;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function (cellItem, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0);
                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                        cell.position = cellItem.position;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function (item, items) {
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(0);
                        //debug.assert(this.owner.hierarchyNavigator.isLeaf(item), "Leaf item expected");
                        var cell = row.getOrCreateFooterRowHeader(column);
                        cell.position = undefined;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getVisibleWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getVisibleHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateColumnCount");
                    };
                    TablixLayoutManager.prototype.updateViewport = function (viewport) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateViewport");
                    };
                    TablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedRowHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getCellWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getContentWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
                        // default implementation has no adjustment
                    };
                    /**
                     * This call makes room for parent header cells where neccessary.
                     * Since HTML cells that span vertically displace other rows,
                     * room has to be made for spanning headers that leave an exiting
                     * row to enter the new row that it starts from and removed when
                     * returning to an entering row.
                     */
                    TablixLayoutManager.prototype.alignRowHeaderCells = function (item, currentRow) {
                        var index = currentRow.getRowHeaderLeafIndex();
                        if (index === -1) {
                            return;
                        }
                        var rowDimension = this._owner.rowDimension;
                        var leaf = rowDimension.getFirstVisibleChildLeaf(item);
                        if (!this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item)) {
                            return;
                        }
                        currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                        get: function () {
                            return this._grid;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                        get: function () {
                            return this._rowLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                        get: function () {
                            return this._columnLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.showEmptySpaceHeader");
                        return false;
                    };
                    TablixLayoutManager.prototype.onStartRenderingSession = function (scrollingDimension, parentElement, clear) {
                        if (this.showEmptySpaceHeader()) {
                            var cell = this._grid.emptySpaceHeaderCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceHeaderCell(cell);
                            }
                            cell = this._grid.emptySpaceFooterCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceFooterCell(cell);
                            }
                            this._grid.HideEmptySpaceCells();
                        }
                        this._scrollingDimension = scrollingDimension;
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.startScrollingSession();
                        }
                        this._rowLayoutManager.onStartRenderingSession();
                        this._columnLayoutManager.onStartRenderingSession();
                        this._grid.onStartRenderingSession(clear);
                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                        if (measureEnabled)
                            this.measureSampleText(parentElement);
                    };
                    TablixLayoutManager.prototype.onEndRenderingSession = function () {
                        this._rowLayoutManager.onEndRenderingSession();
                        this._columnLayoutManager.onEndRenderingSession();
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.endScrollingSession();
                        }
                        this._scrollingDimension = null;
                        if (this.showEmptySpaceHeader()) {
                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                            if (emptySpace > 0) {
                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                var cell = this._grid.emptySpaceHeaderCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceHeaderCell(cell);
                                }
                                cell = this._grid.emptySpaceFooterCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceFooterCell(cell);
                                }
                            }
                        }
                    };
                    TablixLayoutManager.prototype.onStartRenderingIteration = function (clear) {
                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight());
                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth());
                        this._grid.onStartRenderingIteration();
                    };
                    TablixLayoutManager.prototype.onEndRenderingIteration = function () {
                        this._grid.onEndRenderingIteration();
                        // ANDREMI: Comment out for static tablix
                        this._columnLayoutManager.calculateSizes(); // calculate the entire grid first without altering the tree to avoid multiple measure pass invoking
                        this._rowLayoutManager.calculateSizes();
                        this._columnLayoutManager.fixSizes(); // now assign the sizes
                        this._rowLayoutManager.fixSizes();
                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns); // if we are in a middle of a resize, the column to resize might have been swaped during the render, restore its resize state
                        this._columnLayoutManager.applyScrolling();
                        this._rowLayoutManager.applyScrolling();
                        this._columnLayoutManager.onEndRenderingIteration();
                        this._rowLayoutManager.onEndRenderingIteration();
                        return this._columnLayoutManager.done && this._rowLayoutManager.done;
                    };
                    TablixLayoutManager.prototype.onCornerCellRealized = function (item, cell) {
                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item);
                        var rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                        if (columnLeaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf);
                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        var tablixCell = cell;
                        if (tablixCell.colSpan > 1)
                            tablixCell.setContainerWidth(-1);
                        this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onColumnHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        if (leaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onBodyCellRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onBodyCellFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.setAllowHeaderResize = function (value) {
                        this._allowHeaderResize = value;
                    };
                    TablixLayoutManager.prototype.enableCellHorizontalResize = function (isLeaf, cell) {
                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                    };
                    TablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedTextWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.measureSampleText");
                    };
                    return TablixLayoutManager;
                }());
                internal.TablixLayoutManager = TablixLayoutManager;
                var DashboardTablixLayoutManager = /** @class */ (function (_super) {
                    __extends(DashboardTablixLayoutManager, _super);
                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                        var _this = this;
                        var dashboardColumnLayoutManager = new DashboardColumnLayoutManager(null, grid, columnRealizationManager);
                        var dashboardRowLayoutManager = new DashboardRowLayoutManager(null, grid, rowRealizationManager);
                        _this = _super.call(this, binder, grid, dashboardColumnLayoutManager, dashboardRowLayoutManager) || this;
                        dashboardColumnLayoutManager.owner = _this;
                        dashboardRowLayoutManager.owner = _this;
                        _this._sizeComputationManager = sizeComputationManager;
                        return _this;
                    }
                    DashboardTablixLayoutManager.createLayoutManager = function (binder) {
                        // computed sizes are shared between layout manager and grid presenter
                        var sizeComputationManager = new SizeComputationManager();
                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    DashboardTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "tablixDashboard";
                    };
                    DashboardTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 1 /* DashboardTile */;
                    };
                    DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return false;
                    };
                    DashboardTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        var textProperties = powerbi.TextMeasurementService.getSvgMeasurementProperties(parentElement);
                        this._characterHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                        this._sizeComputationManager.updateRowHeight(this._characterHeight);
                        var actualTextSize = PixelConverter.toPoint(parseFloat(textProperties.fontSize));
                        var scalingFactor = actualTextSize / controls.TablixDefaultTextSize;
                        this._sizeComputationManager.updateScalingFactor(powerbi.Double.toIncrement(scalingFactor, 0.05));
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleWidth = function () {
                        return this._sizeComputationManager.visibleWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleHeight = function () {
                        return this._sizeComputationManager.visibleHeight;
                    };
                    DashboardTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return this._sizeComputationManager.cellWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        // On the dashboard it does not matter what text we render, 
                        // we always use the same content width
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
                        this._sizeComputationManager.hasImageContent = hasImage;
                    };
                    DashboardTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // The total number of columns is the number (depth) of row groups + the number of (leaf) column group instances
                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0;
                        var columnInstances = columnDimension ? columnDimension.getItemsCount() : 0;
                        var totalColumnCount = rowDimensionDepth + columnInstances;
                        // Adjust the column count by the static row header (if any)
                        if (!this.binder.hasRowGroups())
                            totalColumnCount--;
                        this._sizeComputationManager.updateColumnCount(totalColumnCount);
                    };
                    DashboardTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        this._sizeComputationManager.updateViewport(viewport);
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this._characterHeight;
                    };
                    return DashboardTablixLayoutManager;
                }(TablixLayoutManager));
                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                var CanvasTablixLayoutManager = /** @class */ (function (_super) {
                    __extends(CanvasTablixLayoutManager, _super);
                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                        var _this = this;
                        var canvasColumnLayoutManager = new CanvasColumnLayoutManager(null, grid, columnRealizationManager);
                        var canvasRowLayoutManager = new CanvasRowLayoutManager(null, grid, rowRealizationManager);
                        _this = _super.call(this, binder, grid, canvasColumnLayoutManager, canvasRowLayoutManager) || this;
                        canvasColumnLayoutManager.owner = _this;
                        canvasRowLayoutManager.owner = _this;
                        return _this;
                    }
                    CanvasTablixLayoutManager.createLayoutManager = function (binder, columnWidthManager) {
                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter(columnWidthManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    CanvasTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "tablixCanvas";
                    };
                    CanvasTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 0 /* Canvas */;
                    };
                    CanvasTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        // TODO: Use TextMeasurementService once the DOM methods are fixed (they are not working right now)
                        var textDiv = controls.internal.TablixUtils.createDiv();
                        textDiv.style.cssFloat = 'left';
                        textDiv.style.whiteSpace = 'nowrap';
                        textDiv.style.overflow = 'hidden';
                        textDiv.style.lineHeight = 'normal';
                        parentElement.appendChild(textDiv);
                        var textNode = document.createTextNode("a");
                        textDiv.appendChild(textNode);
                        this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv);
                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv);
                        textDiv.removeChild(textNode);
                        parentElement.removeChild(textDiv);
                    };
                    CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return !this._columnLayoutManager.fillProportionally;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleWidth = function () {
                        if (this._columnLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeWidth && this._owner.maxWidth) {
                                return this._owner.maxWidth;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementWidth(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleHeight = function () {
                        if (this._rowLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeHeight && this._owner.maxHeight) {
                                return this._owner.maxHeight;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementHeight(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return cell.containerWidth;
                    };
                    CanvasTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return cell.contentWidth;
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function (text) {
                        return text ? text.length * this.characterWidth : 0;
                    };
                    CanvasTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this.characterHeight;
                    };
                    return CanvasTablixLayoutManager;
                }(TablixLayoutManager));
                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this exclusion onto new files! */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var HTMLElementUtils;
            (function (HTMLElementUtils) {
                function clearChildren(element) {
                    if (!element) {
                        return;
                    }
                    while (element.hasChildNodes()) {
                        element.removeChild(element.firstChild);
                    }
                }
                HTMLElementUtils.clearChildren = clearChildren;
                function setElementTop(element, top) {
                    element.style.top = top + "px";
                }
                HTMLElementUtils.setElementTop = setElementTop;
                function setElementLeft(element, left) {
                    element.style.left = left + "px";
                }
                HTMLElementUtils.setElementLeft = setElementLeft;
                function setElementHeight(element, height) {
                    if (HTMLElementUtils.isAutoSize(height))
                        element.style.height = "";
                    else
                        element.style.height = height + "px";
                }
                HTMLElementUtils.setElementHeight = setElementHeight;
                function setElementWidth(element, width) {
                    if (HTMLElementUtils.isAutoSize(width))
                        element.style.width = "";
                    else
                        element.style.width = width + "px";
                }
                HTMLElementUtils.setElementWidth = setElementWidth;
                function getElementWidth(element) {
                    return element.offsetWidth;
                }
                HTMLElementUtils.getElementWidth = getElementWidth;
                function getElementHeight(element) {
                    return element.offsetHeight;
                }
                HTMLElementUtils.getElementHeight = getElementHeight;
                function isAutoSize(size) {
                    return size === -1;
                }
                HTMLElementUtils.isAutoSize = isAutoSize;
                function getAccumulatedScale(element) {
                    var scale = 1;
                    while (element) {
                        scale *= HTMLElementUtils.getScale(element);
                        element = element.parentElement;
                    }
                    return scale;
                }
                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale;
                /**
                 * Get scale of element, return 1 when not scaled.
                 */
                function getScale(element) {
                    element = $(element);
                    var str = element.css('-webkit-transform') ||
                        element.css('-moz-transform') ||
                        element.css('-ms-transform') ||
                        element.css('-o-transform') ||
                        element.css('transform');
                    return (str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) ||
                        str.match(/\d+/) && Number(str.match(/\d+/)[0]))) || 1;
                }
                HTMLElementUtils.getScale = getScale;
                function getRelativeMouseCoordinates(element, mouseEvent) {
                    var rect = element.getBoundingClientRect();
                    var scale = HTMLElementUtils.getAccumulatedScale(element);
                    return {
                        x: (mouseEvent.pageX - rect.left) / scale,
                        y: (mouseEvent.pageY - rect.top) / scale
                    };
                }
                HTMLElementUtils.getRelativeMouseCoordinates = getRelativeMouseCoordinates;
            })(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var DataViewMatrixUtils = powerbi.data.DataViewMatrixUtils;
                var DataViewRoleWildCard = powerbi.data.DataViewRoleWildcard;
                var DomFactory = InJs.DomFactory;
                var FontSize = powerbi.visuals.Units.FontSize;
                var UrlScheme = jsCommon.UrlUtils.UrlScheme;
                var UrlUtils = jsCommon.UrlUtils;
                // ToDo: Get out to a separate file and let it under powerbi.visuals    
                var TablixObjects;
                (function (TablixObjects) {
                    TablixObjects.ObjectGeneral = "general";
                    TablixObjects.ObjectGrid = "grid";
                    TablixObjects.ObjectColumnHeaders = "columnHeaders";
                    TablixObjects.ObjectRowHeaders = "rowHeaders";
                    TablixObjects.ObjectValues = "values";
                    TablixObjects.ObjectTotal = "total";
                    TablixObjects.ObjectSubTotals = "subTotals";
                    TablixObjects.ObjectColumnFormatting = "columnFormatting";
                    TablixObjects.ObjectColumnWidth = 'columnWidth';
                    /**
                     * Represents a DataViewObjects property related to the Tablix
                     */
                    var TablixProperty = /** @class */ (function () {
                        /**
                         * Creates a new TablixProperty
                         * @param {string} objectName Object Name
                         * @param {string} propertyName Property Name
                         * @param {any} defaultValue Default value of the Property
                         * @param {ObjectValueGetterFunction} getterFuntion Function used to get the Property value from the Objects, default is DataViewObjects.getValue
                         * @param {TablixProperty<T>[]} fallbackProperties List of properties to fallback in sequence
                         */
                        function TablixProperty(objectName, propertyName, defaultValue, getterFuntion, fallbackProperties) {
                            this.objectName = objectName;
                            this.propertyName = propertyName;
                            this.defaultValue = defaultValue;
                            this.fallbackProperties = fallbackProperties;
                            this.getterFuntion = getterFuntion || powerbi.DataViewObjects.getValue;
                        }
                        /**
                         * Gets the value of the Property from the Objects
                         * @param {DataViewObjects} objects DataView Objects to get the value from
                         * @param {boolean} useDefault True to fall back to the Default value if the Property is missing from the objects. False to return undefined
                         * @returns Value of the property
                         */
                        TablixProperty.prototype.getValue = function (objects) {
                            // We use this when we intend to have undefined for missing properties. Useful in letting styles fallback to CSS if not defined
                            var value = this.getterFuntion(objects, this, this.defaultValue);
                            if (value !== undefined)
                                return value;
                            if (!_.isEmpty(this.fallbackProperties)) {
                                for (var _i = 0, _a = this.fallbackProperties; _i < _a.length; _i++) {
                                    var property = _a[_i];
                                    value = property.getValue(objects);
                                    if (value !== undefined)
                                        return value;
                                }
                            }
                        };
                        TablixProperty.prototype.setInstanceProperty = function (instance, objects) {
                            var value = this.getValue(objects);
                            if (instance && instance.properties) {
                                instance.properties[this.propertyName] = value;
                            }
                            return value;
                        };
                        return TablixProperty;
                    }());
                    TablixObjects.TablixProperty = TablixProperty;
                    // Per Column
                    TablixObjects.PropColumnFormatString = new TablixProperty(TablixObjects.ObjectGeneral, 'formatString', undefined);
                    // General
                    TablixObjects.PropGeneralAutoSizeColumns = new TablixProperty(TablixObjects.ObjectGeneral, 'autoSizeColumnWidth', true);
                    TablixObjects.PropGeneralTextSize = new TablixProperty(TablixObjects.ObjectGeneral, 'textSize', 8);
                    TablixObjects.PropGeneralTableTotals = new TablixProperty(TablixObjects.ObjectGeneral, 'totals', true);
                    TablixObjects.PropGeneralMatrixRowSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'rowSubtotals', true);
                    TablixObjects.PropGeneralMatrixColumnSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'columnSubtotals', true);
                    //Grid
                    TablixObjects.PropGridVertical = new TablixProperty(TablixObjects.ObjectGrid, 'gridVertical', false);
                    TablixObjects.PropGridVerticalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridVerticalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalWeight', 1);
                    TablixObjects.PropGridHorizontalTable = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', true);
                    TablixObjects.PropGridHorizontalMatrix = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', false);
                    TablixObjects.PropGridHorizontalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridHorizontalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalWeight', 1);
                    TablixObjects.PropGridRowPadding = new TablixProperty(TablixObjects.ObjectGrid, 'rowPadding', 0);
                    TablixObjects.PropGridOutlineColor = new TablixProperty(TablixObjects.ObjectGrid, 'outlineColor', "#CCC", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridOutlineWeight = new TablixProperty(TablixObjects.ObjectGrid, 'outlineWeight', 1);
                    TablixObjects.PropGridImageHeight = new TablixProperty(TablixObjects.ObjectGrid, 'imageHeight', 75);
                    TablixObjects.PropGridPivotTableTextSize = new TablixProperty(TablixObjects.ObjectGrid, 'textSize', 8);
                    // Column Headers
                    TablixObjects.PropColumnsFontColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnsFontFamily = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'fontFamily', visuals.Font.Family.regular.css);
                    TablixObjects.PropColumnsFontSize = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'fontSize', undefined, null, [TablixObjects.PropGridPivotTableTextSize]);
                    TablixObjects.PropColumnsBackColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnsOutline = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'outline', "BottomOnly");
                    TablixObjects.PropColumnsAlignment = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'alignment', visuals.textAlignment.auto);
                    TablixObjects.PropColumnPivotTableAutoSizeColumns = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'autoSizeColumnWidth', true);
                    TablixObjects.PropColumnsWordWrap = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'wordWrap', false);
                    TablixObjects.PropColumnsUrlIcon = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'urlIcon', false);
                    // Row Headers
                    TablixObjects.PropRowsFontColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropRowsFontFamily = new TablixProperty(TablixObjects.ObjectRowHeaders, 'fontFamily', visuals.Font.Family.regular.css);
                    TablixObjects.PropRowsFontSize = new TablixProperty(TablixObjects.ObjectRowHeaders, 'fontSize', undefined, null, [TablixObjects.PropGridPivotTableTextSize]);
                    TablixObjects.PropRowsBackColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropRowsOutline = new TablixProperty(TablixObjects.ObjectRowHeaders, 'outline', "RightOnly");
                    TablixObjects.PropRowsAlignment = new TablixProperty(TablixObjects.ObjectRowHeaders, 'alignment', visuals.textAlignment.auto);
                    TablixObjects.PropRowsSteppedLayout = new TablixProperty(TablixObjects.ObjectRowHeaders, 'stepped', true);
                    TablixObjects.PropRowsSteppedLayoutIndentation = new TablixProperty(TablixObjects.ObjectRowHeaders, 'steppedLayoutIndentation', 10);
                    TablixObjects.PropRowsWordWrap = new TablixProperty(TablixObjects.ObjectRowHeaders, 'wordWrap', false);
                    TablixObjects.PropRowsUrlIcon = new TablixProperty(TablixObjects.ObjectRowHeaders, 'urlIcon', false);
                    // Values
                    TablixObjects.PropValuesBackColor = new TablixProperty(TablixObjects.ObjectValues, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesFontColor = new TablixProperty(TablixObjects.ObjectValues, 'fontColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesFontFamily = new TablixProperty(TablixObjects.ObjectValues, 'fontFamily', visuals.Font.Family.regular.css);
                    TablixObjects.PropValuesFontSize = new TablixProperty(TablixObjects.ObjectValues, 'fontSize', undefined, null, [TablixObjects.PropGridPivotTableTextSize]);
                    TablixObjects.PropValuesFontColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorPrimary', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBackColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'backColorPrimary', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesFontColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorSecondary', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBackColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'backColorSecondary', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBandedRowHeaders = new TablixProperty(TablixObjects.ObjectValues, 'bandedRowHeaders', true);
                    TablixObjects.PropValuesOutline = new TablixProperty(TablixObjects.ObjectValues, 'outline', "None");
                    TablixObjects.PropValuesUrlIcon = new TablixProperty(TablixObjects.ObjectValues, 'urlIcon', false);
                    TablixObjects.PropValuesWordWrap = new TablixProperty(TablixObjects.ObjectValues, 'wordWrap', false);
                    TablixObjects.PropValuesOnRow = new TablixProperty(TablixObjects.ObjectValues, 'valuesOnRow', false, powerbi.DataViewObjects.getValue);
                    // Total
                    TablixObjects.PropTotalTableExTotals = new TablixProperty(TablixObjects.ObjectTotal, 'totals', true);
                    TablixObjects.PropTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, 'fontColor', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropTotalFontFamily = new TablixProperty(TablixObjects.ObjectTotal, 'fontFamily', undefined, null, [TablixObjects.PropValuesFontFamily]);
                    TablixObjects.PropTotalFontSize = new TablixProperty(TablixObjects.ObjectTotal, 'fontSize', undefined, null, [TablixObjects.PropValuesFontSize]);
                    TablixObjects.PropTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropTotalOutline = new TablixProperty(TablixObjects.ObjectTotal, 'outline', "TopOnly");
                    // SubTotals
                    TablixObjects.PropSubTotalsFontColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'fontColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropSubTotalsFontFamily = new TablixProperty(TablixObjects.ObjectSubTotals, 'fontFamily', undefined, null, [TablixObjects.PropValuesFontFamily]);
                    TablixObjects.PropSubTotalsFontSize = new TablixProperty(TablixObjects.ObjectSubTotals, 'fontSize', undefined, null, [TablixObjects.PropValuesFontSize]);
                    TablixObjects.PropSubTotalsBackColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropSubTotalsPivotTableRowSubtotals = new TablixProperty(TablixObjects.ObjectSubTotals, 'rowSubtotals', true);
                    TablixObjects.PropSubTotalsPivotTableRowSubtotalsPosition = new TablixProperty(TablixObjects.ObjectSubTotals, 'rowSubtotalsPosition', 
                    /* defaultValue*/ undefined, function (objects, propertyId, defaultValue) {
                        var value = powerbi.DataViewObjects.getValue(objects, propertyId, defaultValue);
                        if (value != null)
                            return value;
                        return TablixObjects.PropRowsSteppedLayout.getValue(objects) ? visuals.rowSubtotalPosition.top : visuals.rowSubtotalPosition.bottom;
                    });
                    TablixObjects.PropSubTotalsPivotTableRowSubtotalsPerLevel = new TablixProperty(TablixObjects.ObjectSubTotals, 'perRowLevel', false);
                    TablixObjects.PropSubTotalsPivotTableColumnSubtotals = new TablixProperty(TablixObjects.ObjectSubTotals, 'columnSubtotals', true);
                    TablixObjects.PropSubTotalsPivotTableColumnSubtotalsPerLevel = new TablixProperty(TablixObjects.ObjectSubTotals, 'perColumnLevel', false);
                    TablixObjects.PropSubTotalsPivotTableLevelSubtotalEnabled = new TablixProperty(TablixObjects.ObjectSubTotals, 'levelSubtotalEnabled', true);
                    TablixObjects.PropSubTotalsApplyToHeaders = new TablixProperty(TablixObjects.ObjectSubTotals, "applyToHeaders", false);
                    // Grand Total
                    TablixObjects.PropGrandTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, 'fontColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGrandTotalFontFamily = new TablixProperty(TablixObjects.ObjectTotal, 'fontFamily', undefined, null, [TablixObjects.PropSubTotalsFontFamily]);
                    TablixObjects.PropGrandTotalFontSize = new TablixProperty(TablixObjects.ObjectTotal, 'fontSize', undefined, null, [TablixObjects.PropSubTotalsFontSize]);
                    TablixObjects.PropGrandTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGrandTotalApplyToHeaders = new TablixProperty(TablixObjects.ObjectTotal, "applyToHeaders", false);
                    // Column Formatting
                    TablixObjects.PropColumnFormattingFontColor = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'fontColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnFormattingBackColor = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnFormattingAlignment = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'alignment', visuals.textAlignment.auto);
                    TablixObjects.PropColumnFormattingStyleHeader = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'styleHeader', false);
                    TablixObjects.PropColumnFormattingStyleValues = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'styleValues', true);
                    TablixObjects.PropColumnFormattingStyleSubtotals = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'styleSubtotals', true);
                    // For Table Total and Matrix Grand total
                    TablixObjects.PropColumnFormattingStyleTotal = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'styleTotal', false);
                    TablixObjects.PropColumnFormattingDataBars = new TablixProperty(TablixObjects.ObjectColumnFormatting, 'dataBars', undefined);
                    // Column maxWidth        
                    TablixObjects.PropColumnWidthValue = new TablixProperty(TablixObjects.ObjectColumnWidth, 'value', undefined);
                    /**
                     * Get the DataViewObject from the DataView
                     * @param {DataView} dataview The DataView
                     * @returns DataViewObjects (dataView.metadata.objects)
                     */
                    function getMetadadataObjects(dataview) {
                        if (dataview && dataview.metadata)
                            return dataview.metadata.objects;
                        return null;
                    }
                    TablixObjects.getMetadadataObjects = getMetadadataObjects;
                    function enumerateObjectRepetition(enumeration, dataView, tablixType, enableDataBars) {
                        debug.assertValue(enumeration, 'enumeration should be defined');
                        debug.assertValue(dataView, "dataView can't be undefined");
                        var columns;
                        var selectorData = [];
                        switch (tablixType) {
                            case controls.TablixType.Table:
                            case controls.TablixType.TableEx:
                                columns = getTableColumnMetadata(dataView);
                                selectorData = [DataViewRoleWildCard.fromRoles(['Values'])];
                                break;
                            case controls.TablixType.Matrix:
                            case controls.TablixType.PivotTable:
                                columns = getMatrixValuesColumnMetadata(dataView);
                                selectorData = [DataViewRoleWildCard.fromRoles(['Rows', 'Columns'])];
                                break;
                            default:
                                debug.assertFail("enumerateObjectRepetition called with unexpected tablixType");
                                return;
                        }
                        if (!columns)
                            return;
                        for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                            var column = columns_1[_i];
                            // ToDo: drop this checking when we support Conditional Formatting based on another column
                            if (column.isMeasure && column.type.numeric) {
                                var backColorScalesRepetition = {
                                    containerName: column.displayName,
                                    selector: {
                                        data: selectorData,
                                        metadata: column.queryName,
                                    },
                                    objects: (_a = {},
                                        _a[TablixObjects.ObjectValues] = {
                                            formattingProperties: [
                                                TablixObjects.PropValuesBackColor.propertyName,
                                            ]
                                        },
                                        _a)
                                };
                                enumeration.push(backColorScalesRepetition);
                                if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                                    var fontColorScalesRepetition = {
                                        containerName: column.displayName,
                                        selector: {
                                            data: selectorData,
                                            metadata: column.queryName,
                                        },
                                        objects: (_b = {},
                                            _b[TablixObjects.ObjectValues] = {
                                                formattingProperties: [
                                                    TablixObjects.PropValuesFontColor.propertyName,
                                                ]
                                            },
                                            _b)
                                    };
                                    enumeration.push(fontColorScalesRepetition);
                                }
                                if (enableDataBars) {
                                    if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                                        var dataBarsRepetition = {
                                            containerName: column.displayName,
                                            selector: { metadata: column.queryName },
                                            objects: (_c = {},
                                                _c[TablixObjects.ObjectColumnFormatting] = {
                                                    formattingProperties: [TablixObjects.PropColumnFormattingDataBars.propertyName]
                                                },
                                                _c)
                                        };
                                        enumeration.push(dataBarsRepetition);
                                    }
                                }
                            }
                        }
                        var _a, _b, _c;
                    }
                    TablixObjects.enumerateObjectRepetition = enumerateObjectRepetition;
                    function enumerateObjectInstances(options, enumeration, dataView, tablixType) {
                        debug.assertValue(dataView, "dataView can't be undefined");
                        var objects = getMetadadataObjects(dataView);
                        var totalsShown = true;
                        if (tablixType === controls.TablixType.Table) {
                            totalsShown = shouldShowTableTotalsOption(dataView) && TablixObjects.PropGeneralTableTotals.getValue(objects);
                        }
                        else {
                            totalsShown =
                                (shouldShowColumnSubtotalsOption(dataView) && TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects)) ||
                                    (shouldShowRowSubtotalsOption(dataView) && TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects));
                        }
                        switch (options.objectName) {
                            case TablixObjects.ObjectGeneral:
                                enumerateGeneralOptions(enumeration, objects, tablixType, dataView);
                                break;
                            case TablixObjects.ObjectGrid:
                                enumerateGridOptions(enumeration, objects, tablixType);
                                break;
                            case TablixObjects.ObjectColumnHeaders:
                                enumerateColumnHeadersOptions(enumeration, objects, tablixType);
                                break;
                            case TablixObjects.ObjectRowHeaders:
                                enumerateRowHeadersOptions(enumeration, objects, tablixType);
                                break;
                            case TablixObjects.ObjectValues:
                                enumerateValuesOptions(enumeration, objects, tablixType);
                                break;
                            case TablixObjects.ObjectTotal:
                                if (tablixType === controls.TablixType.TableEx) {
                                    enumerateTotalOptions(enumeration, objects, controls.TablixType.TableEx);
                                }
                                else {
                                    if (totalsShown) {
                                        if (tablixType === controls.TablixType.Table)
                                            enumerateTotalOptions(enumeration, objects, controls.TablixType.TableEx);
                                        else
                                            enumerateGrandTotalOptions(enumeration, objects, tablixType);
                                    }
                                }
                                break;
                            case TablixObjects.ObjectSubTotals:
                                if (totalsShown || tablixType === controls.TablixType.PivotTable) {
                                    enumerateSubTotalsOptions(enumeration, objects, tablixType, dataView);
                                }
                                break;
                            case TablixObjects.ObjectColumnFormatting:
                                enumerateColumnFormattingOptions(enumeration, getColumnsMetadata(dataView, tablixType), tablixType);
                                break;
                            default:
                                break;
                        }
                    }
                    TablixObjects.enumerateObjectInstances = enumerateObjectInstances;
                    function getColumnsMetadata(dataView, tablixType) {
                        switch (tablixType) {
                            case controls.TablixType.Table:
                            case controls.TablixType.TableEx:
                                return getTableColumnMetadata(dataView);
                            case controls.TablixType.Matrix:
                            case controls.TablixType.PivotTable:
                                return getMatrixValuesColumnMetadata(dataView);
                            default:
                                debug.assertFail("TablixUtils.enumerateObjectInstances - Unexpected tablixType: " + tablixType);
                                return;
                        }
                    }
                    function getTableColumnMetadata(dataView) {
                        if (!dataView || !dataView.table || _.isEmpty(dataView.table.columns))
                            return;
                        return dataView.table.columns;
                    }
                    function getMatrixValuesColumnMetadata(dataView) {
                        if (!dataView || !dataView.matrix || _.isEmpty(dataView.matrix.valueSources))
                            return;
                        return dataView.matrix.valueSources;
                    }
                    function createVisualObjectInstance(objectName, selector, displayName) {
                        if (selector === void 0) { selector = null; }
                        var instance = {
                            selector: selector,
                            objectName: objectName,
                            properties: {},
                        };
                        if (displayName != null)
                            instance.displayName = displayName;
                        return instance;
                    }
                    function enumerateGeneralOptions(enumeration, objects, tablixType, dataView) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectGeneral);
                        // Total and SubTotals
                        switch (tablixType) {
                            case controls.TablixType.Table:
                                TablixObjects.PropGeneralAutoSizeColumns.setInstanceProperty(instance, objects);
                                TablixObjects.PropGeneralTextSize.setInstanceProperty(instance, objects);
                                if (shouldShowTableTotalsOption(dataView))
                                    TablixObjects.PropGeneralTableTotals.setInstanceProperty(instance, objects);
                                break;
                            case controls.TablixType.Matrix:
                                TablixObjects.PropGeneralAutoSizeColumns.setInstanceProperty(instance, objects);
                                TablixObjects.PropGeneralTextSize.setInstanceProperty(instance, objects);
                                if (shouldShowRowSubtotalsOption(dataView))
                                    TablixObjects.PropGeneralMatrixRowSubtotals.setInstanceProperty(instance, objects);
                                if (shouldShowColumnSubtotalsOption(dataView))
                                    TablixObjects.PropGeneralMatrixColumnSubtotals.setInstanceProperty(instance, objects);
                                break;
                        }
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateGeneralOptions = enumerateGeneralOptions;
                    function enumerateGridOptions(enumeration, objects, tablixType) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectGrid);
                        // Vertical Grid
                        var verticalGridEnabled = TablixObjects.PropGridVertical.getValue(objects);
                        TablixObjects.PropGridVertical.setInstanceProperty(instance, objects);
                        if (verticalGridEnabled) {
                            TablixObjects.PropGridVerticalColor.setInstanceProperty(instance, objects);
                            TablixObjects.PropGridVerticalWeight.setInstanceProperty(instance, objects);
                        }
                        var isTable = tablixType === controls.TablixType.Table || tablixType === controls.TablixType.TableEx;
                        // Horizontal Grid
                        var horizontalGridEnabled = (isTable ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).getValue(objects);
                        (isTable ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).setInstanceProperty(instance, objects);
                        if (horizontalGridEnabled) {
                            TablixObjects.PropGridHorizontalColor.setInstanceProperty(instance, objects);
                            TablixObjects.PropGridHorizontalWeight.setInstanceProperty(instance, objects);
                        }
                        // Row Padding
                        TablixObjects.PropGridRowPadding.setInstanceProperty(instance, objects);
                        // Outline
                        TablixObjects.PropGridOutlineColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropGridOutlineWeight.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx)
                            TablixObjects.PropGridPivotTableTextSize.setInstanceProperty(instance, objects);
                        // Image Height
                        TablixObjects.PropGridImageHeight.setInstanceProperty(instance, objects);
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateGridOptions = enumerateGridOptions;
                    function enumerateColumnHeadersOptions(enumeration, objects, tablixType) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectColumnHeaders);
                        TablixObjects.PropColumnsFontColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropColumnsBackColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropColumnsOutline.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                            TablixObjects.PropColumnPivotTableAutoSizeColumns.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnsFontFamily.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnsFontSize.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnsAlignment.setInstanceProperty(instance, objects);
                        }
                        if (tablixType === controls.TablixType.PivotTable)
                            TablixObjects.PropColumnsUrlIcon.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.Table || tablixType === controls.TablixType.TableEx || tablixType === controls.TablixType.PivotTable)
                            TablixObjects.PropColumnsWordWrap.setInstanceProperty(instance, objects);
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateColumnHeadersOptions = enumerateColumnHeadersOptions;
                    function enumerateRowHeadersOptions(enumeration, objects, tablixType) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectRowHeaders);
                        TablixObjects.PropRowsFontColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropRowsBackColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropRowsOutline.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable) {
                            var steppedLayout = TablixObjects.PropRowsSteppedLayout.setInstanceProperty(instance, objects);
                            if (steppedLayout)
                                TablixObjects.PropRowsSteppedLayoutIndentation.setInstanceProperty(instance, objects);
                            TablixObjects.PropRowsUrlIcon.setInstanceProperty(instance, objects);
                        }
                        if (tablixType === controls.TablixType.Matrix || tablixType === controls.TablixType.PivotTable) {
                            TablixObjects.PropRowsWordWrap.setInstanceProperty(instance, objects);
                        }
                        if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                            TablixObjects.PropRowsFontFamily.setInstanceProperty(instance, objects);
                            TablixObjects.PropRowsFontSize.setInstanceProperty(instance, objects);
                            TablixObjects.PropRowsAlignment.setInstanceProperty(instance, objects);
                        }
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateRowHeadersOptions = enumerateRowHeadersOptions;
                    function enumerateValuesOptions(enumeration, objects, tablixType) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectValues);
                        TablixObjects.PropValuesFontColorPrimary.setInstanceProperty(instance, objects);
                        TablixObjects.PropValuesBackColorPrimary.setInstanceProperty(instance, objects);
                        TablixObjects.PropValuesFontColorSecondary.setInstanceProperty(instance, objects);
                        TablixObjects.PropValuesBackColorSecondary.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable) {
                            TablixObjects.PropValuesBandedRowHeaders.setInstanceProperty(instance, objects);
                            TablixObjects.PropValuesOnRow.setInstanceProperty(instance, objects);
                        }
                        TablixObjects.PropValuesOutline.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.Table || tablixType === controls.TablixType.TableEx || tablixType === controls.TablixType.PivotTable)
                            TablixObjects.PropValuesUrlIcon.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                            TablixObjects.PropValuesWordWrap.setInstanceProperty(instance, objects);
                            TablixObjects.PropValuesFontFamily.setInstanceProperty(instance, objects);
                            TablixObjects.PropValuesFontSize.setInstanceProperty(instance, objects);
                        }
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateValuesOptions = enumerateValuesOptions;
                    function enumerateTotalOptions(enumeration, objects, tablixType) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectTotal);
                        var showProperties;
                        if (tablixType === controls.TablixType.TableEx)
                            showProperties = TablixObjects.PropTotalTableExTotals.setInstanceProperty(instance, objects);
                        else
                            showProperties = true;
                        if (showProperties) {
                            TablixObjects.PropTotalFontColor.setInstanceProperty(instance, objects);
                            TablixObjects.PropTotalBackColor.setInstanceProperty(instance, objects);
                            TablixObjects.PropTotalOutline.setInstanceProperty(instance, objects);
                            if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                                TablixObjects.PropTotalFontFamily.setInstanceProperty(instance, objects);
                                TablixObjects.PropTotalFontSize.setInstanceProperty(instance, objects);
                            }
                        }
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateTotalOptions = enumerateTotalOptions;
                    function enumerateGrandTotalOptions(enumeration, objects, tablixType) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectTotal);
                        TablixObjects.PropGrandTotalFontColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropGrandTotalFontFamily.setInstanceProperty(instance, objects);
                        TablixObjects.PropGrandTotalBackColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropGrandTotalApplyToHeaders.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx) {
                            TablixObjects.PropGrandTotalFontFamily.setInstanceProperty(instance, objects);
                            TablixObjects.PropGrandTotalFontSize.setInstanceProperty(instance, objects);
                        }
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateGrandTotalOptions = enumerateGrandTotalOptions;
                    function enumerateSubTotalsOptions(enumeration, objects, tablixType, dataView) {
                        var instance = createVisualObjectInstance(TablixObjects.ObjectSubTotals);
                        var rowSubtotalsEnabled = false;
                        var columnSubtotalsEnabled = false;
                        if (tablixType === controls.TablixType.PivotTable) {
                            if (shouldShowRowSubtotalsOption(dataView)) {
                                rowSubtotalsEnabled = TablixObjects.PropSubTotalsPivotTableRowSubtotals.setInstanceProperty(instance, objects);
                            }
                            if (shouldShowColumnSubtotalsOption(dataView)) {
                                columnSubtotalsEnabled = TablixObjects.PropSubTotalsPivotTableColumnSubtotals.setInstanceProperty(instance, objects);
                            }
                        }
                        TablixObjects.PropSubTotalsFontColor.setInstanceProperty(instance, objects);
                        TablixObjects.PropSubTotalsFontFamily.setInstanceProperty(instance, objects);
                        TablixObjects.PropSubTotalsBackColor.setInstanceProperty(instance, objects);
                        if (tablixType === controls.TablixType.PivotTable) {
                            TablixObjects.PropSubTotalsFontFamily.setInstanceProperty(instance, objects);
                            TablixObjects.PropSubTotalsFontSize.setInstanceProperty(instance, objects);
                            TablixObjects.PropSubTotalsApplyToHeaders.setInstanceProperty(instance, objects);
                        }
                        enumeration.pushInstance(instance);
                        if (rowSubtotalsEnabled) {
                            // Row subtotal position
                            instance = createVisualObjectInstance(TablixObjects.ObjectSubTotals);
                            TablixObjects.PropSubTotalsPivotTableRowSubtotalsPosition.setInstanceProperty(instance, objects);
                            enumeration.pushInstance(instance);
                            // Per row level
                            instance = createVisualObjectInstance(TablixObjects.ObjectSubTotals);
                            var perLevel = TablixObjects.PropSubTotalsPivotTableRowSubtotalsPerLevel.setInstanceProperty(instance, objects);
                            enumeration.pushInstance(instance, /* mergeInstances */ false);
                            if (perLevel)
                                enumeratePerLevelSubtotals(enumeration, dataView.matrix.rows.levels);
                        }
                        if (columnSubtotalsEnabled) {
                            // Per column level
                            instance = createVisualObjectInstance(TablixObjects.ObjectSubTotals);
                            var perLevel = TablixObjects.PropSubTotalsPivotTableColumnSubtotalsPerLevel.setInstanceProperty(instance, objects);
                            enumeration.pushInstance(instance, /* mergeInstances */ false);
                            debug.assert(!_.isEmpty(dataView.matrix.columns.levels), 'enumerateSubTotalsOptions: Emtpy column levels');
                            if (perLevel)
                                enumeratePerLevelSubtotals(enumeration, dataView.matrix.columns.levels);
                        }
                    }
                    TablixObjects.enumerateSubTotalsOptions = enumerateSubTotalsOptions;
                    function enumeratePerLevelSubtotals(enumeration, hierarchyLevels) {
                        debug.assert(!_.isEmpty(hierarchyLevels), 'enumeratePerLevelSubtotals: Emtpy levels');
                        for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {
                            var level = hierarchyLevels_1[_i];
                            for (var _a = 0, _b = level.sources; _a < _b.length; _a++) {
                                var source = _b[_a];
                                if (!source.isMeasure) {
                                    var instance = createVisualObjectInstance(TablixObjects.ObjectSubTotals, { metadata: source.queryName }, source.displayName);
                                    TablixObjects.PropSubTotalsPivotTableLevelSubtotalEnabled.setInstanceProperty(instance, source.objects);
                                    enumeration.pushInstance(instance, /* mergeInstances */ false);
                                }
                            }
                        }
                    }
                    function enumerateColumnFormattingOptions(enumeration, columns, tablixType) {
                        // Columns array can be empty in case of a Matrix with no measures
                        if (_.isEmpty(columns))
                            return;
                        for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
                            var column = columns_2[_i];
                            enumeration.pushContainer({ displayName: column.displayName });
                            var objects = column && column.objects;
                            var instance = createVisualObjectInstance(TablixObjects.ObjectColumnFormatting, { metadata: column.queryName });
                            TablixObjects.PropColumnFormattingFontColor.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnFormattingBackColor.setInstanceProperty(instance, objects);
                            if (tablixType === controls.TablixType.PivotTable || tablixType === controls.TablixType.TableEx)
                                TablixObjects.PropColumnFormattingAlignment.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnFormattingStyleHeader.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnFormattingStyleValues.setInstanceProperty(instance, objects);
                            if (tablixType === controls.TablixType.Matrix || tablixType === controls.TablixType.PivotTable)
                                TablixObjects.PropColumnFormattingStyleSubtotals.setInstanceProperty(instance, objects);
                            TablixObjects.PropColumnFormattingStyleTotal.setInstanceProperty(instance, objects);
                            enumeration.pushInstance(instance);
                            enumeration.popContainer();
                        }
                    }
                    TablixObjects.enumerateColumnFormattingOptions = enumerateColumnFormattingOptions;
                    function getTableObjects(dataView) {
                        var objects = getMetadadataObjects(dataView);
                        var generalTextSizePt = TablixObjects.PropGeneralTextSize.getValue(objects);
                        var generalTextSize = generalTextSizePt != null ? FontSize.createFromPt(+generalTextSizePt) : undefined;
                        var formattingProperties = {
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: generalTextSize,
                                totals: TablixObjects.PropGeneralTableTotals.getValue(objects),
                            },
                        };
                        formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
                        };
                        formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
                            wordWrap: TablixObjects.PropColumnsWordWrap.getValue(objects),
                        };
                        formattingProperties.values = {
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                            outline: TablixObjects.PropValuesOutline.getValue(objects),
                            urlIcon: TablixObjects.PropValuesUrlIcon.getValue(objects),
                        };
                        formattingProperties.total = {
                            fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                            backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                            outline: TablixObjects.PropTotalOutline.getValue(objects),
                        };
                        formattingProperties.columnFormatting = {};
                        var columns = getTableColumnMetadata(dataView);
                        if (columns) {
                            for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {
                                var column = columns_3[_i];
                                var objects_1 = column && column.objects;
                                formattingProperties.columnFormatting[column.queryName] = {
                                    fontColor: TablixObjects.PropColumnFormattingFontColor.getValue(objects_1),
                                    backColor: TablixObjects.PropColumnFormattingBackColor.getValue(objects_1),
                                    styleHeader: TablixObjects.PropColumnFormattingStyleHeader.getValue(objects_1),
                                    styleValues: TablixObjects.PropColumnFormattingStyleValues.getValue(objects_1),
                                    styleTotal: TablixObjects.PropColumnFormattingStyleTotal.getValue(objects_1),
                                };
                            }
                        }
                        return formattingProperties;
                    }
                    TablixObjects.getTableObjects = getTableObjects;
                    function getMatrixObjects(dataView) {
                        var objects = getMetadadataObjects(dataView);
                        var generalTextSizePt = TablixObjects.PropGeneralTextSize.getValue(objects);
                        var generalTextSize = generalTextSizePt != null ? FontSize.createFromPt(+generalTextSizePt) : undefined;
                        var formattingProperties = {
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: generalTextSize,
                                rowSubtotals: TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects),
                                columnSubtotals: TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects),
                            },
                        };
                        formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
                        };
                        formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
                        };
                        formattingProperties.rowHeaders = {
                            fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                            backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                            outline: TablixObjects.PropRowsOutline.getValue(objects),
                            wordWrap: TablixObjects.PropRowsWordWrap.getValue(objects),
                        };
                        formattingProperties.values = {
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                            outline: TablixObjects.PropValuesOutline.getValue(objects),
                        };
                        formattingProperties.grandTotal = {
                            fontColor: TablixObjects.PropGrandTotalFontColor.getValue(objects),
                            backColor: TablixObjects.PropGrandTotalBackColor.getValue(objects),
                            applyToHeaders: TablixObjects.PropGrandTotalApplyToHeaders.getValue(objects)
                        };
                        formattingProperties.subtotals = {
                            fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                            backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
                        };
                        formattingProperties.columnFormatting = {};
                        var columns = getMatrixValuesColumnMetadata(dataView);
                        if (columns) {
                            for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {
                                var column = columns_4[_i];
                                var objects_2 = column && column.objects;
                                formattingProperties.columnFormatting[column.queryName] = {
                                    fontColor: TablixObjects.PropColumnFormattingFontColor.getValue(objects_2),
                                    backColor: TablixObjects.PropColumnFormattingBackColor.getValue(objects_2),
                                    styleHeader: TablixObjects.PropColumnFormattingStyleHeader.getValue(objects_2),
                                    styleValues: TablixObjects.PropColumnFormattingStyleValues.getValue(objects_2),
                                    styleTotal: TablixObjects.PropColumnFormattingStyleTotal.getValue(objects_2),
                                    styleSubTotals: TablixObjects.PropColumnFormattingStyleSubtotals.getValue(objects_2),
                                };
                            }
                        }
                        return formattingProperties;
                    }
                    TablixObjects.getMatrixObjects = getMatrixObjects;
                    function getPivotTableObjects(dataView) {
                        var objects = getMetadadataObjects(dataView);
                        var generalFontSizePt = TablixObjects.PropGridPivotTableTextSize.getValue(objects);
                        var generalFontSize = generalFontSizePt != null ? FontSize.createFromPt(+generalFontSizePt) : undefined;
                        var columnHeaderFontSizePt = TablixObjects.PropColumnsFontSize.getValue(objects);
                        var columnHeaderFontSize = columnHeaderFontSizePt != null ? FontSize.createFromPt(+columnHeaderFontSizePt) : undefined;
                        var rowHeaderFontSizePt = TablixObjects.PropRowsFontSize.getValue(objects);
                        var rowHeaderFontSize = rowHeaderFontSizePt != null ? FontSize.createFromPt(+rowHeaderFontSizePt) : undefined;
                        var valuesFontSizePt = TablixObjects.PropValuesFontSize.getValue(objects);
                        var valuesFontSize = valuesFontSizePt != null ? FontSize.createFromPt(+valuesFontSizePt) : undefined;
                        var grandTotalFontSizePt = TablixObjects.PropGrandTotalFontSize.getValue(objects);
                        var grandTotalFontSize = grandTotalFontSizePt != null ? FontSize.createFromPt(+grandTotalFontSizePt) : undefined;
                        var subtotalsFontSizePt = TablixObjects.PropSubTotalsFontSize.getValue(objects);
                        var subtotalsFontSize = subtotalsFontSizePt != null ? FontSize.createFromPt(+subtotalsFontSizePt) : undefined;
                        var formattingProperties = {
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropColumnPivotTableAutoSizeColumns.getValue(objects),
                                textSize: generalFontSize,
                                rowSubtotals: TablixObjects.PropSubTotalsPivotTableRowSubtotals.getValue(objects),
                                columnSubtotals: TablixObjects.PropSubTotalsPivotTableColumnSubtotals.getValue(objects),
                            },
                            grid: {
                                gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                                gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                                gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                                gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
                                gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                                gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                                outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                                outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                                rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                                imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
                            },
                            columnHeaders: {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                fontFamily: TablixObjects.PropColumnsFontFamily.getValue(objects),
                                fontSize: columnHeaderFontSize,
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects),
                                urlIcon: TablixObjects.PropColumnsUrlIcon.getValue(objects),
                                wordWrap: TablixObjects.PropColumnsWordWrap.getValue(objects),
                                alignment: TablixObjects.PropColumnsAlignment.getValue(objects),
                            },
                            rowHeaders: {
                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                                fontFamily: TablixObjects.PropRowsFontFamily.getValue(objects),
                                fontSize: rowHeaderFontSize,
                                backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                                outline: TablixObjects.PropRowsOutline.getValue(objects),
                                steppedLayout: TablixObjects.PropRowsSteppedLayout.getValue(objects),
                                steppedLayoutIndentation: TablixObjects.PropRowsSteppedLayoutIndentation.getValue(objects),
                                urlIcon: TablixObjects.PropRowsUrlIcon.getValue(objects),
                                wordWrap: TablixObjects.PropRowsWordWrap.getValue(objects),
                                alignment: TablixObjects.PropRowsAlignment.getValue(objects),
                            },
                            values: {
                                fontFamily: TablixObjects.PropValuesFontFamily.getValue(objects),
                                fontSize: valuesFontSize,
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                bandedRowHeaders: TablixObjects.PropValuesBandedRowHeaders.getValue(objects),
                                outline: TablixObjects.PropValuesOutline.getValue(objects),
                                urlIcon: TablixObjects.PropValuesUrlIcon.getValue(objects),
                                wordWrap: TablixObjects.PropValuesWordWrap.getValue(objects),
                                valuesOnRow: TablixObjects.PropValuesOnRow.getValue(objects),
                            },
                            grandTotal: {
                                fontColor: TablixObjects.PropGrandTotalFontColor.getValue(objects),
                                fontFamily: TablixObjects.PropGrandTotalFontFamily.getValue(objects),
                                fontSize: grandTotalFontSize,
                                backColor: TablixObjects.PropGrandTotalBackColor.getValue(objects),
                                applyToHeaders: TablixObjects.PropGrandTotalApplyToHeaders.getValue(objects),
                            },
                            subtotals: {
                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                                fontFamily: TablixObjects.PropSubTotalsFontFamily.getValue(objects),
                                fontSize: subtotalsFontSize,
                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
                                applyToHeaders: TablixObjects.PropSubTotalsApplyToHeaders.getValue(objects),
                                rowSubtotalsPosition: TablixObjects.PropSubTotalsPivotTableRowSubtotalsPosition.getValue(objects),
                            }
                        };
                        formattingProperties.columnFormatting = {};
                        var columns = getMatrixValuesColumnMetadata(dataView);
                        if (columns) {
                            for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {
                                var column = columns_5[_i];
                                var objects_3 = column && column.objects;
                                formattingProperties.columnFormatting[column.queryName] = {
                                    fontColor: TablixObjects.PropColumnFormattingFontColor.getValue(objects_3),
                                    backColor: TablixObjects.PropColumnFormattingBackColor.getValue(objects_3),
                                    alignment: TablixObjects.PropColumnFormattingAlignment.getValue(objects_3),
                                    styleHeader: TablixObjects.PropColumnFormattingStyleHeader.getValue(objects_3),
                                    styleValues: TablixObjects.PropColumnFormattingStyleValues.getValue(objects_3),
                                    styleTotal: TablixObjects.PropColumnFormattingStyleTotal.getValue(objects_3),
                                    styleSubTotals: TablixObjects.PropColumnFormattingStyleSubtotals.getValue(objects_3),
                                    dataBarsSettings: TablixObjects.PropColumnFormattingDataBars.getValue(objects_3),
                                };
                            }
                        }
                        return formattingProperties;
                    }
                    TablixObjects.getPivotTableObjects = getPivotTableObjects;
                    function getTableExObjects(dataView) {
                        var objects = getMetadadataObjects(dataView);
                        var generalTextSizePt = TablixObjects.PropGridPivotTableTextSize.getValue(objects);
                        var generalTextSize = generalTextSizePt != null ? FontSize.createFromPt(+generalTextSizePt) : undefined;
                        var columnHeaderFontSizePt = TablixObjects.PropColumnsFontSize.getValue(objects);
                        var columnHeaderFontSize = columnHeaderFontSizePt != null ? FontSize.createFromPt(+columnHeaderFontSizePt) : undefined;
                        var valuesFontSizePt = TablixObjects.PropValuesFontSize.getValue(objects);
                        var valuesFontSize = valuesFontSizePt != null ? FontSize.createFromPt(+valuesFontSizePt) : undefined;
                        var totalFontSizePt = TablixObjects.PropTotalFontSize.getValue(objects);
                        var totalFontSize = totalFontSizePt != null ? FontSize.createFromPt(+totalFontSizePt) : undefined;
                        var formattingProperties = {
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropColumnPivotTableAutoSizeColumns.getValue(objects),
                                textSize: generalTextSize,
                                totals: TablixObjects.PropTotalTableExTotals.getValue(objects),
                            },
                        };
                        formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
                        };
                        formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                            fontFamily: TablixObjects.PropColumnsFontFamily.getValue(objects),
                            fontSize: columnHeaderFontSize,
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
                            wordWrap: TablixObjects.PropColumnsWordWrap.getValue(objects),
                            alignment: TablixObjects.PropColumnsAlignment.getValue(objects),
                        };
                        formattingProperties.values = {
                            fontFamily: TablixObjects.PropValuesFontFamily.getValue(objects),
                            fontSize: valuesFontSize,
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                            outline: TablixObjects.PropValuesOutline.getValue(objects),
                            urlIcon: TablixObjects.PropValuesUrlIcon.getValue(objects),
                            wordWrap: TablixObjects.PropValuesWordWrap.getValue(objects),
                        };
                        formattingProperties.total = {
                            fontFamily: TablixObjects.PropTotalFontFamily.getValue(objects),
                            fontSize: totalFontSize,
                            fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                            backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                            outline: TablixObjects.PropTotalOutline.getValue(objects),
                        };
                        formattingProperties.columnFormatting = {};
                        var columns = getTableColumnMetadata(dataView);
                        if (columns) {
                            for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {
                                var column = columns_6[_i];
                                var objects_4 = column && column.objects;
                                formattingProperties.columnFormatting[column.queryName] = {
                                    fontColor: TablixObjects.PropColumnFormattingFontColor.getValue(objects_4),
                                    backColor: TablixObjects.PropColumnFormattingBackColor.getValue(objects_4),
                                    alignment: TablixObjects.PropColumnFormattingAlignment.getValue(objects_4),
                                    styleHeader: TablixObjects.PropColumnFormattingStyleHeader.getValue(objects_4),
                                    styleValues: TablixObjects.PropColumnFormattingStyleValues.getValue(objects_4),
                                    styleTotal: TablixObjects.PropColumnFormattingStyleTotal.getValue(objects_4),
                                    dataBarsSettings: TablixObjects.PropColumnFormattingDataBars.getValue(objects_4),
                                };
                            }
                        }
                        return formattingProperties;
                    }
                    TablixObjects.getTableExObjects = getTableExObjects;
                    function getTextSizeInPx(fontSize) {
                        return jsCommon.PixelConverter.toString(fontSize.px);
                    }
                    TablixObjects.getTextSizeInPx = getTextSizeInPx;
                    function shouldShowTableTotalsOption(dataView) {
                        if (dataView && dataView.table && !_.isEmpty(dataView.table.columns)) {
                            var columns = dataView.table.columns;
                            if (_.some(columns, (function (column) { return column.discourageAggregationAcrossGroups; })))
                                return false;
                        }
                        return true;
                    }
                    function shouldShowRowSubtotalsOption(dataView) {
                        if (!dataView || DataViewMatrixUtils.getRowGroupingLevelsCount(dataView.matrix) < 1)
                            return false;
                        return !isDiscourageAggregationAcrossGroups(dataView.matrix.rows.levels);
                    }
                    function shouldShowColumnSubtotalsOption(dataView) {
                        if (!dataView || !dataView.matrix || DataViewMatrixUtils.getColumnGroupingLevelsCount(dataView.matrix.columns) < 1)
                            return false;
                        var levels = dataView.matrix.columns.levels;
                        if (dataView.matrix.valueSources.length > 1)
                            levels = _.initial(levels); // Drop last element
                        return !isDiscourageAggregationAcrossGroups(levels);
                    }
                    TablixObjects.shouldShowColumnSubtotalsOption = shouldShowColumnSubtotalsOption;
                    function isDiscourageAggregationAcrossGroups(levels) {
                        var lastLevel = _.last(levels);
                        // If the last item is not Aggregatable, disable totals option since there will be no totals at all to display
                        // However, if the non-aggregatable filed is in the middle, there are totals showing up in matrix.
                        // Therefore, we still allow users to turn it off
                        return lastLevel && _.some(lastLevel.sources, (function (source) { return source.discourageAggregationAcrossGroups; }));
                    }
                    TablixObjects.isDiscourageAggregationAcrossGroups = isDiscourageAggregationAcrossGroups;
                })(TablixObjects = internal.TablixObjects || (internal.TablixObjects = {}));
                var TablixUtils;
                (function (TablixUtils) {
                    TablixUtils.PreferredLoadMoreThreshold = 0.8;
                    TablixUtils.TotalLabel = 'TableTotalLabel';
                    TablixUtils.CssClassTablixDiv = "tablixDiv"; // Any DIV inside the table (outer and inner)
                    TablixUtils.CssClassContentElement = "tablixCellContentElement"; // Outer DIV
                    TablixUtils.CssClassContentHost = "tablixCellContentHost"; // Inner DIV
                    TablixUtils.CssClassWrappingContainer = "tablixWrappingContainer"; // Container for word wrapping lines
                    TablixUtils.CssClassTablixHeader = "tablixHeader"; // Any Header in the Table/Matrix
                    TablixUtils.CssClassTablixColumnHeaderLeaf = "tablixColumnHeaderLeaf"; // Leaf Column Headers
                    TablixUtils.CssClassTablixValueNumeric = "tablixValueNumeric"; // Numeric cells, will also be applied to all Matrix body cells
                    TablixUtils.CssClassTablixValueTotal = "tablixValueTotal"; // Total cells,  will also be applied to subtotal Matrix body cells
                    TablixUtils.CssClassValueURLIcon = "powervisuals-glyph tablixUrlIconGlyph"; // Any <a> Tag
                    TablixUtils.CssClassValueURLIconContainer = "tablixValueUrlIcon"; // Container for the <a> tag
                    TablixUtils.CssClassImageContainer = "tablixImageContainer"; // Container for the <img> tag
                    TablixUtils.CssClassMatrixRowHeaderLeaf = "matrixRowHeaderLeaf"; // Matrix Leaf Row Headers
                    TablixUtils.CssClassMatrixRowHeaderSubTotal = "matrixRowHeaderSubTotal"; // Matrix SubTotal Row Headers
                    TablixUtils.CssClassTableFooter = 'tableFooterCell'; // Any cell in the Footer area
                    TablixUtils.CssClassTableBodyCell = 'tableBodyCell'; // Any cell in the Table Body
                    TablixUtils.CssClassTableBodyCellBottom = 'tableBodyCellBottom'; // Bottom-Most Body cell
                    TablixUtils.CssClassPivotTableCell = "tablixCell"; // Any cell in pivotTable
                    TablixUtils.CSSClassPivotTableAlignLeft = "tablixAlignLeft";
                    TablixUtils.CSSClassPivotTableAlignCenter = "tablixAlignCenter";
                    TablixUtils.CSSClassPivotTableAlignRight = "tablixAlignRight";
                    TablixUtils.StringNonBreakingSpace = '&nbsp;';
                    TablixUtils.UnitOfMeasurement = 'px';
                    var SortIconContainerClassName = "tablixSortIconContainer";
                    TablixUtils.CellPaddingLeft = 10;
                    TablixUtils.CellPaddingRight = 5;
                    TablixUtils.CellPaddingLeftMatrixTotal = 5;
                    TablixUtils.SortIconPadding = 5;
                    TablixUtils.ImageDefaultAspectRatio = 1;
                    TablixUtils.FontFamilyCell = visuals.Font.Family.regular.css;
                    TablixUtils.FontFamilyHeader = visuals.Font.Family.regular.css;
                    TablixUtils.FontFamilyTotal = visuals.Font.Family.bold.css;
                    TablixUtils.FontFamilyGlyphs = visuals.Font.Family.glyphs.css;
                    TablixUtils.FontColorCells = "#333";
                    TablixUtils.FontColorHeaders = "#666";
                    TablixUtils.WordWrappingMaxLines = Number.POSITIVE_INFINITY;
                    /** Ratio between the font size for sort icon and the font size for text, used only for Pivot Table */
                    TablixUtils.SortIconFontSizeRatio = 0.71;
                    var EdgeType;
                    (function (EdgeType) {
                        EdgeType[EdgeType["Outline"] = 0] = "Outline";
                        EdgeType[EdgeType["Gridline"] = 1] = "Gridline";
                    })(EdgeType = TablixUtils.EdgeType || (TablixUtils.EdgeType = {}));
                    var EdgeSettings = /** @class */ (function () {
                        function EdgeSettings(weight, color) {
                            this.applyParams(true, weight, color);
                        }
                        EdgeSettings.prototype.applyParams = function (shown, weight, color, type) {
                            if (shown) {
                                this.weight = weight == null ? 0 : weight;
                                this.color = color == null ? 'black' : color;
                                this.type = type == null ? EdgeType.Gridline : type;
                            }
                            else {
                                this.weight = 0;
                                this.color = 'black';
                                this.type = EdgeType.Gridline;
                            }
                        };
                        EdgeSettings.prototype.getCSS = function () {
                            var css = [];
                            if (_.isNumber(this.weight)) {
                                css.push(this.weight + TablixUtils.UnitOfMeasurement);
                                if (this.color)
                                    css.push(this.color);
                                css.push('solid');
                            }
                            return css.join(' ');
                        };
                        /**
                         * Returns the priority of the current edge.
                         * H. Grid = 0
                         * V. Grid = 1
                         * H. Outline = 2
                         * V. Outline = 3
                         * Uknown = -1
                         * @param {Surround<EdgeSettings>} edges Edges. Used to determine the side of the current edge
                         */
                        EdgeSettings.prototype.getPriority = function (edges) {
                            if (this === edges.top || this === edges.bottom)
                                if (this.type === EdgeType.Outline)
                                    return 2;
                                else
                                    return 0;
                            if (this === edges.right || this === edges.left)
                                if (this.type === EdgeType.Outline)
                                    return 3;
                                else
                                    return 1;
                            return -1;
                        };
                        EdgeSettings.prototype.getShadowCss = function (edges) {
                            var output = "inset ";
                            if (this === edges.left)
                                output += this.weight + TablixUtils.UnitOfMeasurement + " 0";
                            else if (this === edges.right)
                                output += "-" + this.weight + TablixUtils.UnitOfMeasurement + " 0";
                            else if (this === edges.top)
                                output += "0 " + this.weight + TablixUtils.UnitOfMeasurement;
                            else if (this === edges.bottom)
                                output += "0 -" + this.weight + TablixUtils.UnitOfMeasurement;
                            else
                                return "";
                            return output + " 0 0 " + this.color;
                        };
                        return EdgeSettings;
                    }());
                    TablixUtils.EdgeSettings = EdgeSettings;
                    /**
                     * Style parameters for each Cell
                     */
                    var CellStyle = /** @class */ (function () {
                        function CellStyle(leftPadding, rightPadding) {
                            if (leftPadding === void 0) { leftPadding = TablixUtils.CellPaddingLeft; }
                            if (rightPadding === void 0) { rightPadding = TablixUtils.CellPaddingRight; }
                            this.borders = {};
                            this.paddings = { top: 0, left: leftPadding, bottom: 0, right: rightPadding };
                            // Initializing values with empty string would cause CSS attributes to not be set if they are undefined
                            this.fontColor = "";
                            this.fontFamily = "";
                            this.backColor = "";
                        }
                        /**
                         * Sets the Inline style for the Cell
                         * @param {ITablixCell} cell Cell to set style to
                         */
                        CellStyle.prototype.applyStyle = function (cell) {
                            var div = cell.extension.contentHost;
                            var style = div.style;
                            var fontAttributeValue = this.buildFontAttributeValue();
                            if (fontAttributeValue != null) {
                                style.font = fontAttributeValue;
                            }
                            else {
                                style.fontFamily = this.fontFamily;
                                style.fontSize = this.fontSize ? jsCommon.PixelConverter.toString(this.fontSize.px) : undefined; // TODO Can we used undefined as the default instead of empty string
                                style.fontWeight = this.fontWeight;
                            }
                            style.color = this.fontColor;
                            style.backgroundColor = this.backColor;
                            style.boxShadow = this.getBoxShadow();
                            style.border = "none";
                            style.paddingTop = this.getPaddingTop();
                            style.paddingRight = this.getPaddingRight();
                            style.paddingBottom = this.getPaddingBottom();
                            style.paddingLeft = this.getPaddingLeft();
                        };
                        CellStyle.prototype.getPaddingTop = function () {
                            return ((this.paddings.top == null ? 0 : this.paddings.top) + (this.borders.top == null ? 0 : this.borders.top.weight)) + TablixUtils.UnitOfMeasurement;
                        };
                        CellStyle.prototype.getPaddingBottom = function () {
                            return ((this.paddings.bottom == null ? 0 : this.paddings.bottom) + (this.borders.bottom == null ? 0 : this.borders.bottom.weight)) + TablixUtils.UnitOfMeasurement;
                        };
                        CellStyle.prototype.getPaddingRight = function () {
                            return ((this.paddings.right == null ? TablixUtils.CellPaddingRight : this.paddings.right) + (this.borders.right == null ? 0 : this.borders.right.weight)) + TablixUtils.UnitOfMeasurement;
                        };
                        CellStyle.prototype.getPaddingLeft = function () {
                            return ((this.paddings.left == null ? TablixUtils.CellPaddingLeft : this.paddings.left) + (this.borders.left == null ? 0 : this.borders.left.weight)) + TablixUtils.UnitOfMeasurement;
                        };
                        CellStyle.prototype.getBoxShadow = function () {
                            var _this = this;
                            var edges = [this.borders.top, this.borders.right, this.borders.bottom, this.borders.left];
                            // Sorting edges by priority Descending
                            edges = _.sortBy(edges, (function (e) {
                                return e ? e.getPriority(_this.borders) : -1;
                            })).reverse();
                            /**
                            * We are setting the borders as inset shadow
                            * This way we can control how intersecting borders would look like when they have different colors
                            */
                            return _.map(edges, (function (e) {
                                if (e)
                                    return e.getShadowCss(_this.borders);
                            })).join(', ');
                        };
                        CellStyle.prototype.getAttributes = function () {
                            var style = {
                                'padding-top': this.getPaddingTop(),
                                'padding-right': this.getPaddingRight(),
                                'padding-bottom': this.getPaddingBottom(),
                                'padding-left': this.getPaddingLeft()
                            };
                            var fontAttributeValue = this.buildFontAttributeValue();
                            if (fontAttributeValue != null) {
                                style['font'] = fontAttributeValue;
                            }
                            else {
                                if (!_.isEmpty(this.fontFamily))
                                    style['font-family'] = this.fontFamily;
                                if (this.fontSize != null)
                                    style['font-size'] = jsCommon.PixelConverter.toString(this.fontSize.px);
                                if (this.fontWeight != null)
                                    style['font-weight'] = this.fontWeight;
                            }
                            if (!_.isEmpty(this.fontColor))
                                style['color'] = this.fontColor;
                            if (!_.isEmpty(this.backColor))
                                style['background-color'] = this.backColor;
                            var boxShadow = this.getBoxShadow();
                            if (!_.isEmpty(boxShadow))
                                style['box-shadow'] = boxShadow;
                            return style;
                        };
                        CellStyle.prototype.getExtraTop = function () {
                            var extra = 0;
                            if (this.paddings.top)
                                extra += this.paddings.top;
                            if (this.borders.top)
                                extra += this.borders.top.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraBottom = function () {
                            var extra = 0;
                            if (this.paddings.bottom)
                                extra += this.paddings.bottom;
                            if (this.borders.bottom)
                                extra += this.borders.bottom.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraRight = function () {
                            var extra = 0;
                            if (this.paddings.right)
                                extra += this.paddings.right;
                            if (this.borders.right)
                                extra += this.borders.right.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraLeft = function () {
                            var extra = 0;
                            if (this.paddings.left)
                                extra += this.paddings.left;
                            if (this.borders.left)
                                extra += this.borders.left.weight;
                            return extra;
                        };
                        CellStyle.prototype.buildFontAttributeValue = function () {
                            var hasFontFamily = !_.isEmpty(this.fontFamily);
                            var hasFontSize = this.fontSize != null;
                            var hasFontWeight = this.fontWeight != null;
                            // If we have both the font family and size, we can use the shorthand, otherwise we have to set them individually
                            if (hasFontFamily && hasFontSize) {
                                return (hasFontWeight ? this.fontWeight + " " : '') + (jsCommon.PixelConverter.toString(this.fontSize.px) + " " + this.fontFamily);
                            }
                            return null;
                        };
                        return CellStyle;
                    }());
                    TablixUtils.CellStyle = CellStyle;
                    /**
                     * Index within a dimension (row/column)
                     */
                    var DimensionPosition = /** @class */ (function () {
                        function DimensionPosition() {
                        }
                        return DimensionPosition;
                    }());
                    TablixUtils.DimensionPosition = DimensionPosition;
                    /**
                     * Poistion information about the cell
                     */
                    var CellPosition = /** @class */ (function () {
                        function CellPosition() {
                            this.row = new DimensionPosition();
                            this.column = new DimensionPosition();
                        }
                        CellPosition.prototype.isMatch = function (position) {
                            return this.column.index === position.column.index &&
                                this.row.index === position.row.index;
                        };
                        return CellPosition;
                    }());
                    TablixUtils.CellPosition = CellPosition;
                    var TablixVisualCell = /** @class */ (function () {
                        function TablixVisualCell(dataPoint, objects, isRowSubTotal, isColumnSubTotal, isRowGrandTotal, isColumnGrandTotal, columnMetadata, formatter, nullsAreBlank) {
                            this.dataPoint = dataPoint;
                            this.objects = objects;
                            this.isRowSubTotal = isRowSubTotal;
                            this.isColumnSubTotal = isColumnSubTotal;
                            this.isRowGrandTotal = isRowGrandTotal;
                            this.isColumnGrandTotal = isColumnGrandTotal;
                            this.columnMetadata = columnMetadata;
                            this.formatter = formatter;
                            this.nullsAreBlank = nullsAreBlank;
                            this.position = new TablixUtils.CellPosition();
                        }
                        Object.defineProperty(TablixVisualCell.prototype, "isTotal", {
                            get: function () {
                                return this.isSubtotal || this.isGrandTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isSubtotal", {
                            get: function () {
                                return this.isColumnSubTotal || this.isRowSubTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isGrandTotal", {
                            get: function () {
                                return this.isColumnGrandTotal || this.isRowGrandTotal;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "textContent", {
                            get: function () {
                                if (this.formatter)
                                    return this.formatter(this.dataPoint, this.objects, this.columnMetadata, TablixObjects.PropColumnFormatString, this.nullsAreBlank);
                                else if (this.dataPoint != null)
                                    return this.dataPoint;
                                else
                                    return '';
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TablixVisualCell.prototype.isKpi = function () {
                            return this.columnMetadata && isValidStatusGraphic(this.columnMetadata.kpi, this.textContent);
                        };
                        Object.defineProperty(TablixVisualCell.prototype, "kpiContent", {
                            get: function () {
                                if (this.isKpi())
                                    return createKpiDom(this.columnMetadata.kpi, this.textContent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isNumeric", {
                            get: function () {
                                if (this.columnMetadata)
                                    return this.columnMetadata.type.numeric && !this.columnMetadata.kpi;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isUrl", {
                            get: function () {
                                if (this.columnMetadata)
                                    return visuals.converterHelper.isWebUrlColumn(this.columnMetadata);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isImage", {
                            get: function () {
                                if (this.columnMetadata)
                                    return visuals.converterHelper.isImageUrlColumn(this.columnMetadata);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isValidUrl", {
                            get: function () {
                                return TablixUtils.getUrlScheme(this.columnMetadata, this.textContent) !== UrlScheme.NONE;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        TablixVisualCell.prototype.isMatch = function (item) {
                            return this.position.isMatch(item.position) && this.backColor === item.backColor;
                        };
                        return TablixVisualCell;
                    }());
                    TablixUtils.TablixVisualCell = TablixVisualCell;
                    function createTable() {
                        return document.createElement("table");
                    }
                    TablixUtils.createTable = createTable;
                    function createDiv() {
                        var div = document.createElement("div");
                        div.className = TablixUtils.CssClassTablixDiv;
                        return div;
                    }
                    TablixUtils.createDiv = createDiv;
                    function resetCellCssClass(cell) {
                        cell.extension.contentElement.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentElement;
                        cell.extension.contentHost.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentHost;
                    }
                    TablixUtils.resetCellCssClass = resetCellCssClass;
                    function addCellCssClass(cell, style) {
                        cell.extension.contentHost.className += " " + style;
                    }
                    TablixUtils.addCellCssClass = addCellCssClass;
                    /**
                     * Clears all inline styles (border, fontColor, background) and resets CSS classes
                     * Performed with unbind-<Cell>
                     */
                    function clearCellStyle(cell) {
                        cell.extension.contentHost.className = "";
                        cell.extension.contentHost.style.cssText = "";
                    }
                    TablixUtils.clearCellStyle = clearCellStyle;
                    function clearCellTextAndTooltip(cell) {
                        cell.extension.contentHost.textContent = '';
                        cell.extension.contentHost.removeAttribute('title');
                        cell.contentHeight = cell.contentWidth = 0;
                        controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
                    }
                    TablixUtils.clearCellTextAndTooltip = clearCellTextAndTooltip;
                    /**
                     * Sets text and tooltip for cell
                     * @param {string} text Text to set
                     * @param {HTMLElement} elementText Element to set text to
                     * @param {HTMLElement} elementTooltip? Element to set tootltip to, if undefined, elementText will be used
                     */
                    function setCellTextAndTooltip(text, elementText, elementTooltip) {
                        TablixUtils.setCellText(text, elementText);
                        TablixUtils.setCellTooltip(text, elementTooltip || elementText);
                    }
                    TablixUtils.setCellTextAndTooltip = setCellTextAndTooltip;
                    function setCellText(text, element) {
                        element.textContent = visuals.TextUtil.replaceSpaceWithNBSP(text);
                    }
                    TablixUtils.setCellText = setCellText;
                    function setCellTooltip(text, element) {
                        element.title = text;
                    }
                    TablixUtils.setCellTooltip = setCellTooltip;
                    /**
                     * Appends a DIV element to the container and set its text, returns the appended DIV
                     * @param {string} text Text
                     * @param {HTMLElement} container Container ELement
                     * @returns Appended DIV
                     */
                    function appendDiv(container, text) {
                        var div = createDiv();
                        container.appendChild(div);
                        if (text)
                            div.textContent = text;
                        return div;
                    }
                    TablixUtils.appendDiv = appendDiv;
                    function isValidSortClick(e) {
                        var colHeader = e.target;
                        var x = e.offsetX;
                        return x >= 0 && x < colHeader.offsetWidth - internal.TablixResizer.resizeHandleSize;
                    }
                    TablixUtils.isValidSortClick = isValidSortClick;
                    function appendATagToBodyCell(value, cellElement, urlIconName) {
                        var atag = null;
                        if (cellElement.childElementCount === 0) {
                            atag = document.createElement('a');
                            cellElement.appendChild(atag);
                        }
                        else {
                            atag = cellElement.children[0];
                        }
                        atag.href = value;
                        atag.target = '_blank';
                        atag.rel = 'noopener noreferrer';
                        atag.title = value;
                        if (urlIconName != null) {
                            atag.className = TablixUtils.CssClassValueURLIcon + ' ' + urlIconName;
                            $(cellElement).addClass(TablixUtils.CssClassValueURLIconContainer);
                        }
                        else {
                            atag.innerText = value;
                        }
                    }
                    TablixUtils.appendATagToBodyCell = appendATagToBodyCell;
                    function appendImgTagToBodyCell(value, cellElement, imageHeight) {
                        var imgContainer = TablixUtils.createDiv();
                        var imgTag = document.createElement('img');
                        imgContainer.style.height = imageHeight + "px";
                        imgContainer.style.width = "100%";
                        imgContainer.style.textAlign = "center";
                        imgTag.src = value;
                        imgTag.style.maxHeight = "100%";
                        imgTag.style.maxWidth = "100%";
                        imgContainer.appendChild(imgTag);
                        cellElement.appendChild(imgContainer);
                        cellElement.title = value;
                    }
                    TablixUtils.appendImgTagToBodyCell = appendImgTagToBodyCell;
                    function createKpiDom(kpi, kpiValue) {
                        debug.assertValue(kpi, 'kpi');
                        debug.assertValue(kpiValue, 'kpiValue');
                        var className = visuals.KpiUtil.getClassForKpi(kpi, kpiValue) || '';
                        return DomFactory.div()
                            .addClass(className)
                            .css({
                            'display': 'inline-block',
                            'vertical-align': 'bottom',
                            'margin': '0',
                        });
                    }
                    TablixUtils.createKpiDom = createKpiDom;
                    function getUrlScheme(metadata, content) {
                        if (!visuals.converterHelper.isWebUrlColumn(metadata))
                            return UrlScheme.NONE;
                        return UrlUtils.getUrlScheme(content);
                    }
                    TablixUtils.getUrlScheme = getUrlScheme;
                    function getUrlIconName(scheme) {
                        switch (scheme) {
                            case UrlScheme.file:
                            case UrlScheme.ftp:
                                return 'page2';
                            case UrlScheme.mailto:
                                return 'mail';
                            case UrlScheme.news:
                                return 'link';
                            case UrlScheme.telnet:
                                return 'pc1';
                            case UrlScheme.http:
                            case UrlScheme.https:
                                return 'link';
                            default:
                                return null;
                        }
                    }
                    TablixUtils.getUrlIconName = getUrlIconName;
                    function isValidImage(header, metadata, content) {
                        return isImage(header, metadata) && UrlUtils.isValidImageUrl(content);
                    }
                    TablixUtils.isValidImage = isValidImage;
                    function isImage(header, metadata) {
                        return visuals.converterHelper.isImageUrlColumn(metadata) && !header.isSubtotal;
                    }
                    TablixUtils.isImage = isImage;
                    function isValidStatusGraphic(kpi, kpiValue) {
                        if (!kpi || kpiValue === undefined) {
                            return false;
                        }
                        return !!visuals.KpiUtil.getClassForKpi(kpi, kpiValue);
                    }
                    TablixUtils.isValidStatusGraphic = isValidStatusGraphic;
                    function getCustomSortEventArgs(queryName, sortDirection) {
                        var sortDescriptors = [{
                                queryName: queryName,
                                sortDirection: sortDirection
                            }];
                        return { sortDescriptors: sortDescriptors };
                    }
                    TablixUtils.getCustomSortEventArgs = getCustomSortEventArgs;
                    function reverseSort(sortDirection) {
                        return sortDirection === 2 /* Descending */ ? 1 /* Ascending */ : 2 /* Descending */;
                    }
                    TablixUtils.reverseSort = reverseSort;
                    /**
                     * Add sort icon to a table cell and return the element that should contain the contents
                     * @param {SortDirection} itemSort SortDirection
                     * @param {HTMLElement} cellDiv The inner DIV of the cell
                     */
                    function addSortIconToColumnHeader(itemSort, cellDiv) {
                        var colHeaderContainer = TablixUtils.createDiv();
                        if (itemSort) {
                            colHeaderContainer.appendChild(createSortIcon(itemSort, true));
                            colHeaderContainer.appendChild(createSortIcon(reverseSort(itemSort), false));
                        }
                        else {
                            colHeaderContainer.appendChild(createSortIcon(2 /* Descending */, false));
                        }
                        var colHeaderTitle = TablixUtils.createDiv();
                        colHeaderContainer.appendChild(colHeaderTitle);
                        cellDiv.appendChild(colHeaderContainer);
                        return colHeaderTitle;
                    }
                    TablixUtils.addSortIconToColumnHeader = addSortIconToColumnHeader;
                    function createSortIcon(sort, isSorted) {
                        var imgSort = document.createElement('i');
                        imgSort.className = SortIconContainerClassName +
                            " " + (isSorted ? "sorted" : "future") +
                            " " + (sort === 1 /* Ascending */ ? "powervisuals-glyph caret-up" : "powervisuals-glyph caret-down");
                        return imgSort;
                    }
                    function checkSortIconExists(cell) {
                        for (var i = 0, len = cell.extension.contentElement.childElementCount; i < len; i++) {
                            var element = cell.extension.contentElement.children.item(i);
                            if (element.classList.contains(SortIconContainerClassName))
                                return true;
                        }
                        return false;
                    }
                    function removeSortIcons(cell) {
                        if (!checkSortIconExists(cell))
                            return;
                        $(cell.extension.contentElement).find('.' + SortIconContainerClassName).remove();
                    }
                    TablixUtils.removeSortIcons = removeSortIcons;
                })(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PivotTableOptions;
        (function (PivotTableOptions) {
            /**
             * Creates the PivotTable construction options for dashboard scenario
             * @returns a PivotTableConstructorOptions with the features enabled/disabled for dashboard
             */
            function createDashboardConstructorOptions() {
                return {
                    scrolling: {
                        enabled: false,
                    },
                    selection: {
                        enabled: false,
                    },
                    sorting: {
                        enabled: false,
                        showActiveSortIcon: true,
                    },
                    columnResizing: {
                        enabled: false
                    },
                    interactivityIndicatorEnabled: false,
                };
            }
            PivotTableOptions.createDashboardConstructorOptions = createDashboardConstructorOptions;
            /**
             * Creates the PivotTable construction options for default scenario
             * @returns a PivotTableConstructorOptions with the features enabled/disabled for default scenario
             */
            function createDefaultConstructorOptions() {
                return {
                    scrolling: {
                        enabled: true,
                    },
                    selection: {
                        enabled: true,
                    },
                    sorting: {
                        enabled: true,
                        showActiveSortIcon: true,
                    },
                    columnResizing: {
                        enabled: true
                    },
                    interactivityIndicatorEnabled: true,
                };
            }
            PivotTableOptions.createDefaultConstructorOptions = createDefaultConstructorOptions;
            function createMobileConstructorOptions() {
                return {
                    scrolling: {
                        enabled: true,
                    },
                    selection: {
                        enabled: true,
                    },
                    sorting: {
                        enabled: true,
                        showActiveSortIcon: true,
                    },
                    columnResizing: {
                        enabled: true
                    },
                    interactivityIndicatorEnabled: false,
                };
            }
            PivotTableOptions.createMobileConstructorOptions = createMobileConstructorOptions;
        })(PivotTableOptions = visuals.PivotTableOptions || (visuals.PivotTableOptions = {}));
        var TableExOptions;
        (function (TableExOptions) {
            function createDashboardConstructorOptions() {
                return {
                    scrolling: {
                        enabled: false,
                    },
                    selection: {
                        enabled: false,
                    },
                    sorting: {
                        enabled: false,
                        showActiveSortIcon: true,
                    },
                    columnResizing: {
                        enabled: false
                    },
                    interactivityIndicatorEnabled: false,
                };
            }
            TableExOptions.createDashboardConstructorOptions = createDashboardConstructorOptions;
            function createDefaultConstructorOptions() {
                return {
                    scrolling: {
                        enabled: true,
                    },
                    selection: {
                        enabled: true,
                    },
                    sorting: {
                        enabled: true,
                        showActiveSortIcon: true,
                    },
                    columnResizing: {
                        enabled: true
                    },
                    interactivityIndicatorEnabled: true,
                };
            }
            TableExOptions.createDefaultConstructorOptions = createDefaultConstructorOptions;
            function createMobileConstructorOptions() {
                return {
                    scrolling: {
                        enabled: true,
                    },
                    selection: {
                        enabled: true,
                    },
                    sorting: {
                        enabled: true,
                        showActiveSortIcon: true,
                    },
                    columnResizing: {
                        enabled: true
                    },
                    interactivityIndicatorEnabled: false,
                };
            }
            TableExOptions.createMobileConstructorOptions = createMobileConstructorOptions;
        })(TableExOptions = visuals.TableExOptions || (visuals.TableExOptions = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            controls.TablixDefaultTextSize = jsCommon.TextSizeDefaults.TextSizeMin;
            var TablixControl = /** @class */ (function () {
                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                    var _this = this;
                    this.scrollBarElementWidth = 9;
                    // Options (fontSize set after container initialized)
                    this.options = options;
                    var isInteractive = options.interactive;
                    this.isTouchEnabled = isInteractive && options.enableTouchSupport;
                    // Main Div
                    this.mainDiv = controls.internal.TablixUtils.createDiv();
                    this.mainDiv.classList.add(TablixControl.TablixTableAreaClassName);
                    // Footer Div
                    this.footerDiv = controls.internal.TablixUtils.createDiv();
                    this.footerDiv.classList.add(TablixControl.TablixFooterClassName);
                    this.gridDimensions = {};
                    this.containerElement = controls.internal.TablixUtils.createDiv();
                    this.className = layoutManager.getTablixClassName();
                    this.autoSizeWidth = false;
                    this.autoSizeHeight = false;
                    this.fontFamily = controls.internal.TablixUtils.FontFamilyCell;
                    this.fontColor = controls.internal.TablixUtils.FontColorCells;
                    this.fontSize = options.fontSize;
                    parentDomElement.className = TablixControl.TablixContainerClassName;
                    parentDomElement.appendChild(this.containerElement);
                    this.containerElement.addEventListener("wheel", (function (e) { _this.onWheel(e); }));
                    this.containerElement.appendChild(this.mainDiv);
                    this.containerElement.appendChild(this.footerDiv);
                    if (this.isTouchEnabled) {
                        this.InitializeTouchSupport();
                        this.bindTouchEvents();
                    }
                    this.controlLayoutManager = layoutManager;
                    this.controlLayoutManager.initialize(this);
                    this.hierarchyTablixNavigator = hierarchyNavigator;
                    this.binder = binder;
                    this.columnDim = new controls.TablixColumnDimension(this);
                    this.rowDim = new controls.TablixRowDimension(this);
                    this.columnDim._otherDimension = this.rowDimension;
                    this.rowDim._otherDimension = this.columnDimension;
                    this.InitializeScrollbars();
                    if (!isInteractive) {
                        this.scrollbarWidth = 0;
                    }
                    this.updateHorizontalPosition();
                    this.updateVerticalPosition();
                    this.updateFooterVisibility();
                    this.lastRenderingArgs = {};
                }
                TablixControl.prototype.InitializeTouchSupport = function () {
                    this.isTouchEventsBound = false;
                    this.touchManager = new controls.TouchUtils.TouchManager();
                    this.touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
                    this.footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
                    this.columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.columnTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.rowTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.bodyTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.footerTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.touchManager.addTouchRegion(this.columnTouchDelegate.dimension, this.columnTouchDelegate, this.columnTouchDelegate);
                    this.touchManager.addTouchRegion(this.rowTouchDelegate.dimension, this.rowTouchDelegate, this.rowTouchDelegate);
                    this.touchManager.addTouchRegion(this.bodyTouchDelegate.dimension, this.bodyTouchDelegate, this.bodyTouchDelegate);
                    this.touchManager.addTouchRegion(this.footerTouchDelegate.dimension, this.footerTouchDelegate, this.footerTouchDelegate);
                };
                TablixControl.prototype.unBindTouchEvents = function () {
                    if (!this.isTouchEventsBound)
                        return;
                    this.touchInterpreter.clearAllTouchEvents();
                    this.footerTouchInterpreter.clearAllTouchEvents();
                    this.isTouchEventsBound = false;
                };
                TablixControl.prototype.bindTouchEvents = function () {
                    if (this.isTouchEventsBound)
                        return;
                    this.touchInterpreter.initTouch(this.mainDiv, null);
                    this.footerTouchInterpreter.initTouch(this.footerDiv, this.mainDiv);
                    this.isTouchEventsBound = true;
                };
                TablixControl.prototype.InitializeScrollbars = function () {
                    // Row Dimension
                    this.rowDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var rowDimensionScrollbarStyle = this.rowDim.scrollbar.element.style;
                    rowDimensionScrollbarStyle.position = "absolute";
                    rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement;
                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement;
                    this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    // Default to true which is the more common case to avoid an extra rendering iteration
                    // when first rendering the visual
                    this.rowDim.scrollbar.show(true);
                    // Column Dimension
                    this.columnDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var columnDimensionScrollbarStyle = this.columnDim.scrollbar.element.style;
                    columnDimensionScrollbarStyle.position = "absolute";
                    columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement;
                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement;
                    this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    this.columnDim.scrollbar.show(false);
                };
                TablixControl.prototype.toggleTouchBindings = function (touchBindingEnabled) {
                    if (!this.isTouchEnabled)
                        return;
                    if (touchBindingEnabled) {
                        this.bindTouchEvents();
                    }
                    else {
                        this.unBindTouchEvents();
                    }
                };
                Object.defineProperty(TablixControl.prototype, "container", {
                    get: function () {
                        return this.containerElement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "contentHost", {
                    get: function () {
                        return this.mainDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "footerHost", {
                    get: function () {
                        return this.footerDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "className", {
                    set: function (value) {
                        this.containerElement.className = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                    get: function () {
                        return this.hierarchyTablixNavigator;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.getBinder = function () {
                    return this.binder;
                };
                Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                    get: function () {
                        return this._autoSizeWidth;
                    },
                    set: function (value) {
                        this._autoSizeWidth = value;
                        if (!value) {
                            this.containerElement.style.minWidth = this.containerElement.style.maxWidth = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                    get: function () {
                        return this._autoSizeHeight;
                    },
                    set: function (value) {
                        if (!value) {
                            this.containerElement.style.minHeight = this.containerElement.style.maxHeight = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxWidth", {
                    get: function () {
                        return this.maximumWidth;
                    },
                    set: function (value) {
                        this.maximumWidth = value;
                        this.containerElement.style.maxWidth = this.maximumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "viewport", {
                    get: function () {
                        return this.viewPort;
                    },
                    set: function (value) {
                        this.viewPort = value;
                        this.containerElement.style.width = this.viewPort.width + TablixControl.UnitOfMeasurement;
                        this.containerElement.style.height = this.viewPort.height + TablixControl.UnitOfMeasurement;
                        this.rowDim.scrollbar.invalidateArrange();
                        this.columnDim.scrollbar.invalidateArrange();
                        this.controlLayoutManager.updateViewport(this.viewPort);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxHeight", {
                    get: function () {
                        return this.maximumHeight;
                    },
                    set: function (value) {
                        this.maximumHeight = value;
                        this.containerElement.style.maxHeight = this.maximumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minWidth", {
                    get: function () {
                        return this.minimumWidth;
                    },
                    set: function (value) {
                        this.minimumWidth = value;
                        this.containerElement.style.minWidth = this.minimumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minHeight", {
                    get: function () {
                        return this.minimumHeight;
                    },
                    set: function (value) {
                        this.minimumHeight = value;
                        this.containerElement.style.minHeight = this.minimumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontSize", {
                    get: function () {
                        return this.textFontSize;
                    },
                    set: function (value) {
                        this.textFontSize = !value ? TablixControl.DefaultFontSize : value;
                        this.containerElement.style.fontSize = this.textFontSize;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontFamily", {
                    get: function () {
                        return this.textFontFamily;
                    },
                    set: function (value) {
                        this.textFontFamily = value;
                        this.containerElement.style.fontFamily = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontColor", {
                    get: function () {
                        return this.textFontColor;
                    },
                    set: function (value) {
                        this.textFontColor = value;
                        this.containerElement.style.color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                    set: function (value) {
                        this.scrollBarElementWidth = value;
                        this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                // for testing purposes
                TablixControl.prototype.getIsTouchEventsBound = function () {
                    return !!this.isTouchEventsBound;
                };
                TablixControl.prototype.updateModels = function (resetScrollOffsets, rowModel, columnModel) {
                    this.rowDim.model = rowModel;
                    this.rowDim.modelDepth = this.hierarchyNavigator.getRowHierarchyDepth();
                    this.columnDim.model = columnModel;
                    this.columnDim.modelDepth = this.hierarchyNavigator.getColumnHierarchyDepth();
                    if (resetScrollOffsets) {
                        this.rowDim.scrollOffset = 0;
                        this.columnDim.scrollOffset = 0;
                    }
                    this.layoutManager.updateColumnCount(this.rowDim, this.columnDim);
                };
                TablixControl.prototype.updateColumnDimensions = function (rowHierarchyWidth, columnHierarchyWidth, count) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.columnCount = count;
                    gridDimensions.rowHierarchyWidth = rowHierarchyWidth;
                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                };
                TablixControl.prototype.updateRowDimensions = function (columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.rowCount = count;
                    gridDimensions.rowHierarchyHeight = rowHierarchyHeight;
                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight;
                    gridDimensions.columnHierarchyHeight = columnHierarchyHeight;
                    gridDimensions.footerHeight = footerHeight;
                };
                TablixControl.prototype.updateTouchDimensions = function () {
                    var gridDimensions = this.gridDimensions;
                    this.columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight);
                    this.columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                    this.rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this.rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this.bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this.bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this.footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight);
                    this.footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                };
                TablixControl.prototype.onWheel = function (e) {
                    this.determineDimensionToScroll(e, (function (dimension, delta) { dimension.scrollbar.onMouseWheel(-1 * delta); }));
                    if (this.options.layoutKind === 0 /* Canvas */)
                        e.preventDefault();
                };
                TablixControl.prototype.determineDimensionToScroll = function (e, scrollCallback) {
                    // If vertical scrollbar is shown, apply normal scrolling in X, Y
                    if (this.rowDim.scrollbar.visible) {
                        if (e.deltaY)
                            scrollCallback(this.rowDim, e.deltaY);
                        // dont use 'else if' here, as trackballs can give delta in both directions
                        if (e.deltaX && this.columnDim.scrollbar.visible)
                            scrollCallback(this.columnDim, e.deltaX);
                    }
                    else if (this.columnDim.scrollbar.visible) {
                        if (e.deltaX)
                            scrollCallback(this.columnDim, e.deltaX);
                        else if (e.deltaY)
                            scrollCallback(this.columnDim, e.deltaY);
                    }
                };
                Object.defineProperty(TablixControl.prototype, "layoutManager", {
                    get: function () {
                        return this.controlLayoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "columnDimension", {
                    get: function () {
                        return this.columnDim;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "rowDimension", {
                    get: function () {
                        return this.rowDim;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.refresh = function (clear) {
                    this.render(clear, null);
                };
                TablixControl.prototype._onScrollAsync = function (dimension) {
                    var _this = this;
                    requestAnimationFrame((function () { _this.performPendingScroll(dimension); }));
                };
                TablixControl.prototype.performPendingScroll = function (dimension) {
                    this.render(false, dimension);
                };
                TablixControl.prototype.updateHorizontalPosition = function () {
                    if (this.rowDim.scrollbar.visible) {
                        this.columnDim.scrollbar.element.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.mainDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    }
                    else {
                        this.columnDim.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this.mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.updateFooterVisibility = function () {
                    if (this.rowDim.hasFooter() ? (this.footerDiv.style.display !== "block") : (this.footerDiv.style.display !== "none")) {
                        if (this.rowDim.hasFooter()) {
                            this.footerDiv.style.display = "block";
                        }
                        else {
                            this.footerDiv.style.display = "none";
                        }
                    }
                };
                TablixControl.prototype.updateVerticalPosition = function () {
                    var hasVerticalScrollbar = this.rowDim.scrollbar.visible;
                    // TODO: ideally the tablix control would not know about where it is rendered but the layout manager
                    //       would provider that information; we should refactor the layout manager so that getLayoutKind is not needed anymore.
                    var isDashboardTile = this.controlLayoutManager.getLayoutKind() === 1 /* DashboardTile */;
                    var showFooter = hasVerticalScrollbar || isDashboardTile;
                    if (showFooter) {
                        var mainBottom = this.footerDiv.offsetHeight;
                        var footerBottom = 0;
                        var verticalScrollbarBottom = 0;
                        // If we have a horizontal scrollbar, we need to adjust the bottom
                        // value by the scrollbar width
                        var hasHorizontalScrollbar = this.columnDim.scrollbar.visible;
                        if (hasHorizontalScrollbar) {
                            mainBottom += this.scrollBarElementWidth;
                            footerBottom += this.scrollBarElementWidth;
                            verticalScrollbarBottom = this.scrollBarElementWidth;
                        }
                        this.mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement;
                        this.rowDim.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement;
                        // With a vertical scrollbar, the footer is always rendered at the bottom
                        this.footerDiv.style.removeProperty("top");
                    }
                    else {
                        // Without a vertical scrollbar, the footer is rendered below the last row;
                        // this is controlled by the top value only
                        this.footerDiv.style.top = this.gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.removeProperty("bottom");
                        this.mainDiv.style.removeProperty("bottom");
                    }
                };
                TablixControl.prototype.alreadyRendered = function (scrollingDimension) {
                    if (scrollingDimension !== this.lastRenderingArgs.scrollingDimension ||
                        this.rowDimension.scrollOffset !== this.lastRenderingArgs.rowScrollOffset ||
                        this.columnDimension.scrollOffset !== this.lastRenderingArgs.columnScrollOffset) {
                        return false;
                    }
                    return true;
                };
                TablixControl.prototype.render = function (clear, scrollingDimension) {
                    // at time of rendering always ensure the scroll offset is valid
                    this.columnDim.makeScrollOffsetValid();
                    this.rowDim.makeScrollOffsetValid();
                    if (clear || scrollingDimension === null) {
                        this.lastRenderingArgs = {};
                    }
                    else if (this.alreadyRendered(scrollingDimension)) {
                        return;
                    }
                    var done = false;
                    this.renderIterationCount = 0;
                    this.controlLayoutManager.onStartRenderingSession(scrollingDimension, this.mainDiv, clear);
                    var binder = this.binder;
                    binder.onStartRenderingSession();
                    var priorFooterHeight = this.gridDimensions.footerHeight;
                    var priorRowHierarchyHeight = this.gridDimensions.rowHierarchyHeight;
                    var priorRowHierarchyContentHeight = this.gridDimensions.rowHierarchyContentHeight;
                    while (!done && this.renderIterationCount < TablixControl.MaxRenderIterationCount) {
                        var hScrollbarVisibility = this.columnDim.scrollbar.visible;
                        var vScrollbarVisibility = this.rowDim.scrollbar.visible;
                        this.columnDim._onStartRenderingIteration();
                        this.rowDim._onStartRenderingIteration();
                        this.controlLayoutManager.onStartRenderingIteration(clear);
                        // These calls add cells to the table.
                        // Column needs to be rendered before rows as the row call will pair up with columns to produce the body cells.
                        this.renderCorner();
                        this.columnDim._render();
                        this.rowDim._render();
                        done = this.controlLayoutManager.onEndRenderingIteration();
                        this.columnDim._onEndRenderingIteration();
                        this.rowDim._onEndRenderingIteration();
                        if ((hScrollbarVisibility !== this.columnDim.scrollbar.visible)) {
                            this.updateVerticalPosition();
                        }
                        if (vScrollbarVisibility !== this.rowDim.scrollbar.visible) {
                            this.updateHorizontalPosition();
                        }
                        this.renderIterationCount++;
                    }
                    this.controlLayoutManager.onEndRenderingSession();
                    binder.onEndRenderingSession();
                    if (this.isTouchEnabled)
                        this.updateTouchDimensions();
                    this.lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    this.lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    this.updateContainerDimensions();
                    var lastRenderingArgs = this.lastRenderingArgs;
                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    lastRenderingArgs.scrollingDimension = scrollingDimension;
                    if (priorFooterHeight !== this.gridDimensions.footerHeight ||
                        priorRowHierarchyHeight !== this.gridDimensions.rowHierarchyHeight ||
                        priorRowHierarchyContentHeight !== this.gridDimensions.rowHierarchyContentHeight) {
                        this.updateVerticalPosition();
                    }
                    // NOTE: it is critical that we refresh the scrollbars only after the vertical
                    //       position was updated above; otherwise the measurements can be incorrect.
                    if (this.options.interactive) {
                        this.columnDim.scrollbar.refresh();
                        this.rowDim.scrollbar.refresh();
                    }
                };
                TablixControl.prototype.updateContainerDimensions = function () {
                    var gridDimensions = this.gridDimensions;
                    if (this._autoSizeWidth) {
                        var vScrollBarWidth = this.rowDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.width =
                            gridDimensions.rowHierarchyWidth +
                                gridDimensions.columnHierarchyWidth +
                                vScrollBarWidth +
                                TablixControl.UnitOfMeasurement;
                    }
                    if (this._autoSizeHeight) {
                        var hScrollBarHeight = this.columnDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.height =
                            gridDimensions.columnHierarchyHeight +
                                gridDimensions.rowHierarchyHeight +
                                gridDimensions.footerHeight +
                                hScrollBarHeight +
                                TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.cornerCellMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 0 /* CornerCell */ && previousItem && this.hierarchyTablixNavigator.cornerCellItemEquals(item, previousItem);
                };
                TablixControl.prototype.renderCorner = function () {
                    var columnDepth = this.columnDim.getDepth();
                    var rowDepth = this.rowDim.getDepth();
                    for (var i = 0; i < columnDepth; i++) {
                        for (var j = 0; j < rowDepth; j++) {
                            var item = this.hierarchyTablixNavigator.getCorner(j, i);
                            var cell = this.controlLayoutManager.getOrCreateCornerCell(item, j, i);
                            var match = this.cornerCellMatch(item, cell);
                            if (!match) {
                                this._unbindCell(cell);
                                cell.type = 0 /* CornerCell */;
                                cell.item = item;
                                this.binder.bindCornerCell(item, cell);
                            }
                            this.controlLayoutManager.onCornerCellRealized(item, cell);
                        }
                    }
                };
                TablixControl.prototype._unbindCell = function (cell) {
                    switch (cell.type) {
                        case 3 /* BodyCell */:
                            this.binder.unbindBodyCell(cell.item, cell);
                            break;
                        case 2 /* ColumnHeader */:
                            this.binder.unbindColumnHeader(cell.item, cell);
                            break;
                        case 1 /* RowHeader */:
                            this.binder.unbindRowHeader(cell.item, cell);
                            break;
                        case 0 /* CornerCell */:
                            this.binder.unbindCornerCell(cell.item, cell);
                    }
                    cell.item = null;
                    cell.type = null;
                };
                TablixControl.prototype.onTouchEvent = function (args) {
                    var colShift;
                    var rowShift;
                    var that;
                    if ((args) && (args.length > 0)) {
                        if (("columnDim" in args[0]) && ("rowDim" in args[0])) {
                            that = args[0];
                            colShift = that.columnDim.scrollbar.visible ? args[1] : 0;
                            rowShift = that.rowDim.scrollbar.visible ? args[2] : 0;
                            that.columnDim.scrollbar.viewMin = Math.max(0, that.columnDim.scrollbar.viewMin + colShift);
                            that.columnDim.scrollOffset = Math.max(0, that.columnDim.scrollOffset + colShift);
                            that.rowDim.scrollbar.viewMin = Math.max(0, that.rowDim.scrollbar.viewMin + rowShift);
                            that.rowDim.scrollOffset = Math.max(0, that.rowDim.scrollOffset + rowShift);
                            if (colShift === 0) {
                                that._onScrollAsync(that.rowDim);
                            }
                            else if (rowShift === 0) {
                                that._onScrollAsync(that.columnDim);
                            }
                            else {
                                that._onScrollAsync(null);
                            }
                        }
                    }
                };
                TablixControl.UnitOfMeasurement = 'px';
                TablixControl.TablixContainerClassName = 'tablixContainer';
                TablixControl.TablixTableAreaClassName = "tablixTableArea";
                TablixControl.TablixFooterClassName = "tableFooterArea";
                TablixControl.DefaultFontSize = jsCommon.PixelConverter.fromPoint(controls.TablixDefaultTextSize);
                /*
                * This is workaround for the infinite loop in rendering
                * BugID: 6518621
                * ToDo: Investigate the underlying cause for rendering to never report completion
                * Rendering typically require 3-5 iterations to complete, so 10 is enough
                */
                TablixControl.MaxRenderIterationCount = 10;
                return TablixControl;
            }());
            controls.TablixControl = TablixControl;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TablixDimension = /** @class */ (function () {
                function TablixDimension(tablixControl) {
                    this._scrollStep = 0.1;
                    this._owner = tablixControl;
                    this._hierarchyNavigator = tablixControl.hierarchyNavigator;
                    this._binder = tablixControl.getBinder();
                    this._tablixLayoutManager = tablixControl.layoutManager;
                    this.scrollOffset = 0;
                }
                TablixDimension.prototype._onStartRenderingIteration = function () {
                    this.updateScrollPosition();
                };
                TablixDimension.prototype._onEndRenderingIteration = function () {
                };
                TablixDimension.prototype.getValidScrollOffset = function (scrollOffset) {
                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                };
                TablixDimension.prototype.makeScrollOffsetValid = function () {
                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                };
                TablixDimension.prototype.getIntegerScrollOffset = function () {
                    return Math.floor(this.scrollOffset);
                };
                TablixDimension.prototype.getFractionScrollOffset = function () {
                    return this.scrollOffset - this.getIntegerScrollOffset();
                };
                Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                    get: function () {
                        return this._scrollbar;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype.getFirstVisibleItem = function (level) {
                    return this._scrollItems[level];
                };
                TablixDimension.prototype.getFirstVisibleChild = function (item) {
                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                };
                TablixDimension.prototype.getFirstVisibleChildIndex = function (item) {
                    var startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                    var firstVisibleIndex;
                    if (startItem === undefined || (startItem !== undefined && this._hierarchyNavigator.getParent(startItem) !== item)) {
                        firstVisibleIndex = 0;
                    }
                    else {
                        firstVisibleIndex = this._hierarchyNavigator.getIndex(startItem);
                    }
                    return firstVisibleIndex;
                };
                TablixDimension.prototype._initializeScrollbar = function (parentElement, touchDiv, layoutKind) {
                    var _this = this;
                    this._scrollbar = this._createScrollbar(parentElement, layoutKind);
                    this._scrollbar._onscroll.push((function (e) { return _this.onScroll(); }));
                    if (touchDiv) {
                        this.scrollbar.initTouch(touchDiv, true);
                        touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom");
                    }
                };
                TablixDimension.prototype.getItemsCount = function () {
                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                };
                TablixDimension.prototype.getDepth = function () {
                    return this.modelDepth;
                };
                TablixDimension.prototype.onScroll = function () {
                    this.scrollOffset = this._scrollbar.viewMin;
                    this._owner._onScrollAsync(this);
                };
                Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                    get: function () {
                        return this._otherDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                    get: function () {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    // abstract
                    debug.assertFail("PureVirtualMethod: TablixDimension._createScrollbar");
                    return null;
                };
                TablixDimension.prototype.updateScrollPosition = function () {
                    this._scrollItems = [];
                    if (!this.model) {
                        return;
                    }
                    var firstVisibleScrollIndex = this.getIntegerScrollOffset();
                    var firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                    if (!firstVisible) {
                        return;
                    }
                    this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                    do {
                        this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible;
                        firstVisible = this._hierarchyNavigator.getParent(firstVisible);
                    } while (firstVisible !== null);
                };
                return TablixDimension;
            }());
            controls.TablixDimension = TablixDimension;
            var TablixRowDimension = /** @class */ (function (_super) {
                __extends(TablixRowDimension, _super);
                function TablixRowDimension(tablixControl) {
                    var _this = _super.call(this, tablixControl) || this;
                    _this._layoutManager = _this._tablixLayoutManager.rowLayoutManager;
                    _this._footer = null;
                    return _this;
                }
                TablixRowDimension.prototype.setFooter = function (footerHeader) {
                    this._footer = footerHeader;
                    this._owner.updateFooterVisibility();
                };
                TablixRowDimension.prototype.hasFooter = function () {
                    return (this._footer !== null);
                };
                /**
                 * This method first populates the footer followed by each row and their correlating body cells from top to bottom.
                 */
                TablixRowDimension.prototype._render = function () {
                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
                    if (this.hasFooter()) {
                        this.addFooterRowHeader(this._footer);
                        this.addFooterBodyCells(this._footer);
                    }
                    if (firstVisibleRowItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                    }
                };
                TablixRowDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    return new controls.VerticalScrollbar(parentElement, layoutKind);
                };
                /**
                 * This function is a recursive call (with its recursive behavior in addNode()) that will navigate
                 * through the row hierarchy in DFS (Depth First Search) order and continue into a single row
                 * upto its estimated edge.
                 */
                TablixRowDimension.prototype.addNodes = function (items, rowIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    //for loop explores children of current "items"
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var item = this._hierarchyNavigator.getAt(items, i);
                        var cell = this.addNode(item, items, rowIndex, depth);
                        rowIndex += cell.rowSpan; //next node is bumped down according cells vertical span
                    }
                };
                TablixRowDimension.prototype.getFirstVisibleChildLeaf = function (item) {
                    var leaf = item;
                    while (!this._hierarchyNavigator.isLeaf(leaf)) {
                        leaf = this.getFirstVisibleChild(leaf);
                    }
                    return leaf;
                };
                TablixRowDimension.prototype.bindRowHeader = function (item, cell) {
                    this._binder.bindRowHeader(item, cell);
                };
                /**
                 * This method can be thought of as the continuation of addNodes() as it continues the DFS (Depth First Search)
                 * started from addNodes(). This function also handles ending the recursion with "_needsToRealize" being set to
                 * false.
                 *
                 * Once the body cells are reached, populating is done linearly with addBodyCells().
                 */
                TablixRowDimension.prototype.addNode = function (item, items, rowIndex, depth) {
                    var previousCount;
                    var rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item));
                    var match = this.rowHeaderMatch(item, rowHeaderCell);
                    if (!match) {
                        this._owner._unbindCell(rowHeaderCell);
                        rowHeaderCell.type = 1 /* RowHeader */;
                        rowHeaderCell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item);
                        rowHeaderCell.rowSpan = 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                        this.addBodyCells(item, items, rowIndex);
                    }
                    else {
                        previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item));
                        rowHeaderCell.colSpan = 1;
                        rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                    }
                    return rowHeaderCell;
                };
                TablixRowDimension.prototype.rowHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 1 /* RowHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                TablixRowDimension.prototype.addBodyCells = function (item, items, rowIndex) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth();
                    var hierarchyNavigator = this._hierarchyNavigator;
                    var otherModel = this._otherDimension.model;
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i));
                        var cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                        this.bindBodyCell(cellItem, cell);
                        layoutManager.onBodyCellRealized(cellItem, cell);
                    }
                };
                TablixRowDimension.prototype.bindBodyCell = function (item, cell) {
                    var match = this.bodyCelMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 3 /* BodyCell */;
                        cell.item = item;
                        this._binder.bindBodyCell(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterRowHeader = function (item) {
                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                    cell.colSpan = this.getDepth();
                    var match = this.rowHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 1 /* RowHeader */;
                        cell.item = item;
                        this.bindRowHeader(item, cell);
                        this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterBodyCells = function (rowItem) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth();
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i);
                        //get corelating body cell and bind it
                        var item = this._hierarchyNavigator.getIntersection(rowItem, columnItem);
                        var cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                        this.bindBodyCell(item, cell);
                        layoutManager.onBodyCellFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.bodyCelMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 3 /* BodyCell */ && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                };
                return TablixRowDimension;
            }(TablixDimension));
            controls.TablixRowDimension = TablixRowDimension;
            var TablixColumnDimension = /** @class */ (function (_super) {
                __extends(TablixColumnDimension, _super);
                function TablixColumnDimension(tablixControl) {
                    var _this = _super.call(this, tablixControl) || this;
                    _this._layoutManager = _this._tablixLayoutManager.columnLayoutManager;
                    return _this;
                }
                TablixColumnDimension.prototype._render = function () {
                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                    if (firstVisibleColumnItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                    }
                };
                TablixColumnDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    var scrollbar = new controls.HorizontalScrollbar(parentElement, layoutKind);
                    // Set smallest increment of the scrollbar to 0.2 rows
                    scrollbar.smallIncrement = 0.2;
                    return scrollbar;
                };
                TablixColumnDimension.prototype.addNodes = function (items, columnIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                        columnIndex += cell.colSpan;
                    }
                };
                TablixColumnDimension.prototype.addNode = function (item, items, columnIndex, depth) {
                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex);
                    var match = this.columnHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 2 /* ColumnHeader */;
                        cell.item = item;
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item);
                    }
                    else {
                        var previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                        // In case we have a grand total with multiple measures, the multi-measures will be direct children
                        // There can be difference in level > 1. In this case, we want the Total cell to have rowspan = the difference
                        var childrenLevelDifference = this._hierarchyNavigator.getChildrenLevelDifference(item);
                        if (childrenLevelDifference === Infinity)
                            cell.rowSpan = 1;
                        else
                            cell.rowSpan = childrenLevelDifference;
                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                    }
                    if (!match)
                        this._binder.bindColumnHeader(item, cell);
                    this._tablixLayoutManager.onColumnHeaderRealized(item, cell);
                    return cell;
                };
                TablixColumnDimension.prototype.columnHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    // If word wrapping is enabled, we always need to rebind
                    return !this._owner.wordWrapColumnHeaders
                        && cell.type === 2 /* ColumnHeader */
                        && previousItem
                        && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                return TablixColumnDimension;
            }(TablixDimension));
            controls.TablixColumnDimension = TablixColumnDimension;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            /**
             * This class represents the touch region of the column headers (this can also apply to footer/total).
             * This class is reponsible for interpreting gestures in terms of pixels to changes in column position.
             *
             * Unlike the table body, this can only scroll in one direction.
             */
            var ColumnTouchDelegate = /** @class */ (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function ColumnTouchDelegate(region) {
                    this.dim = region;
                    this.averageSize = 1; //default
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of columns to be shifted per delta in pixels.
                 *
                 * @param xRatio Column to pixel ratio (# columns / # pixels).
                 */
                ColumnTouchDelegate.prototype.setScrollDensity = function (xRatio) {
                    this.averageSize = xRatio;
                };
                /**
                 * Resize element.
                 *
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                ColumnTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this.dim.x = x;
                    this.dim.y = y;
                    this.dim.width = width;
                    this.dim.height = height;
                };
                /**
                 * @see IPixelToItem.
                 */
                ColumnTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSize, 0, down, -dx * this.averageSize, 0);
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                ColumnTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this.tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                ColumnTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                return ColumnTouchDelegate;
            }());
            controls.ColumnTouchDelegate = ColumnTouchDelegate;
            /**
             * This class represents the touch region of the row headers (left or right side aligned).
             * This class is reponsible for interpreting gestures in terms of pixels to changes in row position.
             *
             * Unlike the table body, this can only scroll in one direction.
             */
            var RowTouchDelegate = /** @class */ (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function RowTouchDelegate(region) {
                    this.dim = region;
                    this.averageSize = 30; //default
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of rows to be shifted per delta in pixels.
                 *
                 * @param yRatio Row to pixel ratio (# rows / # pixels).
                 */
                RowTouchDelegate.prototype.setScrollDensity = function (yRatio) {
                    this.averageSize = yRatio;
                };
                /**
                 * Resize element.
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                RowTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this.dim.x = x;
                    this.dim.y = y;
                    this.dim.width = width;
                    this.dim.height = height;
                };
                /**
                 * @see: IPixelToItem
                 */
                RowTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    var event = new controls.TouchUtils.TouchEvent(0, y * this.averageSize, down, 0, -dy * this.averageSize);
                    return event;
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                RowTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this.tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                RowTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                return RowTouchDelegate;
            }());
            controls.RowTouchDelegate = RowTouchDelegate;
            /**
             * This class represents the touch region covering the body of the table.
             * This class is reponsible for interpreting gestures in terms of pixels to
             * changes in row and column position.
             */
            var BodyTouchDelegate = /** @class */ (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function BodyTouchDelegate(region) {
                    this.dim = region;
                    this.averageSizeX = BodyTouchDelegate.DefaultAverageSizeX;
                    this.averageSizeY = BodyTouchDelegate.DefaultAverageSizeY;
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                    /**
                     * Returns dimension.
                     *
                     * @return The dimentions of the region this delegate listens to.
                     */
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of rows and columns to be shifted per delta in pixels.
                 *
                 * @param xRatio Column to pixel ratio (# columns / # pixels)
                 * @param yRatio Row to pixel ratio (# rows / # pixels)
                 */
                BodyTouchDelegate.prototype.setScrollDensity = function (xRatio, yRatio) {
                    this.averageSizeX = xRatio;
                    this.averageSizeY = yRatio;
                };
                /**
                 * Resize element.
                 *
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                BodyTouchDelegate.prototype.resize = function (x, y, width, height) {
                    var dimension = this.dim;
                    dimension.x = x;
                    dimension.y = y;
                    dimension.width = width;
                    dimension.height = height;
                };
                /**
                 * @see: IPixelToItem.
                 */
                BodyTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSizeX, y * this.averageSizeY, down, -dx * this.averageSizeX, -dy * this.averageSizeY);
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                BodyTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [this.tablixControl, e.dx, e.dy];
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                BodyTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                BodyTouchDelegate.DefaultAverageSizeX = 30;
                BodyTouchDelegate.DefaultAverageSizeY = 30;
                return BodyTouchDelegate;
            }());
            controls.BodyTouchDelegate = BodyTouchDelegate;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TouchUtils;
            (function (TouchUtils) {
                var Point = /** @class */ (function () {
                    function Point(x, y) {
                        this.x = x || 0;
                        this.y = y || 0;
                    }
                    Point.prototype.offset = function (offsetX, offsetY) {
                        this.x += offsetX;
                        this.y += offsetY;
                    };
                    return Point;
                }());
                TouchUtils.Point = Point;
                var Rectangle = /** @class */ (function (_super) {
                    __extends(Rectangle, _super);
                    function Rectangle(x, y, width, height) {
                        var _this = _super.call(this, x, y) || this;
                        _this.width = width || 0;
                        _this.height = height || 0;
                        return _this;
                    }
                    Object.defineProperty(Rectangle.prototype, "point", {
                        get: function () {
                            return new Point(this.x, this.y);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Rectangle.prototype.contains = function (p) {
                        return Rectangle.contains(this, p);
                    };
                    Rectangle.contains = function (rect, p) {
                        if (p && !Rectangle.isEmpty(rect)) {
                            return rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height;
                        }
                        return false;
                    };
                    Rectangle.isEmpty = function (rect) {
                        return !(rect !== undefined && rect.width >= 0 && rect.height >= 0);
                    };
                    return Rectangle;
                }(Point));
                TouchUtils.Rectangle = Rectangle;
                var MouseButton;
                (function (MouseButton) {
                    MouseButton[MouseButton["NoClick"] = 0] = "NoClick";
                    MouseButton[MouseButton["LeftClick"] = 1] = "LeftClick";
                    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
                    MouseButton[MouseButton["CenterClick"] = 3] = "CenterClick";
                })(MouseButton = TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                /**
                 * A simple touch event class that's abstracted away from any platform specific traits.
                 */
                var TouchEvent = /** @class */ (function () {
                    /**
                     * @constructor
                     * @param x X Location of mouse.
                     * @param y Y Location of mouse.
                     * @param isMouseDown Indicates if the mouse button is held down or a finger press on screen.
                     * @param dx (optional) The change in x of the gesture.
                     * @param dy (optional) The change in y of the gesture.
                     */
                    function TouchEvent(x, y, isMouseDown, dx, dy) {
                        this._x = x;
                        this._y = y;
                        this.isMouseButtonDown = isMouseDown;
                        this._dx = dx || 0;
                        this._dy = dy || 0;
                    }
                    Object.defineProperty(TouchEvent.prototype, "x", {
                        get: function () {
                            return this._x;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "y", {
                        get: function () {
                            return this._y;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dx", {
                        get: function () {
                            return this._dx;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dy", {
                        get: function () {
                            return this._dy;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                        /**
                         * Returns a boolean indicating if the mouse button is held down.
                         *
                         * @return: True if the the mouse button is held down,
                         * otherwise false.
                         */
                        get: function () {
                            return this.isMouseButtonDown;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TouchEvent;
                }());
                TouchUtils.TouchEvent = TouchEvent;
                /**
                 * This class "listens" to the TouchEventInterpreter  to recieve touch events and sends it to all
                 * "Touch Delegates" with  TouchRegions that contain the mouse event. Prior to sending off the
                 * event, its position is put in respect to the delegate's TouchRegion and converted to the appropriate
                 * unit (see IPixelToItem).
                 */
                var TouchManager = /** @class */ (function () {
                    /**
                     * Default constructor.
                     *
                     * The default behavior is to enable thresholds and lock to axis.
                     */
                    function TouchManager() {
                        this.touchList = [];
                        this.swipeDirection = 2 /* FreeForm */;
                        this.matchingDirectionCount = 0;
                        this.lockThreshold = true;
                        this.scrollThreshold = true;
                        this.lastTouchEvent = new TouchEvent(0, 0, false);
                    }
                    Object.defineProperty(TouchManager.prototype, "lastEvent", {
                        get: function () {
                            return this.lastTouchEvent;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * @param region Rectangle indicating the locations of the touch region.
                     * @param handler Handler for recieved touch events.
                     * @param converter Converts from pixels to the wanted item of measure (rows, columns, etc).
                     *
                     * EXAMPLE: dx -> from # of pixels to the right to # of columns moved to the right.
                     */
                    TouchManager.prototype.addTouchRegion = function (region, handler, converter) {
                        var item = {
                            lastPoint: new TouchEvent(0, 0, false),
                            handler: handler,
                            region: region,
                            converter: converter
                        };
                        this.touchList = this.touchList.concat([item]);
                    };
                    /**
                     * Sends a mouse up event to all regions with their last event as a mouse down event.
                     */
                    TouchManager.prototype.upAllTouches = function () {
                        var eventPoint;
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].lastPoint.isMouseDown) {
                                eventPoint = this.touchList[i].converter.getPixelToItem(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, 0, 0, false);
                                this.touchList[i].handler.touchEvent(eventPoint);
                            }
                            this.touchList[i].lastPoint = new TouchEvent(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, false);
                        }
                        this.lastTouchEvent = new TouchEvent(0, 0, false);
                    };
                    TouchManager.prototype.touchEvent = function (e) {
                        var list;
                        var length;
                        var x = 0;
                        var y = 0;
                        var dx = 0;
                        var dy = 0;
                        var angle = 0;
                        var eventPoint = null;
                        //assume there are already regions in the middle of a drag event and get those regions
                        list = this._getActive();
                        //if this is the start of a mouse drag event, repopulate the list with touched regions
                        if (!this.lastTouchEvent.isMouseDown && e.isMouseDown) {
                            list = this._findRegions(e);
                        }
                        //determine the delta values and update last event (delta ignored on first mouse down event)
                        dx = this.lastTouchEvent.x - e.x;
                        dy = this.lastTouchEvent.y - e.y;
                        this.lastTouchEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy);
                        //go through the list
                        length = list.length;
                        for (var i = 0; i < length; i++) {
                            x = e.x - list[i].region.point.x;
                            y = e.y - list[i].region.point.y;
                            //is this in the middle of a drag?
                            if (list[i].lastPoint.isMouseDown && e.isMouseDown) {
                                dx = x - list[i].lastPoint.x;
                                dy = y - list[i].lastPoint.y;
                                //calculate the absolute angle from the horizontal axis
                                angle = Math.abs(180 / Math.PI * Math.atan(dy / dx));
                                if (this.scrollThreshold) {
                                    //is the gesture already locked? (6 prior events within the threshold)
                                    if (this.lockThreshold && (this.matchingDirectionCount > 5)) {
                                        if (this.swipeDirection === 1 /* Horizontal */) {
                                            dy = 0;
                                        }
                                        else if (this.swipeDirection === 0 /* Vertical */) {
                                            dx = 0;
                                        }
                                    }
                                    else {
                                        //is it within the horizontal threshold?
                                        if (angle < 20) {
                                            dy = 0;
                                            if (this.swipeDirection === 1 /* Horizontal */) {
                                                this.matchingDirectionCount++;
                                            }
                                            else {
                                                this.matchingDirectionCount = 1;
                                                this.swipeDirection = 1 /* Horizontal */;
                                            }
                                        }
                                        else {
                                            //calculate the absolute angle from the vertical axis
                                            angle = Math.abs(180 / Math.PI * Math.atan(dx / dy));
                                            //is it within the horizontal threshold?
                                            if (angle < 20) {
                                                dx = 0;
                                                if (this.swipeDirection === 0 /* Vertical */) {
                                                    this.matchingDirectionCount++;
                                                }
                                                else {
                                                    this.matchingDirectionCount = 1;
                                                    this.swipeDirection = 0 /* Vertical */;
                                                }
                                            }
                                            else {
                                                if (this.swipeDirection === 2 /* FreeForm */) {
                                                    this.matchingDirectionCount++;
                                                }
                                                else {
                                                    this.swipeDirection = 2 /* FreeForm */;
                                                    this.matchingDirectionCount = 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                dx = 0;
                                dy = 0;
                                this.swipeDirection = 2 /* FreeForm */;
                                this.matchingDirectionCount = 0;
                            }
                            list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy);
                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown);
                            list[i].handler.touchEvent(eventPoint);
                        }
                    };
                    /**
                     * @param e Position of event used to find touched regions
                     * @return Array of regions that contain the event point.
                     */
                    TouchManager.prototype._findRegions = function (e) {
                        var list = [];
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].region.contains(new Point(e.x, e.y))) {
                                list = list.concat([this.touchList[i]]);
                            }
                        }
                        return list;
                    };
                    /**
                     * @return Array of regions that contain a mouse down event. (see ITouchHandlerSet.lastPoint).
                     */
                    TouchManager.prototype._getActive = function () {
                        var list = [];
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].lastPoint.isMouseDown) {
                                list = list.concat([this.touchList[i]]);
                            }
                        }
                        return list;
                    };
                    return TouchManager;
                }());
                TouchUtils.TouchManager = TouchManager;
                var MinDistanceForSwipe = 80;
                var MaxTimeForSwipe = 600;
                /**
                 * This class is responsible for establishing connections to handle touch events
                 * and to interpret those events so they're compatible with the touch abstractions.
                 *
                 * Touch events with platform specific handles should be done here.
                 */
                var TouchEventInterpreter = /** @class */ (function () {
                    function TouchEventInterpreter(manager) {
                        this.manager = manager;
                        this.touchPanel = null;
                        this.scale = 1;
                        this.documentCallbacksWrapper = null;
                        this.panelCallbacksWrapper = null;
                        this.sliding = false;
                    }
                    TouchEventInterpreter.prototype.initTouch = function (panel, touchReferencePoint) {
                        panel.style.setProperty("-ms-touch-action", "pinch-zoom");
                        this.touchReferencePoint = touchReferencePoint;
                        this.touchPanel = panel;
                        this.startTouchPanelEvents();
                    };
                    TouchEventInterpreter.prototype.startTouchPanelEvents = function () {
                        var _this = this;
                        if ("ontouchmove" in this.touchPanel) {
                            this.panelCallbacksWrapper = {
                                startCallback: function (e) { return _this.onTouchStart(e); },
                                endCallback: function (e) { return _this.onTouchEnd(e); }
                            };
                            this.touchPanel.addEventListener("touchstart", this.panelCallbacksWrapper.startCallback);
                            this.touchPanel.addEventListener("touchend", this.panelCallbacksWrapper.endCallback);
                        }
                    };
                    TouchEventInterpreter.prototype.clearTouchPanelEvents = function () {
                        if (this.panelCallbacksWrapper === null)
                            return;
                        if ("ontouchmove" in this.touchPanel) {
                            this.touchPanel.removeEventListener("touchstart", this.panelCallbacksWrapper.startCallback);
                            this.touchPanel.removeEventListener("touchend", this.panelCallbacksWrapper.endCallback);
                        }
                        this.panelCallbacksWrapper = null;
                    };
                    TouchEventInterpreter.prototype.getXYByClient = function (pageX, pageY, rect) {
                        var x = rect.left;
                        var y = rect.top;
                        // Fix for Safari
                        if (window["scrollX"] !== undefined) {
                            x += window["scrollX"];
                            y += window["scrollY"];
                        }
                        var point = new Point(0, 0);
                        point.offset(pageX - x, pageY - y);
                        return point;
                    };
                    TouchEventInterpreter.prototype.onTouchStart = function (e) {
                        if (e.touches.length === 1) {
                            e.cancelBubble = true;
                            var mouseEvent = e.touches[0];
                            this.touchStartTime = new Date().getTime();
                            this.touchStartPageY = mouseEvent.pageY;
                            this.onTouchMouseDown(mouseEvent);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMove = function (e) {
                        if (e.touches.length === 1) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            var mouseEvent = e.touches[0];
                            this.touchLastPageY = mouseEvent.pageY;
                            this.touchLastPageX = mouseEvent.pageX;
                            // while sliding ignore the touch move event 
                            if (!this.sliding) {
                                this.onTouchMouseMove(mouseEvent);
                            }
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchEnd = function (e) {
                        this.clearTouchDocumentEvents();
                        var swipeInfo = this.getSwipeInfo();
                        if (this.didUserSwipe(swipeInfo)) {
                            this.startSlideAffect(swipeInfo);
                        }
                        else if (!this.sliding) {
                            this.upAllTouches();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseDown = function (e) {
                        this.scale = controls.HTMLElementUtils.getAccumulatedScale(this.touchPanel);
                        //any prior touch scrolling that produced a selection outside Tablix will prevent the next touch scroll (1262519)
                        document.getSelection().removeAllRanges();
                        this.rect = (this.touchReferencePoint ? this.touchReferencePoint : this.touchPanel).getBoundingClientRect();
                        this.startTouchDocumentEvents();
                    };
                    TouchEventInterpreter.prototype.startTouchDocumentEvents = function () {
                        var _this = this;
                        if ("ontouchmove" in this.touchPanel) {
                            this.documentCallbacksWrapper = {
                                moveCallback: function (e) { return _this.onTouchMove(e); },
                                endCallback: function (e) { return _this.onTouchEnd(e); }
                            };
                            document.addEventListener("touchend", this.documentCallbacksWrapper.endCallback);
                            document.addEventListener("touchmove", this.documentCallbacksWrapper.moveCallback);
                        }
                        if ("setCapture" in this.touchPanel) {
                            this.touchPanel.setCapture();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseMove = function (e) {
                        var event;
                        var point;
                        var rect = this.rect;
                        var validMouseDragEvent = (rect !== null) && (e.which !== MouseButton.NoClick);
                        // Ignore events that are not part of a drag event
                        if (!validMouseDragEvent || this.sliding)
                            return;
                        point = this.getXYByClient(e.pageX, e.pageY, rect);
                        event = new TouchEvent(point.x / this.scale, point.y / this.scale, validMouseDragEvent);
                        this.manager.touchEvent(event);
                        if (e.preventDefault)
                            e.preventDefault();
                        else if ("returnValue" in e)
                            e["returnValue"] = false;
                    };
                    TouchEventInterpreter.prototype.getSwipeInfo = function () {
                        var touchEndTime = new Date().getTime();
                        var touchTime = touchEndTime - this.touchStartTime;
                        var touchDist = this.touchLastPageY - this.touchStartPageY;
                        var touchDirection = touchDist < 0 ? -1 : 1;
                        return {
                            direction: touchDirection,
                            distance: touchDist,
                            endTime: touchEndTime,
                            time: touchTime,
                        };
                    };
                    TouchEventInterpreter.prototype.didUserSwipe = function (swipeInfo) {
                        return swipeInfo.time < MaxTimeForSwipe && swipeInfo.distance * swipeInfo.direction > MinDistanceForSwipe;
                    };
                    /**
                     * In case of swipe - auto advance to the swipe direction in 2 steps.
                     */
                    TouchEventInterpreter.prototype.startSlideAffect = function (swipeInfo) {
                        var _this = this;
                        if (this.sliding || this.rect === null) {
                            return;
                        }
                        this.sliding = true;
                        var point = this.getXYByClient(this.touchLastPageX, this.touchLastPageY, this.rect);
                        this.slide(point, 300, swipeInfo);
                        // second step
                        requestAnimationFrame((function () {
                            // in case the user is now scrolling in the opposite direction stop the slide
                            if (!_this.didUserChangeDirection(swipeInfo)) {
                                _this.slide(point, 200, swipeInfo);
                            }
                            _this.clearSlide();
                        }));
                    };
                    TouchEventInterpreter.prototype.didUserChangeDirection = function (swipeInfo) {
                        if (this.touchStartTime <= swipeInfo.endTime) {
                            return false;
                        }
                        var updatedDist = this.touchLastPageY - this.touchStartPageY;
                        var updatedDirection = updatedDist < 0 ? -1 : 1;
                        return updatedDirection !== swipeInfo.direction;
                    };
                    TouchEventInterpreter.prototype.slide = function (point, slideDist, swipeInfo) {
                        var updatedDist = this.touchStartTime > swipeInfo.endTime ? this.touchLastPageY - this.touchStartPageY : 0;
                        point.y += slideDist * swipeInfo.direction + updatedDist;
                        var event = new TouchEvent(point.x / this.scale, point.y / this.scale, true);
                        this.manager.touchEvent(event);
                    };
                    TouchEventInterpreter.prototype.clearSlide = function () {
                        this.sliding = false;
                        this.upAllTouches();
                    };
                    TouchEventInterpreter.prototype.upAllTouches = function () {
                        if (this.documentCallbacksWrapper !== null)
                            return;
                        this.rect = null;
                        this.manager.upAllTouches();
                    };
                    TouchEventInterpreter.prototype.clearTouchDocumentEvents = function () {
                        if ("releaseCapture" in this.touchPanel) {
                            this.touchPanel.releaseCapture();
                        }
                        if (this.documentCallbacksWrapper === null)
                            return;
                        if ("ontouchmove" in this.touchPanel) {
                            document.removeEventListener("touchmove", this.documentCallbacksWrapper.moveCallback);
                            document.removeEventListener("touchend", this.documentCallbacksWrapper.endCallback);
                        }
                        this.documentCallbacksWrapper = null;
                    };
                    TouchEventInterpreter.prototype.clearAllTouchEvents = function () {
                        this.clearTouchDocumentEvents();
                        this.clearTouchPanelEvents();
                    };
                    return TouchEventInterpreter;
                }());
                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
            })(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TablixType;
            (function (TablixType) {
                TablixType[TablixType["Matrix"] = 0] = "Matrix";
                TablixType[TablixType["Table"] = 1] = "Table";
                TablixType[TablixType["PivotTable"] = 2] = "PivotTable";
                TablixType[TablixType["TableEx"] = 3] = "TableEx";
            })(TablixType = controls.TablixType || (controls.TablixType = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var PropAutoSizeWidth = controls.internal.TablixObjects.PropGeneralAutoSizeColumns;
            var getMetadataObjects = controls.internal.TablixObjects.getMetadadataObjects;
            var TablixColumnWidthManager = /** @class */ (function () {
                function TablixColumnWidthManager(dataView, isMatrix, hostPersistCallBack, matrixLeafNodes) {
                    this.columnWidthObjects = {};
                    this.isMatrix = isMatrix;
                    this.updateDataView(dataView, matrixLeafNodes);
                    this.hostPersistCallBack = hostPersistCallBack;
                    this.visualObjectInstancesToPersist = { merge: [], remove: [] };
                }
                // #region Update DataView
                /**
                 * Update the current DataView
                 * @param {dataView} DataView new DataView
                 * @param {MatrixVisualNode[]} matrixLeafNodes? (Optional)Matrix Leaf Nodes
                 */
                TablixColumnWidthManager.prototype.updateDataView = function (dataView, matrixLeafNodes) {
                    this.previousDataView = this.currentDataView;
                    if (this.previousDataView)
                        this.previousAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.previousDataView));
                    else
                        this.previousAutoColumnSizePropertyValue = undefined;
                    this.currentDataView = dataView;
                    if (this.currentDataView)
                        this.currentAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.currentDataView));
                    else
                        this.currentAutoColumnSizePropertyValue = undefined;
                    this.matrixLeafNodes = matrixLeafNodes;
                    this.updateColumnsMetadata();
                    this.updateTablixColumnWidths();
                };
                /**
                * Destroy columnWidthObjects and construct it again from the currently displayed Columns with initial width undefined
                */
                TablixColumnWidthManager.prototype.updateColumnsMetadata = function () {
                    this.columnWidthObjects = {};
                    if (this.isMatrix)
                        this.updateMatrixColumnsMetadata();
                    else
                        this.updateTableColumnsMetadata();
                };
                TablixColumnWidthManager.prototype.updateTableColumnsMetadata = function () {
                    if (this.currentDataView && this.currentDataView.table) {
                        var columnMetaData = this.currentDataView.table.columns;
                        for (var i = 0, len = columnMetaData.length; i < len; i++) {
                            var queryName = columnMetaData[i].queryName;
                            if (queryName)
                                this.columnWidthObjects[queryName] = {
                                    queryName: queryName,
                                    width: undefined,
                                    isFixed: false
                                };
                        }
                    }
                };
                TablixColumnWidthManager.prototype.updateMatrixColumnsMetadata = function () {
                    // Matrix visual columns are row headers and column hierarchy leaves
                    if (this.currentDataView && this.currentDataView.matrix && this.currentDataView.matrix.rows) {
                        // Get query names of row groups (row headers)
                        // queryName is undefined for composite-group
                        for (var i = 0, len = this.currentDataView.matrix.rows.levels.length; i < len; i++) {
                            var rowGroup = this.currentDataView.matrix.rows.levels[i];
                            if (rowGroup.sources.length === 1) {
                                var queryName = rowGroup.sources[0].queryName;
                                if (queryName)
                                    this.columnWidthObjects[queryName] = {
                                        queryName: queryName,
                                        width: undefined,
                                        isFixed: false
                                    };
                            }
                        }
                    }
                    // Get query names of columns leaves or values
                    // queryName is undefined for composite-group
                    if (this.matrixLeafNodes) {
                        for (var i = 0, len = this.matrixLeafNodes.length; i < len; i++) {
                            var queryName = this.matrixLeafNodes[i].queryName;
                            if (queryName)
                                this.columnWidthObjects[queryName] = {
                                    queryName: queryName,
                                    width: undefined,
                                    isFixed: false
                                };
                        }
                    }
                };
                /**
                 * Update the column widths after a dataViewChange
                 */
                TablixColumnWidthManager.prototype.updateTablixColumnWidths = function () {
                    var columnMetaData = this.currentDataView && this.currentDataView.metadata && this.currentDataView.metadata.columns;
                    if (columnMetaData) {
                        // Auto-Size false to true.
                        // Blow away any saved widths and revert back to default of calculating column sizes
                        if (this.shouldClearAllColumnWidths()) {
                            this.autoSizeAllColumns();
                            return;
                        }
                        else {
                            this.deserializeColumnsWidth(columnMetaData);
                        }
                    }
                };
                /**
                 * Remove all persisted columns widths and Update visualObjectInstancesToPersist
                 */
                TablixColumnWidthManager.prototype.autoSizeAllColumns = function () {
                    for (var queryName in this.columnWidthObjects) {
                        this.visualObjectInstancesToPersist.remove.push(this.generateColumnWidthObjectToPersist(queryName, undefined));
                    }
                    this.callHostToPersist();
                };
                /**
                 * Read the Column Widths from the Columns metadata
                 * @param {DataViewMetadataColumn[]} columnMetadata Columns metadata
                 */
                TablixColumnWidthManager.prototype.deserializeColumnsWidth = function (columnsMetadata) {
                    // Clear existing widths
                    for (var colObj in this.columnWidthObjects) {
                        this.columnWidthObjects[colObj].isFixed = !this.currentAutoColumnSizePropertyValue;
                        this.columnWidthObjects[colObj].width = undefined;
                    }
                    for (var i = 0, len = columnsMetadata.length; i < len; i++) {
                        var column = columnsMetadata[i];
                        var queryName = column.queryName;
                        var width = powerbi.DataViewObjects.getValue(column.objects, TablixColumnWidthManager.columnWidthProp);
                        if (this.columnWidthObjects.hasOwnProperty(queryName) && width != null) {
                            this.columnWidthObjects[queryName].width = width;
                            this.columnWidthObjects[queryName].isFixed = true;
                        }
                    }
                };
                // #endregion
                // #region AutoSize toggle
                /**
                 * Returns a value indicating that autoSizeColumns was flipped from false to true
                 */
                TablixColumnWidthManager.prototype.shouldClearAllColumnWidths = function () {
                    return this.previousDataView != null && this.previousAutoColumnSizePropertyValue === false
                        && this.currentDataView != null && this.currentAutoColumnSizePropertyValue === true;
                };
                // #endregion
                /**
                * Gets the QueryName associated with a Column (Column Header or Corner Item)
                * @param {internal.TablixColumn} column TablixColumn
                * @returns queryName
                */
                TablixColumnWidthManager.getColumnQueryName = function (column) {
                    var headerCell = column.getTablixCell();
                    switch (headerCell.type) {
                        case 0 /* CornerCell */:
                            if (headerCell.item == null // Corner item for Table hidden column
                                || headerCell.item.metadata == null)
                                return undefined;
                            return headerCell.item.metadata.queryName;
                        case 2 /* ColumnHeader */:
                            debug.assert(headerCell.item != null, "Tablix Column without a ColumnMetadata");
                            return headerCell.item.queryName;
                        default:
                            debug.assertFail("getColumnQueryName called with cellType: " + headerCell.type);
                            return undefined;
                    }
                };
                /**
                 * Returns the current columnWidthObjects
                 * @returns current columnWidthObjects including undefined widths for autosized or unknown columns
                 */
                TablixColumnWidthManager.prototype.getColumnWidthObjects = function () {
                    return this.columnWidthObjects;
                };
                /**
                 * Returns the current columnWidthObjects for only the fixed-size columns
                 * @returns Returns the current columnWidthObjects excluding auto-sized columns
                 */
                // TODO -- used only tests. Factor out to a test method.
                TablixColumnWidthManager.prototype.getFixedColumnWidthObjects = function () {
                    var fixedOnly = {};
                    for (var queryName in this.columnWidthObjects) {
                        var obj = this.columnWidthObjects[queryName];
                        if (obj.isFixed) {
                            fixedOnly[queryName] = obj;
                        }
                    }
                    return fixedOnly;
                };
                /**
                 * Get the persisted width of a certain column in px, or undefined if the columns is set to autosize or queryName is not found
                 * @param {string} queryName queryName of the Column
                 * @returns Column persisted width in pixel
                 */
                TablixColumnWidthManager.prototype.getPersistedColumnWidth = function (queryName) {
                    var obj = this.columnWidthObjects[queryName];
                    return obj && obj.width;
                };
                /**
                 * Call the host to persist the data
                 * @param {boolean} generateInstances
                 */
                TablixColumnWidthManager.prototype.callHostToPersist = function () {
                    if (this.hostPersistCallBack) {
                        this.hostPersistCallBack(this.visualObjectInstancesToPersist);
                    }
                    // Clears persisted objects list
                    this.visualObjectInstancesToPersist = {
                        merge: [],
                        remove: [],
                    };
                };
                /**
                 * Handler for a column width change by the user
                 * @param {string} queryName queryName of the Column
                 * @param {number} width new width
                 */
                TablixColumnWidthManager.prototype.onColumnWidthChanged = function (queryName, width) {
                    // Resizing an invalid column
                    if (queryName == null || this.columnWidthObjects[queryName] == null)
                        return;
                    var resizedColumn = this.columnWidthObjects[queryName];
                    if (width === -1) {
                        // If AutoSize option is ON, remove the persisted value
                        // Else, set value to unknown and expect to be called again soon
                        resizedColumn.width = undefined;
                        resizedColumn.isFixed = !this.currentAutoColumnSizePropertyValue;
                        // Call persist anyway, if isFixed is true, it will be assined to the rendered width
                        this.visualObjectInstancesToPersist.remove.push(this.generateColumnWidthObjectToPersist(resizedColumn.queryName, undefined));
                        this.callHostToPersist();
                    }
                    else {
                        resizedColumn.width = width;
                        resizedColumn.isFixed = true;
                        this.visualObjectInstancesToPersist.merge.push(this.generateColumnWidthObjectToPersist(queryName, width));
                        this.callHostToPersist();
                    }
                };
                /**
                 * Event handler after rendering all columns. Setting any unknown column width.
                 * Returns True if it calls persist
                 * @param renderedColumns Rendered Columns
                 */
                TablixColumnWidthManager.prototype.onColumnsRendered = function (renderedColumns) {
                    // Pick the maximum width for each queryName
                    // This will ensure going from autoSize ON to OFF will not show any ellipsis
                    var maxWidths = {};
                    for (var i = 0, len = renderedColumns.length; i < len; i++) {
                        var queryName = renderedColumns[i].queryName;
                        var newWidth = renderedColumns[i].width;
                        if (maxWidths[queryName] == null) {
                            maxWidths[queryName] = {
                                queryName: queryName,
                                width: newWidth,
                                isFixed: false // Unused
                            };
                        }
                        else if (newWidth > maxWidths[queryName].width) {
                            maxWidths[queryName].width = newWidth;
                        }
                    }
                    var widthChanged = false;
                    for (var queryName in this.columnWidthObjects) {
                        if (maxWidths[queryName]) {
                            var colWidthObj = this.columnWidthObjects[queryName];
                            if (colWidthObj.isFixed && colWidthObj.width == null) {
                                colWidthObj.width = maxWidths[queryName].width;
                                this.visualObjectInstancesToPersist.merge.push(this.generateColumnWidthObjectToPersist(queryName, colWidthObj.width));
                                widthChanged = true;
                            }
                        }
                    }
                    if (widthChanged)
                        this.callHostToPersist();
                    return widthChanged;
                };
                TablixColumnWidthManager.prototype.generateColumnWidthObjectToPersist = function (queryName, width) {
                    return {
                        selector: { metadata: queryName },
                        objectName: 'general',
                        properties: { columnWidth: width }
                    };
                };
                /**
                * PropertyID for Column Widths (General > columnWidth)
                */
                TablixColumnWidthManager.columnWidthProp = { objectName: 'general', propertyName: 'columnWidth' };
                return TablixColumnWidthManager;
            }());
            controls.TablixColumnWidthManager = TablixColumnWidthManager;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var ScrollingMode;
            (function (ScrollingMode) {
                ScrollingMode[ScrollingMode["None"] = 0] = "None";
                ScrollingMode[ScrollingMode["DraggingThumb"] = 1] = "DraggingThumb";
                ScrollingMode[ScrollingMode["BackgroundClicked"] = 2] = "BackgroundClicked";
                ScrollingMode[ScrollingMode["InitialPagingDelay"] = 3] = "InitialPagingDelay";
                ScrollingMode[ScrollingMode["Paging"] = 4] = "Paging";
            })(ScrollingMode || (ScrollingMode = {}));
            var SvgScrollbar = /** @class */ (function () {
                function SvgScrollbar(options) {
                    this.scrollingMode = ScrollingMode.None;
                    this.brush = d3.svg.brush();
                    this.brushWidth = options.scrollbarWidth;
                    this.brushContextAdditionalClass = options.scrollbarClass;
                    this.updateBrushRadius(options.scrollbarRadius);
                }
                SvgScrollbar.prototype.updateBrushRadius = function (radius) {
                    debug.assertAnyValue(radius, "radius can be null");
                    this.brushRadius = (radius != null) ? radius : SvgScrollbar.defaultBrushRadius;
                };
                SvgScrollbar.prototype.updateScrollbarOptions = function (options) {
                    this.brushWidth = options.scrollbarWidth;
                    this.updateBrushRadius(options.scrollbarRadius);
                    var brushClass = options.scrollbarClass;
                    var oldClassName = this.brushContextAdditionalClass;
                    this.brushContextAdditionalClass = brushClass;
                    if (this.brushGraphicsContext && oldClassName !== brushClass) {
                        this.brushGraphicsContext
                            .classed(oldClassName, false)
                            .classed(brushClass, !!brushClass);
                    }
                };
                SvgScrollbar.prototype.init = function (element) {
                    this.element = element;
                };
                SvgScrollbar.prototype.remove = function () {
                    this.element.selectAll(SvgScrollbar.Brush.selector).remove();
                    // Remove the listeners
                    this.brush
                        .on(SvgScrollbar.events.brushStart, null)
                        .on(SvgScrollbar.events.brush, null)
                        .on(SvgScrollbar.events.brushEnd, null);
                    this.brushGraphicsContext = undefined;
                    if (this.timeoutId != null) {
                        clearTimeout(this.timeoutId);
                        this.timeoutId = null;
                    }
                };
                /**
                 * Gets the extent. Note that this returns a new instance every time it's called.
                 */
                SvgScrollbar.prototype.getExtent = function () {
                    var extent = this.brush.extent();
                    return { start: extent[0], end: extent[1] };
                };
                /**
                 * Sets the extent. If start or end are missing, the extentLength will be used to calculate the missing value.
                 * If either side of the extent is out of bounds, it will be moved (clamped) so that it's in bounds.
                 */
                SvgScrollbar.prototype.setExtent = function (extent) {
                    debug.assert(extent.start != null || extent.end != null, 'At least the start or end value for the extent must be given.');
                    var extentLength;
                    // Calculate the start/end position if one of the values are missing.
                    if (extent.start == null || extent.end == null) {
                        extentLength = this.getExtentLength();
                        if (extent.start == null) {
                            extent.start = extent.end - extentLength;
                        }
                        else {
                            extent.end = extent.start + extentLength;
                        }
                    }
                    else {
                        extentLength = extent.end - extent.start;
                    }
                    debug.assert(this.scrollBarLength >= extentLength, 'extentLength should not be greater than scrollBarLength.');
                    var oldStart = this.getExtent().start;
                    extent = SvgScrollbar.clampExtent(extent, this.scrollBarLength, extentLength);
                    // If we're scrolling while this is called, keep track of the offset distance between where the extent was and where it now is.
                    // This typically happens in loadMore. More data is loaded, so the extent changes (is shrunk and is moved).
                    // If the user was dragging and more data was loaded, when they move their mouse again D3 will jump the extent to the mouse position.
                    // The offset allows us to reset the extent back to the position we want it at as the user drags.
                    // Also update the previous extent since that's what we want to use as the baseline now.
                    if (this.scrollingMode !== ScrollingMode.None) {
                        this.offset = extent.start - oldStart;
                        this.previousBrushExtent = extent;
                    }
                    this.brush.extent([extent.start, extent.end]);
                };
                SvgScrollbar.prototype.getExtentLength = function () {
                    var extent = this.getExtent();
                    return extent.end - extent.start;
                };
                /**
                 * Sets the extent length by setting the end of the extent to be extentLength away from the start.
                 */
                SvgScrollbar.prototype.setExtentLength = function (extentLength) {
                    debug.assert(extentLength >= 0, 'extentLength must be 0 or greater');
                    var extent = this.getExtent();
                    extent.end = extent.start + extentLength;
                    this.setExtent(extent);
                };
                SvgScrollbar.prototype.setScale = function (scale) {
                    if (this.isHorizontal)
                        this.brush.x(scale);
                    else
                        this.brush.y(scale);
                };
                SvgScrollbar.prototype.setOrientation = function (isHorizontal) {
                    this.isHorizontal = isHorizontal;
                };
                SvgScrollbar.prototype.render = function (scrollbarX, scrollbarY, onRefreshVisualCallback) {
                    var _this = this;
                    // create graphics context if it doesn't exist
                    if (!this.brushGraphicsContext) {
                        this.brushGraphicsContext = this.element.append("g")
                            .classed(SvgScrollbar.Brush.class, true)
                            .classed(this.brushContextAdditionalClass, !!this.brushContextAdditionalClass);
                    }
                    this.onRefreshVisualCallback = onRefreshVisualCallback;
                    // events
                    this.brush
                        .on(SvgScrollbar.events.brushStart, (function () {
                        _this.previousBrushExtent = _this.getExtent();
                    }))
                        .on(SvgScrollbar.events.brush, (function () {
                        var newExtent = _this.getExtent();
                        if (_this.scrollingMode === ScrollingMode.None) {
                            // Clicking on the edges of the scroll bar results in extents that go out of bounds (ex. [-0.5, 0] or [230, 230.5]).
                            // clampExtent preserves the extent length, which we don't want in this case. We want [-0.5, 0] to become [0, 0]
                            // since this only happens when they click the background.
                            if (newExtent.start < 0 && newExtent.end === 0) {
                                newExtent.start = 0;
                            }
                            else if (newExtent.start === _this.scrollBarLength && newExtent.end > _this.scrollBarLength) {
                                newExtent.end = _this.scrollBarLength;
                            }
                            // If the extents are the same, they clicked on the background
                            _this.scrollingMode = SvgScrollbar.isBackgroundClickExtent(newExtent) ? ScrollingMode.BackgroundClicked : ScrollingMode.DraggingThumb;
                            _this.startBrushExtent = newExtent;
                        }
                        // Apply the offset (if any). See comment in the setter for extent for more background.
                        if (_this.offset != null) {
                            newExtent.start += _this.offset;
                            newExtent.end += _this.offset;
                        }
                        // Always clamp 1st so we're in the bounds
                        var extentLength = _this.getExtentLength();
                        newExtent = SvgScrollbar.clampExtent(newExtent, _this.scrollBarLength, extentLength);
                        _this.pointerPosition = _this.getPointerPosition();
                        switch (_this.scrollingMode) {
                            case ScrollingMode.DraggingThumb:
                                // If the thumb is being dragged around, just update the visual
                                _this.refreshVisual();
                                break;
                            case ScrollingMode.BackgroundClicked:
                                if (!SvgScrollbar.CenterOnBackgroundClick) {
                                    // If they clicked on the background, move the extent one step from where it was before then refresh.
                                    var increasing = newExtent.start > _this.previousBrushExtent.start;
                                    newExtent = SvgScrollbar.stepExtent(_this.previousBrushExtent, increasing);
                                    _this.refreshVisual();
                                    // Set the timeout to detect if they're holding the mouse button down.
                                    _this.scrollingMode = ScrollingMode.InitialPagingDelay;
                                    _this.setStepTimeout(increasing, newExtent);
                                }
                                else {
                                    // If we're centering on click, center the extent on the pointer then refresh
                                    var halfWidth = extentLength / 2;
                                    newExtent.start = _this.pointerPosition - halfWidth;
                                    newExtent.end = _this.pointerPosition + halfWidth;
                                    _this.refreshVisual();
                                }
                                break;
                            case ScrollingMode.InitialPagingDelay:
                            case ScrollingMode.Paging:
                                // The user is dragging the mouse after initially clicking in the background.
                                // This causes D3 to change the extent. We don't want it to move, so restore its previous position.
                                newExtent = _this.previousBrushExtent;
                                break;
                        }
                        // Set the extent to its new value and refresh
                        _this.setExtent(newExtent);
                        _this.refreshExtent();
                        _this.previousBrushExtent = newExtent;
                    }))
                        .on(SvgScrollbar.events.brushEnd, (function () {
                        // Return the extent to the position it should be in
                        _this.setExtent(_this.previousBrushExtent);
                        _this.refreshExtent();
                        // Clear the values
                        _this.previousBrushExtent = null;
                        _this.startBrushExtent = null;
                        _this.pointerPosition = null;
                        _this.scrollingMode = ScrollingMode.None;
                        _this.offset = null;
                        if (_this.timeoutId != null) {
                            window.clearTimeout(_this.timeoutId);
                            _this.timeoutId = null;
                        }
                    }));
                    // position the graphics context
                    var brushContext = this.brushGraphicsContext
                        .attr({
                        "transform": visuals.SVGUtil.translate(scrollbarX, scrollbarY),
                        "drag-resize-disabled": "true" /* Disables resizing of the visual when dragging the scrollbar in edit mode */
                    })
                        .call(this.brush);
                    // Disable the zooming feature by removing the resize elements
                    brushContext.selectAll(".resize")
                        .remove();
                    var rectAttributes = {
                        "rx": this.brushRadius,
                        "ry": this.brushRadius,
                    };
                    if (this.isHorizontal) {
                        rectAttributes["height"] = this.brushWidth;
                    }
                    else {
                        rectAttributes["width"] = this.brushWidth;
                    }
                    brushContext.selectAll("rect").attr(rectAttributes);
                };
                /**
                 * Determines whether the brush should continue stepping. This assumes that a step has just been taken.
                 * @return true if the extent isn't against the start or end of the scrollbar, and the pointer doesn't overlap with it.
                 */
                SvgScrollbar.prototype.shouldContinueStepping = function (scrollBarLength, extent) {
                    var overlaps = this.pointerPosition >= extent.start && this.pointerPosition <= extent.end;
                    return extent.start !== 0 && extent.end !== scrollBarLength && !overlaps;
                };
                /**
                 * Gets the approximate location of the pointer. If the brush event was started in the background,
                 * the position will be accurate. If not, it will use the center of the extent.
                 */
                SvgScrollbar.prototype.getPointerPosition = function () {
                    var extent = this.getExtent();
                    // If we started in the background, the pointer is aligned with the extent that has changed since the start.
                    if (SvgScrollbar.isBackgroundClickExtent(this.startBrushExtent)) {
                        return extent.start < this.startBrushExtent.start ? extent.start : extent.end;
                    }
                    // Otherwise just get the center of the extent.
                    return (extent.end - extent.start) / 2;
                };
                SvgScrollbar.prototype.refreshExtent = function () {
                    var extent = this.getExtent();
                    var extentLength = this.getExtentLength();
                    var rectElement = this.brushGraphicsContext.select(".extent");
                    if (this.isHorizontal) {
                        rectElement.attr({ "width": extentLength, 'x': extent.start });
                    }
                    else {
                        rectElement.attr({ "height": extentLength, 'y': extent.start });
                    }
                };
                SvgScrollbar.prototype.refreshVisual = function () {
                    if (this.onRefreshVisualCallback) {
                        window.requestAnimationFrame(this.onRefreshVisualCallback);
                    }
                };
                SvgScrollbar.prototype.refreshExtentAndVisual = function () {
                    this.refreshExtent();
                    this.refreshVisual();
                };
                SvgScrollbar.prototype.setStepTimeout = function (increasing, extent) {
                    var _this = this;
                    if (this.shouldContinueStepping(this.scrollBarLength, extent)) {
                        var delay = this.scrollingMode === ScrollingMode.InitialPagingDelay ? SvgScrollbar.InitialPagingDelayMS : SvgScrollbar.PagingDelayMS;
                        this.timeoutId = _.delay((function () { _this.onPagingTimeoutExpired(increasing); }), delay);
                    }
                };
                /**
                 * Determines whether the extent was created with a click in the background.
                 * @returns true if extent.start === extent.end
                 */
                SvgScrollbar.isBackgroundClickExtent = function (extent) {
                    return extent.start === extent.end;
                };
                /**
                 * Moves the extent over one "step" in the direction specified by `this.increasing`.
                 * A step is the extent length;
                 */
                SvgScrollbar.stepExtent = function (extent, increasing) {
                    var length = extent.end - extent.start;
                    extent.start = increasing ? extent.start + length : extent.start - length;
                    extent.end = increasing ? extent.end + length : extent.end - length;
                    return extent;
                };
                SvgScrollbar.prototype.onPagingTimeoutExpired = function (increasing) {
                    // If the timeout expired and we were in the inital waiting state, we're now in the paging state.
                    if (this.scrollingMode !== ScrollingMode.Paging) {
                        this.scrollingMode = ScrollingMode.Paging;
                    }
                    // Step the extent and refresh
                    var extent = this.getExtent();
                    var newExtent = SvgScrollbar.stepExtent(extent, increasing);
                    this.setExtent(newExtent);
                    this.refreshExtentAndVisual();
                    this.previousBrushExtent = extent;
                    // Setup the timeout for the next step
                    this.setStepTimeout(increasing, newExtent);
                };
                SvgScrollbar.clampExtent = function (extent, scrollBarLength, extentLength) {
                    debug.assert(scrollBarLength >= extentLength, 'extentLength should not be greater than scrollBarLength');
                    if (extent.start < 0) {
                        extent.start = 0;
                        extent.end = extentLength;
                    }
                    if (extent.end > scrollBarLength) {
                        extent.end = scrollBarLength;
                        extent.start = scrollBarLength - extentLength;
                    }
                    return extent;
                };
                SvgScrollbar.InitialPagingDelayMS = 500;
                SvgScrollbar.PagingDelayMS = 50;
                SvgScrollbar.defaultBrushRadius = 0;
                /**
                 * Sets whether the brush is centered on background clicks or is moved extentLength.
                 */
                SvgScrollbar.CenterOnBackgroundClick = false;
                SvgScrollbar.events = {
                    brushStart: 'brushstart',
                    brush: 'brush',
                    brushEnd: 'brushend'
                };
                SvgScrollbar.Brush = createClassAndSelector('brush');
                return SvgScrollbar;
            }());
            controls.SvgScrollbar = SvgScrollbar;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CartesianPluginMethods;
        (function (CartesianPluginMethods) {
            function getAdditionalTelemetry(dataView) {
                var telemetry = {};
                var categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
                if (categoryColumn) {
                    telemetry.axisType = visuals.ScalarUtils.shouldDrawScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type, undefined, visuals.CartesianHelper.hasCategoryHierarchy(dataView))
                        ? 'scalar'
                        : 'categorical';
                }
                return telemetry;
            }
            CartesianPluginMethods.getAdditionalTelemetry = getAdditionalTelemetry;
        })(CartesianPluginMethods = visuals.CartesianPluginMethods || (visuals.CartesianPluginMethods = {}));
        var ColumnChartPluginMethods;
        (function (ColumnChartPluginMethods) {
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                dataViewMapping.categorical.dataVolume = 4;
                if (visuals.ScalarUtils.mappingSupportsScalarAxis(dataViewMapping)) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
                    var values = dataViewMapping.categorical.values;
                    if (values && values.group) {
                        values.group.dataReductionAlgorithm = { top: {} };
                    }
                }
                else {
                    visuals.CartesianHelper.expandCategoryWindow([dataViewMapping]);
                }
                visuals.CartesianHelper.requestFilteredToUniqueValue(options.dataViewMappings);
                var sortableRoles = getSortableRoles(options);
                visuals.CartesianHelper.applyHierarchicalSorts(options.dataViewMappings, sortableRoles);
            }
            ColumnChartPluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var forIn = dataViewCategories.for.in;
                var categoryItems = forIn.items;
                var activeProjections = forIn.activeItems;
                var categoricalSortableRoles = ['Category', 'Y', 'Tooltips'];
                //TODO: column chart should be sortable by X if it has scalar axis
                // But currently it doesn't support this. Always return 'category'
                // once it is supported.
                var continuousSortableRoles = [];
                if (!_.isEmpty(categoryItems)) {
                    var objects = void 0;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    var categoryType = void 0;
                    // Given that we have columns in the category, active projections shouldn't be empty, but we have this because for some reason we sometimes don't have any
                    if (_.isEmpty(activeProjections)) {
                        categoryType = categoryItems[0].type;
                    }
                    else if (activeProjections.length === 1) {
                        var item = _.find(categoryItems, (function (item) { return item.queryName === activeProjections[0]; }));
                        debug.assert(!!item, "Item should always be defined");
                        categoryType = item.type;
                    }
                    else if (activeProjections.length > 1) {
                        return categoricalSortableRoles;
                    }
                    if (visuals.ScalarUtils.canHaveScalarAxis(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType))
                        return continuousSortableRoles;
                    else
                        return categoricalSortableRoles;
                }
                return null;
            }
            ColumnChartPluginMethods.getSortableRoles = getSortableRoles;
        })(ColumnChartPluginMethods = visuals.ColumnChartPluginMethods || (visuals.ColumnChartPluginMethods = {}));
        var ComboChartPluginMethods;
        (function (ComboChartPluginMethods) {
            function customizeQuery(options) {
                // If there is a dynamic series but no values on the column data view mapping, remove the dynamic series
                var columnMapping = !_.isEmpty(options.dataViewMappings) && options.dataViewMappings[0];
                if (columnMapping) {
                    var columnValuesMapping = columnMapping.categorical && columnMapping.categorical.values;
                    var seriesSelect = columnValuesMapping.group && !_.isEmpty(columnValuesMapping.group.select) && columnValuesMapping.group.select[0];
                    if (_.isEmpty(seriesSelect.for.in.items))
                        columnValuesMapping.group.by.items = undefined;
                }
                var isScalar = visuals.ScalarUtils.mappingSupportsScalarAxis(columnMapping);
                if (columnMapping && columnMapping.categorical) {
                    columnMapping.categorical.dataVolume = 4;
                    if (isScalar) {
                        var dataViewCategories = columnMapping.categorical.categories;
                        dataViewCategories.dataReductionAlgorithm = { sample: {} };
                        var values = columnMapping.categorical.values;
                        if (values && values.group) {
                            values.group.dataReductionAlgorithm = { top: {} };
                        }
                    }
                }
                var lineMapping = options.dataViewMappings.length > 1 && options.dataViewMappings[1];
                if (lineMapping && lineMapping.categorical) {
                    lineMapping.categorical.dataVolume = 4;
                    if (isScalar) {
                        var dataViewCategories = lineMapping.categorical.categories;
                        dataViewCategories.dataReductionAlgorithm = { sample: {} };
                        var values = lineMapping.categorical.values;
                        if (values && values.group) {
                            values.group.dataReductionAlgorithm = { top: {} };
                        }
                    }
                }
                if (!isScalar) {
                    visuals.CartesianHelper.expandCategoryWindow(options.dataViewMappings);
                }
                visuals.CartesianHelper.requestFilteredToUniqueValue(options.dataViewMappings);
                var sortableRoles = getSortableRoles(options);
                visuals.CartesianHelper.applyHierarchicalSorts(options.dataViewMappings, sortableRoles);
            }
            ComboChartPluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles(options) {
                if (options && options.dataViewMappings.length > 0) {
                    var dataViewMapping = options.dataViewMappings[0];
                    //TODO: column chart should be sortable by X if it has scalar axis
                    // But currenly it doesn't support this. Return 'category' once
                    // it is supported.
                    if (!visuals.ScalarUtils.mappingSupportsScalarAxis(dataViewMapping))
                        return ['Category', 'Y', 'Y2', 'Tooltips'];
                }
                return null;
            }
            ComboChartPluginMethods.getSortableRoles = getSortableRoles;
        })(ComboChartPluginMethods = visuals.ComboChartPluginMethods || (visuals.ComboChartPluginMethods = {}));
        var LineChartPluginMethods;
        (function (LineChartPluginMethods) {
            var CompiledDataViewMapping = powerbi.data.CompiledDataViewMapping;
            var ScalarKeyUtils = powerbi.data.ScalarKeyUtils;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                dataViewMapping.categorical.dataVolume = 4;
                var dataViewCategories = dataViewMapping.categorical.categories;
                // Opt in to scalar key
                var requestScalarKeys = false;
                if (visuals.ScalarUtils.scalarAxisTypeAllowed(dataViewMapping.metadata.objects, visuals.lineChartProps.categoryAxis.axisType)) {
                    requestScalarKeys = ScalarKeyUtils.hasScalarKeys(dataViewMapping.categorical);
                    var forecastMapping_1 = _.find(options.dataViewMappings, (function (dataViewMapping) { return dataViewMapping.usage && dataViewMapping.usage.forecast; }));
                    CompiledDataViewMapping.visitCategoricalCategories(dataViewCategories, {
                        visitRole: function (role) {
                            var roleItems = role.items;
                            var _loop_4 = function (i, iLen) {
                                var item = roleItems[i];
                                var scalarKeyInfo = item.scalarKeyInfo;
                                if (scalarKeyInfo && scalarKeyInfo.hasScalarKey) {
                                    scalarKeyInfo.scalarKeyMinProperty = visuals.cartesianChartProps.scalarKey.scalarKeyMin;
                                    // If we are asking for scalar keys, update the forecasting mapping to indicate this as well.
                                    if (forecastMapping_1) {
                                        CompiledDataViewMapping.visitCategoricalCategories(forecastMapping_1.categorical.categories, {
                                            visitRole: function (role) {
                                                if (!role.items[i].scalarKeyInfo) {
                                                    role.items[i].scalarKeyInfo = {};
                                                }
                                                role.items[i].scalarKeyInfo.scalarKeyMinProperty = visuals.cartesianChartProps.scalarKey.scalarKeyMin;
                                            }
                                        });
                                    }
                                    return "break";
                                }
                            };
                            for (var i = 0, iLen = _.size(roleItems); i < iLen; i++) {
                                var state_1 = _loop_4(i, iLen);
                                if (state_1 === "break")
                                    break;
                            }
                        }
                    });
                }
                if (!requestScalarKeys && !visuals.ScalarUtils.mappingSupportsScalarAxis(dataViewMapping)) {
                    _.remove(options.dataViewMappings, (function (dataViewMapping) { return dataViewMapping.usage && dataViewMapping.usage.forecast; }));
                    visuals.LineChartDataReduction.applyWindow(dataViewMapping);
                    var dataViewMappingArray = [dataViewMapping];
                    visuals.CartesianHelper.expandCategoryWindow(dataViewMappingArray);
                    var sortableRoles = getSortableRoles(options);
                    visuals.CartesianHelper.applyHierarchicalSorts(dataViewMappingArray, sortableRoles);
                }
                visuals.CartesianHelper.requestFilteredToUniqueValue(options.dataViewMappings);
            }
            LineChartPluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var forIn = dataViewCategories.for.in;
                var categoryItems = forIn.items;
                var activeProjections = forIn.activeItems;
                var categoricalSortableRoles = ['Category', 'Y', 'Tooltips'];
                //TODO: line chart should be sortable by X if it has scalar axis
                // But currently it doesn't support this. Always return 'category'
                // once it is supported.
                var continuousSortableRoles = [];
                if (!_.isEmpty(categoryItems)) {
                    var objects = void 0;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    // If we have scalar keys and the user didn't force the graph to be categorical
                    if (ScalarKeyUtils.hasScalarKeys(dataViewMapping.categorical) && visuals.ScalarUtils.scalarAxisTypeAllowed(objects, visuals.lineChartProps.categoryAxis.axisType))
                        return continuousSortableRoles;
                    var type = void 0;
                    // Given that we have columns in the category, active projections shouldn't be empty, but we have this because for some reason we sometimes don't have any
                    if (_.isEmpty(activeProjections)) {
                        type = categoryItems[0].type;
                    }
                    else if (activeProjections.length === 1) {
                        var item = _.find(categoryItems, (function (item) { return item.queryName === activeProjections[0]; }));
                        debug.assert(!!item, "Item should always be defined");
                        type = item.type;
                    }
                    else if (activeProjections.length > 1) {
                        return categoricalSortableRoles;
                    }
                    if (visuals.ScalarUtils.canHaveScalarAxis(objects, visuals.lineChartProps.categoryAxis.axisType, type))
                        return continuousSortableRoles;
                    else
                        return categoricalSortableRoles;
                }
                return null;
            }
            LineChartPluginMethods.getSortableRoles = getSortableRoles;
        })(LineChartPluginMethods = visuals.LineChartPluginMethods || (visuals.LineChartPluginMethods = {}));
        var MapPluginMethods;
        (function (MapPluginMethods) {
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (dataViewMapping.categorical) {
                    var categories = dataViewMapping.categorical.categories;
                    if (categories.select) {
                        var values = dataViewMapping.categorical.values;
                        var roleBind = values.group.select[0];
                        // If there are no values in size, use sample to sample across lat/long, which shows a better representation of the data
                        if (_.isEmpty(roleBind.bind.to.items)) {
                            categories.dataReductionAlgorithm = { sample: {} };
                        }
                    }
                }
            }
            MapPluginMethods.customizeQuery = customizeQuery;
        })(MapPluginMethods = visuals.MapPluginMethods || (visuals.MapPluginMethods = {}));
        var MatrixPluginMethods;
        (function (MatrixPluginMethods) {
            var TablixObjects = powerbi.visuals.controls.internal.TablixObjects;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                // If Columns Hierarchy is not empty, set Window DataReduction Count to 100
                if (!_.isEmpty(dataViewMatrix.columns.for.in.items)) {
                    dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100;
                }
                var objects = dataViewMapping.metadata.objects;
                dataViewMatrix.rows.for.in.subtotalType = TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects) ? 2 /* After */ : 0 /* None */;
                dataViewMatrix.columns.for.in.subtotalType = TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects) ? 2 /* After */ : 0 /* None */;
            }
            MatrixPluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles() {
                return ['Rows', 'Values'];
            }
            MatrixPluginMethods.getSortableRoles = getSortableRoles;
        })(MatrixPluginMethods = visuals.MatrixPluginMethods || (visuals.MatrixPluginMethods = {}));
        var MultiRowCardPluginMethods;
        (function (MultiRowCardPluginMethods) {
            var ValuesRole = 'Values';
            function getSortableRoles(options) {
                if (!options || !options.dataViewMappings || _.isEmpty(options.dataViewMappings)) {
                    return;
                }
                for (var _i = 0, _a = options.dataViewMappings; _i < _a.length; _i++) {
                    var dataViewMapping = _a[_i];
                    if (dataViewMapping.table) {
                        var rows = dataViewMapping.table.rows;
                        if (rows && rows.for && rows.for.in && rows.for.in.items) {
                            return [ValuesRole];
                        }
                    }
                }
                return;
            }
            MultiRowCardPluginMethods.getSortableRoles = getSortableRoles;
        })(MultiRowCardPluginMethods = visuals.MultiRowCardPluginMethods || (visuals.MultiRowCardPluginMethods = {}));
        var PivotTablePluginMethods;
        (function (PivotTablePluginMethods) {
            var TablixObjects = powerbi.visuals.controls.internal.TablixObjects;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                // If Columns Hierarchy is not empty, set Window DataReduction Count to 100
                if (!_.isEmpty(dataViewMatrix.columns.for.in.items)) {
                    dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100;
                }
                customizeRowSubtotals(dataViewMapping, dataViewMatrix);
                customizeColumnSubtotals(dataViewMapping, dataViewMatrix);
            }
            PivotTablePluginMethods.customizeQuery = customizeQuery;
            function customizeRowSubtotals(dataViewMapping, dataViewMatrix) {
                var objects = dataViewMapping.metadata.objects;
                var columns = dataViewMapping.metadata.columns;
                var projections = dataViewMatrix.rows.for.in.items;
                var totalsEnabled = TablixObjects.PropSubTotalsPivotTableRowSubtotals.getValue(objects);
                var subtotalType = (TablixObjects.PropSubTotalsPivotTableRowSubtotalsPosition.getValue(objects) === visuals.rowSubtotalPosition.top) ?
                    1 /* Before */ : 2 /* After */;
                var perLevel = TablixObjects.PropSubTotalsPivotTableRowSubtotalsPerLevel.getValue(objects);
                if (!_.isEmpty(projections)) {
                    var _loop_5 = function (i, len) {
                        var projection = projections[i];
                        var column = _.find(columns, (function (c) { return c.queryName === projection.queryName; }));
                        if (!column)
                            return "continue";
                        var levelTotalEnabled = TablixObjects.PropSubTotalsPivotTableLevelSubtotalEnabled.getValue(column.objects);
                        if (!totalsEnabled || perLevel && !levelTotalEnabled) {
                            projection.subtotalType = 0 /* None */;
                        }
                        else {
                            // If stepped layout, first level subtotal should always be Before because it's floating
                            if (i === 0 && TablixObjects.PropRowsSteppedLayout.getValue(objects))
                                projection.subtotalType = 1 /* Before */;
                            else
                                projection.subtotalType = subtotalType;
                        }
                    };
                    for (var i = 0, len = projections.length; i < len; i++) {
                        _loop_5(i, len);
                    }
                }
            }
            function customizeColumnSubtotals(dataViewMapping, dataViewMatrix) {
                var objects = dataViewMapping.metadata.objects;
                var columns = dataViewMapping.metadata.columns;
                var projections = dataViewMatrix.columns.for.in.items;
                var totalsEnabled = TablixObjects.PropSubTotalsPivotTableColumnSubtotals.getValue(objects);
                var perLevel = TablixObjects.PropSubTotalsPivotTableColumnSubtotalsPerLevel.getValue(objects);
                if (!_.isEmpty(projections)) {
                    var _loop_6 = function (projection) {
                        var column = _.find(columns, (function (c) { return c.queryName === projection.queryName; }));
                        if (!column)
                            return "continue";
                        var levelTotalEnabled = TablixObjects.PropSubTotalsPivotTableLevelSubtotalEnabled.getValue(column.objects);
                        if (!totalsEnabled || perLevel && !levelTotalEnabled)
                            projection.subtotalType = 0 /* None */;
                        else
                            projection.subtotalType = 2 /* After */;
                    };
                    for (var _i = 0, projections_1 = projections; _i < projections_1.length; _i++) {
                        var projection = projections_1[_i];
                        _loop_6(projection);
                    }
                }
            }
            function getSortableRoles() {
                return ['Rows', 'Values'];
            }
            PivotTablePluginMethods.getSortableRoles = getSortableRoles;
        })(PivotTablePluginMethods = visuals.PivotTablePluginMethods || (visuals.PivotTablePluginMethods = {}));
        var ScatterChartPluginMethods;
        (function (ScatterChartPluginMethods) {
            var DataRoleHelper = powerbi.data.DataRoleHelper;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                var objects = dataViewMapping.metadata.objects;
                var showRatioLine = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.ratioLine.show, visuals.CartesianHelper.DefaultScatterRatioLineSettings.show);
                if (showRatioLine) {
                    var hasXYGroups = false;
                    var selectMapping = dataViewMatrix.rows;
                    // Ask for totals on the matrix. In case of Sample (just Category or Series and Category), we will get the grand totals
                    // reliably, but not the intermediate subtotals for each series.
                    if (selectMapping && !_.isEmpty(selectMapping.select)) {
                        debug.assert(!!(selectMapping.dataReductionAlgorithm.bottom
                            || selectMapping.dataReductionAlgorithm.sample
                            || selectMapping.dataReductionAlgorithm.overlappingPointsSample), 'invalid data reduction');
                        var selectMappingRoles = [];
                        for (var _i = 0, _a = selectMapping.select; _i < _a.length; _i++) {
                            var select = _a[_i];
                            var mappings = void 0;
                            var compositeMapping = select;
                            if (compositeMapping.composite) {
                                mappings = compositeMapping.composite;
                            }
                            else {
                                mappings = [select];
                            }
                            for (var _b = 0, mappings_1 = mappings; _b < mappings_1.length; _b++) {
                                var mapping = mappings_1[_b];
                                if (mappingIsXYGroup(mapping)) {
                                    hasXYGroups = true;
                                    break;
                                }
                                if (isBindMapping(mapping)) {
                                    selectMappingRoles.push(mapping.bind.to);
                                }
                                if (isForMapping(mapping)) {
                                    selectMappingRoles.push(mapping.for.in);
                                }
                            }
                            if (hasXYGroups) {
                                break;
                            }
                        }
                        // Only request subtotals if we don't have X/Y groupings
                        if (!hasXYGroups) {
                            for (var _c = 0, selectMappingRoles_1 = selectMappingRoles; _c < selectMappingRoles_1.length; _c++) {
                                var selectMappingRole = selectMappingRoles_1[_c];
                                selectMappingRole.subtotalType = 2 /* After */;
                            }
                        }
                    }
                    if (!hasXYGroups && isForMapping(dataViewMatrix.columns)) {
                        dataViewMatrix.columns.for.in.subtotalType = 2 /* After */;
                    }
                }
                var dataReductionAlgorithm = dataViewMatrix.rows.dataReductionAlgorithm;
                var dataVolumeCount = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.general.dataVolume, null);
                if (dataReductionAlgorithm && dataReductionAlgorithm.overlappingPointsSample) {
                    var categoryAxis = powerbi.DataViewObjects.getValue(objects, visuals.cartesianChartProps.categoryAxis.axisScale);
                    var valueAxis = powerbi.DataViewObjects.getValue(objects, visuals.cartesianChartProps.valueAxis.axisScale);
                    if (categoryAxis === visuals.axisScale.log)
                        dataReductionAlgorithm.overlappingPointsSample.x.transform = 1 /* Log */;
                    if (valueAxis === visuals.axisScale.log)
                        dataReductionAlgorithm.overlappingPointsSample.y.transform = 1 /* Log */;
                    // only set data volume if the property is not null
                    if (dataVolumeCount != null)
                        dataReductionAlgorithm.overlappingPointsSample.count = dataVolumeCount;
                }
                else if (dataReductionAlgorithm && dataReductionAlgorithm.sample) {
                    // handle non high-density-visual case
                    if (dataVolumeCount != null) {
                        dataReductionAlgorithm.sample.count = dataVolumeCount;
                    }
                }
            }
            ScatterChartPluginMethods.customizeQuery = customizeQuery;
            function mappingIsXYGroup(mapping) {
                var role;
                if (isBindMapping(mapping)) {
                    role = mapping.bind.to.role;
                }
                else if (isForMapping(mapping)) {
                    role = mapping.for.in.role;
                }
                return role === visuals.scatterRoleNames.x || role === visuals.scatterRoleNames.y;
            }
            function isBindMapping(mapping) {
                return mapping && !!mapping.bind;
            }
            function isForMapping(mapping) {
                return mapping && !!mapping.for;
            }
            function getAdditionalTelemetry(dataView) {
                var telemetry = {
                    hasSize: DataRoleHelper.hasRoleInDataView(dataView, 'Size'),
                    hasPlayAxis: DataRoleHelper.hasRoleInDataView(dataView, 'Play'),
                };
                return telemetry;
            }
            ScatterChartPluginMethods.getAdditionalTelemetry = getAdditionalTelemetry;
        })(ScatterChartPluginMethods = visuals.ScatterChartPluginMethods || (visuals.ScatterChartPluginMethods = {}));
        var SlicerPluginMethods;
        (function (SlicerPluginMethods) {
            var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
            function getSortableRoles(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (dataViewMapping &&
                    dataViewMapping.metadata) {
                    var metaDataColumns = dataViewMapping.metadata.columns;
                    var parameter = metaDataColumns && metaDataColumns[0] && metaDataColumns[0].parameter;
                    if (shouldRequestMinMax(dataViewMapping) || parameter) {
                        var mode = getSlicerMode(dataViewMapping.metadata.objects);
                        if (mode === null || visuals.slicerMode.isRangeSlicerMode(mode) || mode === visuals.slicerMode.relative) {
                            return null;
                        }
                    }
                }
                return [visuals.slicerRoles.value];
            }
            SlicerPluginMethods.getSortableRoles = getSortableRoles;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.metadata)
                    return;
                var mode = getSlicerMode(dataViewMapping.metadata.objects);
                if (mode === visuals.slicerMode.single
                    || (mode === null && powerbi.DataViewMapping.getParameterColumns(dataViewMapping).length > 0)) {
                    var categories = dataViewMapping.categorical && dataViewMapping.categorical.categories;
                    if (categories)
                        categories.dataReductionAlgorithm = { sample: {} };
                    return;
                }
                if (!(mode === null || visuals.slicerMode.slicerModeSupportsMinMax(mode)))
                    return;
                // Apply aggregation for supported slicer types.
                if (shouldRequestMinMax(dataViewMapping)) {
                    var items = dataViewMapping.categorical.categories.for.in.items;
                    dataViewMapping.categorical.categories = null;
                    dataViewMapping.categorical.values = {
                        bind: {
                            to: {
                                role: visuals.slicerRoles.value,
                                aggregates: { min: true, max: true },
                                items: items
                            },
                        },
                    };
                }
            }
            SlicerPluginMethods.customizeQuery = customizeQuery;
            function getSlicerMode(objects) {
                var mode = null;
                if (objects) {
                    mode = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.data.mode, mode);
                }
                return mode;
            }
            function getSlicerModeDefinition(objects) {
                return objects && DataViewObjectDefinitions.getValue(objects, visuals.slicerProps.data.mode, /*selector*/ undefined);
            }
            SlicerPluginMethods.getSlicerModeDefinition = getSlicerModeDefinition;
            function shouldRequestMinMax(dataViewMapping) {
                if (dataViewMapping &&
                    dataViewMapping.categorical &&
                    dataViewMapping.categorical.categories &&
                    dataViewMapping.metadata) {
                    var metaDataColumns = dataViewMapping.metadata.columns;
                    var parameter = metaDataColumns && metaDataColumns[0] && metaDataColumns[0].parameter;
                    var items = dataViewMapping.categorical.categories.for.in.items;
                    var mode = getSlicerMode(dataViewMapping.metadata.objects);
                    if (!_.isEmpty(items)) {
                        var item = items[0];
                        if (item.type && item.type.dateTime)
                            return true;
                        if (item.type
                            && item.type.numeric
                            && (visuals.slicerMode.slicerModeSupportsMinMax(mode) || (visuals.SlicerHelper.NumericSlicerEnabled && mode === null && !parameter))) {
                            return true;
                        }
                    }
                }
                return false;
            }
            SlicerPluginMethods.shouldRequestMinMax = shouldRequestMinMax;
            /**
                * Plugin method. Used to define whether the slicer cross filtered by other visuals.
                * It is cross filtered only if it is date slicer.
                */
            function isCrossFilteredByDefault(options) {
                var dataViewMapping = options.dataViewMappings[0];
                // If the mode is null means we use list slicer.
                if (!dataViewMapping || !dataViewMapping.metadata)
                    return false;
                var mode = getSlicerMode(dataViewMapping.metadata.objects);
                if (mode == null) {
                    return shouldRequestMinMax(dataViewMapping);
                }
                return visuals.slicerMode.isRangeSlicerMode(mode);
            }
            SlicerPluginMethods.isCrossFilteredByDefault = isCrossFilteredByDefault;
        })(SlicerPluginMethods = visuals.SlicerPluginMethods || (visuals.SlicerPluginMethods = {}));
        var TableExPluginMethods;
        (function (TableExPluginMethods) {
            var TablixObjects = powerbi.visuals.controls.internal.TablixObjects;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata)
                    return;
                var dataViewTableRows = dataViewMapping.table.rows;
                var objects = dataViewMapping.metadata.objects;
                dataViewTableRows.for.in.subtotalType = TablixObjects.PropTotalTableExTotals.getValue(objects) ? 1 /* Before */ : 0 /* None */;
            }
            TableExPluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles() {
                return ['Values'];
            }
            TableExPluginMethods.getSortableRoles = getSortableRoles;
        })(TableExPluginMethods = visuals.TableExPluginMethods || (visuals.TableExPluginMethods = {}));
        var TablePluginMethods;
        (function (TablePluginMethods) {
            var TablixObjects = powerbi.visuals.controls.internal.TablixObjects;
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata)
                    return;
                var dataViewTableRows = dataViewMapping.table.rows;
                var objects = dataViewMapping.metadata.objects;
                dataViewTableRows.for.in.subtotalType = TablixObjects.PropGeneralTableTotals.getValue(objects) ? 1 /* Before */ : 0 /* None */;
            }
            TablePluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles() {
                return ['Values'];
            }
            TablePluginMethods.getSortableRoles = getSortableRoles;
        })(TablePluginMethods = visuals.TablePluginMethods || (visuals.TablePluginMethods = {}));
        var WaterfallChartPluginMethods;
        (function (WaterfallChartPluginMethods) {
            function customizeQuery(options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                // Since we ask for 'top' on the secondary axis for breakdown, request for
                // subtotal before all the data so as to avoid it being excluded in the DSR
                // as we always need correct subtotals
                if (dataViewMatrix.columns && dataViewMatrix.columns.for && dataViewMatrix.columns.for.in)
                    dataViewMatrix.columns.for.in.subtotalType = 1 /* Before */;
            }
            WaterfallChartPluginMethods.customizeQuery = customizeQuery;
            function getSortableRoles() {
                return ['Category', 'Y', 'Tooltips'];
            }
            WaterfallChartPluginMethods.getSortableRoles = getSortableRoles;
        })(WaterfallChartPluginMethods = visuals.WaterfallChartPluginMethods || (visuals.WaterfallChartPluginMethods = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AxisViewModel;
        (function (AxisViewModel) {
            /**
             * Creating an axis label after formatting it according to the styleString if provided.
             */
            function createAxisLabel(styleString, label, unitType) {
                if (!styleString) {
                    return label;
                }
                if (styleString === visuals.axisStyle.showBoth) {
                    return label + ' (' + unitType + ')'; //todo: localize
                }
                else if (styleString === visuals.axisStyle.showUnitOnly) {
                    return unitType;
                }
                return label;
            }
            AxisViewModel.createAxisLabel = createAxisLabel;
        })(AxisViewModel = visuals.AxisViewModel || (visuals.AxisViewModel = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var FontSize = visuals.Units.FontSize;
        var AxisDataModel;
        (function (AxisDataModel) {
            var AxesData = /** @class */ (function () {
                function AxesData(valueAxisProperties, categoryAxisProperties, isYCategorical, isValueAxisDisabled, isScatter) {
                    this.AxisDataDefaults = {
                        show: true,
                        position: visuals.yAxisPosition.left,
                        alignZeros: false,
                        showAxisTitle: false,
                        start: undefined,
                        end: undefined,
                        axisType: undefined,
                        axisScale: visuals.DEFAULT_AXIS_SCALE_TYPE,
                        axisStyle: visuals.axisStyle.showTitleOnly,
                        labelDisplayUnits: 0,
                        labelPrecision: visuals.dataLabelUtils.defaultLabelPrecision,
                        titleText: undefined,
                        preferredCategoryWidth: visuals.CartesianHelper.MinOrdinalRectThickness,
                        concatenateLabels: visuals.CartesianHelper.DefaultConcatenateLabelsValue,
                        labelFontProperties: {
                            color: visuals.DEFAULT_AXIS_COLOR,
                            family: visuals.CartesianHelper.DefaultAxisFontFamily,
                            size: FontSize.createFromPx(visuals.CartesianHelper.DefaultAxisFontSizeInPx),
                            style: undefined,
                            variant: undefined,
                            weight: undefined,
                            whiteSpace: undefined,
                        },
                        titleFontProperties: undefined,
                        axisLabel: undefined,
                        gridlineShow: undefined,
                        gridlineColor: visuals.CartesianAxes.gridlineDefaultColor,
                        gridlineStyle: visuals.lineStyle.solid,
                        gridlineThickness: 1,
                    };
                    this.isCategoryAxisSet = !!categoryAxisProperties;
                    this.isValueAxisSet = !!valueAxisProperties;
                    this.isValueAxisDisabled = isValueAxisDisabled;
                    var xProperties = isYCategorical ? valueAxisProperties : categoryAxisProperties;
                    var yProperties = isYCategorical ? categoryAxisProperties : valueAxisProperties;
                    var y2Properties = valueAxisProperties;
                    var xDefaults = _.clone(this.AxisDataDefaults);
                    xDefaults.gridlineShow = isYCategorical || isScatter;
                    var yDefaults = _.clone(this.AxisDataDefaults);
                    yDefaults.gridlineShow = !isYCategorical;
                    this.x = AxesData.createSingleAxisFromObject(xProperties, xDefaults);
                    this.y = AxesData.createSingleAxisFromObject(yProperties, yDefaults);
                    this.categoryAxis = isYCategorical ? this.y : this.x;
                    this.valueAxis = isYCategorical ? this.x : this.y;
                    // update defaults for y2 axis:
                    var y2Defaults = _.clone(this.AxisDataDefaults);
                    y2Defaults.show = undefined;
                    y2Defaults.position = visuals.yAxisPosition.right;
                    y2Defaults.labelFontProperties = isYCategorical ? this.x.labelFontProperties : this.y.labelFontProperties;
                    this.y2 = AxesData.createSingleAxisFromObject(y2Properties, y2Defaults, true);
                    if (isValueAxisDisabled) {
                        this.valueAxis.show = false;
                    }
                }
                AxesData.createDefault = function () {
                    return new AxesData(undefined, undefined, false, false, false);
                };
                AxesData.createSingleAxisFromObject = function (properties, defaults, isSecond) {
                    var getValue = powerbi.DataViewObject.getValue;
                    var getFillColorByPropertyName = powerbi.DataViewObject.getFillColorByPropertyName;
                    var getPropName = isSecond ? function (prop) { return _.camelCase('sec ' + prop.propertyName); } : function (prop) { return prop.propertyName; };
                    var axisProps = visuals.cartesianChartProps.valueAxis;
                    var show = getValue(properties, getPropName(axisProps.show), defaults.show);
                    var alignZeros = getValue(properties, getPropName(axisProps.alignZeros), defaults.alignZeros);
                    var showAxisTitle = getValue(properties, getPropName(axisProps.showAxisTitle), defaults.showAxisTitle);
                    var start = getValue(properties, getPropName(axisProps.start), defaults.start);
                    var end = getValue(properties, getPropName(axisProps.end), defaults.end);
                    var position = getValue(properties, getPropName(axisProps.position), defaults.position);
                    var axisType = getValue(properties, getPropName(axisProps.axisType), defaults.axisType);
                    var axisScale = getValue(properties, getPropName(axisProps.axisScale), defaults.axisScale);
                    var axisStyle = getValue(properties, getPropName(axisProps.axisStyle), defaults.axisStyle);
                    var labelDisplayUnits = getValue(properties, getPropName(axisProps.labelDisplayUnits), defaults.labelDisplayUnits);
                    var labelPrecision = getValue(properties, getPropName(axisProps.labelPrecision), defaults.labelPrecision);
                    if (!labelPrecision || labelPrecision < 0) {
                        labelPrecision = defaults.labelPrecision;
                    }
                    var titleText = getValue(properties, getPropName(axisProps.titleText), defaults.titleText);
                    var preferredCategoryWidth = getValue(properties, getPropName(axisProps.preferredCategoryWidth), defaults.preferredCategoryWidth);
                    var concatenateLabels = getValue(properties, getPropName(axisProps.concatenateLabels), defaults.concatenateLabels);
                    var axisLabel = getValue(properties, getPropName(axisProps.axisLabel));
                    var gridlineShow = getValue(properties, getPropName(axisProps.gridlineShow), defaults.gridlineShow || concatenateLabels === false);
                    var gridlineColor = getFillColorByPropertyName(properties, getPropName(axisProps.gridlineColor), defaults.gridlineColor);
                    var gridlineThickness = getValue(properties, getPropName(axisProps.gridlineThickness), defaults.gridlineThickness);
                    var gridlineStyle = getValue(properties, getPropName(axisProps.gridlineStyle), defaults.gridlineStyle);
                    var names = {
                        family: getPropName(axisProps.fontFamily),
                        size: getPropName(axisProps.fontSize),
                        color: getPropName(axisProps.labelColor),
                        sizeInPixels: true,
                    };
                    var labelFontProperties = visuals.FontProperties.createFromDataViewObject(properties, names, defaults.labelFontProperties);
                    // title defaults are calculated from the labels current properties
                    names.family = getPropName(axisProps.titleFontFamily);
                    names.size = getPropName(axisProps.titleFontSize);
                    names.color = getPropName(axisProps.titleColor);
                    var titleFontProperties = visuals.FontProperties.createFromDataViewObject(properties, names, labelFontProperties);
                    var result = {
                        show: show,
                        alignZeros: alignZeros,
                        showAxisTitle: showAxisTitle,
                        start: start,
                        end: end,
                        position: position,
                        axisType: axisType,
                        axisScale: axisScale,
                        axisStyle: axisStyle,
                        labelDisplayUnits: labelDisplayUnits,
                        labelPrecision: labelPrecision,
                        titleText: titleText,
                        preferredCategoryWidth: preferredCategoryWidth,
                        concatenateLabels: concatenateLabels,
                        labelFontProperties: labelFontProperties,
                        titleFontProperties: titleFontProperties,
                        axisLabel: axisLabel,
                        gridlineShow: gridlineShow,
                        gridlineColor: gridlineColor,
                        gridlineThickness: gridlineThickness,
                        gridlineStyle: gridlineStyle,
                    };
                    return result;
                };
                return AxesData;
            }());
            AxisDataModel.AxesData = AxesData;
            function toColorFill(color) {
                return {
                    solid: { color: color }
                };
            }
            AxisDataModel.toColorFill = toColorFill;
        })(AxisDataModel = visuals.AxisDataModel || (visuals.AxisDataModel = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/* tslint:disable:max-file-line-count */
/* Do not copy this TSLint exclusion onto additional files. */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AxesData = visuals.AxisDataModel.AxesData;
        var FontSize = visuals.Units.FontSize;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = 0.1;
        var COMBOCHART_ALIGN_ZERO_DOMAIN_EXTENT_BUFFER = 0.05;
        var SvgCartesianAxes = /** @class */ (function () {
            function SvgCartesianAxes(axes) {
                this.axes = axes;
                this.axesData = AxesData.createDefault();
            }
            SvgCartesianAxes.prototype.getScrollableRegion = function () {
                return this.axisGraphicsContextScrollable;
            };
            SvgCartesianAxes.prototype.getLabelsRegion = function () {
                return this.labelRegion;
            };
            SvgCartesianAxes.prototype.getLabelBackground = function () {
                return this.labelBackgroundRegion;
            };
            SvgCartesianAxes.prototype.update = function (axesData) {
                this.axesData = axesData;
            };
            SvgCartesianAxes.prototype.init = function (svg) {
                /*
                    The layout of the visual will look like:
                    <svg>
                        <g>
                            <nonscrollable axis/>
                        </g>
                        <svgScrollable>
                            <g>
                                <scrollable axis/>
                            </g>
                        </svgScrollable>
                        <g xbrush/>
                    </svg>
    
                */
                var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
                this.svgScrollable = svg.append('svg')
                    .classed('svgScrollable', true)
                    .style('overflow', 'hidden');
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
                this.labelBackgroundRegion = this.svgScrollable.append('g')
                    .classed(visuals.LabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelRegion = this.svgScrollable.append('g')
                    .classed(visuals.LabelUtils.labelGraphicsContextClass.class, true);
                // NOTE: We infer the axis which should scroll based on whether or not we draw grid lines for the other axis, and
                // only allow one axis to scroll.
                var scrollY = this.axes.isYAxisCategorical;
                if (scrollY) {
                    this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
                    this.xAxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'x axis');
                }
                else {
                    this.y1AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
                    this.xAxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                }
            };
            SvgCartesianAxes.updateTickTooltips = function (axisSelection, axisProps) {
                var tickValues = axisProps.axis.tickValues();
                var tickFormatter = SvgCartesianAxes.getTickFormatter(axisProps.axis);
                axisSelection.selectAll('text').each((function (datum) {
                    var textElement = d3.select(this);
                    // At this point we may have <text> elements from the previous state that have not yet been removed,
                    // so we need to find the tick value with the corresponding data.
                    var tickIndex = tickValues.indexOf(datum);
                    if (tickIndex < 0)
                        return; // This tick will be removed when the axis transition is complete.
                    textElement.append('title').text(tickFormatter(datum));
                }));
            };
            SvgCartesianAxes.getTickFormatter = function (axis) {
                return axis.tickFormat() || SvgCartesianAxes.defaultTickFormat;
            };
            SvgCartesianAxes.defaultTickFormat = function (datum) {
                debug.warn("Using default (unformatted) tickFormat for value \"" + datum + "\"");
                return "" + datum;
            };
            SvgCartesianAxes.prototype.renderXAxis = function (renderProperties) {
                var xAxisGraphicsElement = renderProperties.graphicsElement, axesLayout = renderProperties.layout, fontProperties = renderProperties.fontProperties, axisProps = renderProperties.axisProps, duration = renderProperties.duration, easing = renderProperties.easing, xLabelColor = renderProperties.labelColor, isStacked = renderProperties.isStacked, height = renderProperties.height, gridlineOptions = renderProperties.gridlineOptions;
                var margin = axesLayout.margin;
                var shouldAnimate = !!duration && renderProperties.animate;
                var plotArea = axesLayout.plotArea, isScalar = !visuals.AxisHelper.isOrdinalScale(axisProps.scale);
                if (isScalar) {
                    axisProps.axis.tickSize(-plotArea.height, 0);
                }
                else {
                    axisProps.axis.tickSize(visuals.AxisHelper.DefaultInnerTickSize, 0);
                }
                axisProps.axis.orient("bottom");
                // we only rotate ordinal tick labels
                if (!axisProps.willLabelsFit && !isScalar) {
                    axisProps.axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX);
                }
                if (shouldAnimate) {
                    xAxisGraphicsElement
                        .transition()
                        .duration(duration)
                        .ease(easing)
                        .call(axisProps.axis);
                }
                else {
                    xAxisGraphicsElement
                        .call(axisProps.axis);
                }
                xAxisGraphicsElement
                    .call(SvgCartesianAxes.darkenZeroLine, isScalar)
                    .call(SvgCartesianAxes.setAxisLabelColor, xLabelColor)
                    .call(SvgCartesianAxes.styleGridlines, gridlineOptions);
                // if hierarchical, but not the leaf level
                if (isStacked) {
                    var stackedAxisProps = axisProps;
                    SvgCartesianAxes.removeUnwantedLines(xAxisGraphicsElement, stackedAxisProps);
                    // not the leaf level
                    if (!_.isEmpty(axisProps.xLabelMaxWidths)) {
                        SvgCartesianAxes.centerHierarchyTicks(xAxisGraphicsElement, stackedAxisProps);
                        SvgCartesianAxes.styleHierarchyTicks(xAxisGraphicsElement, stackedAxisProps, gridlineOptions);
                    }
                    else {
                        // Leaf level - remove tiny tick lines added by D3
                        xAxisGraphicsElement.selectAll('g.tick').selectAll('line').remove();
                    }
                }
                var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                var axisTextProperties = visuals.FontProperties.toTextProperties(fontProperties);
                xAxisTextNodes.style(visuals.FontProperties.toSVGStyle(fontProperties));
                if (axisProps.willLabelsWordBreak) {
                    xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, axisProps, height);
                }
                else {
                    xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.rotate, {
                        textTruncator: powerbi.TextMeasurementService.getTailoredTextOrDefault,
                        textProperties: axisTextProperties,
                        needRotate: !axisProps.willLabelsFit && !isScalar,
                        needEllipsis: true,
                        axisProperties: axisProps,
                        margin: margin,
                        scrollbarVisible: axesLayout.isXScrollBarVisible || axesLayout.isYScrollBarVisible || (!axisProps.willLabelsFit && !!isStacked),
                        firstVisibleNode: renderProperties.firstVisibleNode,
                        rotationPadding: visuals.CartesianHelper.TickLabelPadding,
                        height: height
                    });
                }
                // Note: must happen after rotate/workbreaking which modify the SVGTextElement contents.
                SvgCartesianAxes.updateTickTooltips(xAxisGraphicsElement, axisProps);
            };
            SvgCartesianAxes.prototype.renderHierarchicalAxis = function (xAxisGraphicsElement, axesLayout, duration, fontProperties, easing, labelColor, animate, gridlineOptions) {
                var axes = axesLayout.axes;
                var tickLabelMargins = axesLayout.tickLabelMargins;
                // remove single-axis-case elements
                this.axisGraphicsContextScrollable.selectAll('.x.axis > .tick').remove();
                // bind a <g> to each xStack object (using D3)
                var contextLevels = xAxisGraphicsElement.selectAll('.stack').data(axes.xStack);
                contextLevels.enter().append('g').classed({
                    'showLinesOnAxis': gridlineOptions.show,
                    'hideLinesOnAxis': !gridlineOptions.show,
                    'stack': true
                });
                contextLevels.exit().remove();
                var xStackLength = axes.xStack.length;
                // TODO: fix to make this work with Bar charts
                var leafHeight = CartesianAxes.getLeafHeight(tickLabelMargins.xMax, tickLabelMargins.stackHeight, xStackLength);
                // renderLeafHeight is the available space to render the leaf text.
                // Old logic doesn't account for the padding and was using marginLimits.bottom, so use that if the font size is default or smaller to prevent regressions.
                // New logic does account for padding, so we can give it the entire leaf height.
                var defaultOrSmaller = fontProperties.size.px <= visuals.CartesianHelper.DefaultAxisFontSizeInPx;
                var renderLeafHeight = defaultOrSmaller ? axesLayout.marginLimits.bottom : leafHeight;
                var cartesianAxes = this;
                contextLevels.each((function (axisProps, stackLevel) {
                    var transformY = 0;
                    var isLeaf = stackLevel === 0;
                    if (!isLeaf)
                        transformY = leafHeight + (stackLevel - 1) * tickLabelMargins.stackHeight;
                    var childAxisElement = d3.select(this);
                    childAxisElement
                        .attr('transform', visuals.SVGUtil.translate(0, transformY));
                    var nodeDepth = xStackLength - stackLevel; // -1 to get the visual depth, +1 to account for the root, so they offset.
                    var firstVisibleIndex = axisProps.scale.domain()[0];
                    var firstVisibleNode = visuals.HierarchyNodeHelpers.getNodeAtCategoryIndexForDepth(axisProps.rootNode, firstVisibleIndex, nodeDepth);
                    var renderXAxisProperties = {
                        graphicsElement: childAxisElement,
                        axisProps: axisProps,
                        layout: axesLayout,
                        labelColor: labelColor,
                        duration: duration,
                        easing: easing,
                        fontProperties: fontProperties,
                        isStacked: true,
                        firstVisibleNode: firstVisibleNode,
                        height: isLeaf ? renderLeafHeight : tickLabelMargins.stackHeight,
                        animate: animate,
                        gridlineOptions: gridlineOptions,
                    };
                    cartesianAxes.renderXAxis(renderXAxisProperties);
                }));
            };
            SvgCartesianAxes.prototype.removeHierarchicalAxis = function (xAxisGraphicsElement) {
                // Remove any added stacks
                xAxisGraphicsElement.selectAll('.stack').remove();
            };
            SvgCartesianAxes.prototype.renderYAxis = function (axesLayout, duration, fontProperties, easing, yLabelColor, animate, gridlineOptions) {
                var marginLimits = axesLayout.marginLimits;
                var plotArea = axesLayout.plotArea;
                var axes = axesLayout.axes;
                var tickLabelMargins = axesLayout.tickLabelMargins;
                var leftRightMarginLimit = marginLimits.left;
                var showY1OnRight = this.axes.shouldShowY1OnRight();
                var shouldAnimate = !!duration && animate;
                var y1TickPadding = showY1OnRight ? axesLayout.tickPadding.right : axesLayout.tickPadding.left;
                var isScalar = !visuals.AxisHelper.isOrdinalScale(axes.y1.axis.scale());
                if (isScalar) {
                    axes.y1.axis
                        .tickSize(-plotArea.width)
                        .tickPadding(y1TickPadding)
                        .orient(this.axes.getYAxisOrientation().toLowerCase());
                }
                else {
                    axes.y1.axis.tickSize(visuals.AxisHelper.DefaultInnerTickSize);
                }
                var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                if (shouldAnimate) {
                    y1AxisGraphicsElement
                        .transition()
                        .duration(duration)
                        .ease(easing)
                        .call(axes.y1.axis);
                }
                else {
                    y1AxisGraphicsElement
                        .call(axes.y1.axis);
                }
                y1AxisGraphicsElement
                    .style(visuals.FontProperties.toSVGStyle(fontProperties))
                    .call(SvgCartesianAxes.darkenZeroLine, isScalar)
                    .call(SvgCartesianAxes.setAxisLabelColor, yLabelColor)
                    .call(SvgCartesianAxes.styleGridlines, gridlineOptions);
                var y1AxisTextNodes = y1AxisGraphicsElement.selectAll('text');
                var shouldClip = showY1OnRight ? (tickLabelMargins.yRight >= leftRightMarginLimit) : (tickLabelMargins.yLeft >= leftRightMarginLimit);
                if (shouldClip) {
                    y1AxisTextNodes
                        .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                    // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                    leftRightMarginLimit - y1TickPadding, powerbi.TextMeasurementService.svgEllipsis);
                }
                // Note: must happen after rotate/workbreaking which modify the SVGTextElement contents.
                SvgCartesianAxes.updateTickTooltips(y1AxisGraphicsElement, axes.y1);
            };
            SvgCartesianAxes.prototype.removeYAxis = function () {
                this.y1AxisGraphicsContext.selectAll('*').remove();
            };
            SvgCartesianAxes.prototype.renderY2Axis = function (axesLayout, duration, fontProperties, easing, y2LabelColor, animate, gridlineOptions) {
                var marginLimits = axesLayout.marginLimits;
                var axes = axesLayout.axes;
                var tickLabelMargins = axesLayout.tickLabelMargins;
                var leftRightMarginLimit = marginLimits.left;
                var showY1OnRight = this.axes.shouldShowY1OnRight();
                var y2TickPadding = showY1OnRight ? axesLayout.tickPadding.left : axesLayout.tickPadding.right;
                var isScalar = !visuals.AxisHelper.isOrdinalScale(axes.y2.axis.scale());
                if (isScalar) {
                    axes.y2.axis
                        .tickSize(SvgCartesianAxes.Y2TickSize)
                        .tickPadding(y2TickPadding)
                        .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                }
                else {
                    axes.y2.axis.tickSize(visuals.AxisHelper.DefaultInnerTickSize);
                }
                var y2AxisGraphicsElement = this.y2AxisGraphicsContext;
                var shouldAnimate = !!duration && animate;
                if (shouldAnimate) {
                    y2AxisGraphicsElement
                        .transition()
                        .duration(duration)
                        .ease(easing)
                        .call(axes.y2.axis);
                }
                else {
                    y2AxisGraphicsElement
                        .call(axes.y2.axis);
                }
                y2AxisGraphicsElement
                    .style(visuals.FontProperties.toSVGStyle(fontProperties))
                    .call(SvgCartesianAxes.darkenZeroLine, !visuals.AxisHelper.isOrdinalScale(axes.y2.axis.scale()))
                    .call(SvgCartesianAxes.setAxisLabelColor, y2LabelColor)
                    .call(SvgCartesianAxes.styleGridlines, gridlineOptions);
                var shouldClip = showY1OnRight ? (tickLabelMargins.yLeft >= leftRightMarginLimit) : (tickLabelMargins.yRight >= leftRightMarginLimit);
                if (shouldClip) {
                    y2AxisGraphicsElement.selectAll('text')
                        .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                    // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                    leftRightMarginLimit - y2TickPadding, powerbi.TextMeasurementService.svgEllipsis);
                }
                // Note: must happen after rotate/workbreaking which modify the SVGTextElement contents.
                SvgCartesianAxes.updateTickTooltips(y2AxisGraphicsElement, axes.y2);
            };
            SvgCartesianAxes.prototype.removeY2Axis = function () {
                this.y2AxisGraphicsContext.selectAll('*').remove();
            };
            SvgCartesianAxes.prototype.renderAxes = function (arg1, duration, axisFontSize, easing) {
                if (easing === void 0) { easing = 'cubic-in-out'; }
                var axesLayout;
                var options = arg1;
                var animateCategoryAxis = false;
                var animateValueAxis = false;
                var axesFontProperties;
                if (options.axesLayout) {
                    axesLayout = options.axesLayout;
                    duration = options.duration;
                    axesFontProperties = options.axesFontProperties;
                    animateCategoryAxis = options.animateCategoryAxis;
                    animateValueAxis = options.animateValueAxis;
                    easing = options.easing || easing;
                }
                else {
                    debug.assertFail('Using renderAxes without the property bag is deprecated');
                    axesLayout = arg1;
                    if (axisFontSize) {
                        axesFontProperties = {
                            x: {
                                tickLabels: { family: visuals.CartesianHelper.AxisFontFamily, size: FontSize.createFromPx(axisFontSize.x) },
                                title: { family: visuals.CartesianHelper.AxisFontFamily, size: FontSize.createFromPx(axisFontSize.xTitle) }
                            },
                            y: {
                                tickLabels: { family: visuals.CartesianHelper.AxisFontFamily, size: FontSize.createFromPx(axisFontSize.y) },
                                title: { family: visuals.CartesianHelper.AxisFontFamily, size: FontSize.createFromPx(axisFontSize.yTitle) }
                            },
                            y2: {
                                tickLabels: { family: visuals.CartesianHelper.AxisFontFamily, size: FontSize.createFromPx(axisFontSize.y2) },
                                title: { family: visuals.CartesianHelper.AxisFontFamily, size: FontSize.createFromPx(axisFontSize.y2Title) }
                            },
                        };
                    }
                }
                var viewport = axesLayout.viewport;
                var margin = axesLayout.margin;
                var axes = axesLayout.axes;
                var xLabelColor;
                var yLabelColor;
                var y2LabelColor;
                var axisLabels = axesLayout.axisLabels;
                var hideXAxisTitle = axisLabels.x == null;
                var xAxisData = this.axesData && this.axesData.x;
                var yAxisData = this.axesData && this.axesData.y;
                var y2AxisData = this.axesData && this.axesData.y2;
                if (axesLayout.shouldRenderAxis.x) {
                    xLabelColor = visuals.AxisDataModel.toColorFill(xAxisData.labelFontProperties.color);
                    var gridlineAllowed = !visuals.AxisHelper.isOrdinalScale(axes.x.scale) || !_.isEmpty(axes.xStack);
                    var gridlineOptions = {
                        show: gridlineAllowed ? xAxisData.gridlineShow : false,
                        color: visuals.AxisDataModel.toColorFill(xAxisData.gridlineColor),
                        thickness: xAxisData.gridlineThickness,
                        style: xAxisData.gridlineStyle,
                    };
                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
                    if (!_.isEmpty(axes.xStack)) {
                        this.renderHierarchicalAxis(xAxisGraphicsElement, axesLayout, duration, axesFontProperties.x.tickLabels, easing, xLabelColor, animateCategoryAxis, gridlineOptions);
                    }
                    else {
                        this.removeHierarchicalAxis(xAxisGraphicsElement);
                        var defaultOrSmaller = axesFontProperties.x.tickLabels.size.px <= visuals.CartesianHelper.DefaultAxisFontSizeInPx;
                        // New logic (!defaultOrSmaller) accounts for the padding and extra space needed by angled text, so we can use margin.bottom as the max.
                        // Old logic did not account for either so long, angled labels may be cutoff at the bottom if we use margin.bottom.
                        var height = defaultOrSmaller ? axesLayout.marginLimits.bottom : margin.bottom;
                        // If we're not default or smaller, the height is margin.bottom. margin.bottom includes the space used by the title, so we have to subtract it
                        if (!defaultOrSmaller && !hideXAxisTitle) {
                            // If we're displaying the title, subtract that space from the height
                            var axisTitleHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(visuals.FontProperties.toTextProperties(axesFontProperties.x.tickLabels));
                            var xTitleReservedSpace = axisTitleHeight + CartesianAxes.XAxisLabelPadding;
                            height -= xTitleReservedSpace;
                        }
                        // Animations for the axes are disabled by default. This is because they can provide incorrect visual cues.
                        // Example: (Category Axis) A column labeled "Seattle" could animate to "Bellevue" after applying a filter.
                        // Depending on the chart, there may be no visual cue that the label changed.
                        // Example: (Value Axis) Changes in label size could shift the axis position. We don't animate the category axis, 
                        // so the items on the axis snap to the new position while the value axis animates, creating a temporary gap and an unpolished looking animation.
                        var isCategoryAxis = axes.x.isCategoryAxis;
                        var animate = (animateCategoryAxis && isCategoryAxis) || (animateValueAxis && !isCategoryAxis);
                        var renderXAxisProperties = {
                            graphicsElement: xAxisGraphicsElement,
                            axisProps: axes.x,
                            layout: axesLayout,
                            labelColor: xLabelColor,
                            duration: duration,
                            easing: easing,
                            fontProperties: axesFontProperties.x.tickLabels,
                            isStacked: false,
                            height: height,
                            animate: animate,
                            gridlineOptions: gridlineOptions,
                        };
                        this.renderXAxis(renderXAxisProperties);
                    }
                }
                else {
                    this.xAxisGraphicsContext.selectAll('*').remove();
                }
                if (axesLayout.shouldRenderAxis.y) {
                    yLabelColor = visuals.AxisDataModel.toColorFill(yAxisData.labelFontProperties.color);
                    var gridlineAllowed = !visuals.AxisHelper.isOrdinalScale(axes.y1.scale);
                    var gridlineOptions = {
                        show: gridlineAllowed ? yAxisData.gridlineShow : false,
                        color: visuals.AxisDataModel.toColorFill(yAxisData.gridlineColor),
                        thickness: yAxisData.gridlineThickness,
                        style: yAxisData.gridlineStyle,
                    };
                    // Animations for the y1-axis are disabled by default. See the x-axis for explanations
                    var y1IsCategoryAxis = axes.y1.isCategoryAxis;
                    var animateY1 = (animateCategoryAxis && y1IsCategoryAxis) || (animateValueAxis && !y1IsCategoryAxis);
                    this.renderYAxis(axesLayout, duration, axesFontProperties.y.tickLabels, easing, yLabelColor, animateY1, gridlineOptions);
                    if (axes.y2 && y2AxisData.show !== false) {
                        y2LabelColor = visuals.AxisDataModel.toColorFill(y2AxisData.labelFontProperties.color);
                        // Animations for the y2-axis are disabled by default. See the x-axis for explanations
                        var y2IsCategoryAxis = axes.y2.isCategoryAxis;
                        var animateY2 = (animateCategoryAxis && y2IsCategoryAxis) || (animateValueAxis && !y2IsCategoryAxis);
                        this.renderY2Axis(axesLayout, duration, axesFontProperties.y2.tickLabels, easing, y2LabelColor, animateY2, gridlineOptions);
                    }
                    else {
                        this.removeY2Axis();
                    }
                }
                else {
                    this.removeYAxis();
                    this.removeY2Axis();
                }
                // Axis Titles
                var chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                if (chartHasAxisLabels) {
                    var hideYAxisTitle = axisLabels.y == null;
                    var hideY2AxisTitle = axisLabels.y2 == null;
                    var xTitleColor = void 0;
                    var yTitleColor = void 0;
                    var y2TitleColor = void 0;
                    xTitleColor = visuals.AxisDataModel.toColorFill(xAxisData.titleFontProperties.color);
                    yTitleColor = visuals.AxisDataModel.toColorFill(yAxisData.titleFontProperties.color);
                    y2TitleColor = visuals.AxisDataModel.toColorFill(y2AxisData.titleFontProperties.color);
                    var renderAxisOptions = {
                        axisLabels: axisLabels,
                        viewport: viewport,
                        margin: margin,
                        hideXAxisTitle: hideXAxisTitle,
                        hideYAxisTitle: hideYAxisTitle,
                        hideY2AxisTitle: hideY2AxisTitle,
                        xLabelColor: xTitleColor,
                        yLabelColor: yTitleColor,
                        y2LabelColor: y2TitleColor,
                        axesFontProperties: axesFontProperties
                    };
                    this.renderAxesTitles(renderAxisOptions);
                }
                else {
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                }
                this.translateAxes(axesLayout);
            };
            SvgCartesianAxes.prototype.renderAxesTitles = function (options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.viewport, 'options.viewport');
                debug.assertValue(options.axisLabels, 'options.axisLabels');
                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                var margin = options.margin;
                var plotAreaWidth = options.viewport.width - (margin.left + margin.right);
                // Gets the distance to the viewport buttom relative to the axisGraphicsContext
                // Usually that's viewport.height, but the axisGraphicsContext is already translated down by margin.top,
                // so we need to subtract it to get the relative distance.
                var viewportBottom = options.viewport.height - margin.top;
                var showOnRight = this.axes.shouldShowY1OnRight();
                var axesFontProperties = options.axesFontProperties;
                var axisLabels = options.axisLabels;
                if (!options.hideXAxisTitle) {
                    var titleFontProperties = axesFontProperties.x.title;
                    var titleText = axisLabels.x;
                    var axisTextProperties = visuals.FontProperties.toTextProperties(titleFontProperties, titleText);
                    var baselineDelta_1 = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(axisTextProperties);
                    var xAxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .style(visuals.FontProperties.toSVGStyle(titleFontProperties))
                        .text(titleText)
                        .call((function (text) {
                        text.each((function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "xAxisLabel",
                                "transform": visuals.SVGUtil.translate(plotAreaWidth / 2, viewportBottom - CartesianAxes.XAxisLabelPadding - baselineDelta_1)
                            });
                        }));
                    }));
                    xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, plotAreaWidth, powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.x]);
                }
                if (!options.hideYAxisTitle) {
                    var titleFontProperties = axesFontProperties.y.title;
                    var titleText = axisLabels.y;
                    var axisTextProperties = visuals.FontProperties.toTextProperties(titleFontProperties, titleText);
                    var textHeight_1 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties);
                    var yAxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .style(visuals.FontProperties.toSVGStyle(titleFontProperties))
                        .text(titleText)
                        .call((function (text) {
                        text.each((function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? plotAreaWidth + margin.right - textHeight_1 - CartesianAxes.YAxisLabelPadding : -margin.left + CartesianAxes.YAxisLabelPadding,
                                "x": -((viewportBottom - margin.bottom) / 2),
                                "dy": "1em",
                            });
                        }));
                    }));
                    yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, viewportBottom - margin.bottom, powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y]);
                }
                if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                    var titleFontProperties = axesFontProperties.y2.title;
                    var titleText = axisLabels.y2;
                    var axisTextProperties = visuals.FontProperties.toTextProperties(titleFontProperties, titleText);
                    var textHeight_2 = powerbi.TextMeasurementService.estimateSvgTextHeight(axisTextProperties);
                    var y2AxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .style(visuals.FontProperties.toSVGStyle(titleFontProperties))
                        .text(titleText)
                        .call((function (text) {
                        text.each((function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? -margin.left + CartesianAxes.YAxisLabelPadding : plotAreaWidth + margin.right - textHeight_2 - CartesianAxes.YAxisLabelPadding,
                                "x": -((viewportBottom - margin.bottom) / 2),
                                "dy": "1em",
                            });
                        }));
                    }));
                    y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, viewportBottom - margin.bottom, powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y2]);
                }
            };
            SvgCartesianAxes.prototype.translateAxes = function (axesLayout) {
                var viewport = axesLayout.viewport;
                var margin = axesLayout.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var showY1OnRight = this.axes.shouldShowY1OnRight();
                this.xAxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(0, height));
                this.y1AxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));
                this.y2AxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));
                this.svgScrollable.attr({
                    'x': 0,
                    'width': viewport.width,
                    'height': viewport.height
                });
                this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.labelRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                if (axesLayout.isXScrollBarVisible) {
                    this.svgScrollable.attr({
                        'x': margin.left
                    });
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.labelRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.svgScrollable.attr('width', width);
                }
                else if (axesLayout.isYScrollBarVisible) {
                    this.svgScrollable.attr('height', height + margin.top);
                }
            };
            /**
             * Within the context of the given selection (g), find the offset of
             * the zero tick using the d3 attached datum of g.tick elements.
             * 'Classed' is undefined for transition selections
             */
            SvgCartesianAxes.darkenZeroLine = function (g, canDarken) {
                // remove zero-line class from all first, filtering can cause lines that are no longer zero to still be dark (since the key is index based)
                g.selectAll('g.tick line').classed('zero-line', false);
                if (canDarken) {
                    var zeroTick = g.selectAll('g.tick').filter((function (data) { return data === 0; })).node();
                    if (zeroTick) {
                        d3.select(zeroTick).select('line').classed('zero-line', true);
                    }
                }
            };
            /**
             * Within the context of the given selection (g),
             * style the line color, thickness, and dashstyle
             */
            SvgCartesianAxes.styleGridlines = function (g, gridlineOptions) {
                g.classed({
                    'showLinesOnAxis': gridlineOptions.show,
                    'hideLinesOnAxis': !gridlineOptions.show
                });
                g.selectAll('g.tick line').style({
                    'stroke': gridlineOptions.color.solid.color,
                    'stroke-width': gridlineOptions.thickness,
                    'stroke-dasharray': visuals.LineStyle.getStrokeDashArrayFromLineStyle(gridlineOptions.style)
                });
            };
            SvgCartesianAxes.setAxisLabelColor = function (g, fill) {
                g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
            };
            SvgCartesianAxes.removeUnwantedLines = function (g, axisProps) {
                // remove the small tick lines that D3 created
                // TODO: implement our own axis functions so we don't have to post-select-modify axes!
                g.selectAll('g.tick')
                    .filter((function (d) { return axisProps.adjustedValues[d] === CartesianAxes.hierarchyPlaceholder; }))
                    .selectAll('line').remove();
            };
            SvgCartesianAxes.centerHierarchyTicks = function (g, axisProps) {
                g.selectAll('g.tick')
                    .filter((function (d) { return axisProps.adjustedValues[d] !== CartesianAxes.hierarchyPlaceholder; }))
                    .each((function (datum) {
                    var tick = d3.select(this);
                    var currentTransform = tick.attr('transform');
                    var parsedTranslate = visuals.SVGUtil.parseTranslateTransform(currentTransform);
                    if (parsedTranslate && +parsedTranslate.x > 0) {
                        // determine adjustment needed to center-up
                        var xAdjustment = +parsedTranslate.x + axisProps.xLabelMaxWidths[datum] / 2 - axisProps.categoryThickness / 2 + visuals.CartesianHelper.TickLabelPadding;
                        tick.attr('transform', visuals.SVGUtil.translate(xAdjustment, +parsedTranslate.y));
                    }
                }));
            };
            SvgCartesianAxes.styleHierarchyTicks = function (g, axisProps, gridlineOptions) {
                debug.assert(axisProps != null && axisProps.axis != null, 'axis properies are required');
                debug.assert(!_.isEmpty(axisProps.axis.tickValues()) && axisProps.axis.tickFormat() != null, 'tickValues and tickFormat are required');
                // bind to the lineStyleInfo array that was created earlier to get line attributes
                var lines = g.selectAll('g.tick')
                    .filter((function (d) { return axisProps.adjustedValues[d] !== CartesianAxes.hierarchyPlaceholder; }))
                    .selectAll('line').data((function (d) { return axisProps.lineStyleInfo[d]; }));
                lines.enter()
                    .append('line');
                lines
                    .attr('x1', (function (line) { return line.x1; }))
                    .attr('y1', (function (line) { return line.y1; }))
                    .attr('x2', (function (line) { return line.x2; }))
                    .attr('y2', (function (line) { return line.y2; }))
                    .style({
                    'stroke': gridlineOptions.color.solid.color,
                    'stroke-width': gridlineOptions.thickness,
                    'stroke-dasharray': visuals.LineStyle.getStrokeDashArrayFromLineStyle(gridlineOptions.style)
                });
                lines.exit()
                    .remove();
            };
            // These match D3's internal axis padding values
            SvgCartesianAxes.AxisPadding = {
                left: 10,
                right: 10,
                top: 0,
                bottom: 13,
            };
            SvgCartesianAxes.AxisGraphicsContext = createClassAndSelector('axisGraphicsContext');
            SvgCartesianAxes.TickPaddingRotatedX = 5;
            SvgCartesianAxes.Y2TickSize = -6;
            return SvgCartesianAxes;
        }());
        visuals.SvgCartesianAxes = SvgCartesianAxes;
        var CartesianAxes = /** @class */ (function () {
            function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
                this.scrollbarWidth = scrollbarWidth;
                this.isScrollable = isScrollable;
                this.maxMarginFactor = CartesianAxes.MaxMarginFactor;
                this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
                this.axesData = AxesData.createDefault();
            }
            CartesianAxes.prototype.init = function (options) {
                this.isYAxisCategorical = options.isYAxisCategorical;
                if (options.maxMarginFactor != null)
                    this.maxMarginFactor = options.maxMarginFactor;
            };
            CartesianAxes.prototype.shouldShowY1OnRight = function () {
                return this.axesData.y.position === visuals.yAxisPosition.right;
            };
            CartesianAxes.prototype.hasCategoryAxis = function () {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                return this.isYAxisCategorical
                    ? axes.y1 && axes.y1.axis != null
                    : axes.x && axes.x.axis != null;
            };
            CartesianAxes.prototype.isCategoryAxisDateTime = function () {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                var categoryAxis = this.isYAxisCategorical ? axes.y1 : axes.x;
                return categoryAxis.axisType.dateTime;
            };
            CartesianAxes.getLeafHeight = function (availableSpace, stackHeight, numStacks) {
                debug.assertValue(availableSpace, 'availableSpace');
                debug.assertValue(stackHeight, 'stackHeight');
                debug.assertValue(numStacks, 'numStacks');
                return availableSpace - (stackHeight * (numStacks - 1)) + visuals.AxisHelper.stackedAxisPadding + 1;
            };
            CartesianAxes.prototype.hasY2Axis = function () {
                return this.layout && this.layout.axes.y2 != null;
            };
            CartesianAxes.prototype.getYAxisOrientation = function () {
                return this.axesData.y.position;
            };
            CartesianAxes.prototype.update = function (categories, axesData, categoricalAxisRenderMode, scrollbarWidth) {
                this.categories = categories;
                this.axesData = axesData;
                this.updateScrollbarWidthIfNeeded(scrollbarWidth);
                this.isHierarchicalCategoryAxis = categoricalAxisRenderMode === 3 /* Hierarchical */;
            };
            CartesianAxes.prototype.updateResize = function (axesData, scrollbarWidth) {
                this.axesData = axesData;
                this.updateScrollbarWidthIfNeeded(scrollbarWidth);
            };
            CartesianAxes.prototype.addWarnings = function (warningBuilder) {
                var axes = this.layout && this.layout.axes;
                if (axes && (axes.x && axes.x.hasDisallowedZeroInDomain
                    || axes.y1 && axes.y1.hasDisallowedZeroInDomain
                    || axes.y2 && axes.y2.hasDisallowedZeroInDomain)) {
                    warningBuilder.add(new visuals.ZeroValueWarning());
                }
                if (this.alignZerosWithCustomDomainWarning) {
                    var alignZeroObjectWarning = {
                        selector: null,
                        warnings: [new visuals.AlignZerosWithCustomDomainWarning()],
                    };
                    warningBuilder.addForVisualObject("valueAxis", alignZeroObjectWarning);
                }
            };
            CartesianAxes.prototype.getScrollbarWidth = function () {
                return this.scrollbarWidth;
            };
            CartesianAxes.prototype.updateScrollbarWidthIfNeeded = function (scrollbarWidth) {
                debug.assertAnyValue(scrollbarWidth, "scrollbarWidth can be null");
                if (scrollbarWidth != null) {
                    this.scrollbarWidth = scrollbarWidth;
                }
            };
            /**
             * Computes the Cartesian Chart axes from the set of layers.
             * NOTE: this gets called multiple times per render, be efficient in here
             */
            CartesianAxes.prototype.calculateAxes = function (layers, viewport, margin, playAxisControlLayout, axesFontProperties, scrollbarVisible, existingAxisProperties, showAxisTitles, ensureXDomain, ensureYDomain, tickLabelMargins, shouldRenderAxis) {
                debug.assertValue(layers, 'layers');
                var outerPaddingRatio = CartesianAxes.shouldRenderAnyAxis(shouldRenderAxis) ? visuals.CartesianHelper.DefaultOuterPaddingRatio : 0;
                var innerPaddingRatio = layers[0].getInnerPaddingRatio ? layers[0].getInnerPaddingRatio() : visuals.DefaultInnerPaddingRatio;
                var result = {
                    x: null,
                    y1: null,
                };
                var forceMerge = this.axesData.isValueAxisSet && this.axesData.y2.show === false;
                var preventNiceBoth = !CartesianAxes.shouldRenderAnyAxis(shouldRenderAxis);
                var layer1visualOptions = {
                    viewport: viewport,
                    margin: margin,
                    forcedXDomain: visuals.AxisHelper.applyCustomizedDomain([this.axesData.categoryAxis.start, this.axesData.categoryAxis.end], null),
                    forcedYDomain: this.axesData.isValueAxisSet ? visuals.AxisHelper.applyCustomizedDomain([this.axesData.valueAxis.start, this.axesData.valueAxis.end], null) : undefined,
                    forceMerge: forceMerge,
                    trimOrdinalDataOnOverflow: this.trimOrdinalDataOnOverflow,
                    outerPaddingRatio: outerPaddingRatio,
                    innerPaddingRatio: innerPaddingRatio,
                    categoryAxisScaleType: this.axesData.categoryAxis.axisScale,
                    valueAxisScaleType: this.axesData.valueAxis.axisScale,
                    categoryAxisDisplayUnits: this.axesData.categoryAxis.labelDisplayUnits,
                    valueAxisDisplayUnits: this.axesData.valueAxis.labelDisplayUnits,
                    categoryAxisPrecision: this.axesData.categoryAxis.labelPrecision,
                    valueAxisPrecision: this.axesData.valueAxis.labelPrecision,
                    playAxisControlLayout: playAxisControlLayout,
                    ensureXDomain: ensureXDomain,
                    ensureYDomain: ensureYDomain,
                };
                layer1visualOptions.preventNiceX = preventNiceBoth || !_.isEmpty(layer1visualOptions.forcedXDomain);
                var showY2 = this.axesData.isValueAxisSet && this.axesData.y2.show; //preserve tri-state (true/false/undefined)
                var shouldAlignZeros = this.axesData.isValueAxisSet && this.axesData.y.alignZeros;
                var skipMerge = !forceMerge && (showY2 === true || (showY2 === undefined && (shouldAlignZeros || layer1visualOptions.forcedYDomain)));
                var yAxisWillMerge = false;
                if (hasMultipleYAxes(layers) && !skipMerge) {
                    var mergeResult = tryMergeYDomains(layers, layer1visualOptions);
                    yAxisWillMerge = mergeResult.merged;
                    if (yAxisWillMerge) {
                        layer1visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([this.axesData.valueAxis.start, this.axesData.valueAxis.end], mergeResult.domain);
                    }
                    else {
                        layer1visualOptions.forcedTickCount = mergeResult.tickCount;
                    }
                }
                var y2AxisIsVisible = layers.length === 2 && !yAxisWillMerge && showY2 !== false;
                shouldAlignZeros = shouldAlignZeros && y2AxisIsVisible;
                var layer2visualOptions = powerbi.Prototype.inherit(layer1visualOptions);
                if (y2AxisIsVisible) {
                    layer2visualOptions.valueAxisScaleType = this.axesData.y2.axisScale;
                    layer2visualOptions.valueAxisDisplayUnits = this.axesData.y2.labelDisplayUnits;
                    layer2visualOptions.valueAxisPrecision = this.axesData.y2.labelPrecision;
                    if (shouldAlignZeros) {
                        // Set forcedYDomains such that y1 and y2 will match at zero
                        // to align zeros, we must force "include zero" for both layers
                        var layer1domain = layers[0].getValueDomain(layer1visualOptions, true);
                        layer2visualOptions.forcedYDomain = this.axesData.isValueAxisSet && visuals.AxisHelper.applyCustomizedDomain([this.axesData.y2.start, this.axesData.y2.end], null);
                        var layer2domain = layers[1].getValueDomain(layer2visualOptions, true);
                        var alignedDomains = alignZeros(layer1domain, layer2domain, COMBOCHART_ALIGN_ZERO_DOMAIN_EXTENT_BUFFER); //leave 5% extra room to avoid cropping thick lines
                        result.alignZerosWithCustomDomainWarning = this.addStartEndWarnings([layer1visualOptions.forcedYDomain, layer2visualOptions.forcedYDomain], alignedDomains);
                        // don't align zeros if the user specified start/end - custom domain start/end has higher precendence.
                        if (!result.alignZerosWithCustomDomainWarning) {
                            layer1visualOptions.forcedYDomain = alignedDomains[0];
                            layer2visualOptions.forcedYDomain = alignedDomains[1];
                        }
                    }
                    else if (!yAxisWillMerge) {
                        layer2visualOptions.forcedYDomain = this.axesData.isValueAxisSet && visuals.AxisHelper.applyCustomizedDomain([this.axesData.y2.start, this.axesData.y2.end], null);
                    }
                }
                // set preventNiceY only after Y domain logic
                layer1visualOptions.preventNiceY = preventNiceBoth || !_.isEmpty(layer1visualOptions.forcedYDomain);
                layer2visualOptions.preventNiceY = preventNiceBoth || !_.isEmpty(layer2visualOptions.forcedYDomain);
                var visualOptionsArr = [layer1visualOptions, layer2visualOptions];
                for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                    var currentlayer = layers[layerNumber];
                    var currentVisualOptions = visualOptionsArr[layerNumber];
                    var axes = currentlayer.calculateAxesProperties(currentVisualOptions);
                    if (layerNumber === 0) {
                        result.x = axes[0];
                        result.y1 = axes[1];
                    }
                    else if (axes && !result.y2) {
                        if (result.x.usingDefaultDomain || _.isEmpty(result.x.dataDomain)) {
                            // no categories returned for the first layer, use second layer x-axis properties
                            result.x = axes[0];
                            // and 2nd value axis to be the primary
                            result.y1 = axes[1];
                        }
                        else {
                            // make sure all layers use the same x-axis/scale for drawing
                            currentlayer.overrideXScale(result.x);
                            if (!yAxisWillMerge && !axes[1].usingDefaultDomain && !_.isEmpty(axes[1].values))
                                result.y2 = axes[1];
                        }
                    }
                    var axisTextProperties = visuals.FontProperties.toTextProperties(axesFontProperties.x.tickLabels);
                    if (existingAxisProperties && existingAxisProperties.x) {
                        result.x.willLabelsFit = existingAxisProperties.x.willLabelsFit;
                        result.x.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak;
                    }
                    else {
                        var width = viewport.width - (margin.left + margin.right);
                        result.x.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(result.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, axisTextProperties);
                        // If labels do not fit and we are not scrolling, try word breaking
                        result.x.willLabelsWordBreak = (!result.x.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(result.x, margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, axisTextProperties);
                    }
                    if (this.isHierarchicalCategoryAxis) {
                        // TODO Move this to a better place, like conversion
                        var hierarchyAxisProperties = result.x;
                        hierarchyAxisProperties.isHierarchical = true;
                        hierarchyAxisProperties.rootNode = visuals.HierarchyNodeHelpers.Builder.build(this.categories);
                        hierarchyAxisProperties.numLevels = this.categories.length;
                        // If multiple categories (e.g. drill hierarchy), add/update .xStack on axes.x
                        // only if we have tickLabelMargins (which we don't the 1st time this is called)
                        // TODO Migrate data in xStack to HierarchyNodes 
                        if (tickLabelMargins) {
                            result.xStack = CartesianAxes.createStackedAxis(this.categories, result.x, tickLabelMargins.stackHeight, tickLabelMargins.xMax);
                        }
                    }
                }
                this.overrideAxisTitles(result);
                // Adjust for axis titles
                if (!showAxisTitles.x && result.x) {
                    result.x.axisLabel = null;
                }
                if (!showAxisTitles.y && result.y1) {
                    result.y1.axisLabel = null;
                }
                if (!showAxisTitles.y2 && result.y2) {
                    result.y2.axisLabel = null;
                }
                this.addUnitTypeToAxisLabels(result);
                return result;
            };
            /**
             * (public for unit tests)
             * Builds the hierarchy stack to be used for the category axis.
             *   - Prototype.inherit the axisProperties,
             *   - Create a new D3 Axis,
             *   - Maintain a reference to the same D3 Scale for scrolling to work seemlessly for all stacked axes.
             */
            CartesianAxes.createStackedAxis = function (categories, axis, stackHeight, bottomMargin) {
                debug.assertValue(axis, 'axis');
                if (_.isEmpty(categories)) {
                    return;
                }
                var stackLength = categories.length;
                var leafHeight = CartesianAxes.getLeafHeight(bottomMargin, stackHeight, stackLength);
                var stack = [];
                // Get the actual category thickness. stack.categoryThickness is not correct since the outer padding ratio
                // can change, changing the category thickness.
                var singleCategoryWidth = visuals.AxisHelper.getCategoryThickness(axis.scale);
                var levelIdentitySubsetExprs = [];
                var _loop_7 = function (columnIndex) {
                    var isLeafLevel = (columnIndex === stackLength - 1);
                    var levelIndex = stackLength - columnIndex - 1;
                    var levelCategory = categories[columnIndex];
                    if (!isLeafLevel) {
                        // Add the current level so we'll get the identity that references the levels up to and including this one, but not the ones afterwards
                        // We don't need to do this for the leaf level since we use the entire identity
                        // This property is not present before SU09. We shouldn't be hitting this code if it's not set.
                        debug.assertValue(levelCategory.source.identityExprs, 'levelCategory.source.identityExprs');
                        levelIdentitySubsetExprs.push.apply(levelIdentitySubsetExprs, levelCategory.source.identityExprs);
                    }
                    // a left-aligned array with blanks for spaces also owned by the previous label,
                    // e.g. ["Fruits","","","Veggies","","","",""] where Fruits spans three leaf nodes and Veggies spans 5 leaves
                    var newValues = [];
                    var newValuesMaxWidth = []; // passed to AxisHelper.rotate for this case (non-uniform categoryThickness) as truncation/ellipsis occurs in .rotate also
                    var lineStyleInfoArray = []; // array used for d3 biding when rendering tick-styles (outlines)
                    var categorySpanCount = 0;
                    var lastValueLevelIdentity = void 0;
                    var levelCategoryValuesLength = levelCategory.values.length;
                    for (var valueIndex = 0; valueIndex < levelCategoryValuesLength; valueIndex++) {
                        // Use the whole identity if it's a leaf level, otherwise get an identity that only corresponds to this level and above in the hierarchy.
                        var valueLevelIdentity = isLeafLevel ? levelCategory.identity[valueIndex]
                            : CartesianAxes.getSpecificIdentityFromCompositeIdentity(levelCategory, valueIndex, levelIdentitySubsetExprs);
                        var levelValue = levelCategory.values[valueIndex];
                        var formattedLevelValue = visuals.converterHelper.formatFromMetadataColumn(levelValue, levelCategory.source, visuals.columnChartProps.general.formatString);
                        if (!isLeafLevel && lastValueLevelIdentity && powerbi.DataViewScopeIdentity.equals(lastValueLevelIdentity, valueLevelIdentity)) {
                            newValues[valueIndex] = CartesianAxes.hierarchyPlaceholder;
                            categorySpanCount++;
                        }
                        else {
                            // leaf level should not populate this - it has uniform category thickness
                            if (categorySpanCount > 0 && !isLeafLevel) {
                                var adjustedIndex = valueIndex - categorySpanCount;
                                newValuesMaxWidth[adjustedIndex] = CartesianAxes.getMaxCategoryWidth(categorySpanCount, singleCategoryWidth);
                                lineStyleInfoArray[adjustedIndex] = CartesianAxes.getHierarchyLineStyleInfo({
                                    levelIndex: levelIndex,
                                    stackHeight: stackHeight,
                                    leafHeight: leafHeight,
                                    categorySpanCount: categorySpanCount,
                                    categoryWidth: singleCategoryWidth
                                });
                            }
                            categorySpanCount = 1;
                            newValues[valueIndex] = formattedLevelValue;
                        }
                        lastValueLevelIdentity = valueLevelIdentity;
                    }
                    if (categorySpanCount > 0 && !isLeafLevel) {
                        var adjustedIndex = levelCategoryValuesLength - categorySpanCount;
                        newValuesMaxWidth[adjustedIndex] = CartesianAxes.getMaxCategoryWidth(categorySpanCount, singleCategoryWidth);
                        lineStyleInfoArray[adjustedIndex] = CartesianAxes.getHierarchyLineStyleInfo({
                            levelIndex: levelIndex,
                            stackHeight: stackHeight,
                            leafHeight: leafHeight,
                            categorySpanCount: categorySpanCount,
                            categoryWidth: singleCategoryWidth
                        });
                    }
                    var newAxisProps = powerbi.Prototype.inherit(axis);
                    newAxisProps.isStacked = true;
                    newAxisProps.adjustedValues = newValues;
                    newAxisProps.axis = visuals.AxisHelper.createStackedAxis({
                        axis: newAxisProps.axis,
                        scale: newAxisProps.scale,
                        tickFormat: function (valueIndex) { return newValues[valueIndex] !== CartesianAxes.hierarchyPlaceholder ? newValues[valueIndex] : null; }
                    });
                    // Override the category thickness with the actual value.
                    // TODO #8812527 Cartesian Chart - Fix categoryThickness usage
                    newAxisProps.categoryThickness = singleCategoryWidth;
                    newAxisProps.levelIndex = levelIndex;
                    newAxisProps.lineStyleInfo = lineStyleInfoArray;
                    newAxisProps.values = newValues;
                    newAxisProps.xLabelMaxWidths = newValuesMaxWidth;
                    if (isLeafLevel) {
                        newAxisProps.levelSize = leafHeight;
                    }
                    else {
                        newAxisProps.levelSize = stackHeight;
                        // don't rotate or word break anything except the leaf level
                        newAxisProps.willLabelsFit = true;
                        newAxisProps.willLabelsWordBreak = false;
                    }
                    // dataView order is bottom-up, we render top-down, so unshift.
                    stack.unshift(newAxisProps);
                };
                // dataView order is bottom-up (grandparents first), we render top-down
                for (var columnIndex = 0; columnIndex < stackLength; columnIndex++) {
                    _loop_7(columnIndex);
                }
                return stack;
            };
            CartesianAxes.shouldRenderAnyAxis = function (shouldRenderAxis) {
                return shouldRenderAxis &&
                    (shouldRenderAxis.x || shouldRenderAxis.y /* y2 axis won't be rendered if no y axis exists */);
            };
            /*
             * Deconstructs the composite key to get an identity that uniquely represents the value for this column.
             * Ex. The composite key for value1 references both columnA and columnB.
             * If columnA is passed in, an identity for value1 that only references columnA will be returned.
             * Mainly used for detecting unique values on each level of a hierarchy.
             */
            CartesianAxes.getSpecificIdentityFromCompositeIdentity = function (column, valueIndex, groupIdentityFields) {
                var columnIdentities = column.identity;
                debug.assertNonEmpty(columnIdentities, 'columnIdentities');
                var identity = columnIdentities[valueIndex];
                debug.assertValue(identity, 'identity');
                var identitySubsetExpr = powerbi.data.ScopeIdentityExtractor.getSubset(identity.expr, groupIdentityFields);
                var valueGroupIdentity = powerbi.data.createDataViewScopeIdentity(identitySubsetExpr);
                return valueGroupIdentity;
            };
            CartesianAxes.getCategorySpanSize = function (categorySpanCount, categoryWidth) {
                debug.assertValue(categorySpanCount, 'categorySpanCount');
                debug.assertAnyValue(categoryWidth, 'categoryWidth');
                return categorySpanCount * categoryWidth;
            };
            CartesianAxes.getMaxCategoryWidth = function (categorySpanCount, categoryWidth) {
                debug.assertValue(categorySpanCount, 'categorySpanCount');
                debug.assertAnyValue(categoryWidth, 'categoryWidth');
                var categorySpanSize = CartesianAxes.getCategorySpanSize(categorySpanCount, categoryWidth);
                return categorySpanSize - visuals.CartesianHelper.TickLabelPadding * 2;
            };
            CartesianAxes.getHierarchyLineStyleInfo = function (options) {
                debug.assertValue(options, 'options');
                var categorySpanSize = CartesianAxes.getCategorySpanSize(options.categorySpanCount, options.categoryWidth);
                return CartesianAxes.createHierarchyLineStyleInfo(options.levelIndex, options.stackHeight, options.leafHeight, categorySpanSize);
            };
            CartesianAxes.createHierarchyLineStyleInfo = function (levelIndex, stackHeight, leafHeight, maxWidth) {
                debug.assertValue(levelIndex, 'levelIndex');
                debug.assertValue(stackHeight, 'stackHeight');
                debug.assertValue(leafHeight, 'leafHeight');
                debug.assertValue(maxWidth, 'maxWidth');
                // If we're the leaf level, don't add styling since it's not used
                if (levelIndex === 0) {
                    return;
                }
                // second level (levelIndex = 1), needs to draw vertical lines up over the leaf level    
                var outInfo = [];
                var lineStyleInfoLeft = {
                    x1: -maxWidth / 2,
                    y1: stackHeight,
                    x2: -maxWidth / 2,
                    y2: levelIndex === 1 ? -leafHeight : 0,
                };
                var lineStyleInfoRight = {
                    x1: maxWidth / 2,
                    y1: stackHeight,
                    x2: maxWidth / 2,
                    y2: levelIndex === 1 ? -leafHeight : 0,
                };
                outInfo.push(lineStyleInfoLeft);
                outInfo.push(lineStyleInfoRight);
                // all other grandparent+ levels have lines at both sides and at the top   
                if (levelIndex > 1) {
                    var lineStyleInfoTop = {
                        x1: -maxWidth / 2,
                        y1: 0,
                        x2: maxWidth / 2,
                        y2: 0,
                    };
                    outInfo.push(lineStyleInfoTop);
                }
                return outInfo;
            };
            /**
             * Negotiate the axes regions, the plot area, and determine if we need a scrollbar for ordinal categories.
             * @param layers an array of Cartesian layout layers (column, line, etc.)
             * @param parentViewport the full viewport for the visual
             * @param padding the D3 axis padding values
             * @param playAxisControlLayout if this is a playable Cartesian chart, includes the layout for the play controls (start/stop, time slider)
             * @param showAxisTitles axis titles should be rendered
             * @param shouldRenderAxis  axis should be rendered
             * @param axisFontSize axis font and axis titles font
             * @param textProperties text properties to be used by text measurement
             * @param interactivityRightMargin extra right margin for the interactivity
             * @param ensureXDomain if non null, includes values that must be part of the axis domain
             * @param ensureYDomain if non null, includes values that must be part of the axis domain
             */
            CartesianAxes.prototype.negotiateAxes = function (layers, parentViewport, padding, playAxisControlLayout, showAxisTitles, shouldRenderAxis, axesFontProperties, interactivityRightMargin, ensureXDomain, ensureYDomain) {
                // 1> MinMargins -> some initial axis properties / text
                // 2> Get axis margins for the initial text, no rotateXTickLabels90. margins grown? -> axis properties / text again (possibly more tick labels now)
                // ?> do we have more labels? do we need rotate? are we done?
                // 3> margins again (rotate? margins grow?) -> text again (less tick labls now?)
                // FREEZE PROPERTIES THAT CAN CHANGE
                // 4> margins (final), axes (final)
                // 1.a) initialize margins
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                var viewport = powerbi.Prototype.inherit(parentViewport);
                var leftRightMarginLimit = viewport.width * this.maxMarginFactor;
                var bottomMarginLimit = Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * this.maxMarginFactor));
                var marginLimits = {
                    left: leftRightMarginLimit,
                    right: leftRightMarginLimit,
                    top: 0,
                    bottom: bottomMarginLimit,
                };
                // 1.b) Calculate axis properties using initial margins
                var axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, axesFontProperties, 
                /*scrollbarVisible*/ false, 
                /*previousAxisProperties*/ null, showAxisTitles, ensureXDomain, ensureYDomain, 
                /*tickLableMargins*/ undefined, shouldRenderAxis);
                // this is used by getTickLabelMargins and updateAxisMargins
                var willRenderAxis = {
                    x: shouldRenderAxis.x && axes.x && !_.isEmpty(axes.x.values),
                    y: shouldRenderAxis.y && axes.y1 && !_.isEmpty(axes.y1.values),
                    y2: shouldRenderAxis.y2 && axes.y2 && !_.isEmpty(axes.y2.values),
                };
                var showY1OnRight = this.shouldShowY1OnRight();
                var numHierarchyLevels = visuals.AxisHelper.isHierarchical(axes.x) ? axes.x.numLevels : undefined;
                var plotArea = {
                    width: viewport.width - (margin.left + margin.right),
                    height: viewport.height - (margin.top + margin.bottom)
                };
                var isScalar = false;
                if (!_.isEmpty(layers)) {
                    if (layers[0].getVisualCategoryAxisIsScalar)
                        isScalar = layers[0].getVisualCategoryAxisIsScalar();
                }
                // 2.a) calculate axis tick margins
                var tickLabelMargins;
                tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                    plotArea: plotArea,
                    yMarginLimit: marginLimits.left,
                    textWidthMeasurer: powerbi.TextMeasurementService.measureSvgTextWidth,
                    textHeightMeasurer: powerbi.TextMeasurementService.estimateSvgTextHeight,
                    axes: axes,
                    bottomMarginLimit: marginLimits.bottom,
                    axesFontProperties: axesFontProperties,
                    scrollbarVisible: false,
                    showOnRight: showY1OnRight,
                    renderXAxis: willRenderAxis.x,
                    renderY1Axis: willRenderAxis.y,
                    renderY2Axis: willRenderAxis.y2,
                    numHierarchyLevels: numHierarchyLevels
                });
                margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, isScalar ? 0 : interactivityRightMargin, showAxisTitles, willRenderAxis, axesFontProperties);
                // if any of these change, we need to calculate margins again
                var previousTickCountY1 = axes.y1 && axes.y1.values.length;
                var previousTickCountY2 = axes.y2 && axes.y2.values.length;
                var previousWillFitX = axes.x && axes.x.willLabelsFit;
                var previousWillBreakX = axes.x && axes.x.willLabelsWordBreak;
                var previousXLabelMaxWidth = axes.x && axes.x.xLabelMaxWidth;
                var previousCategoryThickness = axes.x && axes.x.categoryThickness;
                // 2.b) Re-calculate the axes with the new margins.
                axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, axesFontProperties, 
                /*scrollbarVisible*/ false, 
                /*previousAxes*/ null, showAxisTitles, ensureXDomain, ensureYDomain, tickLabelMargins, willRenderAxis);
                plotArea.width = viewport.width - (margin.left + margin.right);
                plotArea.height = viewport.height - (margin.top + margin.bottom);
                // check properties that affect getTickLabelMargin - if these are the same, we don't need to calculate axis margins again
                var preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                var rotateXTickLabels90 = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                var allDone = ((!axes.y1 || axes.y1.values.length === previousTickCountY1)
                    && (!axes.y2 || axes.y2.values.length === previousTickCountY2)
                    && (!axes.x || axes.x.willLabelsFit === previousWillFitX)
                    && (!axes.x || axes.x.willLabelsWordBreak === previousWillBreakX)
                    && (!axes.x || axes.x.xLabelMaxWidth === previousXLabelMaxWidth)
                    && !rotateXTickLabels90
                    && !this.isHierarchicalCategoryAxis
                    && (!axes.x || axes.x.categoryThickness === previousCategoryThickness));
                var isXScrollBarVisible = false;
                var isYScrollBarVisible = false;
                if (!allDone) {
                    // 3.a) calculate axis tick margins
                    tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                        plotArea: plotArea,
                        yMarginLimit: marginLimits.left,
                        textWidthMeasurer: powerbi.TextMeasurementService.measureSvgTextWidth,
                        textHeightMeasurer: powerbi.TextMeasurementService.estimateSvgTextHeight,
                        axes: axes,
                        bottomMarginLimit: marginLimits.bottom,
                        axesFontProperties: axesFontProperties,
                        scrollbarVisible: rotateXTickLabels90,
                        showOnRight: showY1OnRight,
                        renderXAxis: willRenderAxis.x,
                        renderY1Axis: willRenderAxis.y,
                        renderY2Axis: willRenderAxis.y2,
                        numHierarchyLevels: numHierarchyLevels
                    });
                    margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, isScalar ? 0 : interactivityRightMargin, showAxisTitles, willRenderAxis, axesFontProperties);
                    // 3.b) Re-calculate the axes with the new final margins
                    axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, axesFontProperties, 
                    /*scrollbarVisible*/ rotateXTickLabels90, axes, showAxisTitles, ensureXDomain, ensureYDomain, tickLabelMargins, willRenderAxis);
                    // now we can determine if we need actual scrolling
                    // rotateXTickLabels90 will give more plotArea to categories since the left-overflow of a rotated category label doesn't exist anymore
                    plotArea.width = viewport.width - (margin.left + margin.right);
                    plotArea.height = viewport.height - (margin.top + margin.bottom);
                    preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                    var willScroll = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                    if (willScroll) {
                        if (axes.x.isCategoryAxis) {
                            isXScrollBarVisible = true;
                            viewport.height -= this.scrollbarWidth;
                        }
                        if (axes.y1.isCategoryAxis) {
                            isYScrollBarVisible = true;
                            viewport.width -= this.scrollbarWidth;
                        }
                        margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, isScalar ? 0 : interactivityRightMargin, showAxisTitles, willRenderAxis, axesFontProperties, isXScrollBarVisible, isYScrollBarVisible);
                        // 3.c) Re-calculate the axes with the final margins (and the updated viewport - scrollbarWidth)
                        axes = this.calculateAxes(layers, viewport, margin, playAxisControlLayout, axesFontProperties, 
                        /*scrollbarVisible*/ true, axes, showAxisTitles, ensureXDomain, ensureYDomain, tickLabelMargins, willRenderAxis);
                        plotArea.width = viewport.width - (margin.left + margin.right);
                        plotArea.height = viewport.height - (margin.top + margin.bottom);
                        preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                    }
                }
                ///////DONE
                var xAxisLabel = !showAxisTitles.x || !axes.x ? null : axes.x.axisLabel;
                var yAxisLabel = !showAxisTitles.y || !axes.y1 ? null : axes.y1.axisLabel;
                var y2AxisLabel = !showAxisTitles.y2 || !axes.y2 ? null : axes.y2.axisLabel;
                var axisLabels = { x: xAxisLabel, y: yAxisLabel, y2: y2AxisLabel };
                this.layout = {
                    axes: axes,
                    axisLabels: axisLabels,
                    margin: margin,
                    marginLimits: marginLimits,
                    viewport: viewport,
                    plotArea: plotArea,
                    preferredPlotArea: preferredPlotArea,
                    tickLabelMargins: tickLabelMargins,
                    tickPadding: padding,
                    rotateXTickLabels90: rotateXTickLabels90,
                    shouldRenderAxis: willRenderAxis,
                    isXScrollBarVisible: isXScrollBarVisible,
                    isYScrollBarVisible: isYScrollBarVisible,
                };
                this.alignZerosWithCustomDomainWarning = axes.alignZerosWithCustomDomainWarning;
                return this.layout;
            };
            CartesianAxes.prototype.getPreferredPlotArea = function (axes, layers, isScalar) {
                var preferredPlotArea;
                if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
                    var categoryThickness = axes.x.isCategoryAxis ? axes.x.categoryThickness : axes.y1.categoryThickness;
                    var categoryCount = axes.x.isCategoryAxis ? axes.x.dataDomain.length : axes.y1.dataDomain.length;
                    preferredPlotArea = layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                }
                return preferredPlotArea;
            };
            CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function (plotArea, preferredPlotArea) {
                if (!this.isYAxisCategorical && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.width, plotArea.width)) {
                    return false;
                }
                if (this.isYAxisCategorical && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.height, plotArea.height)) {
                    return false;
                }
                return true;
            };
            CartesianAxes.prototype.updateAxisMargins = function (axes, tickLabelMargins, padding, showY1OnRight, interactivityRightMargin, showAxisTitles, willRenderAxis, axesFontProperties, isXScrollBarVisible, isYScrollBarVisible) {
                // We look at the y axes as main and second sides, if the y axis orientation is right then the main side represents the right side.
                var maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
                // Only add padding if we are rendering the axis
                if (willRenderAxis.y) {
                    if (showY1OnRight) {
                        maxY1Padding += padding.right;
                    }
                    else {
                        maxY1Padding += padding.left;
                    }
                }
                if (willRenderAxis.y2) {
                    if (showY1OnRight) {
                        maxY2Padding += padding.left;
                    }
                    else {
                        maxY2Padding += padding.right;
                    }
                }
                if (willRenderAxis.x)
                    maxXAxisBottom += padding.bottom;
                // Add padding for the axis titles if they are turned on
                var axisTitles = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                if (axisTitles.x != null && showAxisTitles.x) {
                    var titleTextHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(visuals.FontProperties.toTextProperties(axesFontProperties.x.title));
                    maxXAxisBottom += titleTextHeight + CartesianAxes.XAxisLabelPadding;
                }
                if (axisTitles.y != null && showAxisTitles.y) {
                    var titleTextHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(visuals.FontProperties.toTextProperties(axesFontProperties.y.title));
                    maxY1Padding += titleTextHeight + CartesianAxes.YAxisLabelPadding;
                }
                if (axisTitles.y2 != null && showAxisTitles.y2) {
                    var titleTextHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(visuals.FontProperties.toTextProperties(axesFontProperties.y2.title));
                    maxY2Padding += titleTextHeight + CartesianAxes.YAxisLabelPadding;
                }
                // +interactivityRightMargin for mobile interactive legend
                var rightMargin = (showY1OnRight ? maxY1Padding : maxY2Padding) + interactivityRightMargin;
                rightMargin = (isYScrollBarVisible) ? Math.max(rightMargin, CartesianAxes.MinimumAxisMarginFromScrollbar) : rightMargin;
                var bottomMargin = maxXAxisBottom;
                bottomMargin = (isXScrollBarVisible) ? Math.max(bottomMargin, CartesianAxes.MinimumAxisMarginFromScrollbar) : bottomMargin;
                var minMargins = CartesianAxes.MinimumMargin;
                // TODO Apply the minimum to all values (can't currently do it without changing existing charts)
                var margin = {
                    top: Math.max(tickLabelMargins.yTop, minMargins.top),
                    left: showY1OnRight ? maxY2Padding : maxY1Padding,
                    right: rightMargin,
                    bottom: bottomMargin
                };
                return margin;
            };
            CartesianAxes.prototype.isLogScaleAllowed = function (axisType) {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                switch (axisType) {
                    case 0 /* X */:
                        return axes.x.isLogScaleAllowed;
                    case 1 /* Y1 */:
                        return axes.y1.isLogScaleAllowed;
                    case 2 /* Y2 */:
                        return axes.y2 && axes.y2.isLogScaleAllowed;
                }
            };
            CartesianAxes.prototype.axesHaveTicks = function (viewport) {
                if (!this.layout)
                    return false;
                var margin = this.layout.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                // TODO: this is never the case, remove.
                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
                    && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                    return false;
                }
                return true;
            };
            CartesianAxes.prototype.overrideAxisTitles = function (axes) {
                if (!axes)
                    return;
                if (axes.x && this.axesData.x.titleText) {
                    axes.x.axisLabel = this.axesData.x.titleText;
                }
                if (axes.y1 && this.axesData.y.titleText) {
                    axes.y1.axisLabel = this.axesData.y.titleText;
                }
                if (axes.y2 && this.axesData.y2.titleText) {
                    axes.y2.axisLabel = this.axesData.y2.titleText;
                }
            };
            // TODO: clean this up
            CartesianAxes.prototype.addUnitTypeToAxisLabels = function (axes) {
                var unitType = CartesianAxes.getUnitType(axes.x.formatter);
                if (axes.x.isCategoryAxis) {
                    this.categoryAxisHasUnitType = unitType != null;
                }
                else {
                    this.valueAxisHasUnitType = unitType != null;
                }
                if (axes.x.axisLabel && unitType) {
                    axes.x.axisLabel = visuals.AxisViewModel.createAxisLabel(this.axesData.x.axisStyle, axes.x.axisLabel, unitType);
                }
                unitType = CartesianAxes.getUnitType(axes.y1.formatter);
                if (!axes.y1.isCategoryAxis) {
                    this.valueAxisHasUnitType = unitType != null;
                }
                else {
                    this.categoryAxisHasUnitType = unitType != null;
                }
                if (axes.y1.axisLabel && unitType) {
                    axes.y1.axisLabel = visuals.AxisViewModel.createAxisLabel(this.axesData.y.axisStyle, axes.y1.axisLabel, unitType);
                }
                if (axes.y2) {
                    var unitType_1 = CartesianAxes.getUnitType(axes.y2.formatter);
                    this.secondaryValueAxisHasUnitType = unitType_1 != null;
                    if (axes.y2.axisLabel && unitType_1) {
                        axes.y2.axisLabel = visuals.AxisViewModel.createAxisLabel(this.axesData.y2.axisStyle, axes.y2.axisLabel, unitType_1);
                    }
                }
            };
            /**
             * The input types are 2D number arrays, first dimension is the y-axis index, second dimension is min/max.
             * @param forcedYDomains - y1 and y2 domains, each has a min/max
             * @param alignZeroDomains - y1 and  y2 domains, each has a min/max
            */
            CartesianAxes.prototype.addStartEndWarnings = function (forcedYDomains, alignZeroDomains) {
                //if we have any forcedDomains and they want to align zeros, set warning to true - we can't do both right now.
                // warning states that we can't align zeros since they've specified a custom domain.
                if (forcedYDomains && forcedYDomains.length === 2) {
                    // y1
                    if (forcedYDomains[0] && forcedYDomains[0].length === 2 && alignZeroDomains[0] && alignZeroDomains[0].length === 2) {
                        return true;
                    }
                    // y2
                    if (forcedYDomains[1] && forcedYDomains[1].length === 2 && alignZeroDomains[1] && alignZeroDomains[1].length === 2) {
                        return true;
                    }
                }
                return false;
            };
            CartesianAxes.getUnitType = function (formatter) {
                if (formatter &&
                    formatter.displayUnit &&
                    formatter.displayUnit.value > 1)
                    return formatter.displayUnit.title;
            };
            CartesianAxes.hierarchyPlaceholder = { placeholder: true };
            CartesianAxes.gridlineDefaultColor = '#e9e9e9'; // matches colors.less @chartAxisGridLineColor
            CartesianAxes.YAxisLabelPadding = 5;
            CartesianAxes.XAxisLabelPadding = 3;
            CartesianAxes.MaxMarginFactor = 0.25;
            CartesianAxes.MinimumMargin = {
                left: 1,
                right: 1,
                top: 8,
                bottom: 25,
            };
            CartesianAxes.MinimumAxisMarginFromScrollbar = 5;
            return CartesianAxes;
        }());
        visuals.CartesianAxes = CartesianAxes;
        function hasMultipleYAxes(layers) {
            debug.assertValue(layers, 'layers');
            return layers.length > 1;
        }
        function tryMergeYDomains(layers, visualOptions) {
            debug.assert(layers.length < 3, 'merging of more than 2 layers is not supported');
            var noMerge = {
                domain: undefined,
                merged: false,
                tickCount: undefined
            };
            if (layers.length < 2)
                return noMerge;
            // TODO: replace full calculateAxesProperties with just a data domain calc
            // we need to be aware of which chart require zero (column/bar) and which don't (line)
            var y1props = layers[0].calculateAxesProperties(visualOptions)[1];
            var y2props = layers[1].calculateAxesProperties(visualOptions)[1];
            var firstYDomain = y1props.scale.domain();
            var secondYDomain = y2props.scale.domain();
            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0) {
                noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length);
            }
            var min = Math.min(firstYDomain[0], secondYDomain[0]);
            var max = Math.max(firstYDomain[1], secondYDomain[1]);
            if (visualOptions.forceMerge) {
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount
                };
            }
            // If domains don't intersect don't merge axis.
            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0])
                return noMerge;
            var range = (max - min);
            if (range === 0) {
                return noMerge;
            }
            var maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]);
            var minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
            var overlapRatio = Math.abs((minOfMax - maxOfMin) / range);
            // Only merge if intersection of domains greater than 10% of total range.
            if (overlapRatio < COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE)
                return noMerge;
            else
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount
                };
        }
        /** Assumption is that both domains already include zero.
         * @param d - the domain
         * @returns - two ratios, one for the portion of the domain that is positive and one for the negative. Ratios will sum to 1.0
         */
        function getPositiveAndNegativeDomainRatios(domain) {
            debug.assert(domain.length === 2, 'domain length must be 2');
            debug.assert(domain[1] - domain[0] !== 0, 'div by zero warning');
            return {
                pos: (domain[1] - 0) / (domain[1] - domain[0]),
                neg: (0 - domain[0]) / (domain[1] - domain[0])
            };
        }
        /**
         * Get ratios for aboveZero and belowZero for each domain,
         * expand the smallest ratio to match the other domain ratio on the same side to align the zeros.
         */
        function alignZeros(domain1, domain2, bufferMultiplier) {
            debug.assert(domain1 && domain1.length === 2, "domain1 length");
            debug.assert(domain2 && domain2.length === 2, "domain2 length");
            debug.assert(bufferMultiplier >= 0 && bufferMultiplier <= 0.15, "bufferMultiplier should be between 0 and 0.15");
            var d1Out = domain1.slice();
            var d2Out = domain2.slice();
            if (bufferMultiplier) {
                var d1Range = domain1[1] - domain1[0];
                var d2Range = domain2[1] - domain2[0];
                d1Out[0] = d1Out[0] - (d1Range * bufferMultiplier);
                d1Out[1] = d1Out[1] + (d1Range * bufferMultiplier);
                d2Out[0] = d2Out[0] - (d2Range * bufferMultiplier);
                d2Out[1] = d2Out[1] + (d2Range * bufferMultiplier);
            }
            // use original input domains for all-positive and all-negative checks, avoid bufferMultiplier
            if (domain1[0] >= 0 && domain2[0] >= 0) {
                // all positive
                d1Out[0] = 0;
                d2Out[0] = 0;
            }
            else if (domain1[1] <= 0 && domain2[1] <= 0) {
                // all negative
                d1Out[1] = 0;
                d2Out[1] = 0;
            }
            else {
                // need math
                var d1Ratios = getPositiveAndNegativeDomainRatios(d1Out);
                var d2Ratios = getPositiveAndNegativeDomainRatios(d2Out);
                // make ratios the same by stretching min of each to match the other one
                // never squeeze either axis by more than 50% of their preferred dynamic range
                // a) if min of pos/neg ratio for each axis is on same side, just slightly adjust the smaller one to match larger one.
                // b) if opposite, move both to 50/50
                // Solve: x / (x - k) = desiredRatio (z), x = -zk / (1-z)
                if (d1Ratios.pos < d1Ratios.neg && d2Ratios.pos < d2Ratios.neg) {
                    //both pos are smaller, increase smaller postive ratio to match
                    if (d1Ratios.pos < d2Ratios.pos) {
                        d1Out[1] = -(d2Ratios.pos * d1Out[0]) / (1 - d2Ratios.pos);
                    }
                    else {
                        d2Out[1] = -(d1Ratios.pos * d2Out[0]) / (1 - d1Ratios.pos);
                    }
                }
                else if (d1Ratios.pos > d1Ratios.neg && d2Ratios.pos > d2Ratios.neg) {
                    //both neg are smaller, increase smaller negative ratio to match
                    if (d1Ratios.neg < d2Ratios.neg) {
                        d1Out[0] = -(d2Ratios.neg * d1Out[1]) / (1 - d2Ratios.neg);
                    }
                    else {
                        d2Out[0] = -(d1Ratios.neg * d2Out[1]) / (1 - d1Ratios.neg);
                    }
                }
                else {
                    // lopsided - move both to 50/50. Find abs max for each axis and mirror that to the other side to put zero at the middle.
                    var d1AbsMax = Math.max(Math.abs(d1Out[0]), Math.abs(d1Out[1]));
                    var d2AbsMax = Math.max(Math.abs(d2Out[0]), Math.abs(d2Out[1]));
                    d1Out = [-d1AbsMax, d1AbsMax];
                    d2Out = [-d2AbsMax, d2AbsMax];
                }
            }
            return [d1Out, d2Out];
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CompiledDataViewMapping = powerbi.data.CompiledDataViewMapping;
        visuals.DEFAULT_AXIS_SCALE_TYPE = visuals.axisScale.linear;
        visuals.DEFAULT_AXIS_COLOR = '#777';
        visuals.DEFAULT_FONT_FAMILY = visuals.Font.Family.regular.css;
        visuals.DefaultInnerPaddingRatio = 0.2;
        var CartesianHelper;
        (function (CartesianHelper) {
            CartesianHelper.DefaultConcatenateLabelsValue = true;
            CartesianHelper.MinOrdinalRectThickness = 20;
            CartesianHelper.TickLabelPadding = 2; // between text labels, used by AxisHelper
            CartesianHelper.DefaultAxisFontFamily = visuals.Font.Family.regular.css;
            CartesianHelper.DefaultAxisFontSizeInPx = 11;
            CartesianHelper.AxisFontFamily = visuals.Font.Family.regular.css;
            CartesianHelper.DefaultOuterPaddingRatio = 0.4;
            CartesianHelper.defaultLineStrokeWidth = 2;
            var BubbleRadius = 3 * 2;
            // Chart Area and size range values as defined by PV charts
            var AreaOf300By300Chart = 90000;
            var MinSizeRange = 200;
            var MaxSizeRange = 3000;
            // scatter label layout settings
            CartesianHelper.dataLabelLayoutStartingOffset = 2;
            CartesianHelper.dataLabelLayoutOffsetIterationDelta = 6;
            CartesianHelper.dataLabelLayoutMaximumOffset = CartesianHelper.dataLabelLayoutStartingOffset + (2 * CartesianHelper.dataLabelLayoutOffsetIterationDelta);
            CartesianHelper.DefaultScatterRatioLineSettings = {
                show: false,
                lineColor: { solid: { color: '#000000' } },
                transparency: 0,
                style: visuals.lineStyle.dashed
            };
            function getBubblePixelAreaSizeRange(plotArea, minSizeRange, maxSizeRange) {
                var ratio = 1.0;
                if (plotArea.height > 0 && plotArea.width > 0) {
                    var minSize = Math.min(plotArea.height, plotArea.width);
                    ratio = (minSize * minSize) / AreaOf300By300Chart;
                }
                var minRange = Math.round(minSizeRange * ratio);
                var maxRange = Math.round(maxSizeRange * ratio);
                return {
                    minRange: minRange,
                    maxRange: maxRange,
                    delta: maxRange - minRange
                };
            }
            CartesianHelper.getBubblePixelAreaSizeRange = getBubblePixelAreaSizeRange;
            function getBubbleRadius(radiusData, sizeRange, plotArea, multiplier) {
                var actualSizeDataRange = null;
                var bubblePixelAreaSizeRange = null;
                var measureSize = radiusData.sizeMeasure;
                if (!measureSize && radiusData.value == null)
                    return BubbleRadius * multiplier;
                var minSize = sizeRange.min ? sizeRange.min : 0;
                var maxSize = sizeRange.max ? sizeRange.max : 0;
                var min = Math.min(minSize, 0);
                var max = Math.max(maxSize, 0);
                actualSizeDataRange = {
                    minRange: min,
                    maxRange: max,
                    delta: max - min
                };
                bubblePixelAreaSizeRange = getBubblePixelAreaSizeRange(plotArea, MinSizeRange, MaxSizeRange);
                var sizeValue = (measureSize && measureSize.values[radiusData.index]) || radiusData.value;
                if (sizeValue != null) {
                    return (projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2) * multiplier;
                }
                return BubbleRadius * multiplier;
            }
            CartesianHelper.getBubbleRadius = getBubbleRadius;
            function projectSizeToPixels(size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                var projectedSize = 0;
                if (actualSizeDataRange) {
                    // Project value on the required range of bubble area sizes
                    projectedSize = bubblePixelAreaSizeRange.maxRange;
                    if (actualSizeDataRange.delta !== 0) {
                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                        projectedSize = project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                    }
                    projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
                }
                return Math.round(projectedSize);
            }
            CartesianHelper.projectSizeToPixels = projectSizeToPixels;
            function project(value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
                    return (rangeContains(actualSizeDataRange, value)) ? bubblePixelAreaSizeRange.minRange : null;
                }
                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
            }
            function rangeContains(range, value) {
                return range.minRange <= value && value <= range.maxRange;
            }
            function getRectTop(scale, pos, value) {
                if (value < 0)
                    return scale(pos);
                else
                    return scale(pos) - (scale(0) - scale(value));
            }
            CartesianHelper.getRectTop = getRectTop;
            function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                return {
                    x: function (d) { return xAxisProperties.scale(d.categoryIndex) + (categoryWidth / 2); },
                    y: function (d) { return getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain); }
                };
            }
            CartesianHelper.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall;
            function getWaterfallLabelYPosition(scale, d, dataDomain) {
                var yValue = scale(0) - scale(Math.abs(d.value));
                var yPos = scale(d.position);
                var scaleMinDomain = scale(dataDomain[0]);
                var endPosition = scale(d.position + d.value);
                if (d.value < 0) {
                    var properties = {
                        text: d.labeltext,
                        fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var outsideBelowPosition = yPos + yValue + powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                    if (scaleMinDomain > outsideBelowPosition) {
                        return outsideBelowPosition;
                    }
                }
                else {
                    var outsideAbovePosition = yPos - yValue - visuals.dataLabelUtils.labelMargin;
                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                    if (outsideAbovePosition > 0) {
                        return outsideAbovePosition;
                    }
                }
                d.isLabelInside = true;
                return getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
            }
            function getWaterfallInsideLabelYPosition(startPosition, endPosition, scaleMinDomain) {
                // Get the start and end position of the column
                // If the start or end is outside of the visual because of clipping - adjust the position
                startPosition = startPosition < 0 ? 0 : startPosition;
                startPosition = startPosition > scaleMinDomain ? scaleMinDomain : startPosition;
                endPosition = endPosition < 0 ? 0 : endPosition;
                endPosition = endPosition > scaleMinDomain ? scaleMinDomain : endPosition;
                return (Math.abs(endPosition - startPosition) / 2) + Math.min(startPosition, endPosition);
            }
            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = axisTitleOnByDefault ? { showAxisTitle: true } : {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var categoryAxisObject = objects['categoryAxis'];
                    if (categoryAxisObject) {
                        toReturn = _.clone(categoryAxisObject);
                        toReturn['showAxisTitle'] = categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'];
                    }
                }
                return toReturn;
            }
            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties;
            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = axisTitleOnByDefault ? { showAxisTitle: true } : {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var valueAxisObject = objects['valueAxis'];
                    if (valueAxisObject) {
                        toReturn = _.clone(valueAxisObject);
                        toReturn['showAxisTitle'] = valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'];
                    }
                }
                return toReturn;
            }
            CartesianHelper.getValueAxisProperties = getValueAxisProperties;
            function isScalar(supportsScalar, properties) {
                if (supportsScalar) {
                    return properties && properties.axisType ? properties.axisType === visuals.axisType.scalar : true;
                }
                return false;
            }
            CartesianHelper.isScalar = isScalar;
            function getPreferredCategoryWidth(xAxisCardProperties) {
                var stringValue = xAxisCardProperties['preferredCategoryWidth'];
                return stringValue == null ? undefined : +stringValue;
            }
            CartesianHelper.getPreferredCategoryWidth = getPreferredCategoryWidth;
            function lookupXValue(data, index, type, isScalar) {
                debug.assertValue(data, 'data');
                debug.assertValue(type, 'type');
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isScalar) {
                    if (isDateTime)
                        return new Date(index);
                    // index is the numeric value
                    return index;
                }
                if (type.text) {
                    debug.assert(index < data.categories.length, 'category index out of range');
                    return data.categories[index];
                }
                if (data && data.series && data.series.length > 0) {
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            if (data.hasHighlights)
                                index = index * 2;
                            var dataAtIndex = seriesValues[index];
                            if (dataAtIndex) {
                                if (isDateTime && dataAtIndex.categoryValue != null)
                                    return new Date(dataAtIndex.categoryValue);
                                return dataAtIndex.categoryValue;
                            }
                        }
                    }
                }
                return index;
            }
            CartesianHelper.lookupXValue = lookupXValue;
            function findMaxCategoryIndex(series) {
                if (_.isEmpty(series)) {
                    return 0;
                }
                var maxCategoryIndex = 0;
                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
                    var singleSeries = series_1[_i];
                    if (!_.isEmpty(singleSeries.data)) {
                        var lastIndex = singleSeries.data[singleSeries.data.length - 1].categoryIndex;
                        maxCategoryIndex = Math.max(lastIndex, maxCategoryIndex);
                    }
                }
                return maxCategoryIndex;
            }
            CartesianHelper.findMaxCategoryIndex = findMaxCategoryIndex;
            /**
             * Conditionally returns the first or last category column based on the presence of scalar keys,
             * and whether scalarKeys are available,
             * and the scalar keys themselves.
            */
            function getScalarKeyinfo(categorical, isScalar) {
                var category;
                var useScalarKeys = false;
                var scalarKeys;
                // If there are scalar keys, use the top of the hierarchy as the root
                if (isScalar) {
                    var firstCategory = _.first(categorical.categories);
                    scalarKeys = visuals.ScalarUtils.getScalarKeys(firstCategory);
                    useScalarKeys = isScalar && scalarKeys && !_.isEmpty(scalarKeys.values);
                    category = useScalarKeys ? firstCategory : _.last(categorical.categories);
                }
                else if (!_.isEmpty(categorical.categories)) {
                    category = _.last(categorical.categories);
                }
                else {
                    category = {
                        source: undefined,
                        values: [visuals.valueFormatter.format(null)],
                        identity: undefined,
                    };
                }
                return {
                    category: category,
                    useScalarKeys: useScalarKeys,
                    scalarKeys: scalarKeys,
                };
            }
            CartesianHelper.getScalarKeyinfo = getScalarKeyinfo;
            function hasCategoryHierarchy(dataView) {
                return dataView
                    && dataView.categorical
                    && dataView.categorical.categories
                    && dataView.categorical.categories.length > 1;
            }
            CartesianHelper.hasCategoryHierarchy = hasCategoryHierarchy;
            /**
             * Expands the category data reduction algorithm window if there are no series in any of the data view mappings.
             */
            function expandCategoryWindow(mappings) {
                var NoSeriesWindowCount = 1000;
                if (!shouldExpandCategoryWindow(mappings)) {
                    return;
                }
                for (var _i = 0, mappings_2 = mappings; _i < mappings_2.length; _i++) {
                    var mapping = mappings_2[_i];
                    if (!mapping.categorical) {
                        return;
                    }
                    var categories = mapping.categorical.categories;
                    // Only override the window if we have a window data reduction algorithm
                    if (!categories || !categories.dataReductionAlgorithm || !categories.dataReductionAlgorithm.window) {
                        return;
                    }
                    categories.dataReductionAlgorithm = {
                        window: { count: NoSeriesWindowCount }
                    };
                }
            }
            CartesianHelper.expandCategoryWindow = expandCategoryWindow;
            /**
             * Determines if the category window should be expanded. The window should be expanded if every mapping has categories and no dynamic series.
             */
            function shouldExpandCategoryWindow(mappings) {
                if (_.isEmpty(mappings)) {
                    return false;
                }
                // Check if any of the mappings have series
                var hasSeries = _.any(mappings, (function (mapping) {
                    var categorical = mapping.categorical;
                    if (!categorical) {
                        return false;
                    }
                    var categories = categorical.categories;
                    if (!categories) {
                        return false;
                    }
                    var values = categorical.values;
                    return !!(values && values.group && values.group.by && !_.isEmpty(values.group.by.items));
                }));
                return !hasSeries;
            }
            function requestFilteredToUniqueValue(mappings) {
                debug.assertNonEmpty(mappings, 'mappings');
                for (var _i = 0, mappings_3 = mappings; _i < mappings_3.length; _i++) {
                    var mapping = mappings_3[_i];
                    var dataViewCategories = mapping.categorical.categories;
                    powerbi.data.CompiledDataViewMapping.visitCategoricalCategories(dataViewCategories, {
                        visitRole: function (role) {
                            // Only request the filteredToUniqueValue property for active items in this role
                            var roleItems = role.items;
                            if (_.isEmpty(roleItems) || _.isEmpty(role.activeItems)) {
                                return;
                            }
                            var filteredRoleItems = _.filter(roleItems, (function (roleItem) { return _.contains(role.activeItems, roleItem.queryName); }));
                            for (var _i = 0, filteredRoleItems_1 = filteredRoleItems; _i < filteredRoleItems_1.length; _i++) {
                                var item = filteredRoleItems_1[_i];
                                item.filteredToUniqueValueProperty = visuals.cartesianChartProps.filters.filteredToUniqueValue;
                            }
                        }
                    });
                }
            }
            CartesianHelper.requestFilteredToUniqueValue = requestFilteredToUniqueValue;
            function applyHierarchicalSorts(mappings, sortableRoles, sortDirection) {
                if (sortDirection === void 0) { sortDirection = 1 /* Ascending */; }
                var _loop_8 = function (mapping) {
                    if (!mapping || !mapping.categorical || !mapping.categorical.categories || !mapping.metadata) {
                        return "continue";
                    }
                    // If any columns already have a sort direction, don't touch the sort
                    var metadataColumns = mapping.metadata.columns;
                    var categories = mapping.categorical.categories;
                    if (_.any(metadataColumns, (function (metadataColumn) { return metadataColumn.sort !== undefined; }))) {
                        return "continue";
                    }
                    // Go through each category
                    CompiledDataViewMapping.visitCategoricalCategories(categories, {
                        visitRole: function (role, context) {
                            // If the role isn't sortable or it's not in the active items, don't sort by it
                            if (!_.contains(sortableRoles, role.role)) {
                                return;
                            }
                            var activeItems = role.activeItems;
                            if (_.isEmpty(activeItems)) {
                                return;
                            }
                            var sortIndex = 0;
                            var _loop_9 = function (activeProjection) {
                                var metadataColumn = _.find(metadataColumns, (function (metadataColumn) { return metadataColumn.queryName === activeProjection; }));
                                if (metadataColumn) {
                                    metadataColumn.sort = sortDirection;
                                    metadataColumn.sortOrder = sortIndex++; // Post-increment the sort index
                                }
                            };
                            // Go through the projections in order. If we can locate the metadata, add sort direction and order info
                            for (var _i = 0, activeItems_1 = activeItems; _i < activeItems_1.length; _i++) {
                                var activeProjection = activeItems_1[_i];
                                _loop_9(activeProjection);
                            }
                        }
                    });
                };
                for (var _i = 0, mappings_4 = mappings; _i < mappings_4.length; _i++) {
                    var mapping = mappings_4[_i];
                    _loop_8(mapping);
                }
            }
            CartesianHelper.applyHierarchicalSorts = applyHierarchicalSorts;
        })(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AxesLayoutUtils;
        (function (AxesLayoutUtils) {
            /**
             * Gets the tick label margins and overflow for the given axis.
             * Currently only works for vertical axes.
             */
            function getAxisTickLabelMargins(axisProperties, fontProperties, textWidthMeasurer, textHeightMeasurer) {
                var scale = axisProperties.scale;
                var tickValues = axisProperties.axis.tickValues();
                if (_.isEmpty(tickValues)) {
                    return {
                        maxWidth: 0,
                        overflow: {
                            top: 0,
                            bottom: 0,
                        }
                    };
                }
                var axisStartValue;
                var axisEndValue;
                if (visuals.AxisHelper.isOrdinalScale(scale)) {
                    // Use rangeExtent if we have an ordinal scale to account for outerPadding
                    _a = scale.rangeExtent(), axisStartValue = _a[0], axisEndValue = _a[1];
                }
                else {
                    // otherwise just use the range
                    var range = scale.range();
                    axisStartValue = _.first(range);
                    axisEndValue = _.last(range);
                }
                var labels = axisProperties.values;
                var axisTopPosition;
                var axisTopLabelPosition;
                var axisBottomPosition;
                var axisBottomLabelPosition;
                if (axisStartValue < axisEndValue) {
                    axisTopPosition = axisStartValue;
                    axisTopLabelPosition = scale(_.first(tickValues));
                    axisBottomPosition = axisEndValue;
                    axisBottomLabelPosition = scale(_.last(tickValues));
                }
                else {
                    axisTopPosition = axisEndValue;
                    axisTopLabelPosition = scale(_.last(tickValues));
                    axisBottomPosition = axisStartValue;
                    axisBottomLabelPosition = scale(_.first(tickValues));
                }
                var textProperties = visuals.FontProperties.toTextProperties(fontProperties, "" + _.first(labels));
                var textHeight = textHeightMeasurer(textProperties);
                var topOverflow = Math.max(0, -(axisTopLabelPosition - textHeight / 2 - axisTopPosition));
                var bottomOverflow = Math.max(0, axisBottomLabelPosition + textHeight / 2 - axisBottomPosition);
                var maxWidth = 0;
                for (var i = 0, len = labels.length; i < len; i++) {
                    textProperties.text = "" + labels[i];
                    maxWidth = Math.max(maxWidth, textWidthMeasurer(textProperties));
                }
                return {
                    maxWidth: maxWidth,
                    overflow: {
                        top: topOverflow,
                        bottom: bottomOverflow,
                    }
                };
                var _a;
            }
            AxesLayoutUtils.getAxisTickLabelMargins = getAxisTickLabelMargins;
        })(AxesLayoutUtils = visuals.AxesLayoutUtils || (visuals.AxesLayoutUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ScalarKeyUtils = powerbi.data.ScalarKeyUtils;
        var ScalarUtils;
        (function (ScalarUtils) {
            function shouldDrawScalar(objects, propertyId, type, scalarKeys, hasCategoryHierarchy) {
                if (hasCategoryHierarchy && !scalarKeys)
                    return false;
                if (ScalarUtils.scalarKeysAreValid(scalarKeys))
                    return true;
                return ScalarUtils.canHaveScalarAxis(objects, propertyId, type);
            }
            ScalarUtils.shouldDrawScalar = shouldDrawScalar;
            function canHaveScalarAxis(objects, propertyId, type) {
                if (!typeCanBeScalar(type))
                    return false;
                if (!scalarAxisTypeAllowed(objects, propertyId))
                    return false;
                return true;
            }
            ScalarUtils.canHaveScalarAxis = canHaveScalarAxis;
            function scalarAxisTypeAllowed(objects, propertyId) {
                if (!objects)
                    return true;
                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                return axisTypeValue == null || axisTypeValue === visuals.axisType.scalar;
            }
            ScalarUtils.scalarAxisTypeAllowed = scalarAxisTypeAllowed;
            function typeCanBeScalar(type) {
                return !visuals.AxisHelper.isOrdinal(type);
            }
            ScalarUtils.typeCanBeScalar = typeCanBeScalar;
            function scalarKeysAreValid(scalarKeys) {
                return scalarKeys && !_.isEmpty(scalarKeys.values);
            }
            ScalarUtils.scalarKeysAreValid = scalarKeysAreValid;
            function getScalarKeys(dataViewCategoryColumn) {
                return ScalarKeyUtils.getScalarKeys(dataViewCategoryColumn, visuals.cartesianChartProps.scalarKey.scalarKeyMin);
            }
            ScalarUtils.getScalarKeys = getScalarKeys;
            function mappingSupportsScalarAxis(dataViewMapping) {
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return false;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (_.isEmpty(categoryItems))
                    return false;
                var activeProjections = dataViewCategories.for.in.activeItems;
                var category = categoryItems[0];
                if (!_.isEmpty(activeProjections)) {
                    if (activeProjections.length > 1)
                        return false;
                    var activeCategoryItem = _.find(categoryItems, (function (categoryItem) { return categoryItem.queryName === activeProjections[0]; }));
                    debug.assertValue(activeCategoryItem, 'active projection must be part of category items');
                    category = activeCategoryItem;
                }
                var categoryType = category.type;
                if (!dataViewMapping.metadata)
                    return false;
                var objects = dataViewMapping.metadata.objects;
                if (!canHaveScalarAxis(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType))
                    return false;
                return true;
            }
            ScalarUtils.mappingSupportsScalarAxis = mappingSupportsScalarAxis;
        })(ScalarUtils = visuals.ScalarUtils || (visuals.ScalarUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ViewModelAdapterUtils;
        (function (ViewModelAdapterUtils) {
            function getResponsiveVisualProperties(dataView, capabilitiesProps) {
                var settings = {
                    responsive: false,
                    responsiveLegacy: false,
                };
                if (!dataView || !dataView.metadata)
                    return settings;
                var objects = dataView.metadata.objects;
                if (objects) {
                    settings.responsive = powerbi.DataViewObjects.getValue(objects, capabilitiesProps.general.responsive, settings.responsive);
                    if (capabilitiesProps.general.responsiveLegacy) {
                        settings.responsiveLegacy = powerbi.DataViewObjects.getValue(objects, capabilitiesProps.general.responsiveLegacy, settings.responsiveLegacy);
                    }
                }
                return settings;
            }
            ViewModelAdapterUtils.getResponsiveVisualProperties = getResponsiveVisualProperties;
            function cloneData(data) {
                var copy = _.cloneDeep(data);
                // TODO: (mabrondv, 2017-05-03) the current lodash version doesn't clone functions
                // we will be able to remove this once upgrading to lodash version greater than 4 
                powerbi.Prototype.copyPrototypeDeep(data, copy);
                return copy;
            }
            ViewModelAdapterUtils.cloneData = cloneData;
            function shouldApplyResponsiveChanges(isResponsive, dataView, capabilitiesProps) {
                if (!isResponsive) {
                    return false;
                }
                var responsiveVisualProperties = ViewModelAdapterUtils.getResponsiveVisualProperties(dataView, capabilitiesProps);
                return responsiveVisualProperties.responsive;
            }
            ViewModelAdapterUtils.shouldApplyResponsiveChanges = shouldApplyResponsiveChanges;
        })(ViewModelAdapterUtils = visuals.ViewModelAdapterUtils || (visuals.ViewModelAdapterUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var HelloIVisual = /** @class */ (function () {
                function HelloIVisual() {
                }
                HelloIVisual.converter = function (dataView) {
                    var viewModel = {
                        size: HelloIVisual.getSize(dataView),
                        color: HelloIVisual.getFill(dataView).solid.color,
                        text: HelloIVisual.DefaultText,
                        toolTipInfo: [{
                                displayName: 'Test',
                                value: '1...2....3... can you see me? I am sending random strings to the tooltip',
                            }],
                        selector: visuals.SelectionId.createNull()
                    };
                    var table = dataView.table;
                    if (!table)
                        return viewModel;
                    viewModel.text = table.rows[0][0];
                    if (dataView.categorical) {
                        viewModel.selector = dataView.categorical.categories[0].identity
                            ? visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[0])
                            : visuals.SelectionId.createNull();
                    }
                    return viewModel;
                };
                HelloIVisual.prototype.init = function (options) {
                    this.root = d3.select(options.element.get(0))
                        .append('svg')
                        .classed('hello', true);
                    this.svgText = this.root
                        .append('text')
                        .style('cursor', 'pointer')
                        .style('stroke', 'green')
                        .style('stroke-width', '0px')
                        .attr('text-anchor', 'middle');
                    this.selectiionManager = new SelectionManager({ hostServices: options.host });
                };
                HelloIVisual.prototype.update = function (options) {
                    if (!options.dataViews && !options.dataViews[0])
                        return;
                    var dataView = this.dataView = options.dataViews[0];
                    var viewport = options.viewport;
                    var viewModel = HelloIVisual.converter(dataView);
                    this.root.attr({
                        'height': viewport.height,
                        'width': viewport.width
                    });
                    var textProperties = {
                        fontFamily: 'tahoma',
                        fontSize: viewModel.size + 'px',
                        text: viewModel.text
                    };
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                    var selectionManager = this.selectiionManager;
                    this.svgText.style({
                        'fill': viewModel.color,
                        'font-size': textProperties.fontSize,
                        'font-family': textProperties.fontFamily,
                    }).attr({
                        'y': viewport.height / 2 + textHeight / 3 + 'px',
                        'x': viewport.width / 2,
                    }).text(viewModel.text)
                        .on('click', (function () {
                        var _this = this;
                        selectionManager
                            .select(viewModel.selector)
                            .then((function (ids) { return d3.select(_this).style('stroke-width', ids.length > 0 ? '2px' : '0px'); }));
                    }))
                        .data([viewModel]);
                    visuals.TooltipManager.addTooltip(this.svgText, (function (tooltipEvent) { return tooltipEvent.data.toolTipInfo; }));
                };
                HelloIVisual.getFill = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                var fill = general['fill'];
                                if (fill)
                                    return fill;
                            }
                        }
                    }
                    return { solid: { color: 'red' } };
                };
                HelloIVisual.getSize = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                var size = general['size'];
                                if (size)
                                    return size;
                            }
                        }
                    }
                    return 100;
                };
                HelloIVisual.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    var dataView = this.dataView;
                    switch (options.objectName) {
                        case 'general':
                            var general = {
                                objectName: 'general',
                                displayName: 'General',
                                selector: null,
                                properties: {
                                    fill: HelloIVisual.getFill(dataView),
                                    size: HelloIVisual.getSize(dataView)
                                }
                            };
                            instances.push(general);
                            break;
                    }
                    return instances;
                };
                HelloIVisual.prototype.destroy = function () {
                    this.root = null;
                };
                HelloIVisual.capabilities = {
                    dataRoles: [{
                            displayName: 'Values',
                            name: 'Values',
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }],
                    dataViewMappings: [{
                            table: {
                                rows: {
                                    for: { in: 'Values' },
                                    dataReductionAlgorithm: { window: { count: 100 } }
                                },
                                rowCount: { preferred: { min: 1 } }
                            },
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                fill: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Fill'
                                },
                                size: {
                                    type: { numeric: true },
                                    displayName: 'Size'
                                }
                            },
                        }
                    },
                };
                HelloIVisual.DefaultText = 'Invalid DV';
                return HelloIVisual;
            }());
            samples.HelloIVisual = HelloIVisual;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SelectionManager = visuals.utility.SelectionManager;
        visuals.cheerMeterProps = {
            dataPoint: {
                defaultColor: {
                    objectName: 'dataPoint',
                    propertyName: 'defaultColor'
                },
                fill: {
                    objectName: 'dataPoint',
                    propertyName: 'fill'
                },
            },
        };
        var CheerMeter = /** @class */ (function () {
            function CheerMeter() {
                this.isFirstTime = true;
            }
            CheerMeter.converter = function (dataView) {
                if (!dataView.categorical || !dataView.categorical.categories)
                    return null;
                var cat = dataView.categorical.categories[0];
                if (!cat)
                    return null;
                var catValues = cat.values;
                if (!catValues || _.isEmpty(dataView.categorical.values))
                    return null;
                var values = dataView.categorical.values[0].values;
                var objects = dataView.categorical.categories[0].objects;
                var object1 = objects && objects.length > 0 ? objects[0] : undefined;
                var object2 = objects && objects.length > 1 ? objects[1] : undefined;
                var metadataObjects = dataView.metadata.objects;
                var backgroundColor = CheerMeter.DefaultBackgroundColor;
                if (metadataObjects) {
                    var general = metadataObjects['general'];
                    if (general) {
                        var fill = general['fill'];
                        if (fill) {
                            backgroundColor = fill.solid.color;
                        }
                    }
                }
                var color1 = powerbi.DataViewObjects.getFillColor(object1, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var color2 = powerbi.DataViewObjects.getFillColor(object2, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var idn1 = visuals.SelectionIdBuilder.builder()
                    .withCategory(cat, 0)
                    .createSelectionId();
                var idn2 = visuals.SelectionIdBuilder.builder()
                    .withCategory(cat, 1)
                    .createSelectionId();
                var data = {
                    teamA: {
                        name: catValues[0],
                        value: values[0],
                        color: color1,
                        identity: idn1
                    },
                    teamB: {
                        name: catValues[1],
                        value: values[1],
                        color: color2,
                        identity: idn2
                    },
                    background: backgroundColor
                };
                return data;
            };
            CheerMeter.prototype.init = function (options) {
                this.selectionManager = new SelectionManager({ hostServices: options.host });
                var svg = this.svg = d3.select(options.element.get(0)).append('svg');
                this.textOne = svg.append('text')
                    .style('font-family', CheerMeter.DefaultFontFamily);
                this.textTwo = svg.append('text')
                    .style('font-family', CheerMeter.DefaultFontFamily);
            };
            CheerMeter.prototype.update = function (options) {
                if (!options.dataViews[0]) {
                    return;
                }
                var data = this.data = CheerMeter.converter(options.dataViews[0]);
                if (!data)
                    return;
                var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                this.draw(data, duration, options.viewport);
            };
            CheerMeter.prototype.getRecomendedFontProperties = function (text1, text2, parentViewport) {
                var textProperties = {
                    fontSize: '',
                    fontFamily: CheerMeter.DefaultFontFamily,
                    text: text1 + text2
                };
                var min = 1;
                var max = 1000;
                var i;
                var maxWidth = parentViewport.width;
                var width = 0;
                while (min <= max) {
                    i = (min + max) / 2 | 0;
                    textProperties.fontSize = i + 'px';
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (maxWidth > width)
                        min = i + 1;
                    else if (maxWidth < width)
                        max = i - 1;
                    else
                        break;
                }
                textProperties.fontSize = i + 'px';
                width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (width > maxWidth) {
                    i--;
                    textProperties.fontSize = i + 'px';
                }
                return textProperties;
            };
            CheerMeter.prototype.calculateLayout = function (data, viewport) {
                var text1 = data.teamA.name;
                var text2 = data.teamB.name;
                var avaliableViewport = {
                    height: viewport.height,
                    width: viewport.width - CheerMeter.PaddingBetweenText
                };
                var recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                recomendedFontProperties.text = text1;
                var width1 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                recomendedFontProperties.text = text2;
                var width2 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                var padding = ((viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2) | 0;
                recomendedFontProperties.text = text1 + text2;
                var offsetHeight = (powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties)) | 0;
                var max = data.teamA.value + data.teamB.value;
                var availableHeight = viewport.height - offsetHeight;
                var y1 = (((max - data.teamA.value) / max) * availableHeight + offsetHeight / 2) | 0;
                var y2 = (((max - data.teamB.value) / max) * availableHeight + offsetHeight / 2) | 0;
                return {
                    x1: padding,
                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
                    y1: y1,
                    y2: y2,
                    fontSize: recomendedFontProperties.fontSize
                };
            };
            CheerMeter.prototype.ensureStartState = function (layout, viewport) {
                if (this.isFirstTime) {
                    this.isFirstTime = false;
                    var startY = viewport.height / 2;
                    this.textOne.attr({
                        'x': layout.x1,
                        'y': startY
                    });
                    this.textTwo.attr({
                        'x': layout.x2,
                        'y': startY
                    });
                }
            };
            CheerMeter.prototype.clearSelection = function () {
                var _this = this;
                this.selectionManager.clear().then((function () {
                    _this.clearSelectionUI();
                }));
            };
            CheerMeter.prototype.clearSelectionUI = function () {
                this.textOne.style('stroke', '#FFF').style('stroke-width', 0);
                this.textTwo.style('stroke', '#FFF').style('stroke-width', 0);
            };
            CheerMeter.prototype.updateSelectionUI = function (ids) {
                this.textOne.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamA.identity) ? '2px' : '0px');
                this.textTwo.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamB.identity) ? '2px' : '0px');
            };
            CheerMeter.prototype.draw = function (data, duration, viewport) {
                var _this = this;
                var easeName = 'back';
                var textOne = this.textOne;
                var textTwo = this.textTwo;
                this.svg
                    .attr({
                    'height': viewport.height,
                    'width': viewport.width
                })
                    .on('click', (function () {
                    _this.clearSelection();
                }))
                    .style('background-color', data.background);
                var layout = this.calculateLayout(data, viewport);
                this.ensureStartState(layout, viewport);
                textOne
                    .style('font-size', layout.fontSize)
                    .style('fill', data.teamA.color)
                    .on('click', (function () {
                    _this.selectionManager.select(data.teamA.identity, d3.event.ctrlKey).then((function (ids) {
                        _this.updateSelectionUI(ids);
                    }));
                    d3.event.stopPropagation();
                }))
                    .text(data.teamA.name);
                textTwo
                    .style('font-size', layout.fontSize)
                    .style('fill', data.teamB.color)
                    .on('click', (function () {
                    _this.selectionManager.select(data.teamB.identity, d3.event.ctrlKey).then((function (ids) {
                        _this.updateSelectionUI(ids);
                    }));
                    d3.event.stopPropagation();
                }))
                    .text(data.teamB.name);
                textOne.transition()
                    .duration(duration)
                    .ease(easeName)
                    .attr({
                    y: layout.y1,
                    x: layout.x1
                });
                textTwo.transition()
                    .duration(duration)
                    .ease(easeName)
                    .attr({
                    y: layout.y2,
                    x: layout.x2
                });
            };
            CheerMeter.prototype.destroy = function () {
                this.svg = null;
                this.textOne = this.textTwo = null;
            };
            CheerMeter.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                var data = this.data;
                switch (options.objectName) {
                    case 'dataPoint':
                        if (data) {
                            var teams = [data.teamA, data.teamB];
                            for (var _i = 0, teams_1 = teams; _i < teams_1.length; _i++) {
                                var slice = teams_1[_i];
                                var color = slice.color;
                                var selector = slice.identity;
                                var dataPointInstance = {
                                    objectName: 'dataPoint',
                                    displayName: slice.name,
                                    selector: selector.getSelector(),
                                    properties: {
                                        fill: { solid: { color: color } }
                                    },
                                };
                                instances.push(dataPointInstance);
                            }
                        }
                        break;
                    case 'general':
                        var general = {
                            objectName: 'general',
                            displayName: 'General',
                            selector: null,
                            properties: {
                                fill: { solid: { color: data ? data.background : CheerMeter.DefaultBackgroundColor } }
                            }
                        };
                        instances.push(general);
                        break;
                }
                return instances;
            };
            CheerMeter.capabilities = {
                dataRoles: [
                    {
                        displayName: 'Category',
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                    },
                    {
                        displayName: 'Noise Measure',
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                    },
                ],
                dataViewMappings: [{
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                            values: {
                                select: [{ bind: { to: 'Y' } }]
                            },
                        },
                    }],
                objects: {
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            width: {
                                displayName: '',
                                type: { numeric: true }
                            }
                        }
                    },
                    general: {
                        displayName: 'General',
                        properties: {
                            fill: {
                                displayName: 'Background color',
                                type: { fill: { solid: { color: true } } }
                            },
                        }
                    }
                }
            };
            CheerMeter.DefaultFontFamily = 'cursive';
            CheerMeter.DefaultFontColor = 'rgb(165, 172, 175)';
            CheerMeter.DefaultBackgroundColor = '#243C18';
            CheerMeter.PaddingBetweenText = 15;
            return CheerMeter;
        }());
        visuals.CheerMeter = CheerMeter;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var NoMapLocationWarning = /** @class */ (function () {
            function NoMapLocationWarning() {
            }
            Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                get: function () {
                    return 'NoMapLocation';
                },
                enumerable: true,
                configurable: true
            });
            NoMapLocationWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoMapLocationMessage';
                var titleKey = 'NoMapLocationKey';
                var detailKey = 'NoMapLocationValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return NoMapLocationWarning;
        }());
        visuals.NoMapLocationWarning = NoMapLocationWarning;
        var FilledMapWithoutValidGeotagCategoryWarning = /** @class */ (function () {
            function FilledMapWithoutValidGeotagCategoryWarning() {
            }
            Object.defineProperty(FilledMapWithoutValidGeotagCategoryWarning.prototype, "code", {
                get: function () {
                    return 'NoValidGeotaggedCategory';
                },
                enumerable: true,
                configurable: true
            });
            FilledMapWithoutValidGeotagCategoryWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoValidGeotaggedCategoryMessage';
                var titleKey = 'NoValidGeotaggedCategoryKey';
                var detailKey = 'NoValidGeotaggedCategoryValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return FilledMapWithoutValidGeotagCategoryWarning;
        }());
        visuals.FilledMapWithoutValidGeotagCategoryWarning = FilledMapWithoutValidGeotagCategoryWarning;
        var InvalidLatLongWarning = /** @class */ (function () {
            function InvalidLatLongWarning() {
            }
            Object.defineProperty(InvalidLatLongWarning.prototype, "code", {
                get: function () {
                    return 'InvalidLatLong';
                },
                enumerable: true,
                configurable: true
            });
            InvalidLatLongWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'InvalidLatLongMessage';
                var titleKey = 'InvalidLatLongKey';
                var detailKey = 'InvalidLatLongValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return InvalidLatLongWarning;
        }());
        visuals.InvalidLatLongWarning = InvalidLatLongWarning;
        var GeometryCulledWarning = /** @class */ (function () {
            function GeometryCulledWarning() {
            }
            Object.defineProperty(GeometryCulledWarning.prototype, "code", {
                get: function () {
                    return 'GeometryCulledWarning';
                },
                enumerable: true,
                configurable: true
            });
            GeometryCulledWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'GeometryCulledWarningMessage';
                var titleKey = 'GeometryCulledWarningKey';
                var detailKey = 'GeometryCulledWarningVal';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return GeometryCulledWarning;
        }());
        visuals.GeometryCulledWarning = GeometryCulledWarning;
        var NegativeValuesNotSupportedWarning = /** @class */ (function () {
            function NegativeValuesNotSupportedWarning() {
            }
            Object.defineProperty(NegativeValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NegativeValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NegativeValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_NegativeValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NegativeValuesNotSupportedWarning;
        }());
        visuals.NegativeValuesNotSupportedWarning = NegativeValuesNotSupportedWarning;
        var AllNegativeValuesWarning = /** @class */ (function () {
            function AllNegativeValuesWarning() {
            }
            Object.defineProperty(AllNegativeValuesWarning.prototype, "code", {
                get: function () {
                    return 'AllNegativeValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            AllNegativeValuesWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_AllNegativeValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return AllNegativeValuesWarning;
        }());
        visuals.AllNegativeValuesWarning = AllNegativeValuesWarning;
        var NaNNotSupportedWarning = /** @class */ (function () {
            function NaNNotSupportedWarning() {
            }
            Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NaNNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NaNNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_NanValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NaNNotSupportedWarning;
        }());
        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
        var InfinityValuesNotSupportedWarning = /** @class */ (function () {
            function InfinityValuesNotSupportedWarning() {
            }
            Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'InfinityValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            InfinityValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_InfinityValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return InfinityValuesNotSupportedWarning;
        }());
        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
        var ValuesOutOfRangeWarning = /** @class */ (function () {
            function ValuesOutOfRangeWarning() {
            }
            Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                get: function () {
                    return 'ValuesOutOfRange';
                },
                enumerable: true,
                configurable: true
            });
            ValuesOutOfRangeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_VisualizationOutOfRange';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ValuesOutOfRangeWarning;
        }());
        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
        var ZeroValueWarning = /** @class */ (function () {
            function ZeroValueWarning() {
            }
            Object.defineProperty(ZeroValueWarning.prototype, "code", {
                get: function () {
                    return "ZeroValuesNotSupported";
                },
                enumerable: true,
                configurable: true
            });
            ZeroValueWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_ZeroValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ZeroValueWarning;
        }());
        visuals.ZeroValueWarning = ZeroValueWarning;
        var AlignZerosWithCustomDomainWarning = /** @class */ (function () {
            function AlignZerosWithCustomDomainWarning() {
            }
            Object.defineProperty(AlignZerosWithCustomDomainWarning.prototype, "code", {
                get: function () {
                    return "AlignZerosWithCustomDomain";
                },
                enumerable: true,
                configurable: true
            });
            AlignZerosWithCustomDomainWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_AlignZerosWithCustomDomain';
                var titleKey = 'VisualWarning_AlignZerosWithCustomDomainTitle';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(messageKey),
                };
                return visualMessage;
            };
            return AlignZerosWithCustomDomainWarning;
        }());
        visuals.AlignZerosWithCustomDomainWarning = AlignZerosWithCustomDomainWarning;
        var VisualKPIDataMissingWarning = /** @class */ (function () {
            function VisualKPIDataMissingWarning() {
            }
            Object.defineProperty(VisualKPIDataMissingWarning.prototype, "code", {
                get: function () {
                    return "VisualKPIDataMissing";
                },
                enumerable: true,
                configurable: true
            });
            VisualKPIDataMissingWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_KPI_DataMissing';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return VisualKPIDataMissingWarning;
        }());
        visuals.VisualKPIDataMissingWarning = VisualKPIDataMissingWarning;
        var ScriptVisualRefreshWarning = /** @class */ (function () {
            function ScriptVisualRefreshWarning() {
            }
            Object.defineProperty(ScriptVisualRefreshWarning.prototype, "code", {
                get: function () {
                    return "ScriptVisualNotRefreshed";
                },
                enumerable: true,
                configurable: true
            });
            ScriptVisualRefreshWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'ScriptVisualRefreshWarningMessage';
                var detailKey = 'ScriptVisualRefreshWarningValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return ScriptVisualRefreshWarning;
        }());
        visuals.ScriptVisualRefreshWarning = ScriptVisualRefreshWarning;
        var DateSlicerNoDataWarning = /** @class */ (function () {
            function DateSlicerNoDataWarning() {
            }
            Object.defineProperty(DateSlicerNoDataWarning.prototype, "code", {
                get: function () {
                    return "DateSlicerNoData";
                },
                enumerable: true,
                configurable: true
            });
            DateSlicerNoDataWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_DateSlicerNoData';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return DateSlicerNoDataWarning;
        }());
        visuals.DateSlicerNoDataWarning = DateSlicerNoDataWarning;
        var DataLabelsNotRenderedWarning = /** @class */ (function () {
            function DataLabelsNotRenderedWarning() {
            }
            Object.defineProperty(DataLabelsNotRenderedWarning.prototype, "code", {
                get: function () {
                    return 'DataLabelsNotRendered';
                },
                enumerable: true,
                configurable: true
            });
            DataLabelsNotRenderedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'DataLabelsNotRenderedMessage';
                var detailKey = 'DataLabelsNotRenderedValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return DataLabelsNotRenderedWarning;
        }());
        visuals.DataLabelsNotRenderedWarning = DataLabelsNotRenderedWarning;
        var LegendFontSizeWarning = /** @class */ (function () {
            function LegendFontSizeWarning() {
            }
            Object.defineProperty(LegendFontSizeWarning.prototype, "code", {
                get: function () {
                    return 'LegendFontSize';
                },
                enumerable: true,
                configurable: true
            });
            LegendFontSizeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_LegendFontSize';
                var detailKey = 'Visual_ResponsiveWarningValue_LegendFontSize';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return LegendFontSizeWarning;
        }());
        visuals.LegendFontSizeWarning = LegendFontSizeWarning;
        var LegendNotRenderedWarning = /** @class */ (function () {
            function LegendNotRenderedWarning() {
            }
            Object.defineProperty(LegendNotRenderedWarning.prototype, "code", {
                get: function () {
                    return 'LegendNotRendered';
                },
                enumerable: true,
                configurable: true
            });
            LegendNotRenderedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_LegendNotRendered';
                var detailKey = 'Visual_ResponsiveWarningValue_LegendNotRendered';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return LegendNotRenderedWarning;
        }());
        visuals.LegendNotRenderedWarning = LegendNotRenderedWarning;
        var LegendLocationWarning = /** @class */ (function () {
            function LegendLocationWarning() {
            }
            Object.defineProperty(LegendLocationWarning.prototype, "code", {
                get: function () {
                    return 'LegendLocation';
                },
                enumerable: true,
                configurable: true
            });
            LegendLocationWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_LegendLocation';
                var detailKey = 'Visual_ResponsiveWarningValue_LegendLocation';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return LegendLocationWarning;
        }());
        visuals.LegendLocationWarning = LegendLocationWarning;
        var AxisFontSizeWarning = /** @class */ (function () {
            function AxisFontSizeWarning() {
            }
            Object.defineProperty(AxisFontSizeWarning.prototype, "code", {
                get: function () {
                    return 'AxisFontSize';
                },
                enumerable: true,
                configurable: true
            });
            AxisFontSizeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_AxisFontSize';
                var detailKey = 'Visual_ResponsiveWarningValue_AxisFontSize';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return AxisFontSizeWarning;
        }());
        visuals.AxisFontSizeWarning = AxisFontSizeWarning;
        var AxisAndAxisLabelsNotRenderedWarning = /** @class */ (function () {
            function AxisAndAxisLabelsNotRenderedWarning() {
            }
            Object.defineProperty(AxisAndAxisLabelsNotRenderedWarning.prototype, "code", {
                get: function () {
                    return 'AxisAndAxisLabelsNotRendered';
                },
                enumerable: true,
                configurable: true
            });
            AxisAndAxisLabelsNotRenderedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_AxisNotRendered';
                var detailKey = 'Visual_ResponsiveWarningValue_AxisNotRendered';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return AxisAndAxisLabelsNotRenderedWarning;
        }());
        visuals.AxisAndAxisLabelsNotRenderedWarning = AxisAndAxisLabelsNotRenderedWarning;
        var AxisLabelsNotRenderedWarning = /** @class */ (function () {
            function AxisLabelsNotRenderedWarning() {
            }
            Object.defineProperty(AxisLabelsNotRenderedWarning.prototype, "code", {
                get: function () {
                    return 'AxisLabelsNotRendered';
                },
                enumerable: true,
                configurable: true
            });
            AxisLabelsNotRenderedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_AxisLabelNotRendered';
                var detailKey = 'Visual_ResponsiveWarningValue_AxisLabelNotRendered';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return AxisLabelsNotRenderedWarning;
        }());
        visuals.AxisLabelsNotRenderedWarning = AxisLabelsNotRenderedWarning;
        var SlicerHeaderNotRenderedWarning = /** @class */ (function () {
            function SlicerHeaderNotRenderedWarning() {
            }
            Object.defineProperty(SlicerHeaderNotRenderedWarning.prototype, "code", {
                get: function () {
                    return 'SlicerHeaderNotRendered';
                },
                enumerable: true,
                configurable: true
            });
            SlicerHeaderNotRenderedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_SlicerHeaderNotRendered';
                var detailKey = 'Visual_ResponsiveWarningValue_SlicerHeaderNotRendered';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return SlicerHeaderNotRenderedWarning;
        }());
        visuals.SlicerHeaderNotRenderedWarning = SlicerHeaderNotRenderedWarning;
        var SlicerHeaderFontSizeWarning = /** @class */ (function () {
            function SlicerHeaderFontSizeWarning() {
            }
            Object.defineProperty(SlicerHeaderFontSizeWarning.prototype, "code", {
                get: function () {
                    return 'SlicerHeaderFontSize';
                },
                enumerable: true,
                configurable: true
            });
            SlicerHeaderFontSizeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_ResponsiveWarningMessage_SlicerHeaderFontSize';
                var detailKey = 'Visual_ResponsiveWarningValue_SlicerHeaderFontSize';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return SlicerHeaderFontSizeWarning;
        }());
        visuals.SlicerHeaderFontSizeWarning = SlicerHeaderFontSizeWarning;
        var NoIdentityExprWarning = /** @class */ (function () {
            function NoIdentityExprWarning() {
            }
            Object.defineProperty(NoIdentityExprWarning.prototype, "code", {
                get: function () {
                    return NoIdentityExprWarning.code;
                },
                enumerable: true,
                configurable: true
            });
            NoIdentityExprWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoIdentityExprMessage';
                var detailKey = 'NoIdentityExprValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            };
            NoIdentityExprWarning.code = 'NoIdentityExprWarning';
            return NoIdentityExprWarning;
        }());
        visuals.NoIdentityExprWarning = NoIdentityExprWarning;
        var OnRestoreSelectionNotSupportedWarning = /** @class */ (function () {
            function OnRestoreSelectionNotSupportedWarning() {
            }
            Object.defineProperty(OnRestoreSelectionNotSupportedWarning.prototype, "code", {
                get: function () {
                    return OnRestoreSelectionNotSupportedWarning.code;
                },
                enumerable: true,
                configurable: true
            });
            OnRestoreSelectionNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = "Visual_Error_SelectionNotShownMessage";
                var titleKey = "Visual_Error_SelectionNotShownKey";
                var detailKey = "Visual_Error_SelectionNotShownValue";
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey)
                };
                return visualMessage;
            };
            OnRestoreSelectionNotSupportedWarning.code = "OnRestoreSelectionNotSupportedWarning";
            return OnRestoreSelectionNotSupportedWarning;
        }());
        visuals.OnRestoreSelectionNotSupportedWarning = OnRestoreSelectionNotSupportedWarning;
        var VisualWarningBuilder = /** @class */ (function () {
            function VisualWarningBuilder() {
            }
            VisualWarningBuilder.prototype.add = function () {
                var warnings = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    warnings[_i] = arguments[_i];
                }
                debug.assertValue(warnings, "warnings");
                if (!this.warnings)
                    this.warnings = [];
                (_a = this.warnings).push.apply(_a, warnings);
                return this;
                var _a;
            };
            VisualWarningBuilder.prototype.addForVisualObject = function (objectName) {
                var objectWarnings = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    objectWarnings[_i - 1] = arguments[_i];
                }
                debug.assertValue(objectName, "objectName");
                debug.assertValue(objectWarnings, "objectWarning");
                if (!this.visualObjectWarnings)
                    this.visualObjectWarnings = {};
                var existingWarnings = this.visualObjectWarnings[objectName] = this.visualObjectWarnings[objectName] || [];
                existingWarnings.push.apply(existingWarnings, objectWarnings);
                return this;
            };
            VisualWarningBuilder.prototype.removeForVisualObject = function (objectName) {
                if (this.visualObjectWarnings) {
                    this.visualObjectWarnings[objectName] = undefined;
                }
                return this;
            };
            VisualWarningBuilder.prototype.complete = function () {
                if (!_.isEmpty(this.warnings) || this.visualObjectWarnings != null) {
                    return {
                        warnings: this.warnings,
                        visualObjectWarnings: this.visualObjectWarnings,
                    };
                }
                return undefined;
            };
            return VisualWarningBuilder;
        }());
        visuals.VisualWarningBuilder = VisualWarningBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Lazy = jsCommon.Lazy;
        var controls = powerbi.visuals.controls;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var TouchUtils = powerbi.visuals.TouchUtils;
        var PixelConverter = jsCommon.PixelConverter;
        var ContainerClassName = createClassAndSelector("tooltip-container");
        var ContentContainerClassName = createClassAndSelector("tooltip-content-container");
        var DataContainerClassName = createClassAndSelector("tooltip-data-container");
        var ActionsContainerClassName = createClassAndSelector("tooltip-actions-container");
        var HideActionsContainerClassName = createClassAndSelector("hide-actions");
        var HideActionButtonClassName = createClassAndSelector("hide-action-button");
        var GlyphIconClassName = createClassAndSelector("glyphicon");
        var CloseButtonClassName = createClassAndSelector("close-button");
        var CloseButtonGlyphClassName = createClassAndSelector("pbi-glyph-close");
        var DrillUpButtonClassName = createClassAndSelector("drill-up-button");
        var DrillUpButtonGlyphClassName = createClassAndSelector("pbi-glyph-drillup");
        var DrillDownButtonClassName = createClassAndSelector("drill-down-button");
        var DrillDownButtonGlyphClassName = createClassAndSelector("pbi-glyph-drilldowndisabled");
        var ArrowClassName = createClassAndSelector("arrow");
        var HideArrowClassName = createClassAndSelector("hide-arrow");
        var TooltipHeaderClassName = createClassAndSelector("tooltip-header");
        var TooltipRowClassName = createClassAndSelector("tooltip-row");
        var TooltipColorCellClassName = createClassAndSelector("tooltip-color-cell");
        var TooltipTitleCellClassName = createClassAndSelector("tooltip-title-cell");
        var TooltipValueCellClassName = createClassAndSelector("tooltip-value-cell");
        var SmallTouchScreenClassName = createClassAndSelector("small-touch-screen");
        var LargeTouchScreenClassName = createClassAndSelector("large-touch-screen");
        // tooltipTitleCellMaxWidth, tooltipValueCellMaxWidth, tooltipFontSize, tooltipTitleCellFontFamily and tooltipValuesCellFontFamily
        // should be sync with CSS class div.tooltip-title-cell and div.tooltip-value-cell in visuals.less
        var tooltipTitleCellMaxWidth = 260;
        var tooltipValueCellMaxWidth = 260;
        var tooltipFontSize = 11; //px
        var tooltipTitleCellFontFamily = visuals.Font.Family.regularSecondary.css;
        var tooltipValuesCellFontFamily = visuals.Font.Family.regular.css;
        var titleProperties = {
            fontFamily: tooltipTitleCellFontFamily,
            fontSize: PixelConverter.toString(tooltipFontSize),
        };
        var valueProperties = {
            fontFamily: tooltipValuesCellFontFamily,
            fontSize: PixelConverter.toString(tooltipFontSize),
        };
        var Ellipsis = '';
        var SmallTouchScreenThreshold = 540;
        var WideTooltipMargin = 8;
        visuals.DefaultTooltipOptions = {
            opacity: 1,
            animationDuration: 250,
            offsetX: 0,
            offsetY: 0
        };
        visuals.TouchOptimizedTooltipOptions = {
            opacity: 0.87,
            animationDuration: 250,
            offsetY: 30,
            offsetX: 30,
            showActions: true,
            hideArrow: true,
            touchOptimized: true
        };
        var TooltipContainer = /** @class */ (function () {
            function TooltipContainer(rootElement, options) {
                this.isTooltipVisible = false;
                this.rootElement = rootElement;
                this.originalTooltipOptions = $.extend({}, visuals.DefaultTooltipOptions, options);
                this.tooltipOptions = this.originalTooltipOptions;
            }
            TooltipContainer.prototype.isVisible = function () {
                return this.isTooltipVisible;
            };
            /** Note: For tests only */
            TooltipContainer.prototype.setTestScreenSize = function (width, height) {
                this.customScreenWidth = width;
                this.customScreenHeight = height;
            };
            TooltipContainer.prototype.show = function (tooltipData, clickedArea) {
                this.isTooltipVisible = true;
                var clickedScreenArea;
                var centerPointOffsetWidth;
                var centerPointOffsetHeight;
                var tooltipPosition;
                if (!this.tooltipContainer) {
                    this.tooltipContainer = this.createTooltipContainer(this.rootElement);
                }
                if (clickedArea) {
                    clickedScreenArea = this.getClickedScreenArea(clickedArea);
                    centerPointOffsetWidth = clickedArea.width >> 1;
                    centerPointOffsetHeight = clickedArea.height >> 1;
                    tooltipPosition = new controls.TouchUtils.Point(clickedArea.left + centerPointOffsetWidth, clickedArea.top + centerPointOffsetHeight);
                }
                if (tooltipData) {
                    this.setTooltipData(tooltipData, clickedScreenArea, tooltipPosition);
                }
                //sets display to the default (found in powerbi-visuals.css), which is flex
                this.tooltipContainer
                    .style("display", "")
                    .transition()
                    .duration(0) // Cancel previous transitions
                    .style("opacity", this.tooltipOptions.opacity);
                if (clickedArea) {
                    this.setPositionAndSize(clickedArea, clickedScreenArea, centerPointOffsetWidth, centerPointOffsetHeight, tooltipPosition);
                }
            };
            TooltipContainer.prototype.move = function (tooltipData, clickedArea) {
                debug.assertAnyValue(tooltipData, 'tooltipData');
                var clickedScreenArea;
                var centerPointOffsetWidth;
                var centerPointOffsetHeight;
                var tooltipPosition;
                if (!this.tooltipContainer) {
                    this.tooltipContainer = this.createTooltipContainer(this.rootElement);
                }
                clickedScreenArea = this.getClickedScreenArea(clickedArea);
                centerPointOffsetWidth = clickedArea.width >> 1;
                centerPointOffsetHeight = clickedArea.height >> 1;
                tooltipPosition = new controls.TouchUtils.Point(clickedArea.left + centerPointOffsetWidth, clickedArea.top + centerPointOffsetHeight);
                this.setPositionAndSize(clickedArea, clickedScreenArea, centerPointOffsetWidth, centerPointOffsetHeight, tooltipPosition);
                if (tooltipData) {
                    this.setTooltipData(tooltipData, clickedScreenArea, tooltipPosition);
                }
            };
            TooltipContainer.prototype.hide = function () {
                if (this.isTooltipVisible) {
                    this.isTooltipVisible = false;
                    this.tooltipContainer
                        .transition()
                        .duration(this.tooltipOptions.animationDuration)
                        .style("opacity", 0)
                        .each('end', (function () { this.style.display = "none"; }));
                }
            };
            TooltipContainer.prototype.setTooltipAppearanceOptions = function (options) {
                var mergedOptions = $.extend({}, this.originalTooltipOptions, options);
                this.tooltipOptions = mergedOptions;
                if (this.tooltipContainer) {
                    this.getActionsContainerElement().classed(HideActionsContainerClassName.class, !this.tooltipOptions.showActions);
                }
            };
            TooltipContainer.prototype.createTooltipContainer = function (root) {
                var container = d3.select(root)
                    .append("div")
                    .classed(ContainerClassName.class, true);
                container.append("div").classed(ArrowClassName.class, true);
                var contentContainer = container.append("div").classed(ContentContainerClassName.class, true);
                contentContainer.append("div").classed(DataContainerClassName.class, true);
                var actionsContainer = contentContainer.append("div")
                    .classed(ActionsContainerClassName.class, true)
                    .classed(HideActionsContainerClassName.class, !this.tooltipOptions.showActions);
                this.fillActionsContainer(actionsContainer);
                container.style("display", "none");
                return container;
            };
            TooltipContainer.prototype.fillActionsContainer = function (actionsContainer) {
                var _this = this;
                this.addActionButton(actionsContainer, CloseButtonClassName.class, CloseButtonGlyphClassName.class, (function () { _this.hide(); }));
                var drillUpButton = this.addActionButton(actionsContainer, DrillUpButtonClassName.class, DrillUpButtonGlyphClassName.class, null);
                drillUpButton.classed(HideActionButtonClassName.class, true);
                var drillDownButton = this.addActionButton(actionsContainer, DrillDownButtonClassName.class, DrillDownButtonGlyphClassName.class, null);
                drillDownButton.classed(HideActionButtonClassName.class, true);
            };
            TooltipContainer.prototype.addActionButton = function (actionsContainer, buttonClass, glyphClass, action) {
                var actionButton = actionsContainer.append("button")
                    .classed(buttonClass, true);
                actionButton.append("div")
                    .classed(GlyphIconClassName.class, true)
                    .classed(glyphClass, true);
                actionButton.on("click", action);
                return actionButton;
            };
            TooltipContainer.prototype.setTooltipData = function (tooltipData, clickedScreenArea, tooltipPosition) {
                if (_.isEqual(tooltipData, this.currentContent))
                    return;
                this.currentContent = tooltipData;
                var rowsSelector = TooltipRowClassName.selector;
                var dataContainer = this.tooltipContainer.select(DataContainerClassName.selector);
                // Clear existing content
                dataContainer.selectAll(TooltipHeaderClassName.selector).remove();
                dataContainer.selectAll(TooltipRowClassName.selector).remove();
                if (tooltipData.length === 0)
                    return;
                if (tooltipData[0].header) {
                    dataContainer.append("div").attr("class", TooltipHeaderClassName.class).text(tooltipData[0].header);
                }
                var tooltipRow = dataContainer.selectAll(rowsSelector).data(tooltipData);
                var newRow = tooltipRow.enter().append("div").attr("class", TooltipRowClassName.class);
                if (_.any(tooltipData, (function (tooltipItem) { return tooltipItem.color; }))) {
                    var newColorCell = newRow.filter((function (d) { return d.color; })).append("div").attr("class", TooltipColorCellClassName.class);
                    newColorCell
                        .style('max-width', (function (d) { return d.lineStyle ? '31px' : '13px'; }));
                    var svg = newColorCell
                        .append('svg');
                    svg
                        .attr({
                        'width': function (d) { return d.lineStyle ? TooltipContainer.IconLineTotalWidth : '100%'; },
                        'height': '15px'
                    });
                    // line path
                    svg
                        .append('path')
                        .attr({
                        'transform': function (d) { return visuals.SVGUtil.translateAndScale(d.lineStyle ? TooltipContainer.IconLineTotalWidth / 2 : 5, 8, 5 / visuals.Markers.defaultSize); },
                        'd': function (d) { return d.lineStyle ? 'M 0 0 M -' + TooltipContainer.IconLineTotalWidth / 2 + ' 0 L ' + TooltipContainer.IconLineTotalWidth / 2 + ' 0' : null; },
                    })
                        .style({
                        'stroke': function (d) { return d.lineColor; },
                        'stroke-opacity': 1,
                        'stroke-width': function (d) { return 2; },
                        'stroke-dasharray': function (d) { return d.lineStyle ? visuals.LineStyle.getSrokeDashArrayForLegend(d.lineStyle) : null; },
                    });
                    // marker path
                    svg
                        .append('path')
                        .attr({
                        'transform': function (d) { return visuals.SVGUtil.translateAndScale(d.lineStyle ? TooltipContainer.IconLineTotalWidth / 2 : 5, 8, 5 / visuals.Markers.defaultSize); },
                        'd': function (d) { return visuals.Markers.getPath(d.markerShape || visuals.markerShape.defaultValue); },
                    })
                        .style({
                        'fill': function (d) { return d.color; },
                        'stroke': function (d) { return d.color; },
                        'fill-opacity': function (d) { return d.opacity != null ? d.opacity : 1; },
                        'stroke-opacity': function (d) { return d.opacity != null ? d.opacity : 1; },
                    });
                }
                var newTitleCell = newRow
                    .append("div")
                    .attr("class", TooltipTitleCellClassName.class)
                    .text((function (d) { return d.displayName; }));
                var newValueCell = newRow
                    .append("div")
                    .attr("class", TooltipValueCellClassName.class)
                    .text((function (d) { return d.value; }));
                this.updateTooltipTextLines(tooltipData, newTitleCell, newValueCell, clickedScreenArea, tooltipPosition);
            };
            TooltipContainer.prototype.updateTooltipTextLines = function (tooltipData, newTitleCell, newValueCell, clickedScreenArea, tooltipPosition) {
                var tooltipYPosition = tooltipPosition ? tooltipPosition.y : 0;
                var tooltipTotalHeight;
                switch (clickedScreenArea) {
                    case 0 /* TopLeft */:
                    case 1 /* TopRight */:
                        tooltipTotalHeight = (this.customScreenHeight || window.innerHeight) - tooltipYPosition;
                        break;
                    case 3 /* BottomLeft */:
                    case 2 /* BottomRight */:
                        tooltipTotalHeight = tooltipYPosition;
                }
                var rowHeight = Math.max(powerbi.TextMeasurementService.estimateSvgTextHeight(titleProperties), powerbi.TextMeasurementService.estimateSvgTextHeight(valueProperties));
                var totalAllowedRows = tooltipTotalHeight / rowHeight;
                var totalNeededRows = 0;
                var neededRows = [];
                var allowedRows = [];
                var titleWordsList = [];
                var valueWordsList = [];
                var tooltipContainer = this;
                for (var index = 0; index < tooltipData.length; index++) {
                    titleWordsList[index] = jsCommon.WordBreaker.splitByWidth(tooltipData[index].displayName, titleProperties, powerbi.TextMeasurementService.measureSvgTextWidth, tooltipTitleCellMaxWidth, totalAllowedRows, /*truncator*/ null, /*splitLongWords*/ false, /*preserveNewLines*/ true);
                    valueWordsList[index] = jsCommon.WordBreaker.splitByWidth(tooltipData[index].value, valueProperties, powerbi.TextMeasurementService.measureSvgTextWidth, tooltipValueCellMaxWidth, totalAllowedRows, /*truncator*/ null, /*splitLongWords*/ false, /*preserveNewLines*/ true);
                    var neededRowForCurrentTooltip = Math.max(titleWordsList[index].length, valueWordsList[index].length);
                    neededRows.push(neededRowForCurrentTooltip);
                    totalNeededRows += neededRowForCurrentTooltip;
                }
                // If there is enough space for every tooltip, give them what they need.
                if (totalNeededRows <= totalAllowedRows) {
                    allowedRows = neededRows;
                }
                else {
                    var remainingRows = totalAllowedRows - tooltipData.length;
                    for (var index = 0; index < tooltipData.length; index++) {
                        allowedRows[index] = 1 + Math.round(Math.max(remainingRows, 0) * (neededRows[index] / totalAllowedRows));
                    }
                }
                newTitleCell.each((function (_d, index) { tooltipContainer.placeTooltip(this, titleProperties, rowHeight, tooltipTitleCellMaxWidth, allowedRows[index], titleWordsList[index]); }));
                newValueCell.each((function (_d, index) { tooltipContainer.placeTooltip(this, valueProperties, rowHeight, tooltipValueCellMaxWidth, allowedRows[index], valueWordsList[index]); }));
            };
            TooltipContainer.prototype.placeTooltip = function (element, properties, rowHeight, maxWidth, maxNumLines, words) {
                var node = d3.select(element);
                element.textContent = null;
                // Merge the last two possible rows
                if (words.length > maxNumLines + 1) {
                    words[maxNumLines - 1] += words[maxNumLines] + Ellipsis;
                }
                else if (words.length > maxNumLines) {
                    words[maxNumLines - 1] += words[maxNumLines];
                }
                for (var i = 0, len = Math.min(words.length, maxNumLines); i < len; i++) {
                    properties.text = words[i];
                    node.append('div')
                        .attr({
                        'x': 0,
                        'dy': i === 0 ? 0 : rowHeight,
                    })
                        .text(powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, maxWidth));
                }
            };
            TooltipContainer.prototype.getTooltipContainerBounds = function () {
                var tooltipContainerBounds;
                if (this.tooltipContainer.style("display") === "none") {
                    this.tooltipContainer.style("display", "");
                    tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
                    this.tooltipContainer.style("display", "none");
                }
                else {
                    tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
                }
                return tooltipContainerBounds;
            };
            TooltipContainer.prototype.updateTooltipPosition = function (clickedArea, clickedScreenArea, centerPointOffsetWidth, centerPointOffsetHeight, tooltipPosition) {
                var tooltipContainerBounds = this.getTooltipContainerBounds();
                var offsetX = 0;
                var offsetY = 0;
                var arrowOffset = this.tooltipOptions.hideArrow ? 0 : 7;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffsetWidth;
                    offsetY -= 2 * arrowOffset + centerPointOffsetHeight;
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffsetWidth);
                    offsetY -= 2 * arrowOffset + centerPointOffsetHeight;
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffsetWidth;
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffsetHeight);
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffsetWidth);
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffsetHeight);
                }
                // Offsets are always towards the center of the screen
                // (e.g. if the clicked area is at the bottom right area, then the offsets will move the tooltip up and left).
                var optionsOffsetX = (clickedScreenArea === 0 /* TopLeft */ || clickedScreenArea === 3 /* BottomLeft */)
                    ? this.tooltipOptions.offsetX
                    : (-this.tooltipOptions.offsetX);
                var optionsOffsetY = (clickedScreenArea === 0 /* TopLeft */ || clickedScreenArea === 1 /* TopRight */)
                    ? this.tooltipOptions.offsetY
                    : (-this.tooltipOptions.offsetY);
                offsetX += optionsOffsetX;
                offsetY += optionsOffsetY;
                tooltipPosition.offset(offsetX, offsetY);
                return tooltipPosition;
            };
            TooltipContainer.prototype.setPositionAndSize = function (clickedArea, clickedScreenArea, centerPointOffsetWidth, centerPointOffsetHeight, tooltipPosition) {
                tooltipPosition = this.updateTooltipPosition(clickedArea, clickedScreenArea, centerPointOffsetWidth, centerPointOffsetHeight, tooltipPosition);
                var tooltipRect = this.widenTooltipIfNeeded(tooltipPosition);
                this.setTooltipContainerClass(clickedScreenArea);
                this.tooltipContainer.style({ "left": tooltipRect.left + "px", "top": tooltipRect.top + "px" });
                this.getDataContainerElement().style("width", tooltipRect.width ? (tooltipRect.width + "px") : "");
                this.setArrowPosition(clickedScreenArea);
            };
            TooltipContainer.prototype.widenTooltipIfNeeded = function (tooltipPosition) {
                var tooltipRect = {
                    left: tooltipPosition.x,
                    top: tooltipPosition.y,
                    width: undefined,
                    height: undefined // by default height is calculated depending on the content
                };
                // If the screen is narrow enough (mainly for mobile scenario), the tooltip should take the screen's width,
                // and reset any other tooltip option defined
                if (this.isNarrowTouchScreen()) {
                    tooltipRect.left = WideTooltipMargin;
                    var screenWidth = this.getScreenBounds().width;
                    tooltipRect.width = screenWidth - (2 * WideTooltipMargin);
                }
                return tooltipRect;
            };
            TooltipContainer.prototype.setTooltipContainerClass = function (clickedScreenArea) {
                var tooltipContainerClassName;
                switch (clickedScreenArea) {
                    case 0 /* TopLeft */:
                    case 3 /* BottomLeft */:
                        tooltipContainerClassName = 'left';
                        break;
                    case 1 /* TopRight */:
                    case 2 /* BottomRight */:
                        tooltipContainerClassName = 'right';
                        break;
                }
                this.tooltipContainer
                    .attr('class', ContainerClassName.class) // Reset all classes
                    .classed(tooltipContainerClassName, true)
                    .classed(SmallTouchScreenClassName.class, this.isSmallTouchScreen())
                    .classed(LargeTouchScreenClassName.class, this.isLargeTouchScreen());
            };
            TooltipContainer.prototype.setArrowPosition = function (clickedScreenArea) {
                var arrow = this.getArrowElement();
                var arrowClassName;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    arrowClassName = "top left";
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    arrowClassName = "top right";
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    arrowClassName = "bottom left";
                }
                else {
                    arrowClassName = "bottom right";
                }
                arrow
                    .attr('class', 'arrow') // Reset all classes
                    .classed(arrowClassName, true)
                    .classed(HideArrowClassName.class, this.tooltipOptions.hideArrow);
            };
            TooltipContainer.prototype.getClickedScreenArea = function (clickedArea) {
                var screenBounds = this.getScreenBounds();
                var centerPointOffset = clickedArea.width / 2;
                var centerPoint = new controls.TouchUtils.Point(clickedArea.left + centerPointOffset, clickedArea.top + centerPointOffset);
                var halfWidth = screenBounds.width / 2;
                var halfHeight = screenBounds.height / 2;
                if (centerPoint.x < halfWidth && centerPoint.y < halfHeight) {
                    return 0 /* TopLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y < halfHeight) {
                    return 1 /* TopRight */;
                }
                else if (centerPoint.x < halfWidth && centerPoint.y >= halfHeight) {
                    return 3 /* BottomLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y >= halfHeight) {
                    return 2 /* BottomRight */;
                }
            };
            TooltipContainer.prototype.isNarrowTouchScreen = function () {
                return this.tooltipOptions.touchOptimized && (this.getScreenBounds().width <= SmallTouchScreenThreshold);
            };
            TooltipContainer.prototype.isSmallTouchScreen = function () {
                if (!this.tooltipOptions.touchOptimized) {
                    return false;
                }
                // Getting screen bounds only if touchOptimized is true to avoid unnecessary page layout
                var screenBounds = this.getScreenBounds();
                return screenBounds.width <= SmallTouchScreenThreshold || screenBounds.height <= SmallTouchScreenThreshold;
            };
            TooltipContainer.prototype.isLargeTouchScreen = function () {
                return this.tooltipOptions.touchOptimized && !this.isSmallTouchScreen();
            };
            TooltipContainer.prototype.getArrowElement = function () {
                return this.tooltipContainer.select(ArrowClassName.selector);
            };
            TooltipContainer.prototype.getActionsContainerElement = function () {
                return this.tooltipContainer.select(ActionsContainerClassName.selector);
            };
            TooltipContainer.prototype.getDataContainerElement = function () {
                return this.tooltipContainer.select(DataContainerClassName.selector);
            };
            TooltipContainer.prototype.getScreenBounds = function () {
                return {
                    width: this.customScreenWidth || window.innerWidth,
                    height: this.customScreenHeight || window.innerHeight
                };
            };
            TooltipContainer.IconLineTotalWidth = 31;
            return TooltipContainer;
        }());
        visuals.TooltipContainer = TooltipContainer;
        /**
         * Legacy tooltip component. Please use the tooltip host service instead.
         */
        var ToolTipComponent = /** @class */ (function () {
            function ToolTipComponent(tooltipOptions) {
                this.tooltipOptions = tooltipOptions;
                if (!tooltipOptions) {
                    this.tooltipOptions = visuals.DefaultTooltipOptions;
                }
                // NOTE: This will be called statically by the TooltipManager, thus we need to defer creation of the tooltip container until we actually have a root element.
            }
            ToolTipComponent.prototype.isTooltipComponentVisible = function () {
                return this.tooltipContainer && this.tooltipContainer.isVisible();
            };
            ToolTipComponent.prototype.show = function (tooltipData, clickedArea) {
                this.ensureTooltipContainer();
                this.tooltipContainer.show(tooltipData, this.convertRect(clickedArea));
            };
            ToolTipComponent.prototype.move = function (tooltipData, clickedArea) {
                this.ensureTooltipContainer();
                this.tooltipContainer.move(tooltipData, this.convertRect(clickedArea));
            };
            ToolTipComponent.prototype.hide = function () {
                this.ensureTooltipContainer();
                this.tooltipContainer.hide();
            };
            ToolTipComponent.prototype.setTooltipAppearanceOptions = function (options) {
                this.ensureTooltipContainer();
                this.tooltipContainer.setTooltipAppearanceOptions(options);
            };
            ToolTipComponent.prototype.convertRect = function (rect) {
                return new visuals.Rect(rect.x, rect.y, rect.width, rect.height);
            };
            ToolTipComponent.prototype.ensureTooltipContainer = function () {
                if (!this.tooltipContainer) {
                    var root = $(ToolTipComponent.parentContainerSelector).get(0);
                    this.tooltipContainer = new TooltipContainer(root, this.tooltipOptions);
                }
            };
            ToolTipComponent.parentContainerSelector = "body";
            ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName";
            return ToolTipComponent;
        }());
        visuals.ToolTipComponent = ToolTipComponent;
        /**
         * Legacy tooltip management API. Please use the tooltip host service instead.
         */
        var TooltipManager;
        (function (TooltipManager) {
            var GlobalTooltipEventsAttached = false;
            TooltipManager.ShowTooltips = true;
            TooltipManager.ShowTouchScreenOptimizedTooltips = true;
            TooltipManager.ToolTipInstance = new ToolTipComponent();
            TooltipManager.tooltipMouseOverDelay = 350;
            TooltipManager.tooltipMouseOutDelay = 500;
            TooltipManager.tooltipTouchDelay = 350;
            TooltipManager.handleTouchDelay = 1000;
            var tooltipTimeoutId;
            var handleTouchTimeoutId = 0;
            var mouseCoordinates;
            var tooltipData;
            function removeTooltips(selection) {
                selection.on('.tooltip', null);
            }
            TooltipManager.removeTooltips = removeTooltips;
            function addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove, onMouseOutDelegate) {
                if (!TooltipManager.ShowTooltips) {
                    return;
                }
                debug.assertValue(selection, "selection");
                var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                // Mouse events
                selection.on("mouseover.tooltip", (function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    // Ignore mouseover while handling touch events
                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
                        return;
                    mouseCoordinates = visuals.getCoordinates(rootNode, true);
                    var elementCoordinates = visuals.getCoordinates(target, true);
                    var tooltipEvent = {
                        data: data,
                        coordinates: mouseCoordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: false
                    };
                    clearTooltipTimeout();
                    // if it is already visible, change contents immediately (use 16ms minimum perceivable frame rate to prevent thrashing)
                    var delay = TooltipManager.ToolTipInstance.isTooltipComponentVisible() ? 16 : TooltipManager.tooltipMouseOverDelay;
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delay);
                }));
                selection.on("mouseout.tooltip", (function () {
                    if (!handleTouchTimeoutId) {
                        clearTooltipTimeout();
                        tooltipTimeoutId = hideDelayedTooltip();
                    }
                    if (onMouseOutDelegate) {
                        onMouseOutDelegate();
                    }
                }));
                selection.on("mousemove.tooltip", (function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    // Ignore mousemove while handling touch events
                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
                        return;
                    mouseCoordinates = visuals.getCoordinates(rootNode, true);
                    var elementCoordinates = visuals.getCoordinates(target, true);
                    var tooltipEvent = {
                        data: data,
                        coordinates: mouseCoordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: false
                    };
                    moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                }));
                // --- Touch events ---
                // TODO: static?
                var touchStartEventName = TouchUtils.touchStartEventName();
                var touchMoveEventName = TouchUtils.touchMoveEventName();
                var touchEndEventName = TouchUtils.touchEndEventName();
                var isPointerEvent = touchStartEventName === "pointerdown" || touchStartEventName === "MSPointerDown";
                if (!GlobalTooltipEventsAttached) {
                    // Add root container hide tooltip event
                    attachGlobalEvents(touchStartEventName);
                    GlobalTooltipEventsAttached = true;
                }
                selection.on(touchStartEventName + ".tooltip", (function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    hideTooltipEventHandler();
                    var coordinates = visuals.getCoordinates(rootNode, isPointerEvent);
                    var elementCoordinates = visuals.getCoordinates(target, isPointerEvent);
                    var tooltipEvent = {
                        data: data,
                        coordinates: coordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: true
                    };
                    clearTooltipTimeout();
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, TooltipManager.tooltipTouchDelay);
                }));
                // If touch optimal tooltips are enabled, add scrubbing between data points using touchmove event
                if (TooltipManager.ShowTouchScreenOptimizedTooltips) {
                    selection.on(touchMoveEventName + ".tooltip", (function () {
                        var coordinates = visuals.getCoordinates(rootNode, isPointerEvent);
                        var target = document.elementFromPoint(coordinates[0], coordinates[1]);
                        var data = d3.select(target).datum();
                        var elementCoordinates = visuals.getCoordinates(target, isPointerEvent);
                        var tooltipEvent = {
                            data: data,
                            coordinates: mouseCoordinates,
                            elementCoordinates: elementCoordinates,
                            context: target,
                            isTouchEvent: true
                        };
                        moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, true);
                    }));
                }
                selection.on(touchEndEventName + ".tooltip", (function () {
                    if (!TooltipManager.ShowTouchScreenOptimizedTooltips) {
                        // Touch screen optimized tooltips disabled. Hide tooltip on touchend.
                        clearTooltipTimeout();
                        tooltipTimeoutId = hideDelayedTooltip();
                    }
                    else if (!TooltipManager.ToolTipInstance.isTooltipComponentVisible()) {
                        // Touch screen optimized tooltips enabled and tooltip is currently not visible.
                        // Clearing the timeout to make sure the tooltip is not about to be opened after timeout
                        // (implementation of tap and hold to open tooltip - if timeout threshold was not met until touchend, do not open tooltip).
                        clearTooltipTimeout();
                    }
                    if (handleTouchTimeoutId)
                        clearTimeout(handleTouchTimeoutId);
                    // At the end of touch action, set a timeout that will let us ignore the incoming mouse events for a small amount of time
                    handleTouchTimeoutId = setTimeout((function () {
                        handleTouchTimeoutId = 0;
                    }), TooltipManager.handleTouchDelay);
                }));
            }
            TooltipManager.addTooltip = addTooltip;
            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                return setTimeout((function () { return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate); }), delayInMs);
            }
            function hideDelayedTooltip() {
                return setTimeout((function () { return hideTooltipEventHandler(); }), TooltipManager.tooltipMouseOutDelay);
            }
            function setLocalizedStrings(localizationOptions) {
                ToolTipComponent.localizationOptions = localizationOptions;
            }
            TooltipManager.setLocalizedStrings = setLocalizedStrings;
            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                var tooltipInfo = tooltipData || getTooltipInfoDelegate(tooltipEvent);
                if (!_.isEmpty(tooltipInfo)) {
                    var isOptimizedTouchEvent = tooltipEvent.isTouchEvent && TooltipManager.ShowTouchScreenOptimizedTooltips;
                    TooltipManager.ToolTipInstance.setTooltipAppearanceOptions(isOptimizedTouchEvent ? visuals.TouchOptimizedTooltipOptions : visuals.DefaultTooltipOptions);
                    var coordinates = mouseCoordinates || tooltipEvent.coordinates;
                    var clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                }
            }
            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                tooltipData = undefined;
                if (reloadTooltipDataOnMouseMove) {
                    tooltipData = getTooltipInfoDelegate(tooltipEvent);
                }
                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                TooltipManager.ToolTipInstance.move(tooltipData, clickedArea);
            }
            function hideTooltipEventHandler() {
                TooltipManager.ToolTipInstance.hide();
            }
            function clearTooltipTimeout() {
                if (tooltipTimeoutId) {
                    clearTimeout(tooltipTimeoutId);
                }
            }
            function canDisplayTooltip(d3Event) {
                var cadDisplay = true;
                var mouseEvent = d3Event;
                if (mouseEvent.buttons !== undefined) {
                    // Check mouse buttons state
                    var hasMouseButtonPressed = mouseEvent.buttons !== 0;
                    cadDisplay = !hasMouseButtonPressed;
                }
                return cadDisplay;
            }
            function attachGlobalEvents(touchStartEventName) {
                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, (function (d, i) {
                    TooltipManager.ToolTipInstance.hide();
                }));
            }
            function getClickedArea(x, y, isTouchEvent) {
                var width = 0;
                var pointX = x;
                var pointY = y;
                if (isTouchEvent) {
                    width = 12;
                    var offset = width / 2;
                    pointX = Math.max(x - offset, 0);
                    pointY = Math.max(y - offset, 0);
                }
                return new controls.TouchUtils.Rectangle(pointX, pointY, width, width);
            }
        })(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
        var TooltipBuilder;
        (function (TooltipBuilder) {
            // TODO: implement options bag as input parameter
            function createTooltipInfo(formatStringProp, dataViewCat, categoryValue, value, categories, seriesData, seriesIndex, categoryIndex, highlightedValue, gradientValueColumn) {
                var categorySource;
                var seriesSource = [];
                var valuesSource;
                seriesIndex = seriesIndex | 0;
                var categoriesData = dataViewCat ? dataViewCat.categories : categories;
                if (categoriesData && categoriesData.length > 0) {
                    if (categoriesData.length > 1) {
                        var compositeCategoriesData = [];
                        for (var i = 0, ilen = categoriesData.length; i < ilen; i++) {
                            compositeCategoriesData.push(categoriesData[i].source);
                        }
                        categorySource = { value: categoryValue, metadata: compositeCategoriesData };
                    }
                    else {
                        categorySource = { value: categoryValue, metadata: [categoriesData[0].source] };
                    }
                }
                if (dataViewCat && dataViewCat.values) {
                    if (categorySource && categorySource.metadata[0] === dataViewCat.values.source) {
                        // Category/series on the same column -- don't repeat its value in the tooltip.
                    }
                    else {
                        valuesSource = dataViewCat.values.source;
                    }
                    if (dataViewCat.values.length > 0) {
                        var valueColumn = dataViewCat.values[seriesIndex];
                        var isAutoGeneratedColumn = !!(valueColumn && valueColumn.source && valueColumn.source.isAutoGeneratedColumn);
                        if (!isAutoGeneratedColumn) {
                            seriesSource.push({ value: value, highlightedValue: highlightedValue, metadata: valueColumn });
                        }
                    }
                    //Create Gradient tooltip value
                    var gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
                    if (gradientToolTipData != null)
                        seriesSource.push(gradientToolTipData);
                }
                if (seriesData) {
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        var singleSeriesData = seriesData[i];
                        if (categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source)
                            continue;
                        seriesSource.push({ value: singleSeriesData.value, metadata: singleSeriesData.metadata });
                    }
                }
                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                return tooltipInfo;
            }
            TooltipBuilder.createTooltipInfo = createTooltipInfo;
            function createGradientToolTipData(gradientValueColumn, categoryIndex) {
                if (gradientValueColumn) {
                    // Saturation color
                    return { value: gradientValueColumn.values[categoryIndex], metadata: { source: gradientValueColumn.source, values: [] } };
                }
                return null;
            }
            TooltipBuilder.createGradientToolTipData = createGradientToolTipData;
            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                debug.assertValue(seriesValues, "seriesSource");
                debug.assertValue(ToolTipComponent.localizationOptions, "ToolTipComponent.localizationOptions");
                debug.assertAnyValue(formatStringProp, 'formatStringProp');
                var items = [];
                if (categoryValue) {
                    if (categoryValue.metadata.length > 1) {
                        var displayName = '';
                        // This is being done simply for lat/long for now, as that's the only composite category we use.  If we ever have tooltips
                        //   involving other composite categories, we need to do a more thorough design and be more careful here.
                        for (var i = 0, ilen = categoryValue.metadata.length; i < ilen; i++) {
                            if (i !== 0)
                                displayName += '/';
                            displayName += categoryValue.metadata[i].displayName;
                        }
                        var categoryFormattedValue = visuals.converterHelper.formatFromMetadataColumn(categoryValue.value, categoryValue.metadata[0], formatStringProp);
                        items.push({ displayName: displayName, value: categoryFormattedValue });
                    }
                    else {
                        var categoryFormattedValue = visuals.converterHelper.formatFromMetadataColumn(categoryValue.value, categoryValue.metadata[0], formatStringProp);
                        items.push({ displayName: categoryValue.metadata[0].displayName, value: categoryFormattedValue });
                    }
                }
                if (valuesSource) {
                    // Dynamic series value
                    var dynamicValue = void 0;
                    if (seriesValues.length > 0) {
                        var dynamicValueMetadata = seriesValues[0].metadata.source;
                        dynamicValue = visuals.converterHelper.formatFromMetadataColumn(dynamicValueMetadata.groupName, valuesSource, formatStringProp);
                    }
                    items.push({ displayName: valuesSource.displayName, value: dynamicValue });
                }
                for (var _i = 0, seriesValues_1 = seriesValues; _i < seriesValues_1.length; _i++) {
                    var seriesData = seriesValues_1[_i];
                    if (seriesData && seriesData.metadata) {
                        var seriesMetadataColumn = seriesData.metadata.source;
                        var value = seriesData.value;
                        var highlightedValue = seriesData.highlightedValue;
                        if (value || value === 0) {
                            var formattedValue = visuals.converterHelper.formatFromMetadataColumn(value, seriesMetadataColumn, formatStringProp, /*suppressTypeFallback*/ false);
                            items.push({ displayName: seriesMetadataColumn.displayName, value: formattedValue });
                        }
                        if (highlightedValue || highlightedValue === 0) {
                            var formattedHighlightedValue = visuals.converterHelper.formatFromMetadataColumn(highlightedValue, seriesMetadataColumn, formatStringProp, /*suppressTypeFallback*/ false);
                            var displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                            items.push({ displayName: displayName, value: formattedHighlightedValue });
                        }
                    }
                }
                return items;
            }
            function addTooltipMeasures(reader, tooltipInfo, categoryIndex, seriesIndex, formatStringProp) {
                var tooltipValues = reader.data.getAllValuesForRole("Tooltips", categoryIndex, seriesIndex);
                var displayNames = reader.data.getAllValueDisplayNamesForRole("Tooltips");
                var columnMetadatas = reader.columns.getAllValueMetadataColumnsForRole('Tooltips', seriesIndex);
                if (tooltipValues) {
                    for (var j = 0; j < tooltipValues.length; j++) {
                        if (tooltipValues[j] != null) {
                            tooltipInfo.push({
                                displayName: displayNames[j],
                                value: visuals.converterHelper.formatFromMetadataColumn(tooltipValues[j], columnMetadatas[j], formatStringProp, /*suppressTypeFallback*/ false),
                            });
                        }
                    }
                }
            }
            TooltipBuilder.addTooltipMeasures = addTooltipMeasures;
        })(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
        var LazyTooltipBuilder = /** @class */ (function () {
            function LazyTooltipBuilder() {
                this.items = [];
                this.columns = [];
            }
            LazyTooltipBuilder.prototype.withColumnValueByIndex = function (column, valueIndex, allowNulls, formatter) {
                if (!column)
                    return this;
                var value = column.values[valueIndex];
                return this.withColumnValue(column.source, value, allowNulls, formatter);
            };
            LazyTooltipBuilder.prototype.withColumnValue = function (source, value, allowNulls, formatter) {
                if (!source)
                    return this;
                if (!allowNulls && value == null)
                    return this;
                // Avoid duplicate tooltip items for the same column
                if (_.contains(this.columns, source.queryName))
                    return this;
                this.columns.push(source.queryName);
                this.items.push(new Lazy(function () { return ({
                    displayName: source.displayName,
                    value: formatter(value, source)
                }); }));
                return this;
            };
            LazyTooltipBuilder.prototype.withMultipleColumnAndValues = function (sources, values, allowNulls, formatter) {
                if (!sources)
                    return this;
                debug.assert(sources.length === values.length, 'CategoricalLazyTooltipBuilder:withMultipleColumnAndValues: unexpected count of sources & values');
                if (!allowNulls && _.all(values, (function (value) { return value == null; })))
                    return this;
                var concatenatedQueryName = visuals.DataViewConcatenateUtil.concatenateValues(_.map(sources, (function (source) { return source.queryName; })));
                if (_.contains(this.columns, concatenatedQueryName))
                    return this;
                this.columns.push(concatenatedQueryName);
                var concatenatedDisplayName = visuals.DataViewConcatenateUtil.concatenateValues(_.map(sources, (function (source) { return source.displayName; })));
                this.items.push(new Lazy(function () {
                    var concatenatedValues = visuals.DataViewConcatenateUtil.concatenateValues(_.map(values, (function (value, index) { return formatter(value, sources[index]); })));
                    return {
                        displayName: concatenatedDisplayName,
                        value: concatenatedValues
                    };
                }));
                return this;
            };
            LazyTooltipBuilder.prototype.withValue = function (label, value) {
                this.items.push(new Lazy(function () { return ({
                    displayName: label,
                    value: value,
                }); }));
                return this;
            };
            LazyTooltipBuilder.prototype.withLazyValue = function (lazyValue) {
                this.items.push(lazyValue);
                return this;
            };
            LazyTooltipBuilder.prototype.getTooltipItems = function () {
                return _.map(this.items, (function (item) { return item.getValue(); }));
            };
            return LazyTooltipBuilder;
        }());
        visuals.LazyTooltipBuilder = LazyTooltipBuilder;
        var CategoricalLazyTooltipBuilder = /** @class */ (function (_super) {
            __extends(CategoricalLazyTooltipBuilder, _super);
            function CategoricalLazyTooltipBuilder(reader) {
                var _this = _super.call(this) || this;
                _this.reader = reader;
                return _this;
            }
            CategoricalLazyTooltipBuilder.prototype.withAllValuesForRole = function (role, categoryIndex, seriesIndex, allowNulls, formatter) {
                var columns = this.reader.getAllValueColumnsForRole(role, seriesIndex);
                if (_.isEmpty(columns))
                    return this;
                for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {
                    var column = columns_7[_i];
                    this.withColumnValueByIndex(column, categoryIndex, allowNulls, formatter);
                }
                return this;
            };
            return CategoricalLazyTooltipBuilder;
        }(LazyTooltipBuilder));
        visuals.CategoricalLazyTooltipBuilder = CategoricalLazyTooltipBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualStyles;
        (function (visualStyles) {
            function create(dataColors) {
                if (dataColors === undefined)
                    dataColors = new visuals.DataColorPalette();
                return {
                    titleText: {
                        color: { value: '#333' }
                    },
                    subTitleText: {
                        color: { value: '#919191' }
                    },
                    colorPalette: {
                        foreground: { value: '#333' },
                        background: { value: '#fff' },
                        tableAccent: { value: dataColors.getColorByIndex(0).value },
                        dataColors: dataColors,
                    },
                    labelText: {
                        color: {
                            value: '#333',
                        },
                        fontSize: '11px'
                    },
                    isHighContrast: false,
                };
            }
            visualStyles.create = create;
        })(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
// Refer to the Bing News API v6 documentation for more information:
// https://msdnstage.redmond.corp.microsoft.com/en-us/library/mt743193(v=bsynd.60).aspx
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BingSocialNews = /** @class */ (function () {
            function BingSocialNews() {
            }
            BingSocialNews.prototype.init = function (options) {
                this.currentViewport = options.viewport;
                this.$el = $(BingSocialNews.baseTemplate);
                this.newsList = this.$el.find('.bingSocialNewsList');
                this.loadingPlaceholder = this.$el.find('.loadingPlaceholder');
                this.loadingPlaceholderText = this.$el.find('.loadingPlaceholderText');
                this.loadingPlaceholder.height(options.viewport.height);
                this.loadingPlaceholder.width(options.viewport.width);
                this.getLocalizedString = options.host.getLocalizedString;
                this.loadingPlaceholderText.text(this.getLocalizedString('Tile_LoadingText'));
                options.element.append(this.$el);
                this.data = [];
                this.addSizeClasses();
            };
            BingSocialNews.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews.length > 0) {
                    var data_2 = dataViews[0]['bingSocial'];
                    if (this.data !== data_2) {
                        this.data = data_2;
                        if (this.data.length > 0) {
                            this.loadingPlaceholder.hide();
                            this.updateInternal();
                        }
                        else
                            this.loadingPlaceholderText.text(this.getLocalizedString('BingSocialTile_NoResults'));
                    }
                }
            };
            BingSocialNews.prototype.onResizing = function (finalViewport) {
                if (this.currentViewport.height !== finalViewport.height || this.currentViewport.width !== finalViewport.width) {
                    this.currentViewport = finalViewport;
                    this.addSizeClasses();
                    if (!this.data.length) {
                        this.loadingPlaceholder.height(finalViewport.height).width(finalViewport.width);
                    }
                }
            };
            BingSocialNews.prototype.addSizeClasses = function () {
                this.addSizeClass('height');
                this.addSizeClass('width');
            };
            BingSocialNews.prototype.addSizeClass = function (dimension) {
                var tileDimensions = BingSocialNews.tileDimensions[dimension];
                if (!tileDimensions) {
                    return;
                }
                var size = this.currentViewport[dimension];
                var length = tileDimensions.length;
                var i;
                for (i = 2; i <= length; i++) {
                    this.$el.removeClass(dimension + i);
                    this.$el.removeClass(dimension + i + 'up');
                }
                for (i = length; i > 1; i--) {
                    if (size >= tileDimensions[i - 1]) {
                        this.$el.addClass(dimension + i);
                        break;
                    }
                }
                while (i > 1) {
                    this.$el.addClass(dimension + i + 'up');
                    i--;
                }
            };
            BingSocialNews.prototype.updateInternal = function () {
                this.newsList.empty();
                for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
                    var articleData = _a[_i];
                    var $article = this.fillInArticleTemplate(articleData);
                    this.newsList.append($article);
                }
            };
            BingSocialNews.prototype.fillInArticleTemplate = function (articleData) {
                var $article = $(BingSocialNews.listItemTemplate), thumbnailUrl = articleData.image && articleData.image.thumbnail && articleData.image.thumbnail.contentUrl;
                if (!thumbnailUrl) {
                    return null;
                }
                $article.find('.js-storyLink').attr('href', articleData.url);
                $article.find('.js-newsImage').css('background-image', 'url(' + thumbnailUrl + ')');
                $article.find('.js-title').html(articleData.name);
                $article.find('.js-description').html(articleData.description);
                $article.find('.js-source').text(articleData.provider[0].name);
                return $article;
            };
            BingSocialNews.tileDimensions = {
                height: [100, 280, 460, 640, 820, 1000, 1180].map((function (x) { return x - 90; })),
                width: [230, 490, 750, 1010, 1270, 1530, 1790].map((function (x) { return x - 130; }))
            };
            BingSocialNews.baseTemplate = '' +
                '<div class="bingSocialNews">' +
                '<div>' +
                '<div class="bingSocialLoadingPlaceholder loadingPlaceholder"><div class="loadingPlaceholderText" ></div></div>' +
                '<ul class="bingSocialNewsList"></ul>' +
                '</div>' +
                '</div>';
            BingSocialNews.listItemTemplate = '' +
                '<li>' +
                '<div class="article">' +
                '<div class="contentRight">' +
                '<a class="storyLink js-storyLink" target="_blank">' +
                '<div class="newsImage js-newsImage"></div>' +
                '<span class="title js-title"></span>' +
                '</a>' +
                '<p class="description js-description"></p>' +
                '</div>' +
                '<div class="source js-source"></div>' +
                '</div>' +
                '</li>';
            return BingSocialNews;
        }());
        visuals.BingSocialNews = BingSocialNews;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BingSocialTweets = /** @class */ (function () {
            function BingSocialTweets() {
            }
            BingSocialTweets.prototype.init = function (options) {
                this.currentViewport = options.viewport;
                this.$el = $(BingSocialTweets.baseTemplate);
                this.tweetsList = this.$el.find('.bingSocialTweetsList');
                this.loadingPlaceholder = this.$el.find('.loadingPlaceholder');
                this.loadingPlaceholderText = this.$el.find('.loadingPlaceholderText');
                this.loadingPlaceholder.height(options.viewport.height);
                this.loadingPlaceholder.width(options.viewport.width);
                this.getLocalizedString = options.host.getLocalizedString;
                this.loadingPlaceholderText.text(this.getLocalizedString('Tile_LoadingText'));
                options.element.append(this.$el);
                this.data = [];
                this.addSizeClasses();
            };
            BingSocialTweets.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews.length > 0) {
                    var data_3 = dataViews[0]['bingSocial'];
                    if (this.data !== data_3) {
                        this.data = data_3;
                        if (this.data.length > 0) {
                            this.loadingPlaceholder.hide();
                            this.updateInternal();
                        }
                        else
                            this.loadingPlaceholderText.text(this.getLocalizedString('BingSocialTile_NoResults'));
                    }
                }
            };
            BingSocialTweets.prototype.onResizing = function (finalViewport) {
                if (this.currentViewport.height !== finalViewport.height || this.currentViewport.width !== finalViewport.width) {
                    this.currentViewport = finalViewport;
                    this.addSizeClasses();
                    if (!this.data.length) {
                        this.loadingPlaceholder.height(finalViewport.height).width(finalViewport.width);
                    }
                }
            };
            BingSocialTweets.prototype.addSizeClasses = function () {
                this.addSizeClass('height');
                this.addSizeClass('width');
            };
            BingSocialTweets.prototype.addSizeClass = function (dimension) {
                var tileDimensions = BingSocialTweets.tileDimensions[dimension];
                if (!tileDimensions) {
                    return;
                }
                var size = this.currentViewport[dimension];
                var length = tileDimensions.length;
                var i;
                for (i = 2; i <= length; i++) {
                    this.$el.removeClass(dimension + i);
                    this.$el.removeClass(dimension + i + 'up');
                }
                for (i = length; i > 1; i--) {
                    if (size >= tileDimensions[i - 1]) {
                        this.$el.addClass(dimension + i);
                        break;
                    }
                }
                while (i > 1) {
                    this.$el.addClass(dimension + i + 'up');
                    i--;
                }
            };
            BingSocialTweets.prototype.updateInternal = function () {
                this.tweetsList.empty();
                for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
                    var tweet = _a[_i];
                    var $tweet = this.fillInTweetTemplate(tweet);
                    this.tweetsList.append($tweet);
                }
            };
            BingSocialTweets.prototype.fillInTweetTemplate = function (tweet) {
                var $tweet = $(BingSocialTweets.listItemTemplate), twitterBaseUrl = 'https://www.twitter.com/', user = tweet.User, escapedIdStr = encodeURIComponent(tweet.IdStr), escapedScreenName = encodeURIComponent(user.ScreenName);
                $tweet.find('.js-nameLink').attr('href', twitterBaseUrl + escapedScreenName);
                $tweet.find('.js-avatar').attr('src', user.ProfileImageUrlHttps);
                $tweet.find('.js-name').text(user.Name);
                $tweet.find('.js-screenName').text('@' + user.ScreenName);
                $tweet.find('.js-createdAt').attr('href', twitterBaseUrl + escapedScreenName + '/status/' + escapedIdStr);
                $tweet.find('.js-createdAt').text(moment(tweet.CreatedAt).fromNow());
                $tweet.find('.js-reply').attr('href', twitterBaseUrl + 'intent/tweet?in_reply_to=' + escapedIdStr);
                $tweet.find('.js-retweet').attr('href', twitterBaseUrl + 'intent/retweet?tweet_id=' + escapedIdStr);
                $tweet.find('.js-favorite').attr('href', twitterBaseUrl + 'intent/favorite?tweet_id=' + escapedIdStr);
                $tweet.find('.js-retweetCount').text(tweet.RetweetCount + ' Retweets');
                BingSocialTweets.augmentLinks($tweet.find('.js-text'), tweet);
                return $tweet;
            };
            BingSocialTweets.augmentLinks = function ($el, tweet) {
                var entities = tweet.Entities;
                var arr = [tweet.Text];
                if (entities) {
                    var hashtags = entities.Hashtags.map((function (h) { return h.Text; }));
                    this.replaceTokens(arr, hashtags, BingSocialTweets.hashtagRegexConstructor, (function (hashtag) {
                        return BingSocialTweets.createAnchorTag('#' + hashtag, 'https://www.twitter.com/hashtag/' + encodeURIComponent(hashtag));
                    }));
                    var userMentions = entities.UserMentions.map((function (um) { return um.ScreenName; }));
                    this.replaceTokens(arr, userMentions, BingSocialTweets.userMentionRegexConstructor, (function (screenName) {
                        return BingSocialTweets.createAnchorTag('@' + screenName, 'https://www.twitter.com/' + encodeURIComponent(screenName));
                    }));
                    var urls = entities.Urls.map((function (u) { return u.Url; }));
                    var media = entities.Media.map((function (m) { return m.Url; }));
                    this.replaceTokens(arr, urls.concat(media), BingSocialTweets.urlRegexConstructor, (function (url) {
                        return BingSocialTweets.createAnchorTag(url, url);
                    }));
                }
                for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                    var item = arr_1[_i];
                    if (typeof item === 'string') {
                        var $p = $('<p></p>');
                        $p.html(item);
                        $el.append($p);
                    }
                    else {
                        $el.append(item);
                    }
                }
            };
            BingSocialTweets.createAnchorTag = function (displayLink, url) {
                var $a = $('<a target="_blank"></a>');
                $a.text(displayLink);
                $a.attr('href', url);
                return $a;
            };
            BingSocialTweets.replaceTokens = function (arr, tokens, regexConstructor, replacementCallback) {
                if (!tokens.length) {
                    return;
                }
                var rawToken = tokens.pop();
                for (var i = 0; i < arr.length; i++) {
                    var text = arr[i];
                    if (typeof text !== 'string') {
                        continue;
                    }
                    var tokenRegexString = _.escapeRegExp(rawToken);
                    var tokenRegex = regexConstructor(tokenRegexString);
                    var newTextArray = text.split(tokenRegex);
                    var newTags = [];
                    var firstText = newTextArray[0];
                    if (typeof firstText === 'undefined') {
                        continue;
                    }
                    if (firstText !== '') {
                        newTags.push(firstText);
                    }
                    for (var j = 1; j < newTextArray.length; j++) {
                        if (j % 2 === 1) {
                            newTags.push(replacementCallback(newTextArray[j]));
                        }
                        else {
                            newTags.push(newTextArray[j]);
                        }
                    }
                    Array.prototype.splice.apply(arr, [i, 1].concat(newTags));
                    i += newTags.length - 1;
                }
                return BingSocialTweets.replaceTokens(arr, tokens, regexConstructor, replacementCallback);
            };
            BingSocialTweets.hashtagRegexConstructor = function (token) {
                return new RegExp('\\B' + '#' + '(' + token + ')\\b', 'ig');
            };
            BingSocialTweets.userMentionRegexConstructor = function (token) {
                return new RegExp('\\B' + '@' + '(' + token + ')\\b', 'ig');
            };
            BingSocialTweets.urlRegexConstructor = function (token) {
                return new RegExp('\\b' + '(' + token + ')\\b', 'g');
            };
            BingSocialTweets.tileDimensions = {
                height: [100, 280, 460, 640, 820].map((function (x) { return x - 90; })),
                width: [230, 490, 750, 1010, 1270].map((function (x) { return x - 130; }))
            };
            BingSocialTweets.baseTemplate = '' +
                '<div class="bingSocialTweets">' +
                '<div class="bingSocialLoadingPlaceholder loadingPlaceholder"><div class="loadingPlaceholderText" ></div></div>' +
                '<ul class="bingSocialTweetsList"></ul>' +
                '</div>';
            BingSocialTweets.listItemTemplate = '' +
                '<li>' +
                '<div class="tweet">' +
                '<div class="contentRight">' +
                '<div class="tweetHeader">' +
                '<a class="nameLink js-nameLink" target="_blank">' +
                '<img class="avatar js-avatar" />' +
                '<span class="name js-name"></span>' +
                '<span class="screenName js-screenName"></span>' +
                '</a>' +
                '<a class="createdAt js-createdAt" target="_blank"></a>' +
                '</div>' +
                '<div class="text js-text"></div>' +
                '</div>' +
                '<div class="tweetFooter">' +
                '<a class="tweetActionText tweetReply js-reply" target="_blank" title="Reply"></a>' +
                '<a class="tweetActionText tweetRetweet js-retweet" target="_blank" title="Retweet"></a>' +
                '<a class="tweetActionText tweetFavorite js-favorite" target="_blank" title="Favorite"></a>' +
                '<span class="retweetCount js-retweetCount"></span>' +
                '</div>' +
                '</div>' +
                '</li>';
            return BingSocialTweets;
        }());
        visuals.BingSocialTweets = BingSocialTweets;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            // This file registers the built-in visualizations
            plugins.animatedNumber = {
                name: 'animatedNumber',
                capabilities: visuals.capabilities.animatedNumber,
                create: function (options) { return options.module.createAnimatedNumber(); },
                module: {
                    javascript: 'SingleValueVisuals/animatedNumberModule',
                },
            };
            plugins.areaChart = {
                name: 'areaChart',
                watermarkKey: 'area',
                capabilities: visuals.capabilities.areaChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 1 /* Area */ }); },
                customizeQuery: visuals.LineChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.LineChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.barChart = {
                name: 'barChart',
                watermarkKey: 'bar',
                capabilities: visuals.capabilities.barChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 6 /* StackedBar */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.basicShape = {
                name: 'basicShape',
                capabilities: visuals.basicShapeCapabilities,
                module: { javascript: 'BasicShapeVisual/basicShape' },
                create: function (options) { return new options.module.BasicShape(); }
            };
            plugins.card = {
                name: 'card',
                watermarkKey: 'card',
                capabilities: visuals.capabilities.card,
                create: function (options) { return options.module.createCard(); },
                module: {
                    javascript: 'SingleValueVisuals/cardModule',
                },
            };
            plugins.multiRowCard = {
                name: 'multiRowCard',
                watermarkKey: 'multiRowCard',
                capabilities: visuals.capabilities.multiRowCard,
                create: function () { return new visuals.MultiRowCard(); },
                getSortableRoles: visuals.MultiRowCardPluginMethods.getSortableRoles,
                module: {
                    javascript: 'multiRowCardVisual',
                },
            };
            plugins.clusteredBarChart = {
                name: 'clusteredBarChart',
                watermarkKey: 'clusteredBar',
                capabilities: visuals.capabilities.clusteredBarChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 5 /* ClusteredBar */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.clusteredColumnChart = {
                name: 'clusteredColumnChart',
                watermarkKey: 'clusteredColumn',
                capabilities: visuals.capabilities.clusteredColumnChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 3 /* ClusteredColumn */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.columnChart = {
                name: 'columnChart',
                watermarkKey: 'column',
                capabilities: visuals.capabilities.columnChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 4 /* StackedColumn */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.comboChart = {
                name: 'comboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.comboChart,
                customizeQuery: visuals.ComboChartPluginMethods.customizeQuery,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 11 /* ComboChart */ }); },
                getSortableRoles: visuals.ComboChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.dataDotChart = {
                name: 'dataDotChart',
                capabilities: visuals.capabilities.dataDotChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 12 /* DataDot */ }); },
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.dataDotClusteredColumnComboChart = {
                name: 'dataDotClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.dataDotClusteredColumnComboChart,
                customizeQuery: visuals.ComboChartPluginMethods.customizeQuery,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 16 /* DataDotClusteredColumnCombo */ }); },
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.dataDotStackedColumnComboChart = {
                name: 'dataDotStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.dataDotStackedColumnComboChart,
                customizeQuery: visuals.ComboChartPluginMethods.customizeQuery,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 17 /* DataDotStackedColumnCombo */ }); },
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            var donutBase = {
                capabilities: visuals.capabilities.donutChart,
                module: {
                    javascript: 'donutChartVisuals',
                },
            };
            plugins.donutChart = __assign({}, donutBase, { name: 'donutChart', watermarkKey: 'donut', create: function () { return new visuals.DonutChart(); } });
            plugins.funnel = {
                name: 'funnel',
                watermarkKey: 'funnel',
                capabilities: visuals.capabilities.funnel,
                create: function () { return new visuals.FunnelChart(); },
                module: {
                    javascript: 'funnelChartVisual',
                },
            };
            plugins.gauge = {
                name: 'gauge',
                watermarkKey: 'gauge',
                capabilities: visuals.capabilities.gauge,
                create: function (options) { return options.module.createGauge(); },
                module: {
                    javascript: 'SingleValueVisuals/gaugeModule',
                },
            };
            plugins.hundredPercentStackedBarChart = {
                name: 'hundredPercentStackedBarChart',
                watermarkKey: '100stackedbar',
                capabilities: visuals.capabilities.hundredPercentStackedBarChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 7 /* HundredPercentStackedBar */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.hundredPercentStackedColumnChart = {
                name: 'hundredPercentStackedColumnChart',
                watermarkKey: '100stackedcolumn',
                capabilities: visuals.capabilities.hundredPercentStackedColumnChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 8 /* HundredPercentStackedColumn */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.image = {
                name: 'image',
                capabilities: visuals.capabilities.image,
                create: function () { return new visuals.ImageVisual(); },
                module: {
                    javascript: 'imageVisual',
                },
            };
            plugins.lineChart = {
                name: 'lineChart',
                watermarkKey: 'line',
                capabilities: visuals.capabilities.lineChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 0 /* Line */ }); },
                customizeQuery: visuals.LineChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.LineChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.lineStackedColumnComboChart = {
                name: 'lineStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.lineStackedColumnComboChart,
                customizeQuery: visuals.ComboChartPluginMethods.customizeQuery,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 15 /* LineStackedColumnCombo */ }); },
                getSortableRoles: visuals.ComboChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.lineClusteredColumnComboChart = {
                name: 'lineClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.lineClusteredColumnComboChart,
                customizeQuery: visuals.ComboChartPluginMethods.customizeQuery,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 14 /* LineClusteredColumnCombo */ }); },
                getSortableRoles: visuals.ComboChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.map = {
                name: 'map',
                watermarkKey: 'map',
                capabilities: visuals.capabilities.map,
                create: function () { return new visuals.Map({ filledMap: false }); },
                customizeQuery: visuals.MapPluginMethods.customizeQuery,
                module: {
                    javascript: 'mapVisuals',
                },
            };
            plugins.filledMap = {
                name: 'filledMap',
                watermarkKey: 'filledMap',
                capabilities: visuals.capabilities.filledMap,
                create: function () { return new visuals.Map({ filledMap: true }); },
                module: {
                    javascript: 'mapVisuals',
                },
            };
            plugins.ribbonChart = {
                name: 'ribbonChart',
                watermarkKey: 'ribbon',
                capabilities: visuals.capabilities.ribbonChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 9 /* RibbonChart */ }); },
                customizeQuery: visuals.ColumnChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.ColumnChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.shapeMap = {
                name: 'shapeMap',
                watermarkKey: 'shapeMap',
                capabilities: visuals.capabilities.shapeMap,
                module: { javascript: 'ShapeMapVisual/shapeMap/shapeMap' },
                create: function (options) { return new options.module.ShapeMap(); },
            };
            plugins.treemap = {
                name: 'treemap',
                watermarkKey: 'tree',
                capabilities: visuals.capabilities.treemap,
                module: { javascript: 'TreemapVisual/treemap' },
                create: function (options) { return new options.module.Treemap(); }
            };
            plugins.sunburst = {
                name: 'sunburst',
                watermarkKey: 'defaultWatermark',
                capabilities: visuals.capabilities.sunburst,
                module: { javascript: 'SunburstVisual/sunburst/sunburst' },
                create: function (options) { return new options.module.Sunburst(); },
            };
            plugins.pieChart = __assign({}, donutBase, { name: 'pieChart', watermarkKey: 'pie', create: function () { return new visuals.DonutChart({ sliceWidthRatio: 0 }); } });
            plugins.realTimeLineChart = {
                name: 'realTimeLineChart',
                watermarkKey: 'line',
                capabilities: visuals.capabilities.realTimeLineChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 18 /* RealTimeLineChart */ }); },
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.scatterChart = {
                name: 'scatterChart',
                watermarkKey: 'scatterplot',
                capabilities: visuals.capabilities.scatterChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 10 /* Scatter */ }); },
                customizeQuery: visuals.ScatterChartPluginMethods.customizeQuery,
                getAdditionalTelemetry: visuals.ScatterChartPluginMethods.getAdditionalTelemetry,
            };
            plugins.stackedAreaChart = {
                name: 'stackedAreaChart',
                watermarkKey: 'stackedarea',
                capabilities: visuals.capabilities.stackedAreaChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 2 /* StackedArea */ }); },
                customizeQuery: visuals.LineChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.LineChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.table = {
                name: 'table',
                watermarkKey: 'table',
                capabilities: visuals.capabilities.table,
                create: function () { return new visuals.Table(); },
                customizeQuery: visuals.TablePluginMethods.customizeQuery,
                getSortableRoles: visuals.TablePluginMethods.getSortableRoles,
                module: {
                    javascript: 'pivotTableVisuals',
                }
            };
            plugins.matrix = {
                name: 'matrix',
                watermarkKey: 'matrix',
                capabilities: visuals.capabilities.matrix,
                create: function () { return new visuals.Matrix(); },
                customizeQuery: visuals.MatrixPluginMethods.customizeQuery,
                getSortableRoles: visuals.MatrixPluginMethods.getSortableRoles,
                module: {
                    javascript: 'pivotTableVisuals',
                }
            };
            plugins.tableEx = {
                name: 'tableEx',
                watermarkKey: 'table',
                capabilities: powerbi.visuals.tableExCapabilities,
                create: function () { return new visuals.TableEx(); },
                customizeQuery: visuals.TableExPluginMethods.customizeQuery,
                getSortableRoles: visuals.TableExPluginMethods.getSortableRoles,
                module: {
                    javascript: 'pivotTableVisuals',
                    css: ['pivotTableVisuals'],
                }
            };
            plugins.pivotTable = {
                name: 'pivotTable',
                watermarkKey: 'matrix',
                capabilities: powerbi.visuals.pivotTableCapabilities,
                create: function () { return new visuals.PivotTable(); },
                customizeQuery: visuals.PivotTablePluginMethods.customizeQuery,
                getSortableRoles: visuals.PivotTablePluginMethods.getSortableRoles,
                module: {
                    javascript: 'pivotTableVisuals',
                    css: ['pivotTableVisuals'],
                }
            };
            plugins.accessibleTable = {
                name: 'accessibleTable',
                watermarkKey: 'matrix',
                capabilities: visuals.capabilities.accessibleTable,
                create: function (options) { return options.module.AccessibleTable(); },
                module: {
                    javascript: 'AccessibleTableVisual/accessibleTable/accessibleTable',
                    css: ['accessibleTableVisual'],
                }
            };
            plugins.slicer = {
                name: 'slicer',
                watermarkKey: 'slicer',
                capabilities: visuals.capabilities.slicer,
                create: function () { return new visuals.Slicer(); },
                customizeQuery: visuals.SlicerPluginMethods.customizeQuery,
                getSortableRoles: visuals.SlicerPluginMethods.getSortableRoles,
                isCrossFilteredByDefault: visuals.SlicerPluginMethods.isCrossFilteredByDefault,
                module: {
                    javascript: 'slicerVisual',
                },
            };
            plugins.textbox = {
                name: 'textbox',
                capabilities: visuals.capabilities.textbox,
                create: function (options) { return options.module.createTextbox(); },
                module: {
                    javascript: 'TextboxVisual/textboxModule',
                },
            };
            plugins.waterfallChart = {
                name: 'waterfallChart',
                watermarkKey: 'waterfall',
                capabilities: visuals.capabilities.waterfallChart,
                module: { javascript: 'CartesianVisuals/cartesianModule', },
                create: function (options) { return options.module.createCartesianChart({ chartType: 13 /* Waterfall */ }); },
                customizeQuery: visuals.WaterfallChartPluginMethods.customizeQuery,
                getSortableRoles: visuals.WaterfallChartPluginMethods.getSortableRoles,
                getAdditionalTelemetry: visuals.CartesianPluginMethods.getAdditionalTelemetry,
            };
            plugins.cheerMeter = {
                name: 'cheerMeter',
                capabilities: visuals.CheerMeter.capabilities,
                create: function () { return new visuals.CheerMeter(); }
            };
            plugins.consoleWriter = {
                name: 'consoleWriter',
                capabilities: visuals.samples.consoleWriterCapabilities,
                create: function () { return new visuals.samples.ConsoleWriter(); }
            };
            plugins.helloIVisual = {
                name: 'helloIVisual',
                capabilities: visuals.samples.HelloIVisual.capabilities,
                create: function () { return new visuals.samples.HelloIVisual(); }
            };
            plugins.scriptVisual = {
                name: 'scriptVisual',
                watermarkKey: 'scriptvisual',
                capabilities: visuals.capabilities.scriptVisual,
                module: { javascript: 'ScriptVisual/scriptVisual' },
                create: function (options) { return new options.module.ScriptVisual(); },
            };
            plugins.kpi = {
                name: 'kpi',
                watermarkKey: 'kpi',
                capabilities: visuals.capabilities.kpi,
                create: function () { return new visuals.KPIStatusWithHistory(); },
                module: {
                    javascript: 'kpiVisual',
                },
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            plugins.bingSocialTweets = {
                name: 'bingSocialTweets',
                capabilities: visuals.bingSocialTweetsCapabilities,
                create: function () { return new visuals.BingSocialTweets(); }
            };
            plugins.bingSocialNews = {
                name: 'bingSocialNews',
                capabilities: visuals.bingSocialNewsCapabilities,
                create: function () { return new visuals.BingSocialNews(); }
            };
            plugins.heatMap = {
                name: 'heatMap',
                capabilities: visuals.capabilities.map,
                // Have the client currently show HeatMap as Map
                create: function () { return new visuals.Map({ filledMap: false }); }
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CanvasBackgroundHelper;
        (function (CanvasBackgroundHelper) {
            function getDefaultColor() {
                return '#FFFFFF';
            }
            CanvasBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                };
            }
            CanvasBackgroundHelper.getDefaultValues = getDefaultValues;
        })(CanvasBackgroundHelper = visuals.CanvasBackgroundHelper || (visuals.CanvasBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var defaultMaxValue = 100;
        /**
         * Implements IRange interface for the Date type.
         */
        var DateRange = /** @class */ (function () {
            function DateRange(min, max, start, end) {
                debug.assert(max >= min, "Requires max date to be bigger than min date.");
                debug.assert((!start || start >= min) && (!end || end <= max), "Specified date is out of boundaries");
                this.scale = d3.time.scale()
                    .domain([min, max])
                    .range([0, defaultMaxValue]);
                this.value = {
                    min: start || min,
                    max: end || max
                };
                this.setValue(this.value);
            }
            DateRange.prototype.getScaledValue = function () {
                return this.scaledValue;
            };
            DateRange.prototype.setValue = function (original) {
                debug.assert(original != null, "Value can't be null");
                debug.assert(original.min != null, "Min can't be null");
                debug.assert(original.max != null, "Max can't be null");
                this.value = original;
                this.scaledValue = {
                    min: this.scale(original.min),
                    max: this.scale(original.max)
                };
            };
            DateRange.prototype.getValue = function () {
                return this.value;
            };
            /**
             * Updates scaled value.
             * Value should in range [0 .. 100].
             */
            DateRange.prototype.setScaledValue = function (value) {
                debug.assert(value.min <= defaultMaxValue && value.min >= 0 &&
                    value.max >= 0 && value.max <= defaultMaxValue && value.max >= value.min, "Value is out of range");
                this.scaledValue = value;
                this.value = {
                    min: this.scale.invert(value.min),
                    max: this.scale.invert(value.max)
                };
            };
            return DateRange;
        }());
        visuals.DateRange = DateRange;
        /**
        * Implements IRange interface for the Numeric type.
        */
        var NumericRange = /** @class */ (function () {
            function NumericRange(min, max, start, end) {
                debug.assert(max >= min, "Requires max to be bigger than or equal to min.");
                debug.assert((!start || start >= min) && (!end || end <= max), "Specified value is out of boundaries");
                this.scale = d3.scale.linear()
                    .domain([min, max])
                    .range([0, defaultMaxValue]);
                this.value = {
                    min: start === undefined ? min : start,
                    max: end === undefined ? max : end
                };
                this.setValue(this.value);
            }
            NumericRange.prototype.getScaledValue = function () {
                return this.scaledValue;
            };
            NumericRange.prototype.setValue = function (original) {
                debug.assertValue(original, "Value can't be null");
                debug.assertValue(original.min, "Min can't be null");
                debug.assertValue(original.max, "Max can't be null");
                this.value = original;
                this.scaledValue = {
                    min: this.scale(original.min),
                    max: this.scale(original.max)
                };
            };
            NumericRange.prototype.getValue = function () {
                return this.value;
            };
            /**
             * Updates scaled value.
             * Value should in range [0 .. 100].
             */
            NumericRange.prototype.setScaledValue = function (value) {
                debug.assert(value.min <= defaultMaxValue && value.min >= 0 &&
                    value.max >= 0 && value.max <= defaultMaxValue && value.max >= value.min, "Value is out of range");
                this.scaledValue = value;
                this.value = {
                    min: this.scale.invert(value.min),
                    max: this.scale.invert(value.max)
                };
            };
            return NumericRange;
        }());
        visuals.NumericRange = NumericRange;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var stylePresets;
        (function (stylePresets) {
            var TablixObjects = visuals.controls.internal.TablixObjects;
            var Color = jsCommon.Color;
            var TablixStylePresetDefaults;
            (function (TablixStylePresetDefaults) {
                // Default for values common to most presets to avoid repeating declaring them
                TablixStylePresetDefaults.outlineWeight = TablixObjects.PropGridOutlineWeight.defaultValue;
                TablixStylePresetDefaults.columnsOutline = TablixObjects.PropColumnsOutline.defaultValue;
                TablixStylePresetDefaults.rowsOutline = TablixObjects.PropRowsOutline.defaultValue;
                TablixStylePresetDefaults.valuesOutline = TablixObjects.PropValuesOutline.defaultValue;
                TablixStylePresetDefaults.tableTotalOutline = TablixObjects.PropTotalOutline.defaultValue;
                TablixStylePresetDefaults.gridHorizontalWeight = TablixObjects.PropGridHorizontalWeight.defaultValue;
                TablixStylePresetDefaults.gridlineVerticalWeight = TablixObjects.PropGridVerticalWeight.defaultValue;
                TablixStylePresetDefaults.rowPaddingCondensed = 0;
                TablixStylePresetDefaults.rowPaddingNormal = 3;
                TablixStylePresetDefaults.rowPaddingSparse = 6;
            })(TablixStylePresetDefaults = stylePresets.TablixStylePresetDefaults || (stylePresets.TablixStylePresetDefaults = {}));
            var TablixStylePresetsName;
            (function (TablixStylePresetsName) {
                TablixStylePresetsName.None = "None";
                TablixStylePresetsName.Default = "Default";
                TablixStylePresetsName.Minimal = "Minimal";
                TablixStylePresetsName.BoldHeader = "BoldHeader";
                TablixStylePresetsName.AlternatingRows = "AlternatingRows";
                TablixStylePresetsName.ContrastAlternatingRows = "ContrastAlternatingRows";
                TablixStylePresetsName.FlashyRows = "FlashyRows";
                TablixStylePresetsName.BoldHeaderFlashyRows = "BoldHeaderFlashyRows";
                TablixStylePresetsName.Sparse = "Sparse";
                TablixStylePresetsName.Condensed = "Condensed";
            })(TablixStylePresetsName = stylePresets.TablixStylePresetsName || (stylePresets.TablixStylePresetsName = {}));
            function getTablixStylePresetElements(stylePresetName, theme) {
                var backColor = theme.colorPalette.background.value, foreColor = theme.colorPalette.foreground.value, accent = theme.colorPalette.tableAccent.value, gridColor;
                switch (stylePresetName) {
                    case TablixStylePresetsName.None: {
                        return {
                            outlineColor: TablixObjects.PropGridOutlineColor.defaultValue,
                            gridColor: TablixObjects.PropGridVerticalColor.defaultValue,
                            gridVerticalEnabledTable: TablixObjects.PropGridVertical.defaultValue,
                            gridVerticalEnabledMatrix: TablixObjects.PropGridVertical.defaultValue,
                            gridHorizontalEnabledTable: TablixObjects.PropGridHorizontalTable.defaultValue,
                            gridHorizontalEnabledMatrix: TablixObjects.PropGridHorizontalMatrix.defaultValue,
                            rowPadding: TablixObjects.PropGridRowPadding.defaultValue,
                            fontColorHeaders: TablixObjects.PropColumnsFontColor.defaultValue,
                            backColorHeaders: TablixObjects.PropColumnsBackColor.defaultValue,
                            fontColorValues1: TablixObjects.PropValuesFontColorPrimary.defaultValue,
                            backColorValues1: TablixObjects.PropValuesBackColorPrimary.defaultValue,
                            fontColorValues2: TablixObjects.PropValuesFontColorSecondary.defaultValue,
                            backColorValues2: TablixObjects.PropValuesBackColorSecondary.defaultValue,
                            fontColorTotals: TablixObjects.PropTotalFontColor.defaultValue,
                            backColorTotals: TablixObjects.PropTotalBackColor.defaultValue,
                        };
                    }
                    case TablixStylePresetsName.Default: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = Color.hexBlend(foreColor, 0.12, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: TablixObjects.PropGridHorizontalTable.defaultValue,
                            gridHorizontalEnabledMatrix: TablixObjects.PropGridHorizontalMatrix.defaultValue,
                            rowPadding: 1,
                            fontColorHeaders: foreColor,
                            backColorHeaders: backColor,
                            fontColorValues1: foreColor,
                            backColorValues1: backColor,
                            fontColorValues2: foreColor,
                            backColorValues2: Color.hexBlend(foreColor, 0.08, backColor),
                            fontColorTotals: undefined,
                            backColorTotals: undefined,
                        };
                    }
                    case TablixStylePresetsName.Minimal: {
                        gridColor = Color.hexBlend(foreColor, 0.12, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: true,
                            gridHorizontalEnabledMatrix: true,
                            rowPadding: TablixStylePresetDefaults.rowPaddingNormal,
                            fontColorHeaders: foreColor,
                            backColorHeaders: backColor,
                            fontColorValues1: foreColor,
                            backColorValues1: backColor,
                            fontColorValues2: foreColor,
                            backColorValues2: backColor,
                            fontColorTotals: foreColor,
                            backColorTotals: backColor,
                        };
                    }
                    case TablixStylePresetsName.BoldHeader: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = Color.hexBlend(foreColor, 0.12, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: true,
                            gridHorizontalEnabledMatrix: true,
                            rowPadding: TablixStylePresetDefaults.rowPaddingNormal,
                            backColorHeaders: foreColor,
                            fontColorHeaders: backColor,
                            fontColorValues1: foreColor,
                            backColorValues1: backColor,
                            fontColorValues2: foreColor,
                            backColorValues2: backColor,
                            fontColorTotals: foreColor,
                            backColorTotals: backColor,
                        };
                    }
                    case TablixStylePresetsName.AlternatingRows: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = Color.hexBlend(foreColor, 0.12, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: true,
                            gridHorizontalEnabledMatrix: true,
                            rowPadding: TablixStylePresetDefaults.rowPaddingNormal,
                            fontColorHeaders: backColor,
                            backColorHeaders: foreColor,
                            fontColorValues1: foreColor,
                            backColorValues1: backColor,
                            fontColorValues2: foreColor,
                            backColorValues2: Color.hexBlend(foreColor, 0.08, backColor),
                            fontColorTotals: backColor,
                            backColorTotals: foreColor,
                        };
                    }
                    case TablixStylePresetsName.ContrastAlternatingRows: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = Color.hexBlend(foreColor, 0.12, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: true,
                            gridHorizontalEnabledMatrix: true,
                            rowPadding: TablixStylePresetDefaults.rowPaddingNormal,
                            fontColorHeaders: backColor,
                            backColorHeaders: foreColor,
                            fontColorValues1: backColor,
                            backColorValues1: Color.hexBlend(foreColor, 0.75, backColor),
                            fontColorValues2: foreColor,
                            backColorValues2: Color.hexBlend(foreColor, 0.25, backColor),
                            fontColorTotals: backColor,
                            backColorTotals: foreColor,
                        };
                    }
                    case TablixStylePresetsName.FlashyRows: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = backColor;
                        return {
                            outlineColor: foreColor,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: false,
                            gridHorizontalEnabledMatrix: false,
                            rowPadding: TablixStylePresetDefaults.rowPaddingNormal,
                            fontColorHeaders: foreColor,
                            backColorHeaders: backColor,
                            fontColorValues1: foreColor,
                            backColorValues1: Color.hexBlend(accent, 0.40, backColor),
                            fontColorValues2: foreColor,
                            backColorValues2: Color.hexBlend(accent, 0.80, backColor),
                            fontColorTotals: foreColor,
                            backColorTotals: backColor,
                        };
                    }
                    case TablixStylePresetsName.BoldHeaderFlashyRows: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = backColor;
                        return {
                            outlineColor: backColor,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: false,
                            gridHorizontalEnabledMatrix: false,
                            rowPadding: TablixStylePresetDefaults.rowPaddingNormal,
                            fontColorHeaders: backColor,
                            backColorHeaders: foreColor,
                            fontColorValues1: foreColor,
                            backColorValues1: Color.hexBlend(accent, 0.40, backColor),
                            fontColorValues2: foreColor,
                            backColorValues2: Color.hexBlend(accent, 0.80, backColor),
                            fontColorTotals: backColor,
                            backColorTotals: foreColor,
                        };
                    }
                    case TablixStylePresetsName.Sparse: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = Color.hexBlend(foreColor, 0.20, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: false,
                            gridVerticalEnabledMatrix: false,
                            gridHorizontalEnabledTable: false,
                            gridHorizontalEnabledMatrix: false,
                            rowPadding: TablixStylePresetDefaults.rowPaddingSparse,
                            fontColorHeaders: backColor,
                            backColorHeaders: foreColor,
                            fontColorValues1: foreColor,
                            backColorValues1: backColor,
                            fontColorValues2: foreColor,
                            backColorValues2: backColor,
                            fontColorTotals: backColor,
                            backColorTotals: foreColor,
                        };
                    }
                    case TablixStylePresetsName.Condensed: {
                        backColor = theme.colorPalette.background.value;
                        foreColor = theme.colorPalette.foreground.value;
                        accent = theme.colorPalette.tableAccent.value;
                        gridColor = Color.hexBlend(foreColor, 0.20, backColor);
                        return {
                            outlineColor: accent,
                            gridColor: gridColor,
                            gridVerticalEnabledTable: true,
                            gridVerticalEnabledMatrix: true,
                            gridHorizontalEnabledTable: true,
                            gridHorizontalEnabledMatrix: true,
                            rowPadding: TablixStylePresetDefaults.rowPaddingCondensed,
                            fontColorHeaders: backColor,
                            backColorHeaders: foreColor,
                            fontColorValues1: foreColor,
                            backColorValues1: backColor,
                            fontColorValues2: foreColor,
                            backColorValues2: backColor,
                            fontColorTotals: backColor,
                            backColorTotals: foreColor,
                        };
                    }
                    default: {
                        debug.assertFail("Attempt to get Tablix style elements with invalid preset name [" + stylePresetName + "].");
                        return undefined;
                    }
                }
            }
            stylePresets.getTablixStylePresetElements = getTablixStylePresetElements;
        })(stylePresets = visuals.stylePresets || (visuals.stylePresets = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var stylePresets;
        (function (stylePresets) {
            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var Utility = jsCommon.Utility;
            var createSolidFillDefinition = powerbi.fillDefinitionHelpers.createSolidFillDefinition;
            function wrapTableStylePresetElements(stylePresetName, theme) {
                var elements = stylePresets.getTablixStylePresetElements(stylePresetName, theme);
                if (!elements)
                    return {};
                return {
                    grid: [{
                            properties: {
                                outlineColor: createSolidFillDefinition(elements.outlineColor),
                                outlineWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.outlineWeight, stylePresets.TablixStylePresetDefaults.outlineWeight)),
                                gridVertical: SQExprBuilder.boolean(elements.gridVerticalEnabledTable),
                                gridVerticalColor: createSolidFillDefinition(elements.gridColor),
                                gridVerticalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridVerticalWeight, stylePresets.TablixStylePresetDefaults.gridlineVerticalWeight)),
                                gridHorizontal: SQExprBuilder.boolean(elements.gridHorizontalEnabledTable),
                                gridHorizontalColor: createSolidFillDefinition(elements.gridColor),
                                gridHorizontalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridHorizontalWeight, stylePresets.TablixStylePresetDefaults.gridHorizontalWeight)),
                                rowPadding: SQExprBuilder.integer(elements.rowPadding),
                            },
                        }],
                    columnHeaders: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeColumnHeaders, stylePresets.TablixStylePresetDefaults.columnsOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorHeaders),
                                backColor: createSolidFillDefinition(elements.backColorHeaders),
                            }
                        }],
                    values: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeValues, stylePresets.TablixStylePresetDefaults.valuesOutline)),
                                fontColorPrimary: createSolidFillDefinition(elements.fontColorValues1),
                                backColorPrimary: createSolidFillDefinition(elements.backColorValues1),
                                fontColorSecondary: createSolidFillDefinition(elements.fontColorValues2),
                                backColorSecondary: createSolidFillDefinition(elements.backColorValues2),
                            }
                        }],
                    total: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeTotals, stylePresets.TablixStylePresetDefaults.tableTotalOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorTotals),
                                backColor: createSolidFillDefinition(elements.backColorTotals),
                            }
                        }],
                };
            }
            function tableStylePresets() {
                return {
                    sectionTitle: createDisplayNameGetter('Visual_Table_StylePreset_SectionTitle'),
                    sliceTitle: createDisplayNameGetter('Visual_Table_StylePreset_SliceTitle'),
                    defaultPresetName: stylePresets.TablixStylePresetsName.None,
                    presets: (_a = {},
                        _a[stylePresets.TablixStylePresetsName.None] = {
                            name: stylePresets.TablixStylePresetsName.None,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_None'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.None, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Minimal] = {
                            name: stylePresets.TablixStylePresetsName.Minimal,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_Minimal'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.Minimal, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeader] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeader,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_BoldHeader'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeader, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.AlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.AlternatingRows,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_AlternatingRows'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.AlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.ContrastAlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.ContrastAlternatingRows,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_ContrastAlternatingRows'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.ContrastAlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.FlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.FlashyRows,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_FlashyRows'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.FlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_BoldHeaderFlashyRows'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Sparse] = {
                            name: stylePresets.TablixStylePresetsName.Sparse,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_Sparse'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.Sparse, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Condensed] = {
                            name: stylePresets.TablixStylePresetsName.Condensed,
                            displayName: createDisplayNameGetter('Visual_Table_StylePreset_Condensed'),
                            evaluate: function (theme) { return wrapTableStylePresetElements(stylePresets.TablixStylePresetsName.Condensed, theme); },
                        },
                        _a),
                };
                var _a;
            }
            stylePresets.tableStylePresets = tableStylePresets;
        })(stylePresets = visuals.stylePresets || (visuals.stylePresets = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var stylePresets;
        (function (stylePresets) {
            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var Utility = jsCommon.Utility;
            var createSolidFillDefinition = powerbi.fillDefinitionHelpers.createSolidFillDefinition;
            function wrapMatrixStylePresetElements(stylePresetName, theme) {
                var elements = stylePresets.getTablixStylePresetElements(stylePresetName, theme);
                // Invalid stylePresetName
                if (!elements) {
                    return {};
                }
                return {
                    grid: [{
                            properties: {
                                outlineColor: createSolidFillDefinition(elements.outlineColor),
                                outlineWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.outlineWeight, stylePresets.TablixStylePresetDefaults.outlineWeight)),
                                gridVertical: SQExprBuilder.boolean(elements.gridVerticalEnabledMatrix),
                                gridVerticalColor: createSolidFillDefinition(elements.gridColor),
                                gridVerticalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridVerticalWeight, stylePresets.TablixStylePresetDefaults.gridlineVerticalWeight)),
                                gridHorizontal: SQExprBuilder.boolean(elements.gridHorizontalEnabledMatrix),
                                gridHorizontalColor: createSolidFillDefinition(elements.gridColor),
                                gridHorizontalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridHorizontalWeight, stylePresets.TablixStylePresetDefaults.gridHorizontalWeight)),
                                rowPadding: SQExprBuilder.integer(elements.rowPadding),
                            },
                        }],
                    columnHeaders: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeColumnHeaders, stylePresets.TablixStylePresetDefaults.columnsOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorHeaders),
                                backColor: createSolidFillDefinition(elements.backColorHeaders),
                            }
                        }],
                    rowHeaders: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeRowHeaders, stylePresets.TablixStylePresetDefaults.rowsOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorHeaders),
                                backColor: createSolidFillDefinition(elements.backColorHeaders),
                            }
                        }],
                    values: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeValues, stylePresets.TablixStylePresetDefaults.valuesOutline)),
                                fontColorPrimary: createSolidFillDefinition(elements.fontColorValues1),
                                backColorPrimary: createSolidFillDefinition(elements.backColorValues1),
                                fontColorSecondary: createSolidFillDefinition(elements.fontColorValues2),
                                backColorSecondary: createSolidFillDefinition(elements.backColorValues2),
                            }
                        }],
                    subTotals: [{
                            properties: {
                                fontColor: undefined,
                                backColor: undefined,
                            }
                        }],
                    total: [{
                            properties: {
                                fontColor: createSolidFillDefinition(elements.fontColorTotals),
                                backColor: createSolidFillDefinition(elements.backColorTotals),
                                applyToHeaders: SQExprBuilder.boolean(false),
                            }
                        }],
                };
            }
            function matrixStylePresets() {
                return {
                    sectionTitle: createDisplayNameGetter("Visual_Matrix_StylePreset_SectionTitle"),
                    sliceTitle: createDisplayNameGetter("Visual_Table_StylePreset_SliceTitle"),
                    defaultPresetName: stylePresets.TablixStylePresetsName.None,
                    presets: (_a = {},
                        _a[stylePresets.TablixStylePresetsName.None] = {
                            name: stylePresets.TablixStylePresetsName.None,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_None"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.None, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Minimal] = {
                            name: stylePresets.TablixStylePresetsName.Minimal,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Minimal"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.Minimal, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeader] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeader,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_BoldHeader"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeader, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.AlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.AlternatingRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_AlternatingRows"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.AlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.ContrastAlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.ContrastAlternatingRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_ContrastAlternatingRows"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.ContrastAlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.FlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.FlashyRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_FlashyRows"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.FlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_BoldHeaderFlashyRows"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Sparse] = {
                            name: stylePresets.TablixStylePresetsName.Sparse,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Sparse"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.Sparse, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Condensed] = {
                            name: stylePresets.TablixStylePresetsName.Condensed,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Condensed"),
                            evaluate: function (theme) { return wrapMatrixStylePresetElements(stylePresets.TablixStylePresetsName.Condensed, theme); },
                        },
                        _a),
                };
                var _a;
            }
            stylePresets.matrixStylePresets = matrixStylePresets;
        })(stylePresets = visuals.stylePresets || (visuals.stylePresets = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var stylePresets;
        (function (stylePresets) {
            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var Utility = jsCommon.Utility;
            var createSolidFillDefinition = powerbi.fillDefinitionHelpers.createSolidFillDefinition;
            function wrapPivotTableStylePresetElements(stylePresetName, theme) {
                var elements = stylePresets.getTablixStylePresetElements(stylePresetName, theme);
                // Invalid stylePresetName
                if (!elements) {
                    return {};
                }
                return {
                    grid: [{
                            properties: {
                                outlineColor: createSolidFillDefinition(elements.outlineColor),
                                outlineWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.outlineWeight, stylePresets.TablixStylePresetDefaults.outlineWeight)),
                                gridVertical: SQExprBuilder.boolean(elements.gridVerticalEnabledMatrix),
                                gridVerticalColor: createSolidFillDefinition(elements.gridColor),
                                gridVerticalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridVerticalWeight, stylePresets.TablixStylePresetDefaults.gridlineVerticalWeight)),
                                gridHorizontal: SQExprBuilder.boolean(elements.gridHorizontalEnabledMatrix),
                                gridHorizontalColor: createSolidFillDefinition(elements.gridColor),
                                gridHorizontalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridHorizontalWeight, stylePresets.TablixStylePresetDefaults.gridHorizontalWeight)),
                                rowPadding: SQExprBuilder.integer(elements.rowPadding),
                            },
                        }],
                    columnHeaders: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeColumnHeaders, stylePresets.TablixStylePresetDefaults.columnsOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorHeaders),
                                backColor: createSolidFillDefinition(elements.backColorHeaders),
                            }
                        }],
                    rowHeaders: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeRowHeaders, stylePresets.TablixStylePresetDefaults.rowsOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorHeaders),
                                backColor: createSolidFillDefinition(elements.backColorHeaders),
                                applyAlternation: SQExprBuilder.boolean(true),
                            }
                        }],
                    values: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeValues, stylePresets.TablixStylePresetDefaults.valuesOutline)),
                                fontColorPrimary: createSolidFillDefinition(elements.fontColorValues1),
                                backColorPrimary: createSolidFillDefinition(elements.backColorValues1),
                                fontColorSecondary: createSolidFillDefinition(elements.fontColorValues2),
                                backColorSecondary: createSolidFillDefinition(elements.backColorValues2),
                            }
                        }],
                    subTotals: [{
                            properties: {
                                fontColor: undefined,
                                backColor: undefined,
                            }
                        }],
                    total: [{
                            properties: {
                                fontColor: createSolidFillDefinition(elements.fontColorTotals),
                                backColor: createSolidFillDefinition(elements.backColorTotals),
                                applyToHeaders: SQExprBuilder.boolean(false),
                            }
                        }],
                };
            }
            function pivotTableStylePresets() {
                return {
                    sectionTitle: createDisplayNameGetter("Visual_Matrix_StylePreset_SectionTitle"),
                    sliceTitle: createDisplayNameGetter("Visual_Table_StylePreset_SliceTitle"),
                    defaultPresetName: stylePresets.TablixStylePresetsName.Default,
                    presets: (_a = {},
                        _a[stylePresets.TablixStylePresetsName.Default] = {
                            name: stylePresets.TablixStylePresetsName.Default,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Default"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.Default, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.None] = {
                            name: stylePresets.TablixStylePresetsName.None,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_None"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.None, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Minimal] = {
                            name: stylePresets.TablixStylePresetsName.Minimal,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Minimal"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.Minimal, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeader] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeader,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_BoldHeader"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeader, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.AlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.AlternatingRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_AlternatingRows"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.AlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.ContrastAlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.ContrastAlternatingRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_ContrastAlternatingRows"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.ContrastAlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.FlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.FlashyRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_FlashyRows"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.FlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_BoldHeaderFlashyRows"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Sparse] = {
                            name: stylePresets.TablixStylePresetsName.Sparse,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Sparse"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.Sparse, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Condensed] = {
                            name: stylePresets.TablixStylePresetsName.Condensed,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Condensed"),
                            evaluate: function (theme) { return wrapPivotTableStylePresetElements(stylePresets.TablixStylePresetsName.Condensed, theme); },
                        },
                        _a),
                };
                var _a;
            }
            stylePresets.pivotTableStylePresets = pivotTableStylePresets;
        })(stylePresets = visuals.stylePresets || (visuals.stylePresets = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var stylePresets;
        (function (stylePresets) {
            var createDisplayNameGetter = powerbi.data.createDisplayNameGetter;
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var Utility = jsCommon.Utility;
            var createSolidFillDefinition = powerbi.fillDefinitionHelpers.createSolidFillDefinition;
            function wrapTableExStylePresetElements(stylePresetName, theme) {
                var elements = stylePresets.getTablixStylePresetElements(stylePresetName, theme);
                if (!elements)
                    return {};
                return {
                    grid: [{
                            properties: {
                                outlineColor: createSolidFillDefinition(elements.outlineColor),
                                outlineWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.outlineWeight, stylePresets.TablixStylePresetDefaults.outlineWeight)),
                                gridVertical: SQExprBuilder.boolean(elements.gridVerticalEnabledTable),
                                gridVerticalColor: createSolidFillDefinition(elements.gridColor),
                                gridVerticalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridVerticalWeight, stylePresets.TablixStylePresetDefaults.gridlineVerticalWeight)),
                                gridHorizontal: SQExprBuilder.boolean(elements.gridHorizontalEnabledTable),
                                gridHorizontalColor: createSolidFillDefinition(elements.gridColor),
                                gridHorizontalWeight: SQExprBuilder.integer(Utility.valueOrDefault(elements.gridHorizontalWeight, stylePresets.TablixStylePresetDefaults.gridHorizontalWeight)),
                                rowPadding: SQExprBuilder.integer(elements.rowPadding),
                            },
                        }],
                    columnHeaders: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeColumnHeaders, stylePresets.TablixStylePresetDefaults.columnsOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorHeaders),
                                backColor: createSolidFillDefinition(elements.backColorHeaders),
                            }
                        }],
                    values: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeValues, stylePresets.TablixStylePresetDefaults.valuesOutline)),
                                fontColorPrimary: createSolidFillDefinition(elements.fontColorValues1),
                                backColorPrimary: createSolidFillDefinition(elements.backColorValues1),
                                fontColorSecondary: createSolidFillDefinition(elements.fontColorValues2),
                                backColorSecondary: createSolidFillDefinition(elements.backColorValues2),
                            }
                        }],
                    total: [{
                            properties: {
                                outline: SQExprBuilder.text(Utility.valueOrDefault(elements.outlineModeTotals, stylePresets.TablixStylePresetDefaults.tableTotalOutline)),
                                fontColor: createSolidFillDefinition(elements.fontColorTotals),
                                backColor: createSolidFillDefinition(elements.backColorTotals),
                            }
                        }],
                };
            }
            function tableExStylePresets() {
                return {
                    sectionTitle: createDisplayNameGetter("Visual_Table_StylePreset_SectionTitle"),
                    sliceTitle: createDisplayNameGetter("Visual_Table_StylePreset_SliceTitle"),
                    defaultPresetName: stylePresets.TablixStylePresetsName.Default,
                    presets: (_a = {},
                        _a[stylePresets.TablixStylePresetsName.Default] = {
                            name: stylePresets.TablixStylePresetsName.Default,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Default"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.Default, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.None] = {
                            name: stylePresets.TablixStylePresetsName.None,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_None"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.None, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Minimal] = {
                            name: stylePresets.TablixStylePresetsName.Minimal,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Minimal"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.Minimal, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeader] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeader,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_BoldHeader"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeader, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.AlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.AlternatingRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_AlternatingRows"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.AlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.ContrastAlternatingRows] = {
                            name: stylePresets.TablixStylePresetsName.ContrastAlternatingRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_ContrastAlternatingRows"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.ContrastAlternatingRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.FlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.FlashyRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_FlashyRows"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.FlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows] = {
                            name: stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_BoldHeaderFlashyRows"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.BoldHeaderFlashyRows, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Sparse] = {
                            name: stylePresets.TablixStylePresetsName.Sparse,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Sparse"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.Sparse, theme); },
                        },
                        _a[stylePresets.TablixStylePresetsName.Condensed] = {
                            name: stylePresets.TablixStylePresetsName.Condensed,
                            displayName: createDisplayNameGetter("Visual_Table_StylePreset_Condensed"),
                            evaluate: function (theme) { return wrapTableExStylePresetElements(stylePresets.TablixStylePresetsName.Condensed, theme); },
                        },
                        _a),
                };
                var _a;
            }
            stylePresets.tableExStylePresets = tableExStylePresets;
        })(stylePresets = visuals.stylePresets || (visuals.stylePresets = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
// <copyright company="Microsoft Corporation">
//        Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//-----------------------------------------------------------------------
;var module;(module||{}).exports=window.renderjson=(function(){function n(c,f,y,d,p,_){var v=y?"":f,h=function(n,o,u,c,f){var y,p=i(c),_=function(){y||e(p.parentNode,y=r(f(),s(l.hide,"disclosure",(function(){y.style.display="none",p.style.display="inline"})))),y.style.display="inline",p.style.display="none"};e(p,s(l.show,"disclosure",_),t(c+" syntax",n),s(o,null,_),t(c+" syntax",u));var h=e(i(),a(v.slice(0,-1)),p);return d>0&&_(),h};return null===c?t(null,v,"keyword","null"):void 0===c?t(null,v,"keyword","undefined"):"string"==typeof c&&c.length>p?h('"',c.substr(0,p)+" ...",'"',"string",(function(){return e(i("string"),t(null,v,"string",JSON.stringify(c)))})):l.js_mode&&"function"==typeof c?h("function() {","...","}","function",(function(){var n=c.toString().match(/^([^{]*{)([\s\S]*)(})\s?$/),r=n&&n[1]?n[1]:"function() {",o=n&&n[2]?n[2]:"";return e(i("function"),t("function syntax",r,null,"\n"),t(null,f,"function",o),a("\n"),t(null,f,"function syntax","}"))})):"object"!=typeof c?t(null,v,typeof c,JSON.stringify(c)):c.constructor==Array?0==c.length?t(null,v,"array syntax","[]"):h("["," ... ","]","array",(function(){for(var r=e(i("array"),t("array syntax","[",null,"\n")),o=0;o<c.length;o++)e(r,n(c[o],f+"    ",!1,d-1,p,_),o!=c.length-1?t("syntax",","):[],a("\n"));return e(r,t(null,f,"array syntax","]")),r})):(l.js_mode&&(c=u(c)),o(c)?t(null,v,"object syntax","{}"):h("{","...","}","object",(function(){var r=e(i("object"),t("object syntax","{",null,"\n"));for(var o in c)var s=o;var u=Object.keys(c);_&&(u=u.sort());for(var l in u){var o=u[l];e(r,t(null,f+"    ","key",'"'+o+'"',"object syntax",": "),n(c[o],f+"    ",!0,d-1,p,_),o!=s?t("syntax",","):[],a("\n"))}return e(r,t(null,f,"object syntax","}")),r})))}var t=function(){for(var n=[];arguments.length;)n.push(e(i(Array.prototype.shift.call(arguments)),a(Array.prototype.shift.call(arguments))));return n},e=function(){for(var n=Array.prototype.shift.call(arguments),t=0;t<arguments.length;t++)arguments[t].constructor==Array?e.apply(this,[n].concat(arguments[t])):n.appendChild(arguments[t]);return n},r=function(n,t){return n.insertBefore(t,n.firstChild),n},o=function(n){for(var t in n)if(Object.hasOwnProperty.call(n,t))return!1;return!0},a=function(n){return document.createTextNode(n)},i=function(n){var t=document.createElement("span");return n&&(t.className=n),t},s=function(n,t,e){var r=document.createElement("a");return t&&(r.className=t),r.appendChild(a(n)),r.href="#",r.onclick=function(n){return e(),n&&n.stopPropagation(),!1},r},u=function(n){for(var t={},e=n;null!=e;e=Object.getPrototypeOf(e))for(var r=Object.getOwnPropertyNames(e),o=0;o<r.length;o++){var a=r[o];"undefined"==typeof t[a]&&(t[a]=n[a])}return t},l=function c(t){var r=e(document.createElement("pre"),n(t,"",!1,c.show_to_level,c.max_string_length,c.sort_objects));return r.className="renderjson",r};return l.set_js_mode=function(n){return l.js_mode=n,l},l.set_icons=function(n,t){return l.show=n,l.hide=t,l},l.set_show_to_level=function(n){return l.show_to_level="string"==typeof n&&"all"===n.toLowerCase()?Number.MAX_VALUE:n,l},l.set_max_string_length=function(n){return l.max_string_length="string"==typeof n&&"none"===n.toLowerCase()?Number.MAX_VALUE:n,l},l.set_sort_objects=function(n){return l.sort_objects=n,l},l.set_show_by_default=function(n){return l.show_to_level=n?Number.MAX_VALUE:0,l},l.set_icons("",""),l.set_show_by_default(!1),l.set_sort_objects(!1),l.set_max_string_length("none"),l.set_js_mode(!1),l})();!(function(n){var t;!(function(t){var e;!(function(t){var e;!(function(t){var e=(function(){function t(n){var t=this.container=$("<div>");t.addClass("jsonViewScrollPane"),$(n.element).append(t),renderjson.set_js_mode(!0)}return t.prototype.update=function(t){t.type&n.VisualUpdateType.Data&&this.container.empty().append(renderjson(t.dataViews))},t})();t.Visual=e})(e=t.dataViewer||(t.dataViewer={}))})(e=t.visual||(t.visual={}))})(t=n.extensibility||(n.extensibility={}))})(powerbi||(powerbi={}));!(function(n){var t;!(function(t){var e;!(function(t){t.dataViewer={name:"dataViewer",displayName:"data viewer","class":"Visual",version:"1.0.0",apiVersion:"1.0.0",create:function(t){return new n.extensibility.visual.dataViewer.Visual(t)},custom:!0}})(e=t.plugins||(t.plugins={}))})(t=n.visuals||(n.visuals={}))})(powerbi||(powerbi={})); 

window.parseTimeMarkers['powerbi-visuals.js'].end = Date.now();
